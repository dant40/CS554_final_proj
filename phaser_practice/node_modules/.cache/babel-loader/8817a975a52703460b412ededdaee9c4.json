{"ast":null,"code":"/**\r\n* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.\r\n*\r\n* @class Sleeping\r\n*/\nvar Sleeping = {};\nmodule.exports = Sleeping;\n\nvar Events = require('./Events');\n\n(function () {\n  Sleeping._motionWakeThreshold = 0.18;\n  Sleeping._motionSleepThreshold = 0.08;\n  Sleeping._minBias = 0.9;\n  /**\r\n   * Puts bodies to sleep or wakes them up depending on their motion.\r\n   * @method update\r\n   * @param {body[]} bodies\r\n   * @param {number} timeScale\r\n   */\n\n  Sleeping.update = function (bodies, timeScale) {\n    var timeFactor = timeScale * timeScale * timeScale; // update bodies sleeping status\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i],\n          motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed; // wake up bodies if they have a force applied\n\n      if (body.force.x !== 0 || body.force.y !== 0) {\n        Sleeping.set(body, false);\n        continue;\n      }\n\n      var minMotion = Math.min(body.motion, motion),\n          maxMotion = Math.max(body.motion, motion); // biased average motion estimation between frames\n\n      body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;\n\n      if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {\n        body.sleepCounter += 1;\n        if (body.sleepCounter >= body.sleepThreshold) Sleeping.set(body, true);\n      } else if (body.sleepCounter > 0) {\n        body.sleepCounter -= 1;\n      }\n    }\n  };\n  /**\r\n   * Given a set of colliding pairs, wakes the sleeping bodies involved.\r\n   * @method afterCollisions\r\n   * @param {pair[]} pairs\r\n   * @param {number} timeScale\r\n   */\n\n\n  Sleeping.afterCollisions = function (pairs, timeScale) {\n    var timeFactor = timeScale * timeScale * timeScale; // wake up bodies involved in collisions\n\n    for (var i = 0; i < pairs.length; i++) {\n      var pair = pairs[i]; // don't wake inactive pairs\n\n      if (!pair.isActive) continue;\n      var collision = pair.collision,\n          bodyA = collision.bodyA.parent,\n          bodyB = collision.bodyB.parent; // don't wake if at least one body is static\n\n      if (bodyA.isSleeping && bodyB.isSleeping || bodyA.isStatic || bodyB.isStatic) continue;\n\n      if (bodyA.isSleeping || bodyB.isSleeping) {\n        var sleepingBody = bodyA.isSleeping && !bodyA.isStatic ? bodyA : bodyB,\n            movingBody = sleepingBody === bodyA ? bodyB : bodyA;\n\n        if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {\n          Sleeping.set(sleepingBody, false);\n        }\n      }\n    }\n  };\n  /**\r\n   * Set a body as sleeping or awake.\r\n   * @method set\r\n   * @param {body} body\r\n   * @param {boolean} isSleeping\r\n   */\n\n\n  Sleeping.set = function (body, isSleeping) {\n    var wasSleeping = body.isSleeping;\n\n    if (isSleeping) {\n      body.isSleeping = true;\n      body.sleepCounter = body.sleepThreshold;\n      body.positionImpulse.x = 0;\n      body.positionImpulse.y = 0;\n      body.positionPrev.x = body.position.x;\n      body.positionPrev.y = body.position.y;\n      body.anglePrev = body.angle;\n      body.speed = 0;\n      body.angularSpeed = 0;\n      body.motion = 0;\n\n      if (!wasSleeping) {\n        Events.trigger(body, 'sleepStart');\n      }\n    } else {\n      body.isSleeping = false;\n      body.sleepCounter = 0;\n\n      if (wasSleeping) {\n        Events.trigger(body, 'sleepEnd');\n      }\n    }\n  };\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/lib/core/Sleeping.js"],"names":["Sleeping","module","exports","Events","require","_motionWakeThreshold","_motionSleepThreshold","_minBias","update","bodies","timeScale","timeFactor","i","length","body","motion","speed","angularSpeed","force","x","y","set","minMotion","Math","min","maxMotion","max","sleepThreshold","sleepCounter","afterCollisions","pairs","pair","isActive","collision","bodyA","parent","bodyB","isSleeping","isStatic","sleepingBody","movingBody","wasSleeping","positionImpulse","positionPrev","position","anglePrev","angle","trigger"],"mappings":"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","sourcesContent":["/**\r\n* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.\r\n*\r\n* @class Sleeping\r\n*/\r\n\r\nvar Sleeping = {};\r\n\r\nmodule.exports = Sleeping;\r\n\r\nvar Events = require('./Events');\r\n\r\n(function() {\r\n\r\n    Sleeping._motionWakeThreshold = 0.18;\r\n    Sleeping._motionSleepThreshold = 0.08;\r\n    Sleeping._minBias = 0.9;\r\n\r\n    /**\r\n     * Puts bodies to sleep or wakes them up depending on their motion.\r\n     * @method update\r\n     * @param {body[]} bodies\r\n     * @param {number} timeScale\r\n     */\r\n    Sleeping.update = function(bodies, timeScale) {\r\n        var timeFactor = timeScale * timeScale * timeScale;\r\n\r\n        // update bodies sleeping status\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i],\r\n                motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;\r\n\r\n            // wake up bodies if they have a force applied\r\n            if (body.force.x !== 0 || body.force.y !== 0) {\r\n                Sleeping.set(body, false);\r\n                continue;\r\n            }\r\n\r\n            var minMotion = Math.min(body.motion, motion),\r\n                maxMotion = Math.max(body.motion, motion);\r\n        \r\n            // biased average motion estimation between frames\r\n            body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;\r\n            \r\n            if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {\r\n                body.sleepCounter += 1;\r\n                \r\n                if (body.sleepCounter >= body.sleepThreshold)\r\n                    Sleeping.set(body, true);\r\n            } else if (body.sleepCounter > 0) {\r\n                body.sleepCounter -= 1;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Given a set of colliding pairs, wakes the sleeping bodies involved.\r\n     * @method afterCollisions\r\n     * @param {pair[]} pairs\r\n     * @param {number} timeScale\r\n     */\r\n    Sleeping.afterCollisions = function(pairs, timeScale) {\r\n        var timeFactor = timeScale * timeScale * timeScale;\r\n\r\n        // wake up bodies involved in collisions\r\n        for (var i = 0; i < pairs.length; i++) {\r\n            var pair = pairs[i];\r\n            \r\n            // don't wake inactive pairs\r\n            if (!pair.isActive)\r\n                continue;\r\n\r\n            var collision = pair.collision,\r\n                bodyA = collision.bodyA.parent, \r\n                bodyB = collision.bodyB.parent;\r\n        \r\n            // don't wake if at least one body is static\r\n            if ((bodyA.isSleeping && bodyB.isSleeping) || bodyA.isStatic || bodyB.isStatic)\r\n                continue;\r\n        \r\n            if (bodyA.isSleeping || bodyB.isSleeping) {\r\n                var sleepingBody = (bodyA.isSleeping && !bodyA.isStatic) ? bodyA : bodyB,\r\n                    movingBody = sleepingBody === bodyA ? bodyB : bodyA;\r\n\r\n                if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {\r\n                    Sleeping.set(sleepingBody, false);\r\n                }\r\n            }\r\n        }\r\n    };\r\n  \r\n    /**\r\n     * Set a body as sleeping or awake.\r\n     * @method set\r\n     * @param {body} body\r\n     * @param {boolean} isSleeping\r\n     */\r\n    Sleeping.set = function(body, isSleeping) {\r\n        var wasSleeping = body.isSleeping;\r\n\r\n        if (isSleeping) {\r\n            body.isSleeping = true;\r\n            body.sleepCounter = body.sleepThreshold;\r\n\r\n            body.positionImpulse.x = 0;\r\n            body.positionImpulse.y = 0;\r\n\r\n            body.positionPrev.x = body.position.x;\r\n            body.positionPrev.y = body.position.y;\r\n\r\n            body.anglePrev = body.angle;\r\n            body.speed = 0;\r\n            body.angularSpeed = 0;\r\n            body.motion = 0;\r\n\r\n            if (!wasSleeping) {\r\n                Events.trigger(body, 'sleepStart');\r\n            }\r\n        } else {\r\n            body.isSleeping = false;\r\n            body.sleepCounter = 0;\r\n\r\n            if (wasSleeping) {\r\n                Events.trigger(body, 'sleepEnd');\r\n            }\r\n        }\r\n    };\r\n\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}