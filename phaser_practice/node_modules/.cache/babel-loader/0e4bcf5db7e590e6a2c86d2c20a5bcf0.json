{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Length = require('../line/Length');\n\nvar Point = require('../point/Point');\n/**\r\n * Returns an array of evenly spaced points on the perimeter of a Triangle.\r\n *\r\n * @function Phaser.Geom.Triangle.GetPoints\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to get the points from.\r\n * @param {integer} quantity - The number of evenly spaced points to return. Set to 0 to return an arbitrary number of points based on the `stepRate`.\r\n * @param {number} stepRate - If `quantity` is 0, the distance between each returned point.\r\n * @param {(array|Phaser.Geom.Point[])} [out] - An array to which the points should be appended.\r\n *\r\n * @return {(array|Phaser.Geom.Point[])} The modified `out` array, or a new array if none was provided.\r\n */\n\n\nvar GetPoints = function (triangle, quantity, stepRate, out) {\n  if (out === undefined) {\n    out = [];\n  }\n\n  var line1 = triangle.getLineA();\n  var line2 = triangle.getLineB();\n  var line3 = triangle.getLineC();\n  var length1 = Length(line1);\n  var length2 = Length(line2);\n  var length3 = Length(line3);\n  var perimeter = length1 + length2 + length3; //  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\n\n  if (!quantity) {\n    quantity = perimeter / stepRate;\n  }\n\n  for (var i = 0; i < quantity; i++) {\n    var p = perimeter * (i / quantity);\n    var localPosition = 0;\n    var point = new Point(); //  Which line is it on?\n\n    if (p < length1) {\n      //  Line 1\n      localPosition = p / length1;\n      point.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;\n      point.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;\n    } else if (p > length1 + length2) {\n      //  Line 3\n      p -= length1 + length2;\n      localPosition = p / length3;\n      point.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;\n      point.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;\n    } else {\n      //  Line 2\n      p -= length1;\n      localPosition = p / length2;\n      point.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;\n      point.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;\n    }\n\n    out.push(point);\n  }\n\n  return out;\n};\n\nmodule.exports = GetPoints;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/geom/triangle/GetPoints.js"],"names":["Length","require","Point","GetPoints","triangle","quantity","stepRate","out","undefined","line1","getLineA","line2","getLineB","line3","getLineC","length1","length2","length3","perimeter","i","p","localPosition","point","x","x1","x2","y","y1","y2","push","module","exports"],"mappings":"AAAA;;;;;AAMA,IAAIA,MAAM,GAAGC,OAAO,CAAC,gBAAD,CAApB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,gBAAD,CAAnB;AAEA;;;;;;;;;;;;;;;;;AAeA,IAAIE,SAAS,GAAG,UAAUC,QAAV,EAAoBC,QAApB,EAA8BC,QAA9B,EAAwCC,GAAxC,EAChB;AACI,MAAIA,GAAG,KAAKC,SAAZ,EAAuB;AAAED,IAAAA,GAAG,GAAG,EAAN;AAAW;;AAEpC,MAAIE,KAAK,GAAGL,QAAQ,CAACM,QAAT,EAAZ;AACA,MAAIC,KAAK,GAAGP,QAAQ,CAACQ,QAAT,EAAZ;AACA,MAAIC,KAAK,GAAGT,QAAQ,CAACU,QAAT,EAAZ;AAEA,MAAIC,OAAO,GAAGf,MAAM,CAACS,KAAD,CAApB;AACA,MAAIO,OAAO,GAAGhB,MAAM,CAACW,KAAD,CAApB;AACA,MAAIM,OAAO,GAAGjB,MAAM,CAACa,KAAD,CAApB;AAEA,MAAIK,SAAS,GAAGH,OAAO,GAAGC,OAAV,GAAoBC,OAApC,CAXJ,CAaI;;AACA,MAAI,CAACZ,QAAL,EACA;AACIA,IAAAA,QAAQ,GAAGa,SAAS,GAAGZ,QAAvB;AACH;;AAED,OAAK,IAAIa,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,QAApB,EAA8Bc,CAAC,EAA/B,EACA;AACI,QAAIC,CAAC,GAAGF,SAAS,IAAIC,CAAC,GAAGd,QAAR,CAAjB;AACA,QAAIgB,aAAa,GAAG,CAApB;AAEA,QAAIC,KAAK,GAAG,IAAIpB,KAAJ,EAAZ,CAJJ,CAMI;;AAEA,QAAIkB,CAAC,GAAGL,OAAR,EACA;AACI;AACAM,MAAAA,aAAa,GAAGD,CAAC,GAAGL,OAApB;AAEAO,MAAAA,KAAK,CAACC,CAAN,GAAUd,KAAK,CAACe,EAAN,GAAW,CAACf,KAAK,CAACgB,EAAN,GAAWhB,KAAK,CAACe,EAAlB,IAAwBH,aAA7C;AACAC,MAAAA,KAAK,CAACI,CAAN,GAAUjB,KAAK,CAACkB,EAAN,GAAW,CAAClB,KAAK,CAACmB,EAAN,GAAWnB,KAAK,CAACkB,EAAlB,IAAwBN,aAA7C;AACH,KAPD,MAQK,IAAID,CAAC,GAAGL,OAAO,GAAGC,OAAlB,EACL;AACI;AACAI,MAAAA,CAAC,IAAIL,OAAO,GAAGC,OAAf;AACAK,MAAAA,aAAa,GAAGD,CAAC,GAAGH,OAApB;AAEAK,MAAAA,KAAK,CAACC,CAAN,GAAUV,KAAK,CAACW,EAAN,GAAW,CAACX,KAAK,CAACY,EAAN,GAAWZ,KAAK,CAACW,EAAlB,IAAwBH,aAA7C;AACAC,MAAAA,KAAK,CAACI,CAAN,GAAUb,KAAK,CAACc,EAAN,GAAW,CAACd,KAAK,CAACe,EAAN,GAAWf,KAAK,CAACc,EAAlB,IAAwBN,aAA7C;AACH,KARI,MAUL;AACI;AACAD,MAAAA,CAAC,IAAIL,OAAL;AACAM,MAAAA,aAAa,GAAGD,CAAC,GAAGJ,OAApB;AAEAM,MAAAA,KAAK,CAACC,CAAN,GAAUZ,KAAK,CAACa,EAAN,GAAW,CAACb,KAAK,CAACc,EAAN,GAAWd,KAAK,CAACa,EAAlB,IAAwBH,aAA7C;AACAC,MAAAA,KAAK,CAACI,CAAN,GAAUf,KAAK,CAACgB,EAAN,GAAW,CAAChB,KAAK,CAACiB,EAAN,GAAWjB,KAAK,CAACgB,EAAlB,IAAwBN,aAA7C;AACH;;AAEDd,IAAAA,GAAG,CAACsB,IAAJ,CAASP,KAAT;AACH;;AAED,SAAOf,GAAP;AACH,CA5DD;;AA8DAuB,MAAM,CAACC,OAAP,GAAiB5B,SAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Length = require('../line/Length');\r\nvar Point = require('../point/Point');\r\n\r\n/**\r\n * Returns an array of evenly spaced points on the perimeter of a Triangle.\r\n *\r\n * @function Phaser.Geom.Triangle.GetPoints\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to get the points from.\r\n * @param {integer} quantity - The number of evenly spaced points to return. Set to 0 to return an arbitrary number of points based on the `stepRate`.\r\n * @param {number} stepRate - If `quantity` is 0, the distance between each returned point.\r\n * @param {(array|Phaser.Geom.Point[])} [out] - An array to which the points should be appended.\r\n *\r\n * @return {(array|Phaser.Geom.Point[])} The modified `out` array, or a new array if none was provided.\r\n */\r\nvar GetPoints = function (triangle, quantity, stepRate, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    var line1 = triangle.getLineA();\r\n    var line2 = triangle.getLineB();\r\n    var line3 = triangle.getLineC();\r\n\r\n    var length1 = Length(line1);\r\n    var length2 = Length(line2);\r\n    var length3 = Length(line3);\r\n\r\n    var perimeter = length1 + length2 + length3;\r\n\r\n    //  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\r\n    if (!quantity)\r\n    {\r\n        quantity = perimeter / stepRate;\r\n    }\r\n\r\n    for (var i = 0; i < quantity; i++)\r\n    {\r\n        var p = perimeter * (i / quantity);\r\n        var localPosition = 0;\r\n\r\n        var point = new Point();\r\n\r\n        //  Which line is it on?\r\n\r\n        if (p < length1)\r\n        {\r\n            //  Line 1\r\n            localPosition = p / length1;\r\n\r\n            point.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;\r\n            point.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;\r\n        }\r\n        else if (p > length1 + length2)\r\n        {\r\n            //  Line 3\r\n            p -= length1 + length2;\r\n            localPosition = p / length3;\r\n\r\n            point.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;\r\n            point.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;\r\n        }\r\n        else\r\n        {\r\n            //  Line 2\r\n            p -= length1;\r\n            localPosition = p / length2;\r\n\r\n            point.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;\r\n            point.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;\r\n        }\r\n\r\n        out.push(point);\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetPoints;\r\n"]},"metadata":{},"sourceType":"script"}