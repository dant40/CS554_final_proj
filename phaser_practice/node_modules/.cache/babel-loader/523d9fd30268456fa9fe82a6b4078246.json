{"ast":null,"code":"/**\r\n* The `Matter.Engine` module contains methods for creating and manipulating engines.\r\n* An engine is a controller that manages updating the simulation of the world.\r\n* See `Matter.Runner` for an optional game loop utility.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Engine\r\n*/\nvar Engine = {};\nmodule.exports = Engine;\n\nvar World = require('../body/World');\n\nvar Sleeping = require('./Sleeping');\n\nvar Resolver = require('../collision/Resolver');\n\nvar Pairs = require('../collision/Pairs');\n\nvar Metrics = require('./Metrics');\n\nvar Grid = require('../collision/Grid');\n\nvar Events = require('./Events');\n\nvar Composite = require('../body/Composite');\n\nvar Constraint = require('../constraint/Constraint');\n\nvar Common = require('./Common');\n\nvar Body = require('../body/Body');\n\n(function () {\n  /**\r\n   * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n   * All properties have default values, and many are pre-calculated automatically based on other properties.\r\n   * See the properties section below for detailed information on what you can pass via the `options` object.\r\n   * @method create\r\n   * @param {object} [options]\r\n   * @return {engine} engine\r\n   */\n  Engine.create = function (element, options) {\n    // options may be passed as the first (and only) argument\n    options = Common.isElement(element) ? options : element;\n    element = Common.isElement(element) ? element : null;\n    options = options || {};\n\n    if (element || options.render) {\n      Common.warn('Engine.create: engine.render is deprecated (see docs)');\n    }\n\n    var defaults = {\n      positionIterations: 6,\n      velocityIterations: 4,\n      constraintIterations: 2,\n      enableSleeping: false,\n      events: [],\n      plugin: {},\n      timing: {\n        timestamp: 0,\n        timeScale: 1\n      },\n      broadphase: {\n        controller: Grid\n      }\n    };\n    var engine = Common.extend(defaults, options);\n    engine.world = options.world || World.create(engine.world);\n    engine.pairs = Pairs.create();\n    engine.broadphase = engine.broadphase.controller.create(engine.broadphase);\n    engine.metrics = engine.metrics || {\n      extended: false\n    }; // @if DEBUG\n\n    engine.metrics = Metrics.create(engine.metrics); // @endif\n\n    return engine;\n  };\n  /**\r\n   * Moves the simulation forward in time by `delta` ms.\r\n   * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.\r\n   * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.\r\n   * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.\r\n   * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).\r\n   * See the paper on <a href=\"http://lonesock.net/article/verlet.html\">Time Corrected Verlet</a> for more information.\r\n   *\r\n   * Triggers `beforeUpdate` and `afterUpdate` events.\r\n   * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.\r\n   * @method update\r\n   * @param {engine} engine\r\n   * @param {number} [delta=16.666]\r\n   * @param {number} [correction=1]\r\n   */\n\n\n  Engine.update = function (engine, delta, correction) {\n    delta = delta || 1000 / 60;\n    correction = correction || 1;\n    var world = engine.world,\n        timing = engine.timing,\n        broadphase = engine.broadphase,\n        broadphasePairs = [],\n        i; // increment timestamp\n\n    timing.timestamp += delta * timing.timeScale; // create an event object\n\n    var event = {\n      timestamp: timing.timestamp\n    };\n    Events.trigger(engine, 'beforeUpdate', event); // get lists of all bodies and constraints, no matter what composites they are in\n\n    var allBodies = Composite.allBodies(world),\n        allConstraints = Composite.allConstraints(world); // @if DEBUG\n    // reset metrics logging\n\n    Metrics.reset(engine.metrics); // @endif\n    // if sleeping enabled, call the sleeping controller\n\n    if (engine.enableSleeping) Sleeping.update(allBodies, timing.timeScale); // applies gravity to all bodies\n\n    Engine._bodiesApplyGravity(allBodies, world.gravity); // update all body position and rotation by integration\n\n\n    Engine._bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds); // update all constraints (first pass)\n\n\n    Constraint.preSolveAll(allBodies);\n\n    for (i = 0; i < engine.constraintIterations; i++) {\n      Constraint.solveAll(allConstraints, timing.timeScale);\n    }\n\n    Constraint.postSolveAll(allBodies); // broadphase pass: find potential collision pairs\n\n    if (broadphase.controller) {\n      // if world is dirty, we must flush the whole grid\n      if (world.isModified) broadphase.controller.clear(broadphase); // update the grid buckets based on current bodies\n\n      broadphase.controller.update(broadphase, allBodies, engine, world.isModified);\n      broadphasePairs = broadphase.pairsList;\n    } else {\n      // if no broadphase set, we just pass all bodies\n      broadphasePairs = allBodies;\n    } // clear all composite modified flags\n\n\n    if (world.isModified) {\n      Composite.setModified(world, false, false, true);\n    } // narrowphase pass: find actual collisions, then create or update collision pairs\n\n\n    var collisions = broadphase.detector(broadphasePairs, engine); // update collision pairs\n\n    var pairs = engine.pairs,\n        timestamp = timing.timestamp;\n    Pairs.update(pairs, collisions, timestamp);\n    Pairs.removeOld(pairs, timestamp); // wake up bodies involved in collisions\n\n    if (engine.enableSleeping) Sleeping.afterCollisions(pairs.list, timing.timeScale); // trigger collision events\n\n    if (pairs.collisionStart.length > 0) Events.trigger(engine, 'collisionStart', {\n      pairs: pairs.collisionStart\n    }); // iteratively resolve position between collisions\n\n    Resolver.preSolvePosition(pairs.list);\n\n    for (i = 0; i < engine.positionIterations; i++) {\n      Resolver.solvePosition(pairs.list, allBodies, timing.timeScale);\n    }\n\n    Resolver.postSolvePosition(allBodies); // update all constraints (second pass)\n\n    Constraint.preSolveAll(allBodies);\n\n    for (i = 0; i < engine.constraintIterations; i++) {\n      Constraint.solveAll(allConstraints, timing.timeScale);\n    }\n\n    Constraint.postSolveAll(allBodies); // iteratively resolve velocity between collisions\n\n    Resolver.preSolveVelocity(pairs.list);\n\n    for (i = 0; i < engine.velocityIterations; i++) {\n      Resolver.solveVelocity(pairs.list, timing.timeScale);\n    } // trigger collision events\n\n\n    if (pairs.collisionActive.length > 0) Events.trigger(engine, 'collisionActive', {\n      pairs: pairs.collisionActive\n    });\n    if (pairs.collisionEnd.length > 0) Events.trigger(engine, 'collisionEnd', {\n      pairs: pairs.collisionEnd\n    }); // @if DEBUG\n    // update metrics log\n\n    Metrics.update(engine.metrics, engine); // @endif\n    // clear force buffers\n\n    Engine._bodiesClearForces(allBodies);\n\n    Events.trigger(engine, 'afterUpdate', event);\n    return engine;\n  };\n  /**\r\n   * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.\r\n   * @method merge\r\n   * @param {engine} engineA\r\n   * @param {engine} engineB\r\n   */\n\n\n  Engine.merge = function (engineA, engineB) {\n    Common.extend(engineA, engineB);\n\n    if (engineB.world) {\n      engineA.world = engineB.world;\n      Engine.clear(engineA);\n      var bodies = Composite.allBodies(engineA.world);\n\n      for (var i = 0; i < bodies.length; i++) {\n        var body = bodies[i];\n        Sleeping.set(body, false);\n        body.id = Common.nextId();\n      }\n    }\n  };\n  /**\r\n   * Clears the engine including the world, pairs and broadphase.\r\n   * @method clear\r\n   * @param {engine} engine\r\n   */\n\n\n  Engine.clear = function (engine) {\n    var world = engine.world;\n    Pairs.clear(engine.pairs);\n    var broadphase = engine.broadphase;\n\n    if (broadphase.controller) {\n      var bodies = Composite.allBodies(world);\n      broadphase.controller.clear(broadphase);\n      broadphase.controller.update(broadphase, bodies, engine, true);\n    }\n  };\n  /**\r\n   * Zeroes the `body.force` and `body.torque` force buffers.\r\n   * @method _bodiesClearForces\r\n   * @private\r\n   * @param {body[]} bodies\r\n   */\n\n\n  Engine._bodiesClearForces = function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i]; // reset force buffers\n\n      body.force.x = 0;\n      body.force.y = 0;\n      body.torque = 0;\n    }\n  };\n  /**\r\n   * Applys a mass dependant force to all given bodies.\r\n   * @method _bodiesApplyGravity\r\n   * @private\r\n   * @param {body[]} bodies\r\n   * @param {vector} gravity\r\n   */\n\n\n  Engine._bodiesApplyGravity = function (bodies, gravity) {\n    var gravityScale = typeof gravity.scale !== 'undefined' ? gravity.scale : 0.001;\n\n    if (gravity.x === 0 && gravity.y === 0 || gravityScale === 0) {\n      return;\n    }\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i];\n      if (body.ignoreGravity || body.isStatic || body.isSleeping) continue; // apply gravity\n\n      body.force.x += body.mass * gravity.x * gravityScale * body.gravityScale.x;\n      body.force.y += body.mass * gravity.y * gravityScale * body.gravityScale.y;\n    }\n  };\n  /**\r\n   * Applys `Body.update` to all given `bodies`.\r\n   * @method _bodiesUpdate\r\n   * @private\r\n   * @param {body[]} bodies\r\n   * @param {number} deltaTime \r\n   * The amount of time elapsed between updates\r\n   * @param {number} timeScale\r\n   * @param {number} correction \r\n   * The Verlet correction factor (deltaTime / lastDeltaTime)\r\n   * @param {bounds} worldBounds\r\n   */\n\n\n  Engine._bodiesUpdate = function (bodies, deltaTime, timeScale, correction, worldBounds) {\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i];\n      if (body.isStatic || body.isSleeping) continue;\n      Body.update(body, deltaTime, timeScale, correction);\n    }\n  };\n  /**\r\n   * An alias for `Runner.run`, see `Matter.Runner` for more information.\r\n   * @method run\r\n   * @param {engine} engine\r\n   */\n\n  /**\r\n  * Fired just before an update\r\n  *\r\n  * @event beforeUpdate\r\n  * @param {} event An event object\r\n  * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /**\r\n  * Fired after engine update and all collision events\r\n  *\r\n  * @event afterUpdate\r\n  * @param {} event An event object\r\n  * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /**\r\n  * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)\r\n  *\r\n  * @event collisionStart\r\n  * @param {} event An event object\r\n  * @param {} event.pairs List of affected pairs\r\n  * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /**\r\n  * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)\r\n  *\r\n  * @event collisionActive\r\n  * @param {} event An event object\r\n  * @param {} event.pairs List of affected pairs\r\n  * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /**\r\n  * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)\r\n  *\r\n  * @event collisionEnd\r\n  * @param {} event An event object\r\n  * @param {} event.pairs List of affected pairs\r\n  * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /*\r\n  *\r\n  *  Properties Documentation\r\n  *\r\n  */\n\n  /**\r\n   * An integer `Number` that specifies the number of position iterations to perform each update.\r\n   * The higher the value, the higher quality the simulation will be at the expense of performance.\r\n   *\r\n   * @property positionIterations\r\n   * @type number\r\n   * @default 6\r\n   */\n\n  /**\r\n   * An integer `Number` that specifies the number of velocity iterations to perform each update.\r\n   * The higher the value, the higher quality the simulation will be at the expense of performance.\r\n   *\r\n   * @property velocityIterations\r\n   * @type number\r\n   * @default 4\r\n   */\n\n  /**\r\n   * An integer `Number` that specifies the number of constraint iterations to perform each update.\r\n   * The higher the value, the higher quality the simulation will be at the expense of performance.\r\n   * The default value of `2` is usually very adequate.\r\n   *\r\n   * @property constraintIterations\r\n   * @type number\r\n   * @default 2\r\n   */\n\n  /**\r\n   * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.\r\n   * Sleeping can improve stability and performance, but often at the expense of accuracy.\r\n   *\r\n   * @property enableSleeping\r\n   * @type boolean\r\n   * @default false\r\n   */\n\n  /**\r\n   * An `Object` containing properties regarding the timing systems of the engine. \r\n   *\r\n   * @property timing\r\n   * @type object\r\n   */\n\n  /**\r\n   * A `Number` that specifies the global scaling factor of time for all bodies.\r\n   * A value of `0` freezes the simulation.\r\n   * A value of `0.1` gives a slow-motion effect.\r\n   * A value of `1.2` gives a speed-up effect.\r\n   *\r\n   * @property timing.timeScale\r\n   * @type number\r\n   * @default 1\r\n   */\n\n  /**\r\n   * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. \r\n   * It is incremented on every `Engine.update` by the given `delta` argument. \r\n   *\r\n   * @property timing.timestamp\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * An instance of a `Render` controller. The default value is a `Matter.Render` instance created by `Engine.create`.\r\n   * One may also develop a custom renderer module based on `Matter.Render` and pass an instance of it to `Engine.create` via `options.render`.\r\n   *\r\n   * A minimal custom renderer object must define at least three functions: `create`, `clear` and `world` (see `Matter.Render`).\r\n   * It is also possible to instead pass the _module_ reference via `options.render.controller` and `Engine.create` will instantiate one for you.\r\n   *\r\n   * @property render\r\n   * @type render\r\n   * @deprecated see Demo.js for an example of creating a renderer\r\n   * @default a Matter.Render instance\r\n   */\n\n  /**\r\n   * An instance of a broadphase controller. The default value is a `Matter.Grid` instance created by `Engine.create`.\r\n   *\r\n   * @property broadphase\r\n   * @type grid\r\n   * @default a Matter.Grid instance\r\n   */\n\n  /**\r\n   * A `World` composite object that will contain all simulated bodies and constraints.\r\n   *\r\n   * @property world\r\n   * @type world\r\n   * @default a Matter.World instance\r\n   */\n\n  /**\r\n   * An object reserved for storing plugin-specific properties.\r\n   *\r\n   * @property plugin\r\n   * @type {}\r\n   */\n\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/lib/core/Engine.js"],"names":["Engine","module","exports","World","require","Sleeping","Resolver","Pairs","Metrics","Grid","Events","Composite","Constraint","Common","Body","create","element","options","isElement","render","warn","defaults","positionIterations","velocityIterations","constraintIterations","enableSleeping","events","plugin","timing","timestamp","timeScale","broadphase","controller","engine","extend","world","pairs","metrics","extended","update","delta","correction","broadphasePairs","i","event","trigger","allBodies","allConstraints","reset","_bodiesApplyGravity","gravity","_bodiesUpdate","bounds","preSolveAll","solveAll","postSolveAll","isModified","clear","pairsList","setModified","collisions","detector","removeOld","afterCollisions","list","collisionStart","length","preSolvePosition","solvePosition","postSolvePosition","preSolveVelocity","solveVelocity","collisionActive","collisionEnd","_bodiesClearForces","merge","engineA","engineB","bodies","body","set","id","nextId","force","x","y","torque","gravityScale","scale","ignoreGravity","isStatic","isSleeping","mass","deltaTime","worldBounds"],"mappings":"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","sourcesContent":["/**\r\n* The `Matter.Engine` module contains methods for creating and manipulating engines.\r\n* An engine is a controller that manages updating the simulation of the world.\r\n* See `Matter.Runner` for an optional game loop utility.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Engine\r\n*/\r\n\r\nvar Engine = {};\r\n\r\nmodule.exports = Engine;\r\n\r\nvar World = require('../body/World');\r\nvar Sleeping = require('./Sleeping');\r\nvar Resolver = require('../collision/Resolver');\r\nvar Pairs = require('../collision/Pairs');\r\nvar Metrics = require('./Metrics');\r\nvar Grid = require('../collision/Grid');\r\nvar Events = require('./Events');\r\nvar Composite = require('../body/Composite');\r\nvar Constraint = require('../constraint/Constraint');\r\nvar Common = require('./Common');\r\nvar Body = require('../body/Body');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\r\n     * See the properties section below for detailed information on what you can pass via the `options` object.\r\n     * @method create\r\n     * @param {object} [options]\r\n     * @return {engine} engine\r\n     */\r\n    Engine.create = function(element, options) {\r\n        // options may be passed as the first (and only) argument\r\n        options = Common.isElement(element) ? options : element;\r\n        element = Common.isElement(element) ? element : null;\r\n        options = options || {};\r\n\r\n        if (element || options.render) {\r\n            Common.warn('Engine.create: engine.render is deprecated (see docs)');\r\n        }\r\n\r\n        var defaults = {\r\n            positionIterations: 6,\r\n            velocityIterations: 4,\r\n            constraintIterations: 2,\r\n            enableSleeping: false,\r\n            events: [],\r\n            plugin: {},\r\n            timing: {\r\n                timestamp: 0,\r\n                timeScale: 1\r\n            },\r\n            broadphase: {\r\n                controller: Grid\r\n            }\r\n        };\r\n\r\n        var engine = Common.extend(defaults, options);\r\n\r\n        engine.world = options.world || World.create(engine.world);\r\n        engine.pairs = Pairs.create();\r\n        engine.broadphase = engine.broadphase.controller.create(engine.broadphase);\r\n        engine.metrics = engine.metrics || { extended: false };\r\n\r\n        // @if DEBUG\r\n        engine.metrics = Metrics.create(engine.metrics);\r\n        // @endif\r\n\r\n        return engine;\r\n    };\r\n\r\n    /**\r\n     * Moves the simulation forward in time by `delta` ms.\r\n     * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.\r\n     * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.\r\n     * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.\r\n     * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).\r\n     * See the paper on <a href=\"http://lonesock.net/article/verlet.html\">Time Corrected Verlet</a> for more information.\r\n     *\r\n     * Triggers `beforeUpdate` and `afterUpdate` events.\r\n     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.\r\n     * @method update\r\n     * @param {engine} engine\r\n     * @param {number} [delta=16.666]\r\n     * @param {number} [correction=1]\r\n     */\r\n    Engine.update = function(engine, delta, correction) {\r\n        delta = delta || 1000 / 60;\r\n        correction = correction || 1;\r\n\r\n        var world = engine.world,\r\n            timing = engine.timing,\r\n            broadphase = engine.broadphase,\r\n            broadphasePairs = [],\r\n            i;\r\n\r\n        // increment timestamp\r\n        timing.timestamp += delta * timing.timeScale;\r\n\r\n        // create an event object\r\n        var event = {\r\n            timestamp: timing.timestamp\r\n        };\r\n\r\n        Events.trigger(engine, 'beforeUpdate', event);\r\n\r\n        // get lists of all bodies and constraints, no matter what composites they are in\r\n        var allBodies = Composite.allBodies(world),\r\n            allConstraints = Composite.allConstraints(world);\r\n\r\n        // @if DEBUG\r\n        // reset metrics logging\r\n        Metrics.reset(engine.metrics);\r\n        // @endif\r\n\r\n        // if sleeping enabled, call the sleeping controller\r\n        if (engine.enableSleeping)\r\n            Sleeping.update(allBodies, timing.timeScale);\r\n\r\n        // applies gravity to all bodies\r\n        Engine._bodiesApplyGravity(allBodies, world.gravity);\r\n\r\n        // update all body position and rotation by integration\r\n        Engine._bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds);\r\n\r\n        // update all constraints (first pass)\r\n        Constraint.preSolveAll(allBodies);\r\n        for (i = 0; i < engine.constraintIterations; i++) {\r\n            Constraint.solveAll(allConstraints, timing.timeScale);\r\n        }\r\n        Constraint.postSolveAll(allBodies);\r\n\r\n        // broadphase pass: find potential collision pairs\r\n        if (broadphase.controller) {\r\n            // if world is dirty, we must flush the whole grid\r\n            if (world.isModified)\r\n                broadphase.controller.clear(broadphase);\r\n\r\n            // update the grid buckets based on current bodies\r\n            broadphase.controller.update(broadphase, allBodies, engine, world.isModified);\r\n            broadphasePairs = broadphase.pairsList;\r\n        } else {\r\n            // if no broadphase set, we just pass all bodies\r\n            broadphasePairs = allBodies;\r\n        }\r\n\r\n        // clear all composite modified flags\r\n        if (world.isModified) {\r\n            Composite.setModified(world, false, false, true);\r\n        }\r\n\r\n        // narrowphase pass: find actual collisions, then create or update collision pairs\r\n        var collisions = broadphase.detector(broadphasePairs, engine);\r\n\r\n        // update collision pairs\r\n        var pairs = engine.pairs,\r\n            timestamp = timing.timestamp;\r\n        Pairs.update(pairs, collisions, timestamp);\r\n        Pairs.removeOld(pairs, timestamp);\r\n\r\n        // wake up bodies involved in collisions\r\n        if (engine.enableSleeping)\r\n            Sleeping.afterCollisions(pairs.list, timing.timeScale);\r\n\r\n        // trigger collision events\r\n        if (pairs.collisionStart.length > 0)\r\n            Events.trigger(engine, 'collisionStart', { pairs: pairs.collisionStart });\r\n\r\n        // iteratively resolve position between collisions\r\n        Resolver.preSolvePosition(pairs.list);\r\n        for (i = 0; i < engine.positionIterations; i++) {\r\n            Resolver.solvePosition(pairs.list, allBodies, timing.timeScale);\r\n        }\r\n        Resolver.postSolvePosition(allBodies);\r\n\r\n        // update all constraints (second pass)\r\n        Constraint.preSolveAll(allBodies);\r\n        for (i = 0; i < engine.constraintIterations; i++) {\r\n            Constraint.solveAll(allConstraints, timing.timeScale);\r\n        }\r\n        Constraint.postSolveAll(allBodies);\r\n\r\n        // iteratively resolve velocity between collisions\r\n        Resolver.preSolveVelocity(pairs.list);\r\n        for (i = 0; i < engine.velocityIterations; i++) {\r\n            Resolver.solveVelocity(pairs.list, timing.timeScale);\r\n        }\r\n\r\n        // trigger collision events\r\n        if (pairs.collisionActive.length > 0)\r\n            Events.trigger(engine, 'collisionActive', { pairs: pairs.collisionActive });\r\n\r\n        if (pairs.collisionEnd.length > 0)\r\n            Events.trigger(engine, 'collisionEnd', { pairs: pairs.collisionEnd });\r\n\r\n        // @if DEBUG\r\n        // update metrics log\r\n        Metrics.update(engine.metrics, engine);\r\n        // @endif\r\n\r\n        // clear force buffers\r\n        Engine._bodiesClearForces(allBodies);\r\n\r\n        Events.trigger(engine, 'afterUpdate', event);\r\n\r\n        return engine;\r\n    };\r\n    \r\n    /**\r\n     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.\r\n     * @method merge\r\n     * @param {engine} engineA\r\n     * @param {engine} engineB\r\n     */\r\n    Engine.merge = function(engineA, engineB) {\r\n        Common.extend(engineA, engineB);\r\n        \r\n        if (engineB.world) {\r\n            engineA.world = engineB.world;\r\n\r\n            Engine.clear(engineA);\r\n\r\n            var bodies = Composite.allBodies(engineA.world);\r\n\r\n            for (var i = 0; i < bodies.length; i++) {\r\n                var body = bodies[i];\r\n                Sleeping.set(body, false);\r\n                body.id = Common.nextId();\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Clears the engine including the world, pairs and broadphase.\r\n     * @method clear\r\n     * @param {engine} engine\r\n     */\r\n    Engine.clear = function(engine) {\r\n        var world = engine.world;\r\n        \r\n        Pairs.clear(engine.pairs);\r\n\r\n        var broadphase = engine.broadphase;\r\n        if (broadphase.controller) {\r\n            var bodies = Composite.allBodies(world);\r\n            broadphase.controller.clear(broadphase);\r\n            broadphase.controller.update(broadphase, bodies, engine, true);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Zeroes the `body.force` and `body.torque` force buffers.\r\n     * @method _bodiesClearForces\r\n     * @private\r\n     * @param {body[]} bodies\r\n     */\r\n    Engine._bodiesClearForces = function(bodies) {\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n\r\n            // reset force buffers\r\n            body.force.x = 0;\r\n            body.force.y = 0;\r\n            body.torque = 0;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Applys a mass dependant force to all given bodies.\r\n     * @method _bodiesApplyGravity\r\n     * @private\r\n     * @param {body[]} bodies\r\n     * @param {vector} gravity\r\n     */\r\n    Engine._bodiesApplyGravity = function(bodies, gravity) {\r\n        var gravityScale = typeof gravity.scale !== 'undefined' ? gravity.scale : 0.001;\r\n\r\n        if ((gravity.x === 0 && gravity.y === 0) || gravityScale === 0) {\r\n            return;\r\n        }\r\n        \r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n\r\n            if (body.ignoreGravity || body.isStatic || body.isSleeping)\r\n                continue;\r\n\r\n            // apply gravity\r\n            body.force.x += (body.mass * gravity.x * gravityScale) * body.gravityScale.x;\r\n            body.force.y += (body.mass * gravity.y * gravityScale) * body.gravityScale.y;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Applys `Body.update` to all given `bodies`.\r\n     * @method _bodiesUpdate\r\n     * @private\r\n     * @param {body[]} bodies\r\n     * @param {number} deltaTime \r\n     * The amount of time elapsed between updates\r\n     * @param {number} timeScale\r\n     * @param {number} correction \r\n     * The Verlet correction factor (deltaTime / lastDeltaTime)\r\n     * @param {bounds} worldBounds\r\n     */\r\n    Engine._bodiesUpdate = function(bodies, deltaTime, timeScale, correction, worldBounds) {\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n\r\n            if (body.isStatic || body.isSleeping)\r\n                continue;\r\n\r\n            Body.update(body, deltaTime, timeScale, correction);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * An alias for `Runner.run`, see `Matter.Runner` for more information.\r\n     * @method run\r\n     * @param {engine} engine\r\n     */\r\n\r\n    /**\r\n    * Fired just before an update\r\n    *\r\n    * @event beforeUpdate\r\n    * @param {} event An event object\r\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /**\r\n    * Fired after engine update and all collision events\r\n    *\r\n    * @event afterUpdate\r\n    * @param {} event An event object\r\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /**\r\n    * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)\r\n    *\r\n    * @event collisionStart\r\n    * @param {} event An event object\r\n    * @param {} event.pairs List of affected pairs\r\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /**\r\n    * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)\r\n    *\r\n    * @event collisionActive\r\n    * @param {} event An event object\r\n    * @param {} event.pairs List of affected pairs\r\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /**\r\n    * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)\r\n    *\r\n    * @event collisionEnd\r\n    * @param {} event An event object\r\n    * @param {} event.pairs List of affected pairs\r\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /*\r\n    *\r\n    *  Properties Documentation\r\n    *\r\n    */\r\n\r\n    /**\r\n     * An integer `Number` that specifies the number of position iterations to perform each update.\r\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\r\n     *\r\n     * @property positionIterations\r\n     * @type number\r\n     * @default 6\r\n     */\r\n\r\n    /**\r\n     * An integer `Number` that specifies the number of velocity iterations to perform each update.\r\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\r\n     *\r\n     * @property velocityIterations\r\n     * @type number\r\n     * @default 4\r\n     */\r\n\r\n    /**\r\n     * An integer `Number` that specifies the number of constraint iterations to perform each update.\r\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\r\n     * The default value of `2` is usually very adequate.\r\n     *\r\n     * @property constraintIterations\r\n     * @type number\r\n     * @default 2\r\n     */\r\n\r\n    /**\r\n     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.\r\n     * Sleeping can improve stability and performance, but often at the expense of accuracy.\r\n     *\r\n     * @property enableSleeping\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n\r\n    /**\r\n     * An `Object` containing properties regarding the timing systems of the engine. \r\n     *\r\n     * @property timing\r\n     * @type object\r\n     */\r\n\r\n    /**\r\n     * A `Number` that specifies the global scaling factor of time for all bodies.\r\n     * A value of `0` freezes the simulation.\r\n     * A value of `0.1` gives a slow-motion effect.\r\n     * A value of `1.2` gives a speed-up effect.\r\n     *\r\n     * @property timing.timeScale\r\n     * @type number\r\n     * @default 1\r\n     */\r\n\r\n    /**\r\n     * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. \r\n     * It is incremented on every `Engine.update` by the given `delta` argument. \r\n     *\r\n     * @property timing.timestamp\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * An instance of a `Render` controller. The default value is a `Matter.Render` instance created by `Engine.create`.\r\n     * One may also develop a custom renderer module based on `Matter.Render` and pass an instance of it to `Engine.create` via `options.render`.\r\n     *\r\n     * A minimal custom renderer object must define at least three functions: `create`, `clear` and `world` (see `Matter.Render`).\r\n     * It is also possible to instead pass the _module_ reference via `options.render.controller` and `Engine.create` will instantiate one for you.\r\n     *\r\n     * @property render\r\n     * @type render\r\n     * @deprecated see Demo.js for an example of creating a renderer\r\n     * @default a Matter.Render instance\r\n     */\r\n\r\n    /**\r\n     * An instance of a broadphase controller. The default value is a `Matter.Grid` instance created by `Engine.create`.\r\n     *\r\n     * @property broadphase\r\n     * @type grid\r\n     * @default a Matter.Grid instance\r\n     */\r\n\r\n    /**\r\n     * A `World` composite object that will contain all simulated bodies and constraints.\r\n     *\r\n     * @property world\r\n     * @type world\r\n     * @default a Matter.World instance\r\n     */\r\n\r\n    /**\r\n     * An object reserved for storing plugin-specific properties.\r\n     *\r\n     * @property plugin\r\n     * @type {}\r\n     */\r\n\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}