{"ast":null,"code":"/**\r\n* The `Matter.Resolver` module contains methods for resolving collision pairs.\r\n*\r\n* @class Resolver\r\n*/\nvar Resolver = {};\nmodule.exports = Resolver;\n\nvar Vertices = require('../geometry/Vertices');\n\nvar Vector = require('../geometry/Vector');\n\nvar Common = require('../core/Common');\n\nvar Bounds = require('../geometry/Bounds');\n\n(function () {\n  Resolver._restingThresh = 4;\n  Resolver._restingThreshTangent = 6;\n  Resolver._positionDampen = 0.9;\n  Resolver._positionWarming = 0.8;\n  Resolver._frictionNormalMultiplier = 5;\n  /**\r\n   * Prepare pairs for position solving.\r\n   * @method preSolvePosition\r\n   * @param {pair[]} pairs\r\n   */\n\n  Resolver.preSolvePosition = function (pairs) {\n    var i, pair, activeCount; // find total contacts on each body\n\n    for (i = 0; i < pairs.length; i++) {\n      pair = pairs[i];\n      if (!pair.isActive) continue;\n      activeCount = pair.activeContacts.length;\n      pair.collision.parentA.totalContacts += activeCount;\n      pair.collision.parentB.totalContacts += activeCount;\n    }\n  };\n  /**\r\n   * Find a solution for pair positions.\r\n   * @method solvePosition\r\n   * @param {pair[]} pairs\r\n   * @param {body[]} bodies\r\n   * @param {number} timeScale\r\n   */\n\n\n  Resolver.solvePosition = function (pairs, bodies, timeScale) {\n    var i,\n        normalX,\n        normalY,\n        pair,\n        collision,\n        bodyA,\n        bodyB,\n        normal,\n        separation,\n        penetration,\n        positionImpulseA,\n        positionImpulseB,\n        contactShare,\n        bodyBtoAX,\n        bodyBtoAY,\n        positionImpulse,\n        impulseCoefficient = timeScale * Resolver._positionDampen;\n\n    for (i = 0; i < bodies.length; i++) {\n      var body = bodies[i];\n      body.previousPositionImpulse.x = body.positionImpulse.x;\n      body.previousPositionImpulse.y = body.positionImpulse.y;\n    } // find impulses required to resolve penetration\n\n\n    for (i = 0; i < pairs.length; i++) {\n      pair = pairs[i];\n      if (!pair.isActive || pair.isSensor) continue;\n      collision = pair.collision;\n      bodyA = collision.parentA;\n      bodyB = collision.parentB;\n      normal = collision.normal;\n      positionImpulseA = bodyA.previousPositionImpulse;\n      positionImpulseB = bodyB.previousPositionImpulse;\n      penetration = collision.penetration;\n      bodyBtoAX = positionImpulseB.x - positionImpulseA.x + penetration.x;\n      bodyBtoAY = positionImpulseB.y - positionImpulseA.y + penetration.y;\n      normalX = normal.x;\n      normalY = normal.y;\n      separation = normalX * bodyBtoAX + normalY * bodyBtoAY;\n      pair.separation = separation;\n      positionImpulse = (separation - pair.slop) * impulseCoefficient;\n      if (bodyA.isStatic || bodyB.isStatic) positionImpulse *= 2;\n\n      if (!(bodyA.isStatic || bodyA.isSleeping)) {\n        contactShare = positionImpulse / bodyA.totalContacts;\n        bodyA.positionImpulse.x += normalX * contactShare;\n        bodyA.positionImpulse.y += normalY * contactShare;\n      }\n\n      if (!(bodyB.isStatic || bodyB.isSleeping)) {\n        contactShare = positionImpulse / bodyB.totalContacts;\n        bodyB.positionImpulse.x -= normalX * contactShare;\n        bodyB.positionImpulse.y -= normalY * contactShare;\n      }\n    }\n  };\n  /**\r\n   * Apply position resolution.\r\n   * @method postSolvePosition\r\n   * @param {body[]} bodies\r\n   */\n\n\n  Resolver.postSolvePosition = function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i]; // reset contact count\n\n      body.totalContacts = 0;\n\n      if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {\n        // update body geometry\n        for (var j = 0; j < body.parts.length; j++) {\n          var part = body.parts[j];\n          Vertices.translate(part.vertices, body.positionImpulse);\n          Bounds.update(part.bounds, part.vertices, body.velocity);\n          part.position.x += body.positionImpulse.x;\n          part.position.y += body.positionImpulse.y;\n        } // move the body without changing velocity\n\n\n        body.positionPrev.x += body.positionImpulse.x;\n        body.positionPrev.y += body.positionImpulse.y;\n\n        if (Vector.dot(body.positionImpulse, body.velocity) < 0) {\n          // reset cached impulse if the body has velocity along it\n          body.positionImpulse.x = 0;\n          body.positionImpulse.y = 0;\n        } else {\n          // warm the next iteration\n          body.positionImpulse.x *= Resolver._positionWarming;\n          body.positionImpulse.y *= Resolver._positionWarming;\n        }\n      }\n    }\n  };\n  /**\r\n   * Prepare pairs for velocity solving.\r\n   * @method preSolveVelocity\r\n   * @param {pair[]} pairs\r\n   */\n\n\n  Resolver.preSolveVelocity = function (pairs) {\n    var i,\n        j,\n        pair,\n        contacts,\n        collision,\n        bodyA,\n        bodyB,\n        normal,\n        tangent,\n        contact,\n        contactVertex,\n        normalImpulse,\n        tangentImpulse,\n        offset,\n        impulse = Vector._temp[0],\n        tempA = Vector._temp[1];\n\n    for (i = 0; i < pairs.length; i++) {\n      pair = pairs[i];\n      if (!pair.isActive || pair.isSensor) continue;\n      contacts = pair.activeContacts;\n      collision = pair.collision;\n      bodyA = collision.parentA;\n      bodyB = collision.parentB;\n      normal = collision.normal;\n      tangent = collision.tangent; // resolve each contact\n\n      for (j = 0; j < contacts.length; j++) {\n        contact = contacts[j];\n        contactVertex = contact.vertex;\n        normalImpulse = contact.normalImpulse;\n        tangentImpulse = contact.tangentImpulse;\n\n        if (normalImpulse !== 0 || tangentImpulse !== 0) {\n          // total impulse from contact\n          impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse;\n          impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse; // apply impulse from contact\n\n          if (!(bodyA.isStatic || bodyA.isSleeping)) {\n            offset = Vector.sub(contactVertex, bodyA.position, tempA);\n            bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;\n            bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;\n            bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;\n          }\n\n          if (!(bodyB.isStatic || bodyB.isSleeping)) {\n            offset = Vector.sub(contactVertex, bodyB.position, tempA);\n            bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;\n            bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;\n            bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Find a solution for pair velocities.\r\n   * @method solveVelocity\r\n   * @param {pair[]} pairs\r\n   * @param {number} timeScale\r\n   */\n\n\n  Resolver.solveVelocity = function (pairs, timeScale) {\n    var timeScaleSquared = timeScale * timeScale,\n        impulse = Vector._temp[0],\n        tempA = Vector._temp[1],\n        tempB = Vector._temp[2],\n        tempC = Vector._temp[3],\n        tempD = Vector._temp[4],\n        tempE = Vector._temp[5];\n\n    for (var i = 0; i < pairs.length; i++) {\n      var pair = pairs[i];\n      if (!pair.isActive || pair.isSensor) continue;\n      var collision = pair.collision,\n          bodyA = collision.parentA,\n          bodyB = collision.parentB,\n          normal = collision.normal,\n          tangent = collision.tangent,\n          contacts = pair.activeContacts,\n          contactShare = 1 / contacts.length; // update body velocities\n\n      bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;\n      bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;\n      bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;\n      bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;\n      bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;\n      bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev; // resolve each contact\n\n      for (var j = 0; j < contacts.length; j++) {\n        var contact = contacts[j],\n            contactVertex = contact.vertex,\n            offsetA = Vector.sub(contactVertex, bodyA.position, tempA),\n            offsetB = Vector.sub(contactVertex, bodyB.position, tempB),\n            velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC),\n            velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD),\n            relativeVelocity = Vector.sub(velocityPointA, velocityPointB, tempE),\n            normalVelocity = Vector.dot(normal, relativeVelocity);\n        var tangentVelocity = Vector.dot(tangent, relativeVelocity),\n            tangentSpeed = Math.abs(tangentVelocity),\n            tangentVelocityDirection = Common.sign(tangentVelocity); // raw impulses\n\n        var normalImpulse = (1 + pair.restitution) * normalVelocity,\n            normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier; // coulomb friction\n\n\n        var tangentImpulse = tangentVelocity,\n            maxFriction = Infinity;\n\n        if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {\n          maxFriction = tangentSpeed;\n          tangentImpulse = Common.clamp(pair.friction * tangentVelocityDirection * timeScaleSquared, -maxFriction, maxFriction);\n        } // modify impulses accounting for mass, inertia and offset\n\n\n        var oAcN = Vector.cross(offsetA, normal),\n            oBcN = Vector.cross(offsetB, normal),\n            share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN + bodyB.inverseInertia * oBcN * oBcN);\n        normalImpulse *= share;\n        tangentImpulse *= share; // handle high velocity and resting collisions separately\n\n        if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {\n          // high normal velocity so clear cached contact normal impulse\n          contact.normalImpulse = 0;\n        } else {\n          // solve resting collision constraints using Erin Catto's method (GDC08)\n          // impulse constraint tends to 0\n          var contactNormalImpulse = contact.normalImpulse;\n          contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);\n          normalImpulse = contact.normalImpulse - contactNormalImpulse;\n        } // handle high velocity and resting collisions separately\n\n\n        if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {\n          // high tangent velocity so clear cached contact tangent impulse\n          contact.tangentImpulse = 0;\n        } else {\n          // solve resting collision constraints using Erin Catto's method (GDC08)\n          // tangent impulse tends to -tangentSpeed or +tangentSpeed\n          var contactTangentImpulse = contact.tangentImpulse;\n          contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);\n          tangentImpulse = contact.tangentImpulse - contactTangentImpulse;\n        } // total impulse from contact\n\n\n        impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse;\n        impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse; // apply impulse from contact\n\n        if (!(bodyA.isStatic || bodyA.isSleeping)) {\n          bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;\n          bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;\n          bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;\n        }\n\n        if (!(bodyB.isStatic || bodyB.isSleeping)) {\n          bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;\n          bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;\n          bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;\n        }\n      }\n    }\n  };\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/lib/collision/Resolver.js"],"names":["Resolver","module","exports","Vertices","require","Vector","Common","Bounds","_restingThresh","_restingThreshTangent","_positionDampen","_positionWarming","_frictionNormalMultiplier","preSolvePosition","pairs","i","pair","activeCount","length","isActive","activeContacts","collision","parentA","totalContacts","parentB","solvePosition","bodies","timeScale","normalX","normalY","bodyA","bodyB","normal","separation","penetration","positionImpulseA","positionImpulseB","contactShare","bodyBtoAX","bodyBtoAY","positionImpulse","impulseCoefficient","body","previousPositionImpulse","x","y","isSensor","slop","isStatic","isSleeping","postSolvePosition","j","parts","part","translate","vertices","update","bounds","velocity","position","positionPrev","dot","preSolveVelocity","contacts","tangent","contact","contactVertex","normalImpulse","tangentImpulse","offset","impulse","_temp","tempA","vertex","sub","inverseMass","anglePrev","cross","inverseInertia","solveVelocity","timeScaleSquared","tempB","tempC","tempD","tempE","angularVelocity","angle","offsetA","offsetB","velocityPointA","add","mult","perp","velocityPointB","relativeVelocity","normalVelocity","tangentVelocity","tangentSpeed","Math","abs","tangentVelocityDirection","sign","restitution","normalForce","clamp","maxFriction","Infinity","friction","frictionStatic","oAcN","oBcN","share","contactNormalImpulse","min","contactTangentImpulse"],"mappings":"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","sourcesContent":["/**\r\n* The `Matter.Resolver` module contains methods for resolving collision pairs.\r\n*\r\n* @class Resolver\r\n*/\r\n\r\nvar Resolver = {};\r\n\r\nmodule.exports = Resolver;\r\n\r\nvar Vertices = require('../geometry/Vertices');\r\nvar Vector = require('../geometry/Vector');\r\nvar Common = require('../core/Common');\r\nvar Bounds = require('../geometry/Bounds');\r\n\r\n(function() {\r\n\r\n    Resolver._restingThresh = 4;\r\n    Resolver._restingThreshTangent = 6;\r\n    Resolver._positionDampen = 0.9;\r\n    Resolver._positionWarming = 0.8;\r\n    Resolver._frictionNormalMultiplier = 5;\r\n\r\n    /**\r\n     * Prepare pairs for position solving.\r\n     * @method preSolvePosition\r\n     * @param {pair[]} pairs\r\n     */\r\n    Resolver.preSolvePosition = function(pairs) {\r\n        var i,\r\n            pair,\r\n            activeCount;\r\n\r\n        // find total contacts on each body\r\n        for (i = 0; i < pairs.length; i++) {\r\n            pair = pairs[i];\r\n            \r\n            if (!pair.isActive)\r\n                continue;\r\n            \r\n            activeCount = pair.activeContacts.length;\r\n            pair.collision.parentA.totalContacts += activeCount;\r\n            pair.collision.parentB.totalContacts += activeCount;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Find a solution for pair positions.\r\n     * @method solvePosition\r\n     * @param {pair[]} pairs\r\n     * @param {body[]} bodies\r\n     * @param {number} timeScale\r\n     */\r\n    Resolver.solvePosition = function(pairs, bodies, timeScale) {\r\n        var i,\r\n            normalX,\r\n            normalY,\r\n            pair,\r\n            collision,\r\n            bodyA,\r\n            bodyB,\r\n            normal,\r\n            separation,\r\n            penetration,\r\n            positionImpulseA,\r\n            positionImpulseB,\r\n            contactShare,\r\n            bodyBtoAX,\r\n            bodyBtoAY,\r\n            positionImpulse,\r\n            impulseCoefficient = timeScale * Resolver._positionDampen;\r\n\r\n        for (i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n            body.previousPositionImpulse.x = body.positionImpulse.x;\r\n            body.previousPositionImpulse.y = body.positionImpulse.y;\r\n        }\r\n\r\n        // find impulses required to resolve penetration\r\n        for (i = 0; i < pairs.length; i++) {\r\n            pair = pairs[i];\r\n            \r\n            if (!pair.isActive || pair.isSensor)\r\n                continue;\r\n\r\n            collision = pair.collision;\r\n            bodyA = collision.parentA;\r\n            bodyB = collision.parentB;\r\n            normal = collision.normal;\r\n\r\n            positionImpulseA = bodyA.previousPositionImpulse;\r\n            positionImpulseB = bodyB.previousPositionImpulse;\r\n\r\n            penetration = collision.penetration;\r\n\r\n            bodyBtoAX = positionImpulseB.x - positionImpulseA.x + penetration.x;\r\n            bodyBtoAY = positionImpulseB.y - positionImpulseA.y + penetration.y;\r\n\r\n            normalX = normal.x;\r\n            normalY = normal.y;\r\n\r\n            separation = normalX * bodyBtoAX + normalY * bodyBtoAY;\r\n            pair.separation = separation;\r\n\r\n            positionImpulse = (separation - pair.slop) * impulseCoefficient;\r\n\r\n            if (bodyA.isStatic || bodyB.isStatic)\r\n                positionImpulse *= 2;\r\n            \r\n            if (!(bodyA.isStatic || bodyA.isSleeping)) {\r\n                contactShare = positionImpulse / bodyA.totalContacts;\r\n                bodyA.positionImpulse.x += normalX * contactShare;\r\n                bodyA.positionImpulse.y += normalY * contactShare;\r\n            }\r\n\r\n            if (!(bodyB.isStatic || bodyB.isSleeping)) {\r\n                contactShare = positionImpulse / bodyB.totalContacts;\r\n                bodyB.positionImpulse.x -= normalX * contactShare;\r\n                bodyB.positionImpulse.y -= normalY * contactShare;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Apply position resolution.\r\n     * @method postSolvePosition\r\n     * @param {body[]} bodies\r\n     */\r\n    Resolver.postSolvePosition = function(bodies) {\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n\r\n            // reset contact count\r\n            body.totalContacts = 0;\r\n\r\n            if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {\r\n                // update body geometry\r\n                for (var j = 0; j < body.parts.length; j++) {\r\n                    var part = body.parts[j];\r\n                    Vertices.translate(part.vertices, body.positionImpulse);\r\n                    Bounds.update(part.bounds, part.vertices, body.velocity);\r\n                    part.position.x += body.positionImpulse.x;\r\n                    part.position.y += body.positionImpulse.y;\r\n                }\r\n\r\n                // move the body without changing velocity\r\n                body.positionPrev.x += body.positionImpulse.x;\r\n                body.positionPrev.y += body.positionImpulse.y;\r\n\r\n                if (Vector.dot(body.positionImpulse, body.velocity) < 0) {\r\n                    // reset cached impulse if the body has velocity along it\r\n                    body.positionImpulse.x = 0;\r\n                    body.positionImpulse.y = 0;\r\n                } else {\r\n                    // warm the next iteration\r\n                    body.positionImpulse.x *= Resolver._positionWarming;\r\n                    body.positionImpulse.y *= Resolver._positionWarming;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Prepare pairs for velocity solving.\r\n     * @method preSolveVelocity\r\n     * @param {pair[]} pairs\r\n     */\r\n    Resolver.preSolveVelocity = function(pairs) {\r\n        var i,\r\n            j,\r\n            pair,\r\n            contacts,\r\n            collision,\r\n            bodyA,\r\n            bodyB,\r\n            normal,\r\n            tangent,\r\n            contact,\r\n            contactVertex,\r\n            normalImpulse,\r\n            tangentImpulse,\r\n            offset,\r\n            impulse = Vector._temp[0],\r\n            tempA = Vector._temp[1];\r\n        \r\n        for (i = 0; i < pairs.length; i++) {\r\n            pair = pairs[i];\r\n            \r\n            if (!pair.isActive || pair.isSensor)\r\n                continue;\r\n            \r\n            contacts = pair.activeContacts;\r\n            collision = pair.collision;\r\n            bodyA = collision.parentA;\r\n            bodyB = collision.parentB;\r\n            normal = collision.normal;\r\n            tangent = collision.tangent;\r\n\r\n            // resolve each contact\r\n            for (j = 0; j < contacts.length; j++) {\r\n                contact = contacts[j];\r\n                contactVertex = contact.vertex;\r\n                normalImpulse = contact.normalImpulse;\r\n                tangentImpulse = contact.tangentImpulse;\r\n\r\n                if (normalImpulse !== 0 || tangentImpulse !== 0) {\r\n                    // total impulse from contact\r\n                    impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);\r\n                    impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);\r\n                    \r\n                    // apply impulse from contact\r\n                    if (!(bodyA.isStatic || bodyA.isSleeping)) {\r\n                        offset = Vector.sub(contactVertex, bodyA.position, tempA);\r\n                        bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;\r\n                        bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;\r\n                        bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;\r\n                    }\r\n\r\n                    if (!(bodyB.isStatic || bodyB.isSleeping)) {\r\n                        offset = Vector.sub(contactVertex, bodyB.position, tempA);\r\n                        bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;\r\n                        bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;\r\n                        bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Find a solution for pair velocities.\r\n     * @method solveVelocity\r\n     * @param {pair[]} pairs\r\n     * @param {number} timeScale\r\n     */\r\n    Resolver.solveVelocity = function(pairs, timeScale) {\r\n        var timeScaleSquared = timeScale * timeScale,\r\n            impulse = Vector._temp[0],\r\n            tempA = Vector._temp[1],\r\n            tempB = Vector._temp[2],\r\n            tempC = Vector._temp[3],\r\n            tempD = Vector._temp[4],\r\n            tempE = Vector._temp[5];\r\n        \r\n        for (var i = 0; i < pairs.length; i++) {\r\n            var pair = pairs[i];\r\n            \r\n            if (!pair.isActive || pair.isSensor)\r\n                continue;\r\n            \r\n            var collision = pair.collision,\r\n                bodyA = collision.parentA,\r\n                bodyB = collision.parentB,\r\n                normal = collision.normal,\r\n                tangent = collision.tangent,\r\n                contacts = pair.activeContacts,\r\n                contactShare = 1 / contacts.length;\r\n\r\n            // update body velocities\r\n            bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;\r\n            bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;\r\n            bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;\r\n            bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;\r\n            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;\r\n            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;\r\n\r\n            // resolve each contact\r\n            for (var j = 0; j < contacts.length; j++) {\r\n                var contact = contacts[j],\r\n                    contactVertex = contact.vertex,\r\n                    offsetA = Vector.sub(contactVertex, bodyA.position, tempA),\r\n                    offsetB = Vector.sub(contactVertex, bodyB.position, tempB),\r\n                    velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC),\r\n                    velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD), \r\n                    relativeVelocity = Vector.sub(velocityPointA, velocityPointB, tempE),\r\n                    normalVelocity = Vector.dot(normal, relativeVelocity);\r\n\r\n                var tangentVelocity = Vector.dot(tangent, relativeVelocity),\r\n                    tangentSpeed = Math.abs(tangentVelocity),\r\n                    tangentVelocityDirection = Common.sign(tangentVelocity);\r\n\r\n                // raw impulses\r\n                var normalImpulse = (1 + pair.restitution) * normalVelocity,\r\n                    normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier;\r\n\r\n                // coulomb friction\r\n                var tangentImpulse = tangentVelocity,\r\n                    maxFriction = Infinity;\r\n\r\n                if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {\r\n                    maxFriction = tangentSpeed;\r\n                    tangentImpulse = Common.clamp(\r\n                        pair.friction * tangentVelocityDirection * timeScaleSquared,\r\n                        -maxFriction, maxFriction\r\n                    );\r\n                }\r\n\r\n                // modify impulses accounting for mass, inertia and offset\r\n                var oAcN = Vector.cross(offsetA, normal),\r\n                    oBcN = Vector.cross(offsetB, normal),\r\n                    share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN  + bodyB.inverseInertia * oBcN * oBcN);\r\n\r\n                normalImpulse *= share;\r\n                tangentImpulse *= share;\r\n\r\n                // handle high velocity and resting collisions separately\r\n                if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {\r\n                    // high normal velocity so clear cached contact normal impulse\r\n                    contact.normalImpulse = 0;\r\n                } else {\r\n                    // solve resting collision constraints using Erin Catto's method (GDC08)\r\n                    // impulse constraint tends to 0\r\n                    var contactNormalImpulse = contact.normalImpulse;\r\n                    contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);\r\n                    normalImpulse = contact.normalImpulse - contactNormalImpulse;\r\n                }\r\n\r\n                // handle high velocity and resting collisions separately\r\n                if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {\r\n                    // high tangent velocity so clear cached contact tangent impulse\r\n                    contact.tangentImpulse = 0;\r\n                } else {\r\n                    // solve resting collision constraints using Erin Catto's method (GDC08)\r\n                    // tangent impulse tends to -tangentSpeed or +tangentSpeed\r\n                    var contactTangentImpulse = contact.tangentImpulse;\r\n                    contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);\r\n                    tangentImpulse = contact.tangentImpulse - contactTangentImpulse;\r\n                }\r\n\r\n                // total impulse from contact\r\n                impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);\r\n                impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);\r\n                \r\n                // apply impulse from contact\r\n                if (!(bodyA.isStatic || bodyA.isSleeping)) {\r\n                    bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;\r\n                    bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;\r\n                    bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;\r\n                }\r\n\r\n                if (!(bodyB.isStatic || bodyB.isSleeping)) {\r\n                    bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;\r\n                    bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;\r\n                    bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}