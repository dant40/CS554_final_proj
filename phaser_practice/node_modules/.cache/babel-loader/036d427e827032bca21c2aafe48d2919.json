{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar FloatBetween = require('../../math/FloatBetween');\n\nvar GetEaseFunction = require('../../tweens/builders/GetEaseFunction');\n\nvar GetFastValue = require('../../utils/object/GetFastValue');\n\nvar Wrap = require('../../math/Wrap');\n/**\r\n * @classdesc\r\n * A Particle Emitter property.\r\n *\r\n * Facilitates changing Particle properties as they are emitted and throughout their lifetime.\r\n *\r\n * @class EmitterOp\r\n * @memberof Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} config - Settings for the Particle Emitter that owns this property.\r\n * @param {string} key - The name of the property.\r\n * @param {number} defaultValue - The default value of the property.\r\n * @param {boolean} [emitOnly=false] - Whether the property can only be modified when a Particle is emitted.\r\n */\n\n\nvar EmitterOp = new Class({\n  initialize: function EmitterOp(config, key, defaultValue, emitOnly) {\n    if (emitOnly === undefined) {\n      emitOnly = false;\n    }\n    /**\r\n     * The name of this property.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#propertyKey\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.propertyKey = key;\n    /**\r\n     * The value of this property.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#propertyValue\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.propertyValue = defaultValue;\n    /**\r\n     * The default value of this property.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#defaultValue\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.defaultValue = defaultValue;\n    /**\r\n     * The number of steps for stepped easing between {@link Phaser.GameObjects.Particles.EmitterOp#start} and\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#end} values, per emit.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#steps\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.steps = 0;\n    /**\r\n     * The step counter for stepped easing, per emit.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#counter\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.counter = 0;\n    /**\r\n     * The start value for this property to ease between.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#start\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.start = 0;\n    /**\r\n     * The end value for this property to ease between.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#end\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.end = 0;\n    /**\r\n     * The easing function to use for updating this property.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#ease\r\n     * @type {?function}\r\n     * @since 3.0.0\r\n     */\n\n    this.ease;\n    /**\r\n     * Whether this property can only be modified when a Particle is emitted.\r\n     *\r\n     * Set to `true` to allow only {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} callbacks to be set and\r\n     * affect this property.\r\n     *\r\n     * Set to `false` to allow both {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} and\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#onUpdate} callbacks to be set and affect this property.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#emitOnly\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.emitOnly = emitOnly;\n    /**\r\n     * The callback to run for Particles when they are emitted from the Particle Emitter.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#onEmit\r\n     * @type {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitCallback}\r\n     * @since 3.0.0\r\n     */\n\n    this.onEmit = this.defaultEmit;\n    /**\r\n     * The callback to run for Particles when they are updated.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.EmitterOp#onUpdate\r\n     * @type {Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateCallback}\r\n     * @since 3.0.0\r\n     */\n\n    this.onUpdate = this.defaultUpdate;\n    this.loadConfig(config);\n  },\n\n  /**\r\n   * Load the property from a Particle Emitter configuration object.\r\n   *\r\n   * Optionally accepts a new property key to use, replacing the current one.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#loadConfig\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} [config] - Settings for the Particle Emitter that owns this property.\r\n   * @param {string} [newKey] - The new key to use for this property, if any.\r\n   */\n  loadConfig: function (config, newKey) {\n    if (config === undefined) {\n      config = {};\n    }\n\n    if (newKey) {\n      this.propertyKey = newKey;\n    }\n\n    this.propertyValue = GetFastValue(config, this.propertyKey, this.defaultValue);\n    this.setMethods();\n\n    if (this.emitOnly) {\n      //  Reset it back again\n      this.onUpdate = this.defaultUpdate;\n    }\n  },\n\n  /**\r\n   * Build a JSON representation of this Particle Emitter property.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#toJSON\r\n   * @since 3.0.0\r\n   *\r\n   * @return {object} A JSON representation of this Particle Emitter property.\r\n   */\n  toJSON: function () {\n    return this.propertyValue;\n  },\n\n  /**\r\n   * Change the current value of the property and update its callback methods.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#onChange\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The value of the property.\r\n   *\r\n   * @return {Phaser.GameObjects.Particles.EmitterOp} This Emitter Op object.\r\n   */\n  onChange: function (value) {\n    this.propertyValue = value;\n    return this.setMethods();\n  },\n\n  /**\r\n   * Update the {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} and\r\n   * {@link Phaser.GameObjects.Particles.EmitterOp#onUpdate} callbacks based on the type of the current\r\n   * {@link Phaser.GameObjects.Particles.EmitterOp#propertyValue}.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#setMethods\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.GameObjects.Particles.EmitterOp} This Emitter Op object.\r\n   */\n  setMethods: function () {\n    var value = this.propertyValue;\n    var t = typeof value;\n\n    if (t === 'number') {\n      //  Explicit static value:\n      //  x: 400\n      this.onEmit = this.staticValueEmit;\n      this.onUpdate = this.staticValueUpdate; // How?\n    } else if (Array.isArray(value)) {\n      //  Picks a random element from the array:\n      //  x: [ 100, 200, 300, 400 ]\n      this.onEmit = this.randomStaticValueEmit;\n    } else if (t === 'function') {\n      //  The same as setting just the onUpdate function and no onEmit (unless this op is an emitOnly one)\n      //  Custom callback, must return a value:\n\n      /*\r\n      x: function (particle, key, t, value)\r\n         {\r\n             return value + 50;\r\n         }\r\n      */\n      if (this.emitOnly) {\n        this.onEmit = value;\n      } else {\n        this.onUpdate = value;\n      }\n    } else if (t === 'object' && (this.has(value, 'random') || this.hasBoth(value, 'start', 'end') || this.hasBoth(value, 'min', 'max'))) {\n      this.start = this.has(value, 'start') ? value.start : value.min;\n      this.end = this.has(value, 'end') ? value.end : value.max;\n      var isRandom = this.hasBoth(value, 'min', 'max') || !!value.random; //  A random starting value (using 'min | max' instead of 'start | end' automatically implies a random value)\n      //  x: { start: 100, end: 400, random: true } OR { min: 100, max: 400 } OR { random: [ 100, 400 ] }\n\n      if (isRandom) {\n        var rnd = value.random; //  x: { random: [ 100, 400 ] } = the same as doing: x: { start: 100, end: 400, random: true }\n\n        if (Array.isArray(rnd)) {\n          this.start = rnd[0];\n          this.end = rnd[1];\n        }\n\n        this.onEmit = this.randomRangedValueEmit;\n      }\n\n      if (this.has(value, 'steps')) {\n        //  A stepped (per emit) range\n        //  x: { start: 100, end: 400, steps: 64 }\n        //  Increments a value stored in the emitter\n        this.steps = value.steps;\n        this.counter = this.start;\n        this.onEmit = this.steppedEmit;\n      } else {\n        //  An eased range (defaults to Linear if not specified)\n        //  x: { start: 100, end: 400, [ ease: 'Linear' ] }\n        var easeType = this.has(value, 'ease') ? value.ease : 'Linear';\n        this.ease = GetEaseFunction(easeType);\n\n        if (!isRandom) {\n          this.onEmit = this.easedValueEmit;\n        } //  BUG: alpha, rotate, scaleX, scaleY, or tint are eased here if {min, max} is given.\n        //  Probably this branch should exclude isRandom entirely.\n\n\n        this.onUpdate = this.easeValueUpdate;\n      }\n    } else if (t === 'object' && this.hasEither(value, 'onEmit', 'onUpdate')) {\n      //  Custom onEmit and onUpdate callbacks\n\n      /*\r\n      x: {\r\n          //  Called at the start of the particles life, when it is being created\r\n          onEmit: function (particle, key, t, value)\r\n          {\r\n              return value;\r\n          },\r\n            //  Called during the particles life on each update\r\n          onUpdate: function (particle, key, t, value)\r\n          {\r\n              return value;\r\n          }\r\n      }\r\n      */\n      if (this.has(value, 'onEmit')) {\n        this.onEmit = value.onEmit;\n      }\n\n      if (this.has(value, 'onUpdate')) {\n        this.onUpdate = value.onUpdate;\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Check whether an object has the given property.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#has\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} object - The object to check.\r\n   * @param {string} key - The key of the property to look for in the object.\r\n   *\r\n   * @return {boolean} `true` if the property exists in the object, `false` otherwise.\r\n   */\n  has: function (object, key) {\n    return object.hasOwnProperty(key);\n  },\n\n  /**\r\n   * Check whether an object has both of the given properties.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#hasBoth\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} object - The object to check.\r\n   * @param {string} key1 - The key of the first property to check the object for.\r\n   * @param {string} key2 - The key of the second property to check the object for.\r\n   *\r\n   * @return {boolean} `true` if both properties exist in the object, `false` otherwise.\r\n   */\n  hasBoth: function (object, key1, key2) {\n    return object.hasOwnProperty(key1) && object.hasOwnProperty(key2);\n  },\n\n  /**\r\n   * Check whether an object has at least one of the given properties.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#hasEither\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} object - The object to check.\r\n   * @param {string} key1 - The key of the first property to check the object for.\r\n   * @param {string} key2 - The key of the second property to check the object for.\r\n   *\r\n   * @return {boolean} `true` if at least one of the properties exists in the object, `false` if neither exist.\r\n   */\n  hasEither: function (object, key1, key2) {\n    return object.hasOwnProperty(key1) || object.hasOwnProperty(key2);\n  },\n\n  /**\r\n   * The returned value sets what the property will be at the START of the particles life, on emit.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#defaultEmit\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n   * @param {string} key - The name of the property.\r\n   * @param {number} [value] - The current value of the property.\r\n   *\r\n   * @return {number} The new value of the property.\r\n   */\n  defaultEmit: function (particle, key, value) {\n    return value;\n  },\n\n  /**\r\n   * The returned value updates the property for the duration of the particles life.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#defaultUpdate\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n   * @param {string} key - The name of the property.\r\n   * @param {number} t - The T value (between 0 and 1)\r\n   * @param {number} value - The current value of the property.\r\n   *\r\n   * @return {number} The new value of the property.\r\n   */\n  defaultUpdate: function (particle, key, t, value) {\n    return value;\n  },\n\n  /**\r\n   * An `onEmit` callback that returns the current value of the property.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#staticValueEmit\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The current value of the property.\r\n   */\n  staticValueEmit: function () {\n    return this.propertyValue;\n  },\n\n  /**\r\n   * An `onUpdate` callback that returns the current value of the property.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#staticValueUpdate\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The current value of the property.\r\n   */\n  staticValueUpdate: function () {\n    return this.propertyValue;\n  },\n\n  /**\r\n   * An `onEmit` callback that returns a random value from the current value array.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#randomStaticValueEmit\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The new value of the property.\r\n   */\n  randomStaticValueEmit: function () {\n    var randomIndex = Math.floor(Math.random() * this.propertyValue.length);\n    return this.propertyValue[randomIndex];\n  },\n\n  /**\r\n   * An `onEmit` callback that returns a value between the {@link Phaser.GameObjects.Particles.EmitterOp#start} and\r\n   * {@link Phaser.GameObjects.Particles.EmitterOp#end} range.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#randomRangedValueEmit\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n   * @param {string} key - The key of the property.\r\n   *\r\n   * @return {number} The new value of the property.\r\n   */\n  randomRangedValueEmit: function (particle, key) {\n    var value = FloatBetween(this.start, this.end);\n\n    if (particle && particle.data[key]) {\n      particle.data[key].min = value;\n    }\n\n    return value;\n  },\n\n  /**\r\n   * An `onEmit` callback that returns a stepped value between the\r\n   * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}\r\n   * range.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#steppedEmit\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The new value of the property.\r\n   */\n  steppedEmit: function () {\n    var current = this.counter;\n    var next = this.counter + (this.end - this.start) / this.steps;\n    this.counter = Wrap(next, this.start, this.end);\n    return current;\n  },\n\n  /**\r\n   * An `onEmit` callback for an eased property.\r\n   *\r\n   * It prepares the particle for easing by {@link Phaser.GameObjects.Particles.EmitterOp#easeValueUpdate}.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#easedValueEmit\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n   * @param {string} key - The name of the property.\r\n   *\r\n   * @return {number} {@link Phaser.GameObjects.Particles.EmitterOp#start}, as the new value of the property.\r\n   */\n  easedValueEmit: function (particle, key) {\n    if (particle && particle.data[key]) {\n      var data = particle.data[key];\n      data.min = this.start;\n      data.max = this.end;\n    }\n\n    return this.start;\n  },\n\n  /**\r\n   * An `onUpdate` callback that returns an eased value between the\r\n   * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}\r\n   * range.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.EmitterOp#easeValueUpdate\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n   * @param {string} key - The name of the property.\r\n   * @param {number} t - The T value (between 0 and 1)\r\n   *\r\n   * @return {number} The new value of the property.\r\n   */\n  easeValueUpdate: function (particle, key, t) {\n    var data = particle.data[key];\n    return (data.max - data.min) * this.ease(t) + data.min;\n  }\n});\nmodule.exports = EmitterOp;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/particles/EmitterOp.js"],"names":["Class","require","FloatBetween","GetEaseFunction","GetFastValue","Wrap","EmitterOp","initialize","config","key","defaultValue","emitOnly","undefined","propertyKey","propertyValue","steps","counter","start","end","ease","onEmit","defaultEmit","onUpdate","defaultUpdate","loadConfig","newKey","setMethods","toJSON","onChange","value","t","staticValueEmit","staticValueUpdate","Array","isArray","randomStaticValueEmit","has","hasBoth","min","max","isRandom","random","rnd","randomRangedValueEmit","steppedEmit","easeType","easedValueEmit","easeValueUpdate","hasEither","object","hasOwnProperty","key1","key2","particle","randomIndex","Math","floor","length","data","current","next","module","exports"],"mappings":"AAAA;;;;;AAMA,IAAIA,KAAK,GAAGC,OAAO,CAAC,mBAAD,CAAnB;;AACA,IAAIC,YAAY,GAAGD,OAAO,CAAC,yBAAD,CAA1B;;AACA,IAAIE,eAAe,GAAGF,OAAO,CAAC,uCAAD,CAA7B;;AACA,IAAIG,YAAY,GAAGH,OAAO,CAAC,iCAAD,CAA1B;;AACA,IAAII,IAAI,GAAGJ,OAAO,CAAC,iBAAD,CAAlB;AAEA;;;;;;;;;;;;;;;;;;AAgBA,IAAIK,SAAS,GAAG,IAAIN,KAAJ,CAAU;AAEtBO,EAAAA,UAAU,EAEV,SAASD,SAAT,CAAoBE,MAApB,EAA4BC,GAA5B,EAAiCC,YAAjC,EAA+CC,QAA/C,EACA;AACI,QAAIA,QAAQ,KAAKC,SAAjB,EACA;AACID,MAAAA,QAAQ,GAAG,KAAX;AACH;AAED;;;;;;;;;AAOA,SAAKE,WAAL,GAAmBJ,GAAnB;AAEA;;;;;;;;AAOA,SAAKK,aAAL,GAAqBJ,YAArB;AAEA;;;;;;;;AAOA,SAAKA,YAAL,GAAoBA,YAApB;AAEA;;;;;;;;;;AASA,SAAKK,KAAL,GAAa,CAAb;AAEA;;;;;;;;;AAQA,SAAKC,OAAL,GAAe,CAAf;AAEA;;;;;;;;;AAQA,SAAKC,KAAL,GAAa,CAAb;AAEA;;;;;;;;;AAQA,SAAKC,GAAL,GAAW,CAAX;AAEA;;;;;;;;AAOA,SAAKC,IAAL;AAEA;;;;;;;;;;;;;;AAaA,SAAKR,QAAL,GAAgBA,QAAhB;AAEA;;;;;;;;AAOA,SAAKS,MAAL,GAAc,KAAKC,WAAnB;AAEA;;;;;;;;AAOA,SAAKC,QAAL,GAAgB,KAAKC,aAArB;AAEA,SAAKC,UAAL,CAAgBhB,MAAhB;AACH,GA1HqB;;AA4HtB;;;;;;;;;;;AAWAgB,EAAAA,UAAU,EAAE,UAAUhB,MAAV,EAAkBiB,MAAlB,EACZ;AACI,QAAIjB,MAAM,KAAKI,SAAf,EACA;AACIJ,MAAAA,MAAM,GAAG,EAAT;AACH;;AAED,QAAIiB,MAAJ,EACA;AACI,WAAKZ,WAAL,GAAmBY,MAAnB;AACH;;AAED,SAAKX,aAAL,GAAqBV,YAAY,CAC7BI,MAD6B,EAE7B,KAAKK,WAFwB,EAG7B,KAAKH,YAHwB,CAAjC;AAMA,SAAKgB,UAAL;;AAEA,QAAI,KAAKf,QAAT,EACA;AACI;AACA,WAAKW,QAAL,GAAgB,KAAKC,aAArB;AACH;AACJ,GAhKqB;;AAkKtB;;;;;;;;AAQAI,EAAAA,MAAM,EAAE,YACR;AACI,WAAO,KAAKb,aAAZ;AACH,GA7KqB;;AA+KtB;;;;;;;;;;AAUAc,EAAAA,QAAQ,EAAE,UAAUC,KAAV,EACV;AACI,SAAKf,aAAL,GAAqBe,KAArB;AAEA,WAAO,KAAKH,UAAL,EAAP;AACH,GA9LqB;;AAgMtB;;;;;;;;;;AAUAA,EAAAA,UAAU,EAAE,YACZ;AACI,QAAIG,KAAK,GAAG,KAAKf,aAAjB;AAEA,QAAIgB,CAAC,GAAG,OAAOD,KAAf;;AAEA,QAAIC,CAAC,KAAK,QAAV,EACA;AACI;AACA;AAEA,WAAKV,MAAL,GAAc,KAAKW,eAAnB;AACA,WAAKT,QAAL,GAAgB,KAAKU,iBAArB,CALJ,CAK4C;AAC3C,KAPD,MAQK,IAAIC,KAAK,CAACC,OAAN,CAAcL,KAAd,CAAJ,EACL;AACI;AACA;AAEA,WAAKT,MAAL,GAAc,KAAKe,qBAAnB;AACH,KANI,MAOA,IAAIL,CAAC,KAAK,UAAV,EACL;AACI;AACA;;AAEA;;;;;;AAOA,UAAI,KAAKnB,QAAT,EACA;AACI,aAAKS,MAAL,GAAcS,KAAd;AACH,OAHD,MAKA;AACI,aAAKP,QAAL,GAAgBO,KAAhB;AACH;AACJ,KApBI,MAqBA,IAAIC,CAAC,KAAK,QAAN,KAAmB,KAAKM,GAAL,CAASP,KAAT,EAAgB,QAAhB,KAA6B,KAAKQ,OAAL,CAAaR,KAAb,EAAoB,OAApB,EAA6B,KAA7B,CAA7B,IAAoE,KAAKQ,OAAL,CAAaR,KAAb,EAAoB,KAApB,EAA2B,KAA3B,CAAvF,CAAJ,EACL;AACI,WAAKZ,KAAL,GAAa,KAAKmB,GAAL,CAASP,KAAT,EAAgB,OAAhB,IAA2BA,KAAK,CAACZ,KAAjC,GAAyCY,KAAK,CAACS,GAA5D;AACA,WAAKpB,GAAL,GAAW,KAAKkB,GAAL,CAASP,KAAT,EAAgB,KAAhB,IAAyBA,KAAK,CAACX,GAA/B,GAAqCW,KAAK,CAACU,GAAtD;AAEA,UAAIC,QAAQ,GAAI,KAAKH,OAAL,CAAaR,KAAb,EAAoB,KAApB,EAA2B,KAA3B,KAAqC,CAAC,CAACA,KAAK,CAACY,MAA7D,CAJJ,CAMI;AAEA;;AAEA,UAAID,QAAJ,EACA;AACI,YAAIE,GAAG,GAAGb,KAAK,CAACY,MAAhB,CADJ,CAGI;;AACA,YAAIR,KAAK,CAACC,OAAN,CAAcQ,GAAd,CAAJ,EACA;AACI,eAAKzB,KAAL,GAAayB,GAAG,CAAC,CAAD,CAAhB;AACA,eAAKxB,GAAL,GAAWwB,GAAG,CAAC,CAAD,CAAd;AACH;;AAED,aAAKtB,MAAL,GAAc,KAAKuB,qBAAnB;AACH;;AAED,UAAI,KAAKP,GAAL,CAASP,KAAT,EAAgB,OAAhB,CAAJ,EACA;AACI;AAEA;AAEA;AAEA,aAAKd,KAAL,GAAac,KAAK,CAACd,KAAnB;AACA,aAAKC,OAAL,GAAe,KAAKC,KAApB;AAEA,aAAKG,MAAL,GAAc,KAAKwB,WAAnB;AACH,OAZD,MAcA;AACI;AAEA;AAEA,YAAIC,QAAQ,GAAG,KAAKT,GAAL,CAASP,KAAT,EAAgB,MAAhB,IAA0BA,KAAK,CAACV,IAAhC,GAAuC,QAAtD;AAEA,aAAKA,IAAL,GAAYhB,eAAe,CAAC0C,QAAD,CAA3B;;AAEA,YAAI,CAACL,QAAL,EACA;AACI,eAAKpB,MAAL,GAAc,KAAK0B,cAAnB;AACH,SAZL,CAcI;AACA;;;AAEA,aAAKxB,QAAL,GAAgB,KAAKyB,eAArB;AACH;AACJ,KA1DI,MA2DA,IAAIjB,CAAC,KAAK,QAAN,IAAkB,KAAKkB,SAAL,CAAenB,KAAf,EAAsB,QAAtB,EAAgC,UAAhC,CAAtB,EACL;AACI;;AAEA;;;;;;;;;;;;;;AAgBA,UAAI,KAAKO,GAAL,CAASP,KAAT,EAAgB,QAAhB,CAAJ,EACA;AACI,aAAKT,MAAL,GAAcS,KAAK,CAACT,MAApB;AACH;;AAED,UAAI,KAAKgB,GAAL,CAASP,KAAT,EAAgB,UAAhB,CAAJ,EACA;AACI,aAAKP,QAAL,GAAgBO,KAAK,CAACP,QAAtB;AACH;AACJ;;AAED,WAAO,IAAP;AACH,GA/UqB;;AAiVtB;;;;;;;;;;;AAWAc,EAAAA,GAAG,EAAE,UAAUa,MAAV,EAAkBxC,GAAlB,EACL;AACI,WAAOwC,MAAM,CAACC,cAAP,CAAsBzC,GAAtB,CAAP;AACH,GA/VqB;;AAiWtB;;;;;;;;;;;;AAYA4B,EAAAA,OAAO,EAAE,UAAUY,MAAV,EAAkBE,IAAlB,EAAwBC,IAAxB,EACT;AACI,WAAOH,MAAM,CAACC,cAAP,CAAsBC,IAAtB,KAA+BF,MAAM,CAACC,cAAP,CAAsBE,IAAtB,CAAtC;AACH,GAhXqB;;AAkXtB;;;;;;;;;;;;AAYAJ,EAAAA,SAAS,EAAE,UAAUC,MAAV,EAAkBE,IAAlB,EAAwBC,IAAxB,EACX;AACI,WAAOH,MAAM,CAACC,cAAP,CAAsBC,IAAtB,KAA+BF,MAAM,CAACC,cAAP,CAAsBE,IAAtB,CAAtC;AACH,GAjYqB;;AAmYtB;;;;;;;;;;;;AAYA/B,EAAAA,WAAW,EAAE,UAAUgC,QAAV,EAAoB5C,GAApB,EAAyBoB,KAAzB,EACb;AACI,WAAOA,KAAP;AACH,GAlZqB;;AAoZtB;;;;;;;;;;;;;AAaAN,EAAAA,aAAa,EAAE,UAAU8B,QAAV,EAAoB5C,GAApB,EAAyBqB,CAAzB,EAA4BD,KAA5B,EACf;AACI,WAAOA,KAAP;AACH,GApaqB;;AAsatB;;;;;;;;AAQAE,EAAAA,eAAe,EAAE,YACjB;AACI,WAAO,KAAKjB,aAAZ;AACH,GAjbqB;;AAmbtB;;;;;;;;AAQAkB,EAAAA,iBAAiB,EAAE,YACnB;AACI,WAAO,KAAKlB,aAAZ;AACH,GA9bqB;;AAgctB;;;;;;;;AAQAqB,EAAAA,qBAAqB,EAAE,YACvB;AACI,QAAImB,WAAW,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACd,MAAL,KAAgB,KAAK3B,aAAL,CAAmB2C,MAA9C,CAAlB;AAEA,WAAO,KAAK3C,aAAL,CAAmBwC,WAAnB,CAAP;AACH,GA7cqB;;AA+ctB;;;;;;;;;;;;AAYAX,EAAAA,qBAAqB,EAAE,UAAUU,QAAV,EAAoB5C,GAApB,EACvB;AACI,QAAIoB,KAAK,GAAG3B,YAAY,CAAC,KAAKe,KAAN,EAAa,KAAKC,GAAlB,CAAxB;;AAEA,QAAImC,QAAQ,IAAIA,QAAQ,CAACK,IAAT,CAAcjD,GAAd,CAAhB,EACA;AACI4C,MAAAA,QAAQ,CAACK,IAAT,CAAcjD,GAAd,EAAmB6B,GAAnB,GAAyBT,KAAzB;AACH;;AAED,WAAOA,KAAP;AACH,GAreqB;;AAuetB;;;;;;;;;;AAUAe,EAAAA,WAAW,EAAE,YACb;AACI,QAAIe,OAAO,GAAG,KAAK3C,OAAnB;AAEA,QAAI4C,IAAI,GAAG,KAAK5C,OAAL,GAAe,CAAC,KAAKE,GAAL,GAAW,KAAKD,KAAjB,IAA0B,KAAKF,KAAzD;AAEA,SAAKC,OAAL,GAAeX,IAAI,CAACuD,IAAD,EAAO,KAAK3C,KAAZ,EAAmB,KAAKC,GAAxB,CAAnB;AAEA,WAAOyC,OAAP;AACH,GA1fqB;;AA4ftB;;;;;;;;;;;;;AAaAb,EAAAA,cAAc,EAAE,UAAUO,QAAV,EAAoB5C,GAApB,EAChB;AACI,QAAI4C,QAAQ,IAAIA,QAAQ,CAACK,IAAT,CAAcjD,GAAd,CAAhB,EACA;AACI,UAAIiD,IAAI,GAAGL,QAAQ,CAACK,IAAT,CAAcjD,GAAd,CAAX;AAEAiD,MAAAA,IAAI,CAACpB,GAAL,GAAW,KAAKrB,KAAhB;AACAyC,MAAAA,IAAI,CAACnB,GAAL,GAAW,KAAKrB,GAAhB;AACH;;AAED,WAAO,KAAKD,KAAZ;AACH,GAphBqB;;AAshBtB;;;;;;;;;;;;;;AAcA8B,EAAAA,eAAe,EAAE,UAAUM,QAAV,EAAoB5C,GAApB,EAAyBqB,CAAzB,EACjB;AACI,QAAI4B,IAAI,GAAGL,QAAQ,CAACK,IAAT,CAAcjD,GAAd,CAAX;AAEA,WAAO,CAACiD,IAAI,CAACnB,GAAL,GAAWmB,IAAI,CAACpB,GAAjB,IAAwB,KAAKnB,IAAL,CAAUW,CAAV,CAAxB,GAAuC4B,IAAI,CAACpB,GAAnD;AACH;AAziBqB,CAAV,CAAhB;AA4iBAuB,MAAM,CAACC,OAAP,GAAiBxD,SAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FloatBetween = require('../../math/FloatBetween');\r\nvar GetEaseFunction = require('../../tweens/builders/GetEaseFunction');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Wrap = require('../../math/Wrap');\r\n\r\n/**\r\n * @classdesc\r\n * A Particle Emitter property.\r\n *\r\n * Facilitates changing Particle properties as they are emitted and throughout their lifetime.\r\n *\r\n * @class EmitterOp\r\n * @memberof Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} config - Settings for the Particle Emitter that owns this property.\r\n * @param {string} key - The name of the property.\r\n * @param {number} defaultValue - The default value of the property.\r\n * @param {boolean} [emitOnly=false] - Whether the property can only be modified when a Particle is emitted.\r\n */\r\nvar EmitterOp = new Class({\r\n\r\n    initialize:\r\n\r\n    function EmitterOp (config, key, defaultValue, emitOnly)\r\n    {\r\n        if (emitOnly === undefined)\r\n        {\r\n            emitOnly = false;\r\n        }\r\n\r\n        /**\r\n         * The name of this property.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#propertyKey\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.propertyKey = key;\r\n\r\n        /**\r\n         * The value of this property.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#propertyValue\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.propertyValue = defaultValue;\r\n\r\n        /**\r\n         * The default value of this property.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#defaultValue\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultValue = defaultValue;\r\n\r\n        /**\r\n         * The number of steps for stepped easing between {@link Phaser.GameObjects.Particles.EmitterOp#start} and\r\n         * {@link Phaser.GameObjects.Particles.EmitterOp#end} values, per emit.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#steps\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.steps = 0;\r\n\r\n        /**\r\n         * The step counter for stepped easing, per emit.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#counter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.counter = 0;\r\n\r\n        /**\r\n         * The start value for this property to ease between.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#start\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.start = 0;\r\n\r\n        /**\r\n         * The end value for this property to ease between.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#end\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.end = 0;\r\n\r\n        /**\r\n         * The easing function to use for updating this property.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#ease\r\n         * @type {?function}\r\n         * @since 3.0.0\r\n         */\r\n        this.ease;\r\n\r\n        /**\r\n         * Whether this property can only be modified when a Particle is emitted.\r\n         *\r\n         * Set to `true` to allow only {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} callbacks to be set and\r\n         * affect this property.\r\n         *\r\n         * Set to `false` to allow both {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} and\r\n         * {@link Phaser.GameObjects.Particles.EmitterOp#onUpdate} callbacks to be set and affect this property.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#emitOnly\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.emitOnly = emitOnly;\r\n\r\n        /**\r\n         * The callback to run for Particles when they are emitted from the Particle Emitter.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#onEmit\r\n         * @type {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.onEmit = this.defaultEmit;\r\n\r\n        /**\r\n         * The callback to run for Particles when they are updated.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#onUpdate\r\n         * @type {Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.onUpdate = this.defaultUpdate;\r\n\r\n        this.loadConfig(config);\r\n    },\r\n\r\n    /**\r\n     * Load the property from a Particle Emitter configuration object.\r\n     *\r\n     * Optionally accepts a new property key to use, replacing the current one.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#loadConfig\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} [config] - Settings for the Particle Emitter that owns this property.\r\n     * @param {string} [newKey] - The new key to use for this property, if any.\r\n     */\r\n    loadConfig: function (config, newKey)\r\n    {\r\n        if (config === undefined)\r\n        {\r\n            config = {};\r\n        }\r\n\r\n        if (newKey)\r\n        {\r\n            this.propertyKey = newKey;\r\n        }\r\n\r\n        this.propertyValue = GetFastValue(\r\n            config,\r\n            this.propertyKey,\r\n            this.defaultValue\r\n        );\r\n\r\n        this.setMethods();\r\n\r\n        if (this.emitOnly)\r\n        {\r\n            //  Reset it back again\r\n            this.onUpdate = this.defaultUpdate;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Build a JSON representation of this Particle Emitter property.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} A JSON representation of this Particle Emitter property.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return this.propertyValue;\r\n    },\r\n\r\n    /**\r\n     * Change the current value of the property and update its callback methods.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#onChange\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The value of the property.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.EmitterOp} This Emitter Op object.\r\n     */\r\n    onChange: function (value)\r\n    {\r\n        this.propertyValue = value;\r\n\r\n        return this.setMethods();\r\n    },\r\n\r\n    /**\r\n     * Update the {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} and\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#onUpdate} callbacks based on the type of the current\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#propertyValue}.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#setMethods\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.EmitterOp} This Emitter Op object.\r\n     */\r\n    setMethods: function ()\r\n    {\r\n        var value = this.propertyValue;\r\n\r\n        var t = typeof value;\r\n\r\n        if (t === 'number')\r\n        {\r\n            //  Explicit static value:\r\n            //  x: 400\r\n\r\n            this.onEmit = this.staticValueEmit;\r\n            this.onUpdate = this.staticValueUpdate; // How?\r\n        }\r\n        else if (Array.isArray(value))\r\n        {\r\n            //  Picks a random element from the array:\r\n            //  x: [ 100, 200, 300, 400 ]\r\n\r\n            this.onEmit = this.randomStaticValueEmit;\r\n        }\r\n        else if (t === 'function')\r\n        {\r\n            //  The same as setting just the onUpdate function and no onEmit (unless this op is an emitOnly one)\r\n            //  Custom callback, must return a value:\r\n\r\n            /*\r\n            x: function (particle, key, t, value)\r\n               {\r\n                   return value + 50;\r\n               }\r\n            */\r\n\r\n            if (this.emitOnly)\r\n            {\r\n                this.onEmit = value;\r\n            }\r\n            else\r\n            {\r\n                this.onUpdate = value;\r\n            }\r\n        }\r\n        else if (t === 'object' && (this.has(value, 'random') || this.hasBoth(value, 'start', 'end') || this.hasBoth(value, 'min', 'max')))\r\n        {\r\n            this.start = this.has(value, 'start') ? value.start : value.min;\r\n            this.end = this.has(value, 'end') ? value.end : value.max;\r\n\r\n            var isRandom = (this.hasBoth(value, 'min', 'max') || !!value.random);\r\n\r\n            //  A random starting value (using 'min | max' instead of 'start | end' automatically implies a random value)\r\n\r\n            //  x: { start: 100, end: 400, random: true } OR { min: 100, max: 400 } OR { random: [ 100, 400 ] }\r\n\r\n            if (isRandom)\r\n            {\r\n                var rnd = value.random;\r\n\r\n                //  x: { random: [ 100, 400 ] } = the same as doing: x: { start: 100, end: 400, random: true }\r\n                if (Array.isArray(rnd))\r\n                {\r\n                    this.start = rnd[0];\r\n                    this.end = rnd[1];\r\n                }\r\n\r\n                this.onEmit = this.randomRangedValueEmit;\r\n            }\r\n\r\n            if (this.has(value, 'steps'))\r\n            {\r\n                //  A stepped (per emit) range\r\n\r\n                //  x: { start: 100, end: 400, steps: 64 }\r\n\r\n                //  Increments a value stored in the emitter\r\n\r\n                this.steps = value.steps;\r\n                this.counter = this.start;\r\n\r\n                this.onEmit = this.steppedEmit;\r\n            }\r\n            else\r\n            {\r\n                //  An eased range (defaults to Linear if not specified)\r\n\r\n                //  x: { start: 100, end: 400, [ ease: 'Linear' ] }\r\n\r\n                var easeType = this.has(value, 'ease') ? value.ease : 'Linear';\r\n\r\n                this.ease = GetEaseFunction(easeType);\r\n\r\n                if (!isRandom)\r\n                {\r\n                    this.onEmit = this.easedValueEmit;\r\n                }\r\n\r\n                //  BUG: alpha, rotate, scaleX, scaleY, or tint are eased here if {min, max} is given.\r\n                //  Probably this branch should exclude isRandom entirely.\r\n\r\n                this.onUpdate = this.easeValueUpdate;\r\n            }\r\n        }\r\n        else if (t === 'object' && this.hasEither(value, 'onEmit', 'onUpdate'))\r\n        {\r\n            //  Custom onEmit and onUpdate callbacks\r\n\r\n            /*\r\n            x: {\r\n                //  Called at the start of the particles life, when it is being created\r\n                onEmit: function (particle, key, t, value)\r\n                {\r\n                    return value;\r\n                },\r\n\r\n                //  Called during the particles life on each update\r\n                onUpdate: function (particle, key, t, value)\r\n                {\r\n                    return value;\r\n                }\r\n            }\r\n            */\r\n\r\n            if (this.has(value, 'onEmit'))\r\n            {\r\n                this.onEmit = value.onEmit;\r\n            }\r\n\r\n            if (this.has(value, 'onUpdate'))\r\n            {\r\n                this.onUpdate = value.onUpdate;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Check whether an object has the given property.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#has\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} object - The object to check.\r\n     * @param {string} key - The key of the property to look for in the object.\r\n     *\r\n     * @return {boolean} `true` if the property exists in the object, `false` otherwise.\r\n     */\r\n    has: function (object, key)\r\n    {\r\n        return object.hasOwnProperty(key);\r\n    },\r\n\r\n    /**\r\n     * Check whether an object has both of the given properties.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#hasBoth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} object - The object to check.\r\n     * @param {string} key1 - The key of the first property to check the object for.\r\n     * @param {string} key2 - The key of the second property to check the object for.\r\n     *\r\n     * @return {boolean} `true` if both properties exist in the object, `false` otherwise.\r\n     */\r\n    hasBoth: function (object, key1, key2)\r\n    {\r\n        return object.hasOwnProperty(key1) && object.hasOwnProperty(key2);\r\n    },\r\n\r\n    /**\r\n     * Check whether an object has at least one of the given properties.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#hasEither\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} object - The object to check.\r\n     * @param {string} key1 - The key of the first property to check the object for.\r\n     * @param {string} key2 - The key of the second property to check the object for.\r\n     *\r\n     * @return {boolean} `true` if at least one of the properties exists in the object, `false` if neither exist.\r\n     */\r\n    hasEither: function (object, key1, key2)\r\n    {\r\n        return object.hasOwnProperty(key1) || object.hasOwnProperty(key2);\r\n    },\r\n\r\n    /**\r\n     * The returned value sets what the property will be at the START of the particles life, on emit.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#defaultEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n     * @param {string} key - The name of the property.\r\n     * @param {number} [value] - The current value of the property.\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    defaultEmit: function (particle, key, value)\r\n    {\r\n        return value;\r\n    },\r\n\r\n    /**\r\n     * The returned value updates the property for the duration of the particles life.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#defaultUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n     * @param {string} key - The name of the property.\r\n     * @param {number} t - The T value (between 0 and 1)\r\n     * @param {number} value - The current value of the property.\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    defaultUpdate: function (particle, key, t, value)\r\n    {\r\n        return value;\r\n    },\r\n\r\n    /**\r\n     * An `onEmit` callback that returns the current value of the property.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#staticValueEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The current value of the property.\r\n     */\r\n    staticValueEmit: function ()\r\n    {\r\n        return this.propertyValue;\r\n    },\r\n\r\n    /**\r\n     * An `onUpdate` callback that returns the current value of the property.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#staticValueUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The current value of the property.\r\n     */\r\n    staticValueUpdate: function ()\r\n    {\r\n        return this.propertyValue;\r\n    },\r\n\r\n    /**\r\n     * An `onEmit` callback that returns a random value from the current value array.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#randomStaticValueEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    randomStaticValueEmit: function ()\r\n    {\r\n        var randomIndex = Math.floor(Math.random() * this.propertyValue.length);\r\n\r\n        return this.propertyValue[randomIndex];\r\n    },\r\n\r\n    /**\r\n     * An `onEmit` callback that returns a value between the {@link Phaser.GameObjects.Particles.EmitterOp#start} and\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#end} range.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#randomRangedValueEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n     * @param {string} key - The key of the property.\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    randomRangedValueEmit: function (particle, key)\r\n    {\r\n        var value = FloatBetween(this.start, this.end);\r\n\r\n        if (particle && particle.data[key])\r\n        {\r\n            particle.data[key].min = value;\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n    /**\r\n     * An `onEmit` callback that returns a stepped value between the\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}\r\n     * range.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#steppedEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    steppedEmit: function ()\r\n    {\r\n        var current = this.counter;\r\n\r\n        var next = this.counter + (this.end - this.start) / this.steps;\r\n\r\n        this.counter = Wrap(next, this.start, this.end);\r\n\r\n        return current;\r\n    },\r\n\r\n    /**\r\n     * An `onEmit` callback for an eased property.\r\n     *\r\n     * It prepares the particle for easing by {@link Phaser.GameObjects.Particles.EmitterOp#easeValueUpdate}.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#easedValueEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n     * @param {string} key - The name of the property.\r\n     *\r\n     * @return {number} {@link Phaser.GameObjects.Particles.EmitterOp#start}, as the new value of the property.\r\n     */\r\n    easedValueEmit: function (particle, key)\r\n    {\r\n        if (particle && particle.data[key])\r\n        {\r\n            var data = particle.data[key];\r\n\r\n            data.min = this.start;\r\n            data.max = this.end;\r\n        }\r\n\r\n        return this.start;\r\n    },\r\n\r\n    /**\r\n     * An `onUpdate` callback that returns an eased value between the\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}\r\n     * range.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#easeValueUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n     * @param {string} key - The name of the property.\r\n     * @param {number} t - The T value (between 0 and 1)\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    easeValueUpdate: function (particle, key, t)\r\n    {\r\n        var data = particle.data[key];\r\n\r\n        return (data.max - data.min) * this.ease(t) + data.min;\r\n    }\r\n});\r\n\r\nmodule.exports = EmitterOp;\r\n"]},"metadata":{},"sourceType":"script"}