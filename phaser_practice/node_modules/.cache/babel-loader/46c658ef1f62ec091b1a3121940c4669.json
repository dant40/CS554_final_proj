{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Bounds = require('./lib/geometry/Bounds');\n\nvar Class = require('../../utils/Class');\n\nvar Composite = require('./lib/body/Composite');\n\nvar Constraint = require('./lib/constraint/Constraint');\n\nvar Detector = require('./lib/collision/Detector');\n\nvar Events = require('./events');\n\nvar InputEvents = require('../../input/events');\n\nvar Merge = require('../../utils/object/Merge');\n\nvar Sleeping = require('./lib/core/Sleeping');\n\nvar Vector2 = require('../../math/Vector2');\n\nvar Vertices = require('./lib/geometry/Vertices');\n/**\r\n * @classdesc\r\n * A Pointer Constraint is a special type of constraint that allows you to click\r\n * and drag bodies in a Matter World. It monitors the active Pointers in a Scene,\r\n * and when one is pressed down it checks to see if that hit any part of any active\r\n * body in the world. If it did, and the body has input enabled, it will begin to\r\n * drag it until either released, or you stop it via the `stopDrag` method.\r\n * \r\n * You can adjust the stiffness, length and other properties of the constraint via\r\n * the `options` object on creation.\r\n *\r\n * @class PointerConstraint\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene to which this Pointer Constraint belongs.\r\n * @param {Phaser.Physics.Matter.World} world - A reference to the Matter World instance to which this Constraint belongs.\r\n * @param {object} [options] - A Constraint configuration object.\r\n */\n\n\nvar PointerConstraint = new Class({\n  initialize: function PointerConstraint(scene, world, options) {\n    if (options === undefined) {\n      options = {};\n    } //  Defaults\n\n\n    var defaults = {\n      label: 'Pointer Constraint',\n      pointA: {\n        x: 0,\n        y: 0\n      },\n      pointB: {\n        x: 0,\n        y: 0\n      },\n      length: 0.01,\n      stiffness: 0.1,\n      angularStiffness: 1,\n      collisionFilter: {\n        category: 0x0001,\n        mask: 0xFFFFFFFF,\n        group: 0\n      }\n    };\n    /**\r\n     * A reference to the Scene to which this Pointer Constraint belongs.\r\n     * This is the same Scene as the Matter World instance.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n\n    this.scene = scene;\n    /**\r\n     * A reference to the Matter World instance to which this Constraint belongs.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#world\r\n     * @type {Phaser.Physics.Matter.World}\r\n     * @since 3.0.0\r\n     */\n\n    this.world = world;\n    /**\r\n     * The Camera the Pointer was interacting with when the input\r\n     * down event was processed.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#camera\r\n     * @type {Phaser.Cameras.Scene2D.Camera}\r\n     * @since 3.0.0\r\n     */\n\n    this.camera = null;\n    /**\r\n     * A reference to the Input Pointer that activated this Constraint.\r\n     * This is set in the `onDown` handler.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#pointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.pointer = null;\n    /**\r\n     * Is this Constraint active or not?\r\n     * \r\n     * An active constraint will be processed each update. An inactive one will be skipped.\r\n     * Use this to toggle a Pointer Constraint on and off.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#active\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.active = true;\n    /**\r\n     * The internal transformed position.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#position\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.position = new Vector2();\n    /**\r\n     * The body that is currently being dragged, if any.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#body\r\n     * @type {?MatterJS.BodyType}\r\n     * @since 3.16.2\r\n     */\n\n    this.body = null;\n    /**\r\n     * The part of the body that was clicked on to start the drag.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#part\r\n     * @type {?MatterJS.BodyType}\r\n     * @since 3.16.2\r\n     */\n\n    this.part = null;\n    /**\r\n     * The native Matter Constraint that is used to attach to bodies.\r\n     *\r\n     * @name Phaser.Physics.Matter.PointerConstraint#constraint\r\n     * @type {MatterJS.ConstraintType}\r\n     * @since 3.0.0\r\n     */\n\n    this.constraint = Constraint.create(Merge(options, defaults));\n    this.world.on(Events.BEFORE_UPDATE, this.update, this);\n    scene.sys.input.on(InputEvents.POINTER_DOWN, this.onDown, this);\n    scene.sys.input.on(InputEvents.POINTER_UP, this.onUp, this);\n  },\n\n  /**\r\n   * A Pointer has been pressed down onto the Scene.\r\n   * \r\n   * If this Constraint doesn't have an active Pointer then a hit test is set to\r\n   * run against all active bodies in the world during the _next_ call to `update`.\r\n   * If a body is found, it is bound to this constraint and the drag begins.\r\n   *\r\n   * @method Phaser.Physics.Matter.PointerConstraint#onDown\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - A reference to the Pointer that was pressed.\r\n   */\n  onDown: function (pointer) {\n    if (!this.pointer) {\n      this.pointer = pointer;\n      this.camera = pointer.camera;\n    }\n  },\n\n  /**\r\n   * A Pointer has been released from the Scene. If it was the one this constraint was using, it's cleared.\r\n   *\r\n   * @method Phaser.Physics.Matter.PointerConstraint#onUp\r\n   * @since 3.22.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - A reference to the Pointer that was pressed.\r\n   */\n  onUp: function (pointer) {\n    if (pointer === this.pointer) {\n      this.pointer = null;\n    }\n  },\n\n  /**\r\n   * Scans all active bodies in the current Matter World to see if any of them\r\n   * are hit by the Pointer. The _first one_ found to hit is set as the active contraint\r\n   * body.\r\n   *\r\n   * @method Phaser.Physics.Matter.PointerConstraint#getBody\r\n   * @fires Phaser.Physics.Matter.Events#DRAG_START\r\n   * @since 3.16.2\r\n   * \r\n   * @return {boolean} `true` if a body was found and set, otherwise `false`.\r\n   */\n  getBody: function (pointer) {\n    var pos = this.position;\n    var constraint = this.constraint;\n    this.camera.getWorldPoint(pointer.x, pointer.y, pos);\n    var bodies = Composite.allBodies(this.world.localWorld);\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i];\n\n      if (!body.ignorePointer && Bounds.contains(body.bounds, pos) && Detector.canCollide(body.collisionFilter, constraint.collisionFilter)) {\n        if (this.hitTestBody(body, pos)) {\n          this.world.emit(Events.DRAG_START, body, this.part, this);\n          return true;\n        }\n      }\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Scans the current body to determine if a part of it was clicked on.\r\n   * If a part is found the body is set as the `constraint.bodyB` property,\r\n   * as well as the `body` property of this class. The part is also set.\r\n   *\r\n   * @method Phaser.Physics.Matter.PointerConstraint#hitTestBody\r\n   * @since 3.16.2\r\n   *\r\n   * @param {MatterJS.BodyType} body - The Matter Body to check.\r\n   * @param {Phaser.Math.Vector2} position - A translated hit test position.\r\n   *\r\n   * @return {boolean} `true` if a part of the body was hit, otherwise `false`.\r\n   */\n  hitTestBody: function (body, position) {\n    var constraint = this.constraint;\n    var partsLength = body.parts.length;\n    var start = partsLength > 1 ? 1 : 0;\n\n    for (var i = start; i < partsLength; i++) {\n      var part = body.parts[i];\n\n      if (Vertices.contains(part.vertices, position)) {\n        constraint.pointA = position;\n        constraint.pointB = {\n          x: position.x - body.position.x,\n          y: position.y - body.position.y\n        };\n        constraint.bodyB = body;\n        constraint.angleB = body.angle;\n        Sleeping.set(body, false);\n        this.part = part;\n        this.body = body;\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Internal update handler. Called in the Matter BEFORE_UPDATE step.\r\n   *\r\n   * @method Phaser.Physics.Matter.PointerConstraint#update\r\n   * @fires Phaser.Physics.Matter.Events#DRAG\r\n   * @since 3.0.0\r\n   */\n  update: function () {\n    var pointer = this.pointer;\n    var body = this.body;\n\n    if (!this.active || !pointer) {\n      if (body) {\n        this.stopDrag();\n      }\n\n      return;\n    }\n\n    if (!pointer.isDown && body) {\n      this.stopDrag();\n      return;\n    } else if (pointer.isDown) {\n      if (!body && !this.getBody(pointer)) {\n        return;\n      }\n\n      body = this.body;\n      var pos = this.position;\n      var constraint = this.constraint;\n      this.camera.getWorldPoint(pointer.x, pointer.y, pos); //  Drag update\n\n      constraint.pointA.x = pos.x;\n      constraint.pointA.y = pos.y;\n      Sleeping.set(body, false);\n      this.world.emit(Events.DRAG, body, this);\n    }\n  },\n\n  /**\r\n   * Stops the Pointer Constraint from dragging the body any further.\r\n   * \r\n   * This is called automatically if the Pointer is released while actively\r\n   * dragging a body. Or, you can call it manually to release a body from a\r\n   * constraint without having to first release the pointer.\r\n   *\r\n   * @method Phaser.Physics.Matter.PointerConstraint#stopDrag\r\n   * @fires Phaser.Physics.Matter.Events#DRAG_END\r\n   * @since 3.16.2\r\n   */\n  stopDrag: function () {\n    var body = this.body;\n    var constraint = this.constraint;\n    constraint.bodyB = null;\n    constraint.pointB = null;\n    this.pointer = null;\n    this.body = null;\n    this.part = null;\n\n    if (body) {\n      this.world.emit(Events.DRAG_END, body, this);\n    }\n  },\n\n  /**\r\n   * Destroys this Pointer Constraint instance and all of its references.\r\n   *\r\n   * @method Phaser.Physics.Matter.PointerConstraint#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.world.removeConstraint(this.constraint);\n    this.pointer = null;\n    this.constraint = null;\n    this.body = null;\n    this.part = null;\n    this.world.off(Events.BEFORE_UPDATE, this.update);\n    this.scene.sys.input.off(InputEvents.POINTER_DOWN, this.onDown, this);\n    this.scene.sys.input.off(InputEvents.POINTER_UP, this.onUp, this);\n  }\n});\nmodule.exports = PointerConstraint;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/PointerConstraint.js"],"names":["Bounds","require","Class","Composite","Constraint","Detector","Events","InputEvents","Merge","Sleeping","Vector2","Vertices","PointerConstraint","initialize","scene","world","options","undefined","defaults","label","pointA","x","y","pointB","length","stiffness","angularStiffness","collisionFilter","category","mask","group","camera","pointer","active","position","body","part","constraint","create","on","BEFORE_UPDATE","update","sys","input","POINTER_DOWN","onDown","POINTER_UP","onUp","getBody","pos","getWorldPoint","bodies","allBodies","localWorld","i","ignorePointer","contains","bounds","canCollide","hitTestBody","emit","DRAG_START","partsLength","parts","start","vertices","bodyB","angleB","angle","set","stopDrag","isDown","DRAG","DRAG_END","destroy","removeConstraint","off","module","exports"],"mappings":"AAAA;;;;;AAMA,IAAIA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAApB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,mBAAD,CAAnB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,sBAAD,CAAvB;;AACA,IAAIG,UAAU,GAAGH,OAAO,CAAC,6BAAD,CAAxB;;AACA,IAAII,QAAQ,GAAGJ,OAAO,CAAC,0BAAD,CAAtB;;AACA,IAAIK,MAAM,GAAGL,OAAO,CAAC,UAAD,CAApB;;AACA,IAAIM,WAAW,GAAGN,OAAO,CAAC,oBAAD,CAAzB;;AACA,IAAIO,KAAK,GAAGP,OAAO,CAAC,0BAAD,CAAnB;;AACA,IAAIQ,QAAQ,GAAGR,OAAO,CAAC,qBAAD,CAAtB;;AACA,IAAIS,OAAO,GAAGT,OAAO,CAAC,oBAAD,CAArB;;AACA,IAAIU,QAAQ,GAAGV,OAAO,CAAC,yBAAD,CAAtB;AAEA;;;;;;;;;;;;;;;;;;;;;;AAoBA,IAAIW,iBAAiB,GAAG,IAAIV,KAAJ,CAAU;AAE9BW,EAAAA,UAAU,EAEV,SAASD,iBAAT,CAA4BE,KAA5B,EAAmCC,KAAnC,EAA0CC,OAA1C,EACA;AACI,QAAIA,OAAO,KAAKC,SAAhB,EAA2B;AAAED,MAAAA,OAAO,GAAG,EAAV;AAAe,KADhD,CAGI;;;AACA,QAAIE,QAAQ,GAAG;AACXC,MAAAA,KAAK,EAAE,oBADI;AAEXC,MAAAA,MAAM,EAAE;AAAEC,QAAAA,CAAC,EAAE,CAAL;AAAQC,QAAAA,CAAC,EAAE;AAAX,OAFG;AAGXC,MAAAA,MAAM,EAAE;AAAEF,QAAAA,CAAC,EAAE,CAAL;AAAQC,QAAAA,CAAC,EAAE;AAAX,OAHG;AAIXE,MAAAA,MAAM,EAAE,IAJG;AAKXC,MAAAA,SAAS,EAAE,GALA;AAMXC,MAAAA,gBAAgB,EAAE,CANP;AAOXC,MAAAA,eAAe,EAAE;AACbC,QAAAA,QAAQ,EAAE,MADG;AAEbC,QAAAA,IAAI,EAAE,UAFO;AAGbC,QAAAA,KAAK,EAAE;AAHM;AAPN,KAAf;AAcA;;;;;;;;;AAQA,SAAKhB,KAAL,GAAaA,KAAb;AAEA;;;;;;;;AAOA,SAAKC,KAAL,GAAaA,KAAb;AAEA;;;;;;;;;AAQA,SAAKgB,MAAL,GAAc,IAAd;AAEA;;;;;;;;;;AASA,SAAKC,OAAL,GAAe,IAAf;AAEA;;;;;;;;;;;;AAWA,SAAKC,MAAL,GAAc,IAAd;AAEA;;;;;;;;AAOA,SAAKC,QAAL,GAAgB,IAAIxB,OAAJ,EAAhB;AAEA;;;;;;;;AAOA,SAAKyB,IAAL,GAAY,IAAZ;AAEA;;;;;;;;AAOA,SAAKC,IAAL,GAAY,IAAZ;AAEA;;;;;;;;AAOA,SAAKC,UAAL,GAAkBjC,UAAU,CAACkC,MAAX,CAAkB9B,KAAK,CAACQ,OAAD,EAAUE,QAAV,CAAvB,CAAlB;AAEA,SAAKH,KAAL,CAAWwB,EAAX,CAAcjC,MAAM,CAACkC,aAArB,EAAoC,KAAKC,MAAzC,EAAiD,IAAjD;AAEA3B,IAAAA,KAAK,CAAC4B,GAAN,CAAUC,KAAV,CAAgBJ,EAAhB,CAAmBhC,WAAW,CAACqC,YAA/B,EAA6C,KAAKC,MAAlD,EAA0D,IAA1D;AACA/B,IAAAA,KAAK,CAAC4B,GAAN,CAAUC,KAAV,CAAgBJ,EAAhB,CAAmBhC,WAAW,CAACuC,UAA/B,EAA2C,KAAKC,IAAhD,EAAsD,IAAtD;AACH,GApH6B;;AAsH9B;;;;;;;;;;;;AAYAF,EAAAA,MAAM,EAAE,UAAUb,OAAV,EACR;AACI,QAAI,CAAC,KAAKA,OAAV,EACA;AACI,WAAKA,OAAL,GAAeA,OAAf;AACA,WAAKD,MAAL,GAAcC,OAAO,CAACD,MAAtB;AACH;AACJ,GAzI6B;;AA2I9B;;;;;;;;AAQAgB,EAAAA,IAAI,EAAE,UAAUf,OAAV,EACN;AACI,QAAIA,OAAO,KAAK,KAAKA,OAArB,EACA;AACI,WAAKA,OAAL,GAAe,IAAf;AACH;AACJ,GAzJ6B;;AA2J9B;;;;;;;;;;;AAWAgB,EAAAA,OAAO,EAAE,UAAUhB,OAAV,EACT;AACI,QAAIiB,GAAG,GAAG,KAAKf,QAAf;AACA,QAAIG,UAAU,GAAG,KAAKA,UAAtB;AAEA,SAAKN,MAAL,CAAYmB,aAAZ,CAA0BlB,OAAO,CAACX,CAAlC,EAAqCW,OAAO,CAACV,CAA7C,EAAgD2B,GAAhD;AAEA,QAAIE,MAAM,GAAGhD,SAAS,CAACiD,SAAV,CAAoB,KAAKrC,KAAL,CAAWsC,UAA/B,CAAb;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAAC3B,MAA3B,EAAmC8B,CAAC,EAApC,EACA;AACI,UAAInB,IAAI,GAAGgB,MAAM,CAACG,CAAD,CAAjB;;AAEA,UAAI,CAACnB,IAAI,CAACoB,aAAN,IACAvD,MAAM,CAACwD,QAAP,CAAgBrB,IAAI,CAACsB,MAArB,EAA6BR,GAA7B,CADA,IAEA5C,QAAQ,CAACqD,UAAT,CAAoBvB,IAAI,CAACR,eAAzB,EAA0CU,UAAU,CAACV,eAArD,CAFJ,EAGA;AACI,YAAI,KAAKgC,WAAL,CAAiBxB,IAAjB,EAAuBc,GAAvB,CAAJ,EACA;AACI,eAAKlC,KAAL,CAAW6C,IAAX,CAAgBtD,MAAM,CAACuD,UAAvB,EAAmC1B,IAAnC,EAAyC,KAAKC,IAA9C,EAAoD,IAApD;AAEA,iBAAO,IAAP;AACH;AACJ;AACJ;;AAED,WAAO,KAAP;AACH,GAjM6B;;AAmM9B;;;;;;;;;;;;;AAaAuB,EAAAA,WAAW,EAAE,UAAUxB,IAAV,EAAgBD,QAAhB,EACb;AACI,QAAIG,UAAU,GAAG,KAAKA,UAAtB;AACA,QAAIyB,WAAW,GAAG3B,IAAI,CAAC4B,KAAL,CAAWvC,MAA7B;AAEA,QAAIwC,KAAK,GAAIF,WAAW,GAAG,CAAf,GAAoB,CAApB,GAAwB,CAApC;;AAEA,SAAK,IAAIR,CAAC,GAAGU,KAAb,EAAoBV,CAAC,GAAGQ,WAAxB,EAAqCR,CAAC,EAAtC,EACA;AACI,UAAIlB,IAAI,GAAGD,IAAI,CAAC4B,KAAL,CAAWT,CAAX,CAAX;;AAEA,UAAI3C,QAAQ,CAAC6C,QAAT,CAAkBpB,IAAI,CAAC6B,QAAvB,EAAiC/B,QAAjC,CAAJ,EACA;AACIG,QAAAA,UAAU,CAACjB,MAAX,GAAoBc,QAApB;AACAG,QAAAA,UAAU,CAACd,MAAX,GAAoB;AAAEF,UAAAA,CAAC,EAAEa,QAAQ,CAACb,CAAT,GAAac,IAAI,CAACD,QAAL,CAAcb,CAAhC;AAAmCC,UAAAA,CAAC,EAAEY,QAAQ,CAACZ,CAAT,GAAaa,IAAI,CAACD,QAAL,CAAcZ;AAAjE,SAApB;AAEAe,QAAAA,UAAU,CAAC6B,KAAX,GAAmB/B,IAAnB;AACAE,QAAAA,UAAU,CAAC8B,MAAX,GAAoBhC,IAAI,CAACiC,KAAzB;AAEA3D,QAAAA,QAAQ,CAAC4D,GAAT,CAAalC,IAAb,EAAmB,KAAnB;AAEA,aAAKC,IAAL,GAAYA,IAAZ;AACA,aAAKD,IAAL,GAAYA,IAAZ;AAEA,eAAO,IAAP;AACH;AACJ;;AAED,WAAO,KAAP;AACH,GA7O6B;;AA+O9B;;;;;;;AAOAM,EAAAA,MAAM,EAAE,YACR;AACI,QAAIT,OAAO,GAAG,KAAKA,OAAnB;AACA,QAAIG,IAAI,GAAG,KAAKA,IAAhB;;AAEA,QAAI,CAAC,KAAKF,MAAN,IAAgB,CAACD,OAArB,EACA;AACI,UAAIG,IAAJ,EACA;AACI,aAAKmC,QAAL;AACH;;AAED;AACH;;AAED,QAAI,CAACtC,OAAO,CAACuC,MAAT,IAAmBpC,IAAvB,EACA;AACI,WAAKmC,QAAL;AAEA;AACH,KALD,MAMK,IAAItC,OAAO,CAACuC,MAAZ,EACL;AACI,UAAI,CAACpC,IAAD,IAAS,CAAC,KAAKa,OAAL,CAAahB,OAAb,CAAd,EACA;AACI;AACH;;AAEDG,MAAAA,IAAI,GAAG,KAAKA,IAAZ;AAEA,UAAIc,GAAG,GAAG,KAAKf,QAAf;AACA,UAAIG,UAAU,GAAG,KAAKA,UAAtB;AAEA,WAAKN,MAAL,CAAYmB,aAAZ,CAA0BlB,OAAO,CAACX,CAAlC,EAAqCW,OAAO,CAACV,CAA7C,EAAgD2B,GAAhD,EAXJ,CAaI;;AACAZ,MAAAA,UAAU,CAACjB,MAAX,CAAkBC,CAAlB,GAAsB4B,GAAG,CAAC5B,CAA1B;AACAgB,MAAAA,UAAU,CAACjB,MAAX,CAAkBE,CAAlB,GAAsB2B,GAAG,CAAC3B,CAA1B;AAEAb,MAAAA,QAAQ,CAAC4D,GAAT,CAAalC,IAAb,EAAmB,KAAnB;AAEA,WAAKpB,KAAL,CAAW6C,IAAX,CAAgBtD,MAAM,CAACkE,IAAvB,EAA6BrC,IAA7B,EAAmC,IAAnC;AACH;AACJ,GAjS6B;;AAmS9B;;;;;;;;;;;AAWAmC,EAAAA,QAAQ,EAAE,YACV;AACI,QAAInC,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAIE,UAAU,GAAG,KAAKA,UAAtB;AAEAA,IAAAA,UAAU,CAAC6B,KAAX,GAAmB,IAAnB;AACA7B,IAAAA,UAAU,CAACd,MAAX,GAAoB,IAApB;AAEA,SAAKS,OAAL,GAAe,IAAf;AACA,SAAKG,IAAL,GAAY,IAAZ;AACA,SAAKC,IAAL,GAAY,IAAZ;;AAEA,QAAID,IAAJ,EACA;AACI,WAAKpB,KAAL,CAAW6C,IAAX,CAAgBtD,MAAM,CAACmE,QAAvB,EAAiCtC,IAAjC,EAAuC,IAAvC;AACH;AACJ,GA9T6B;;AAgU9B;;;;;;AAMAuC,EAAAA,OAAO,EAAE,YACT;AACI,SAAK3D,KAAL,CAAW4D,gBAAX,CAA4B,KAAKtC,UAAjC;AAEA,SAAKL,OAAL,GAAe,IAAf;AACA,SAAKK,UAAL,GAAkB,IAAlB;AACA,SAAKF,IAAL,GAAY,IAAZ;AACA,SAAKC,IAAL,GAAY,IAAZ;AAEA,SAAKrB,KAAL,CAAW6D,GAAX,CAAetE,MAAM,CAACkC,aAAtB,EAAqC,KAAKC,MAA1C;AAEA,SAAK3B,KAAL,CAAW4B,GAAX,CAAeC,KAAf,CAAqBiC,GAArB,CAAyBrE,WAAW,CAACqC,YAArC,EAAmD,KAAKC,MAAxD,EAAgE,IAAhE;AACA,SAAK/B,KAAL,CAAW4B,GAAX,CAAeC,KAAf,CAAqBiC,GAArB,CAAyBrE,WAAW,CAACuC,UAArC,EAAiD,KAAKC,IAAtD,EAA4D,IAA5D;AACH;AAnV6B,CAAV,CAAxB;AAuVA8B,MAAM,CAACC,OAAP,GAAiBlE,iBAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Bounds = require('./lib/geometry/Bounds');\r\nvar Class = require('../../utils/Class');\r\nvar Composite = require('./lib/body/Composite');\r\nvar Constraint = require('./lib/constraint/Constraint');\r\nvar Detector = require('./lib/collision/Detector');\r\nvar Events = require('./events');\r\nvar InputEvents = require('../../input/events');\r\nvar Merge = require('../../utils/object/Merge');\r\nvar Sleeping = require('./lib/core/Sleeping');\r\nvar Vector2 = require('../../math/Vector2');\r\nvar Vertices = require('./lib/geometry/Vertices');\r\n\r\n/**\r\n * @classdesc\r\n * A Pointer Constraint is a special type of constraint that allows you to click\r\n * and drag bodies in a Matter World. It monitors the active Pointers in a Scene,\r\n * and when one is pressed down it checks to see if that hit any part of any active\r\n * body in the world. If it did, and the body has input enabled, it will begin to\r\n * drag it until either released, or you stop it via the `stopDrag` method.\r\n * \r\n * You can adjust the stiffness, length and other properties of the constraint via\r\n * the `options` object on creation.\r\n *\r\n * @class PointerConstraint\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene to which this Pointer Constraint belongs.\r\n * @param {Phaser.Physics.Matter.World} world - A reference to the Matter World instance to which this Constraint belongs.\r\n * @param {object} [options] - A Constraint configuration object.\r\n */\r\nvar PointerConstraint = new Class({\r\n\r\n    initialize:\r\n\r\n    function PointerConstraint (scene, world, options)\r\n    {\r\n        if (options === undefined) { options = {}; }\r\n\r\n        //  Defaults\r\n        var defaults = {\r\n            label: 'Pointer Constraint',\r\n            pointA: { x: 0, y: 0 },\r\n            pointB: { x: 0, y: 0 },\r\n            length: 0.01,\r\n            stiffness: 0.1,\r\n            angularStiffness: 1,\r\n            collisionFilter: {\r\n                category: 0x0001,\r\n                mask: 0xFFFFFFFF,\r\n                group: 0\r\n            }\r\n        };\r\n\r\n        /**\r\n         * A reference to the Scene to which this Pointer Constraint belongs.\r\n         * This is the same Scene as the Matter World instance.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Matter World instance to which this Constraint belongs.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#world\r\n         * @type {Phaser.Physics.Matter.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        /**\r\n         * The Camera the Pointer was interacting with when the input\r\n         * down event was processed.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#camera\r\n         * @type {Phaser.Cameras.Scene2D.Camera}\r\n         * @since 3.0.0\r\n         */\r\n        this.camera = null;\r\n\r\n        /**\r\n         * A reference to the Input Pointer that activated this Constraint.\r\n         * This is set in the `onDown` handler.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#pointer\r\n         * @type {Phaser.Input.Pointer}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.pointer = null;\r\n\r\n        /**\r\n         * Is this Constraint active or not?\r\n         * \r\n         * An active constraint will be processed each update. An inactive one will be skipped.\r\n         * Use this to toggle a Pointer Constraint on and off.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * The internal transformed position.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#position\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.position = new Vector2();\r\n\r\n        /**\r\n         * The body that is currently being dragged, if any.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#body\r\n         * @type {?MatterJS.BodyType}\r\n         * @since 3.16.2\r\n         */\r\n        this.body = null;\r\n\r\n        /**\r\n         * The part of the body that was clicked on to start the drag.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#part\r\n         * @type {?MatterJS.BodyType}\r\n         * @since 3.16.2\r\n         */\r\n        this.part = null;\r\n\r\n        /**\r\n         * The native Matter Constraint that is used to attach to bodies.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#constraint\r\n         * @type {MatterJS.ConstraintType}\r\n         * @since 3.0.0\r\n         */\r\n        this.constraint = Constraint.create(Merge(options, defaults));\r\n\r\n        this.world.on(Events.BEFORE_UPDATE, this.update, this);\r\n\r\n        scene.sys.input.on(InputEvents.POINTER_DOWN, this.onDown, this);\r\n        scene.sys.input.on(InputEvents.POINTER_UP, this.onUp, this);\r\n    },\r\n\r\n    /**\r\n     * A Pointer has been pressed down onto the Scene.\r\n     * \r\n     * If this Constraint doesn't have an active Pointer then a hit test is set to\r\n     * run against all active bodies in the world during the _next_ call to `update`.\r\n     * If a body is found, it is bound to this constraint and the drag begins.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#onDown\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - A reference to the Pointer that was pressed.\r\n     */\r\n    onDown: function (pointer)\r\n    {\r\n        if (!this.pointer)\r\n        {\r\n            this.pointer = pointer;\r\n            this.camera = pointer.camera;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * A Pointer has been released from the Scene. If it was the one this constraint was using, it's cleared.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#onUp\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - A reference to the Pointer that was pressed.\r\n     */\r\n    onUp: function (pointer)\r\n    {\r\n        if (pointer === this.pointer)\r\n        {\r\n            this.pointer = null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Scans all active bodies in the current Matter World to see if any of them\r\n     * are hit by the Pointer. The _first one_ found to hit is set as the active contraint\r\n     * body.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#getBody\r\n     * @fires Phaser.Physics.Matter.Events#DRAG_START\r\n     * @since 3.16.2\r\n     * \r\n     * @return {boolean} `true` if a body was found and set, otherwise `false`.\r\n     */\r\n    getBody: function (pointer)\r\n    {\r\n        var pos = this.position;\r\n        var constraint = this.constraint;\r\n\r\n        this.camera.getWorldPoint(pointer.x, pointer.y, pos);\r\n\r\n        var bodies = Composite.allBodies(this.world.localWorld);\r\n\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            var body = bodies[i];\r\n\r\n            if (!body.ignorePointer &&\r\n                Bounds.contains(body.bounds, pos) &&\r\n                Detector.canCollide(body.collisionFilter, constraint.collisionFilter))\r\n            {\r\n                if (this.hitTestBody(body, pos))\r\n                {\r\n                    this.world.emit(Events.DRAG_START, body, this.part, this);\r\n\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Scans the current body to determine if a part of it was clicked on.\r\n     * If a part is found the body is set as the `constraint.bodyB` property,\r\n     * as well as the `body` property of this class. The part is also set.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#hitTestBody\r\n     * @since 3.16.2\r\n     *\r\n     * @param {MatterJS.BodyType} body - The Matter Body to check.\r\n     * @param {Phaser.Math.Vector2} position - A translated hit test position.\r\n     *\r\n     * @return {boolean} `true` if a part of the body was hit, otherwise `false`.\r\n     */\r\n    hitTestBody: function (body, position)\r\n    {\r\n        var constraint = this.constraint;\r\n        var partsLength = body.parts.length;\r\n\r\n        var start = (partsLength > 1) ? 1 : 0;\r\n\r\n        for (var i = start; i < partsLength; i++)\r\n        {\r\n            var part = body.parts[i];\r\n\r\n            if (Vertices.contains(part.vertices, position))\r\n            {\r\n                constraint.pointA = position;\r\n                constraint.pointB = { x: position.x - body.position.x, y: position.y - body.position.y };\r\n\r\n                constraint.bodyB = body;\r\n                constraint.angleB = body.angle;\r\n\r\n                Sleeping.set(body, false);\r\n\r\n                this.part = part;\r\n                this.body = body;\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler. Called in the Matter BEFORE_UPDATE step.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#update\r\n     * @fires Phaser.Physics.Matter.Events#DRAG\r\n     * @since 3.0.0\r\n     */\r\n    update: function ()\r\n    {\r\n        var pointer = this.pointer;\r\n        var body = this.body;\r\n\r\n        if (!this.active || !pointer)\r\n        {\r\n            if (body)\r\n            {\r\n                this.stopDrag();\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (!pointer.isDown && body)\r\n        {\r\n            this.stopDrag();\r\n\r\n            return;\r\n        }\r\n        else if (pointer.isDown)\r\n        {\r\n            if (!body && !this.getBody(pointer))\r\n            {\r\n                return;\r\n            }\r\n\r\n            body = this.body;\r\n\r\n            var pos = this.position;\r\n            var constraint = this.constraint;\r\n    \r\n            this.camera.getWorldPoint(pointer.x, pointer.y, pos);\r\n   \r\n            //  Drag update\r\n            constraint.pointA.x = pos.x;\r\n            constraint.pointA.y = pos.y;\r\n\r\n            Sleeping.set(body, false);\r\n\r\n            this.world.emit(Events.DRAG, body, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Stops the Pointer Constraint from dragging the body any further.\r\n     * \r\n     * This is called automatically if the Pointer is released while actively\r\n     * dragging a body. Or, you can call it manually to release a body from a\r\n     * constraint without having to first release the pointer.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#stopDrag\r\n     * @fires Phaser.Physics.Matter.Events#DRAG_END\r\n     * @since 3.16.2\r\n     */\r\n    stopDrag: function ()\r\n    {\r\n        var body = this.body;\r\n        var constraint = this.constraint;\r\n\r\n        constraint.bodyB = null;\r\n        constraint.pointB = null;\r\n\r\n        this.pointer = null;\r\n        this.body = null;\r\n        this.part = null;\r\n\r\n        if (body)\r\n        {\r\n            this.world.emit(Events.DRAG_END, body, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys this Pointer Constraint instance and all of its references.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.world.removeConstraint(this.constraint);\r\n\r\n        this.pointer = null;\r\n        this.constraint = null;\r\n        this.body = null;\r\n        this.part = null;\r\n\r\n        this.world.off(Events.BEFORE_UPDATE, this.update);\r\n\r\n        this.scene.sys.input.off(InputEvents.POINTER_DOWN, this.onDown, this);\r\n        this.scene.sys.input.off(InputEvents.POINTER_UP, this.onUp, this);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = PointerConstraint;\r\n"]},"metadata":{},"sourceType":"script"}