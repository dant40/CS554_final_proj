{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.DynamicBitmapText#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.DynamicBitmapText} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\n\n\nvar DynamicBitmapTextCanvasRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix) {\n  var text = src._text;\n  var textLength = text.length;\n  var ctx = renderer.currentContext;\n\n  if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {\n    return;\n  }\n\n  var textureFrame = src.frame;\n  var displayCallback = src.displayCallback;\n  var callbackData = src.callbackData;\n  var chars = src.fontData.chars;\n  var lineHeight = src.fontData.lineHeight;\n  var letterSpacing = src._letterSpacing;\n  var xAdvance = 0;\n  var yAdvance = 0;\n  var charCode = 0;\n  var glyph = null;\n  var glyphX = 0;\n  var glyphY = 0;\n  var glyphW = 0;\n  var glyphH = 0;\n  var x = 0;\n  var y = 0;\n  var lastGlyph = null;\n  var lastCharCode = 0;\n  var image = src.frame.source.image;\n  var textureX = textureFrame.cutX;\n  var textureY = textureFrame.cutY;\n  var rotation = 0;\n  var scale = 0;\n  var baseScale = src._fontSize / src.fontData.size;\n  var align = src._align;\n  var currentLine = 0;\n  var lineOffsetX = 0; //  Update the bounds - skipped internally if not dirty\n\n  src.getTextBounds(false);\n  var lineData = src._bounds.lines;\n\n  if (align === 1) {\n    lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;\n  } else if (align === 2) {\n    lineOffsetX = lineData.longest - lineData.lengths[0];\n  }\n\n  ctx.translate(-src.displayOriginX, -src.displayOriginY);\n  var roundPixels = camera.roundPixels;\n\n  if (src.cropWidth > 0 && src.cropHeight > 0) {\n    ctx.beginPath();\n    ctx.rect(0, 0, src.cropWidth, src.cropHeight);\n    ctx.clip();\n  }\n\n  for (var i = 0; i < textLength; i++) {\n    //  Reset the scale (in case the callback changed it)\n    scale = baseScale;\n    rotation = 0;\n    charCode = text.charCodeAt(i);\n\n    if (charCode === 10) {\n      currentLine++;\n\n      if (align === 1) {\n        lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;\n      } else if (align === 2) {\n        lineOffsetX = lineData.longest - lineData.lengths[currentLine];\n      }\n\n      xAdvance = 0;\n      yAdvance += lineHeight;\n      lastGlyph = null;\n      continue;\n    }\n\n    glyph = chars[charCode];\n\n    if (!glyph) {\n      continue;\n    }\n\n    glyphX = textureX + glyph.x;\n    glyphY = textureY + glyph.y;\n    glyphW = glyph.width;\n    glyphH = glyph.height;\n    x = glyph.xOffset + xAdvance - src.scrollX;\n    y = glyph.yOffset + yAdvance - src.scrollY;\n\n    if (lastGlyph !== null) {\n      var kerningOffset = glyph.kerning[lastCharCode];\n      x += kerningOffset !== undefined ? kerningOffset : 0;\n    }\n\n    if (displayCallback) {\n      callbackData.index = i;\n      callbackData.charCode = charCode;\n      callbackData.x = x;\n      callbackData.y = y;\n      callbackData.scale = scale;\n      callbackData.rotation = rotation;\n      callbackData.data = glyph.data;\n      var output = displayCallback(callbackData);\n      x = output.x;\n      y = output.y;\n      scale = output.scale;\n      rotation = output.rotation;\n    }\n\n    x *= scale;\n    y *= scale;\n    x += lineOffsetX;\n    xAdvance += glyph.xAdvance + letterSpacing;\n    lastGlyph = glyph;\n    lastCharCode = charCode; //  Nothing to render or a space? Then skip to the next glyph\n\n    if (glyphW === 0 || glyphH === 0 || charCode === 32) {\n      continue;\n    }\n\n    if (roundPixels) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(rotation);\n    ctx.scale(scale, scale);\n    ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);\n    ctx.restore();\n  }\n\n  ctx.restore();\n};\n\nmodule.exports = DynamicBitmapTextCanvasRenderer;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapTextCanvasRenderer.js"],"names":["SetTransform","require","DynamicBitmapTextCanvasRenderer","renderer","src","interpolationPercentage","camera","parentMatrix","text","_text","textLength","length","ctx","currentContext","textureFrame","frame","displayCallback","callbackData","chars","fontData","lineHeight","letterSpacing","_letterSpacing","xAdvance","yAdvance","charCode","glyph","glyphX","glyphY","glyphW","glyphH","x","y","lastGlyph","lastCharCode","image","source","textureX","cutX","textureY","cutY","rotation","scale","baseScale","_fontSize","size","align","_align","currentLine","lineOffsetX","getTextBounds","lineData","_bounds","lines","longest","lengths","translate","displayOriginX","displayOriginY","roundPixels","cropWidth","cropHeight","beginPath","rect","clip","i","charCodeAt","width","height","xOffset","scrollX","yOffset","scrollY","kerningOffset","kerning","undefined","index","data","output","Math","round","save","rotate","drawImage","restore","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.DynamicBitmapText#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.DynamicBitmapText} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar DynamicBitmapTextCanvasRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix)\r\n{\r\n    var text = src._text;\r\n    var textLength = text.length;\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        return;\r\n    }\r\n    \r\n    var textureFrame = src.frame;\r\n\r\n    var displayCallback = src.displayCallback;\r\n    var callbackData = src.callbackData;\r\n\r\n    var chars = src.fontData.chars;\r\n    var lineHeight = src.fontData.lineHeight;\r\n    var letterSpacing = src._letterSpacing;\r\n\r\n    var xAdvance = 0;\r\n    var yAdvance = 0;\r\n\r\n    var charCode = 0;\r\n\r\n    var glyph = null;\r\n    var glyphX = 0;\r\n    var glyphY = 0;\r\n    var glyphW = 0;\r\n    var glyphH = 0;\r\n\r\n    var x = 0;\r\n    var y = 0;\r\n\r\n    var lastGlyph = null;\r\n    var lastCharCode = 0;\r\n\r\n    var image = src.frame.source.image;\r\n\r\n    var textureX = textureFrame.cutX;\r\n    var textureY = textureFrame.cutY;\r\n\r\n    var rotation = 0;\r\n    var scale = 0;\r\n    var baseScale = (src._fontSize / src.fontData.size);\r\n\r\n    var align = src._align;\r\n    var currentLine = 0;\r\n    var lineOffsetX = 0;\r\n\r\n    //  Update the bounds - skipped internally if not dirty\r\n    src.getTextBounds(false);\r\n\r\n    var lineData = src._bounds.lines;\r\n\r\n    if (align === 1)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;\r\n    }\r\n    else if (align === 2)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]);\r\n    }\r\n\r\n    ctx.translate(-src.displayOriginX, -src.displayOriginY);\r\n\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    if (src.cropWidth > 0 && src.cropHeight > 0)\r\n    {\r\n        ctx.beginPath();\r\n        ctx.rect(0, 0, src.cropWidth, src.cropHeight);\r\n        ctx.clip();\r\n    }\r\n\r\n    for (var i = 0; i < textLength; i++)\r\n    {\r\n        //  Reset the scale (in case the callback changed it)\r\n        scale = baseScale;\r\n        rotation = 0;\r\n\r\n        charCode = text.charCodeAt(i);\r\n\r\n        if (charCode === 10)\r\n        {\r\n            currentLine++;\r\n\r\n            if (align === 1)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;\r\n            }\r\n            else if (align === 2)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]);\r\n            }\r\n\r\n            xAdvance = 0;\r\n            yAdvance += lineHeight;\r\n            lastGlyph = null;\r\n\r\n            continue;\r\n        }\r\n\r\n        glyph = chars[charCode];\r\n\r\n        if (!glyph)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        glyphX = textureX + glyph.x;\r\n        glyphY = textureY + glyph.y;\r\n\r\n        glyphW = glyph.width;\r\n        glyphH = glyph.height;\r\n\r\n        x = (glyph.xOffset + xAdvance) - src.scrollX;\r\n        y = (glyph.yOffset + yAdvance) - src.scrollY;\r\n\r\n        if (lastGlyph !== null)\r\n        {\r\n            var kerningOffset = glyph.kerning[lastCharCode];\r\n            x += (kerningOffset !== undefined) ? kerningOffset : 0;\r\n        }\r\n\r\n        if (displayCallback)\r\n        {\r\n            callbackData.index = i;\r\n            callbackData.charCode = charCode;\r\n            callbackData.x = x;\r\n            callbackData.y = y;\r\n            callbackData.scale = scale;\r\n            callbackData.rotation = rotation;\r\n            callbackData.data = glyph.data;\r\n\r\n            var output = displayCallback(callbackData);\r\n\r\n            x = output.x;\r\n            y = output.y;\r\n            scale = output.scale;\r\n            rotation = output.rotation;\r\n        }\r\n\r\n        x *= scale;\r\n        y *= scale;\r\n\r\n        x += lineOffsetX;\r\n\r\n        xAdvance += glyph.xAdvance + letterSpacing;\r\n        lastGlyph = glyph;\r\n        lastCharCode = charCode;\r\n\r\n        //  Nothing to render or a space? Then skip to the next glyph\r\n        if (glyphW === 0 || glyphH === 0 || charCode === 32)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (roundPixels)\r\n        {\r\n            x = Math.round(x);\r\n            y = Math.round(y);\r\n        }\r\n\r\n        ctx.save();\r\n\r\n        ctx.translate(x, y);\r\n\r\n        ctx.rotate(rotation);\r\n\r\n        ctx.scale(scale, scale);\r\n\r\n        ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    ctx.restore();\r\n};\r\n\r\nmodule.exports = DynamicBitmapTextCanvasRenderer;\r\n"]},"metadata":{},"sourceType":"script"}