{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar CONST = require('./const');\n\nvar DefaultPlugins = require('../plugins/DefaultPlugins');\n\nvar Events = require('./events');\n\nvar GetPhysicsPlugins = require('./GetPhysicsPlugins');\n\nvar GetScenePlugins = require('./GetScenePlugins');\n\nvar NOOP = require('../utils/NOOP');\n\nvar Settings = require('./Settings');\n/**\r\n * @classdesc\r\n * The Scene Systems class.\r\n *\r\n * This class is available from within a Scene under the property `sys`.\r\n * It is responsible for managing all of the plugins a Scene has running, including the display list, and\r\n * handling the update step and renderer. It also contains references to global systems belonging to Game.\r\n *\r\n * @class Systems\r\n * @memberof Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that owns this Systems instance.\r\n * @param {(string|Phaser.Types.Scenes.SettingsConfig)} config - Scene specific configuration settings.\r\n */\n\n\nvar Systems = new Class({\n  initialize: function Systems(scene, config) {\n    /**\r\n     * A reference to the Scene that these Systems belong to.\r\n     *\r\n     * @name Phaser.Scenes.Systems#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n    this.scene = scene;\n    /**\r\n     * A reference to the Phaser Game instance.\r\n     *\r\n     * @name Phaser.Scenes.Systems#game\r\n     * @type {Phaser.Game}\r\n     * @since 3.0.0\r\n     */\n\n    this.game;\n    /**\r\n     * A reference to either the Canvas or WebGL Renderer that this Game is using.\r\n     *\r\n     * @name Phaser.Scenes.Systems#renderer\r\n     * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n     * @since 3.17.0\r\n     */\n\n    this.renderer;\n\n    if (typeof PLUGIN_FBINSTANT) {\n      /**\r\n       * The Facebook Instant Games Plugin.\r\n       *\r\n       * @name Phaser.Scenes.Systems#facebook\r\n       * @type {Phaser.FacebookInstantGamesPlugin}\r\n       * @since 3.12.0\r\n       */\n      this.facebook;\n    }\n    /**\r\n     * The Scene Configuration object, as passed in when creating the Scene.\r\n     *\r\n     * @name Phaser.Scenes.Systems#config\r\n     * @type {(string|Phaser.Types.Scenes.SettingsConfig)}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.config = config;\n    /**\r\n     * The Scene Settings. This is the parsed output based on the Scene configuration.\r\n     *\r\n     * @name Phaser.Scenes.Systems#settings\r\n     * @type {Phaser.Types.Scenes.SettingsObject}\r\n     * @since 3.0.0\r\n     */\n\n    this.settings = Settings.create(config);\n    /**\r\n     * A handy reference to the Scene canvas / context.\r\n     *\r\n     * @name Phaser.Scenes.Systems#canvas\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.0.0\r\n     */\n\n    this.canvas;\n    /**\r\n     * A reference to the Canvas Rendering Context being used by the renderer.\r\n     *\r\n     * @name Phaser.Scenes.Systems#context\r\n     * @type {CanvasRenderingContext2D}\r\n     * @since 3.0.0\r\n     */\n\n    this.context; //  Global Systems - these are single-instance global managers that belong to Game\n\n    /**\r\n     * A reference to the global Animations Manager.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.anims` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#anims\r\n     * @type {Phaser.Animations.AnimationManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.anims;\n    /**\r\n     * A reference to the global Cache. The Cache stores all files bought in to Phaser via\r\n     * the Loader, with the exception of images. Images are stored in the Texture Manager.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.cache` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#cache\r\n     * @type {Phaser.Cache.CacheManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.cache;\n    /**\r\n     * A reference to the global Plugins Manager.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.plugins` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#plugins\r\n     * @type {Phaser.Plugins.PluginManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.plugins;\n    /**\r\n     * A reference to the global registry. This is a game-wide instance of the Data Manager, allowing\r\n     * you to exchange data between Scenes via a universal and shared point.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.registry` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#registry\r\n     * @type {Phaser.Data.DataManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.registry;\n    /**\r\n     * A reference to the global Scale Manager.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.scale` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#scale\r\n     * @type {Phaser.Scale.ScaleManager}\r\n     * @since 3.15.0\r\n     */\n\n    this.scale;\n    /**\r\n     * A reference to the global Sound Manager.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.sound` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#sound\r\n     * @type {(Phaser.Sound.NoAudioSoundManager|Phaser.Sound.HTML5AudioSoundManager|Phaser.Sound.WebAudioSoundManager)}\r\n     * @since 3.0.0\r\n     */\n\n    this.sound;\n    /**\r\n     * A reference to the global Texture Manager.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.textures` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#textures\r\n     * @type {Phaser.Textures.TextureManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.textures; //  Core Plugins - these are non-optional Scene plugins, needed by lots of the other systems\n\n    /**\r\n     * A reference to the Scene's Game Object Factory.\r\n     * \r\n     * Use this to quickly and easily create new Game Object's.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.add` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#add\r\n     * @type {Phaser.GameObjects.GameObjectFactory}\r\n     * @since 3.0.0\r\n     */\n\n    this.add;\n    /**\r\n     * A reference to the Scene's Camera Manager.\r\n     * \r\n     * Use this to manipulate and create Cameras for this specific Scene.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.cameras` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#cameras\r\n     * @type {Phaser.Cameras.Scene2D.CameraManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.cameras;\n    /**\r\n     * A reference to the Scene's Display List.\r\n     * \r\n     * Use this to organize the children contained in the display list.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.children` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#displayList\r\n     * @type {Phaser.GameObjects.DisplayList}\r\n     * @since 3.0.0\r\n     */\n\n    this.displayList;\n    /**\r\n     * A reference to the Scene's Event Manager.\r\n     * \r\n     * Use this to listen for Scene specific events, such as `pause` and `shutdown`.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.events` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#events\r\n     * @type {Phaser.Events.EventEmitter}\r\n     * @since 3.0.0\r\n     */\n\n    this.events;\n    /**\r\n     * A reference to the Scene's Game Object Creator.\r\n     * \r\n     * Use this to quickly and easily create new Game Object's. The difference between this and the\r\n     * Game Object Factory, is that the Creator just creates and returns Game Object instances, it\r\n     * doesn't then add them to the Display List or Update List.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.make` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#make\r\n     * @type {Phaser.GameObjects.GameObjectCreator}\r\n     * @since 3.0.0\r\n     */\n\n    this.make;\n    /**\r\n     * A reference to the Scene Manager Plugin.\r\n     * \r\n     * Use this to manipulate both this and other Scene's in your game, for example to launch a parallel Scene,\r\n     * or pause or resume a Scene, or switch from this Scene to another.\r\n     * \r\n     * In the default set-up you can access this from within a Scene via the `this.scene` property.\r\n     *\r\n     * @name Phaser.Scenes.Systems#scenePlugin\r\n     * @type {Phaser.Scenes.ScenePlugin}\r\n     * @since 3.0.0\r\n     */\n\n    this.scenePlugin;\n    /**\r\n     * A reference to the Scene's Update List.\r\n     * \r\n     * Use this to organize the children contained in the update list.\r\n     * \r\n     * The Update List is responsible for managing children that need their `preUpdate` methods called,\r\n     * in order to process so internal components, such as Sprites with Animations.\r\n     * \r\n     * In the default set-up there is no reference to this from within the Scene itself.\r\n     *\r\n     * @name Phaser.Scenes.Systems#updateList\r\n     * @type {Phaser.GameObjects.UpdateList}\r\n     * @since 3.0.0\r\n     */\n\n    this.updateList;\n    /**\r\n     * The Scene Update function.\r\n     *\r\n     * This starts out as NOOP during init, preload and create, and at the end of create\r\n     * it swaps to be whatever the Scene.update function is.\r\n     *\r\n     * @name Phaser.Scenes.Systems#sceneUpdate\r\n     * @type {function}\r\n     * @private\r\n     * @since 3.10.0\r\n     */\n\n    this.sceneUpdate = NOOP;\n  },\n\n  /**\r\n   * This method is called only once by the Scene Manager when the Scene is instantiated.\r\n   * It is responsible for setting up all of the Scene plugins and references.\r\n   * It should never be called directly.\r\n   *\r\n   * @method Phaser.Scenes.Systems#init\r\n   * @protected\r\n   * @fires Phaser.Scenes.Events#BOOT\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Game} game - A reference to the Phaser Game instance.\r\n   */\n  init: function (game) {\n    this.settings.status = CONST.INIT; //  This will get replaced by the SceneManager with the actual update function, if it exists, once create is over.\n\n    this.sceneUpdate = NOOP;\n    this.game = game;\n    this.renderer = game.renderer;\n    this.canvas = game.canvas;\n    this.context = game.context;\n    var pluginManager = game.plugins;\n    this.plugins = pluginManager;\n    pluginManager.addToScene(this, DefaultPlugins.Global, [DefaultPlugins.CoreScene, GetScenePlugins(this), GetPhysicsPlugins(this)]);\n    this.events.emit(Events.BOOT, this);\n    this.settings.isBooted = true;\n  },\n\n  /**\r\n   * Called by a plugin, it tells the System to install the plugin locally.\r\n   *\r\n   * @method Phaser.Scenes.Systems#install\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {array} plugin - An array of plugins to install into this Scene.\r\n   */\n  install: function (plugin) {\n    if (!Array.isArray(plugin)) {\n      plugin = [plugin];\n    }\n\n    this.plugins.installLocal(this, plugin);\n  },\n\n  /**\r\n   * A single game step. Called automatically by the Scene Manager as a result of a Request Animation\r\n   * Frame or Set Timeout call to the main Game instance.\r\n   *\r\n   * @method Phaser.Scenes.Systems#step\r\n   * @fires Phaser.Scenes.Events#PRE_UPDATE\r\n   * @fires Phaser.Scenes.Events#_UPDATE\r\n   * @fires Phaser.Scenes.Events#POST_UPDATE\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} time - The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().\r\n   * @param {number} delta - The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.\r\n   */\n  step: function (time, delta) {\n    this.events.emit(Events.PRE_UPDATE, time, delta);\n    this.events.emit(Events.UPDATE, time, delta);\n    this.sceneUpdate.call(this.scene, time, delta);\n    this.events.emit(Events.POST_UPDATE, time, delta);\n  },\n\n  /**\r\n   * Called automatically by the Scene Manager.\r\n   * Instructs the Scene to render itself via its Camera Manager to the renderer given.\r\n   *\r\n   * @method Phaser.Scenes.Systems#render\r\n   * @fires Phaser.Scenes.Events#RENDER\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer that invoked the render call.\r\n   */\n  render: function (renderer) {\n    var displayList = this.displayList;\n    displayList.depthSort();\n    this.cameras.render(renderer, displayList);\n    this.events.emit(Events.RENDER, renderer);\n  },\n\n  /**\r\n   * Force a sort of the display list on the next render.\r\n   *\r\n   * @method Phaser.Scenes.Systems#queueDepthSort\r\n   * @since 3.0.0\r\n   */\n  queueDepthSort: function () {\n    this.displayList.queueDepthSort();\n  },\n\n  /**\r\n   * Immediately sorts the display list if the flag is set.\r\n   *\r\n   * @method Phaser.Scenes.Systems#depthSort\r\n   * @since 3.0.0\r\n   */\n  depthSort: function () {\n    this.displayList.depthSort();\n  },\n\n  /**\r\n   * Pause this Scene.\r\n   * A paused Scene still renders, it just doesn't run ANY of its update handlers or systems.\r\n   *\r\n   * @method Phaser.Scenes.Systems#pause\r\n   * @fires Phaser.Scenes.Events#PAUSE\r\n   * @since 3.0.0\r\n   * \r\n   * @param {object} [data] - A data object that will be passed in the 'pause' event.\r\n   *\r\n   * @return {Phaser.Scenes.Systems} This Systems object.\r\n   */\n  pause: function (data) {\n    if (this.settings.active) {\n      this.settings.status = CONST.PAUSED;\n      this.settings.active = false;\n      this.events.emit(Events.PAUSE, this, data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Resume this Scene from a paused state.\r\n   *\r\n   * @method Phaser.Scenes.Systems#resume\r\n   * @fires Phaser.Scenes.Events#RESUME\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} [data] - A data object that will be passed in the 'resume' event.\r\n   *\r\n   * @return {Phaser.Scenes.Systems} This Systems object.\r\n   */\n  resume: function (data) {\n    if (!this.settings.active) {\n      this.settings.status = CONST.RUNNING;\n      this.settings.active = true;\n      this.events.emit(Events.RESUME, this, data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Send this Scene to sleep.\r\n   *\r\n   * A sleeping Scene doesn't run its update step or render anything, but it also isn't shut down\r\n   * or has any of its systems or children removed, meaning it can be re-activated at any point and\r\n   * will carry on from where it left off. It also keeps everything in memory and events and callbacks\r\n   * from other Scenes may still invoke changes within it, so be careful what is left active.\r\n   *\r\n   * @method Phaser.Scenes.Systems#sleep\r\n   * @fires Phaser.Scenes.Events#SLEEP\r\n   * @since 3.0.0\r\n   * \r\n   * @param {object} [data] - A data object that will be passed in the 'sleep' event.\r\n   *\r\n   * @return {Phaser.Scenes.Systems} This Systems object.\r\n   */\n  sleep: function (data) {\n    this.settings.status = CONST.SLEEPING;\n    this.settings.active = false;\n    this.settings.visible = false;\n    this.events.emit(Events.SLEEP, this, data);\n    return this;\n  },\n\n  /**\r\n   * Wake-up this Scene if it was previously asleep.\r\n   *\r\n   * @method Phaser.Scenes.Systems#wake\r\n   * @fires Phaser.Scenes.Events#WAKE\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} [data] - A data object that will be passed in the 'wake' event.\r\n   *\r\n   * @return {Phaser.Scenes.Systems} This Systems object.\r\n   */\n  wake: function (data) {\n    var settings = this.settings;\n    settings.status = CONST.RUNNING;\n    settings.active = true;\n    settings.visible = true;\n    this.events.emit(Events.WAKE, this, data);\n\n    if (settings.isTransition) {\n      this.events.emit(Events.TRANSITION_WAKE, settings.transitionFrom, settings.transitionDuration);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Returns any data that was sent to this Scene by another Scene.\r\n   * \r\n   * The data is also passed to `Scene.init` and in various Scene events, but\r\n   * you can access it at any point via this method.\r\n   *\r\n   * @method Phaser.Scenes.Systems#getData\r\n   * @since 3.22.0\r\n   *\r\n   * @return {any} \r\n   */\n  getData: function () {\n    return this.settings.data;\n  },\n\n  /**\r\n   * Is this Scene sleeping?\r\n   *\r\n   * @method Phaser.Scenes.Systems#isSleeping\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} `true` if this Scene is asleep, otherwise `false`.\r\n   */\n  isSleeping: function () {\n    return this.settings.status === CONST.SLEEPING;\n  },\n\n  /**\r\n   * Is this Scene running?\r\n   *\r\n   * @method Phaser.Scenes.Systems#isActive\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} `true` if this Scene is running, otherwise `false`.\r\n   */\n  isActive: function () {\n    return this.settings.status === CONST.RUNNING;\n  },\n\n  /**\r\n   * Is this Scene paused?\r\n   *\r\n   * @method Phaser.Scenes.Systems#isPaused\r\n   * @since 3.13.0\r\n   *\r\n   * @return {boolean} `true` if this Scene is paused, otherwise `false`.\r\n   */\n  isPaused: function () {\n    return this.settings.status === CONST.PAUSED;\n  },\n\n  /**\r\n   * Is this Scene currently transitioning out to, or in from another Scene?\r\n   *\r\n   * @method Phaser.Scenes.Systems#isTransitioning\r\n   * @since 3.5.0\r\n   *\r\n   * @return {boolean} `true` if this Scene is currently transitioning, otherwise `false`.\r\n   */\n  isTransitioning: function () {\n    return this.settings.isTransition || this.scenePlugin._target !== null;\n  },\n\n  /**\r\n   * Is this Scene currently transitioning out from itself to another Scene?\r\n   *\r\n   * @method Phaser.Scenes.Systems#isTransitionOut\r\n   * @since 3.5.0\r\n   *\r\n   * @return {boolean} `true` if this Scene is in transition to another Scene, otherwise `false`.\r\n   */\n  isTransitionOut: function () {\n    return this.scenePlugin._target !== null && this.scenePlugin._duration > 0;\n  },\n\n  /**\r\n   * Is this Scene currently transitioning in from another Scene?\r\n   *\r\n   * @method Phaser.Scenes.Systems#isTransitionIn\r\n   * @since 3.5.0\r\n   *\r\n   * @return {boolean} `true` if this Scene is transitioning in from another Scene, otherwise `false`.\r\n   */\n  isTransitionIn: function () {\n    return this.settings.isTransition;\n  },\n\n  /**\r\n   * Is this Scene visible and rendering?\r\n   *\r\n   * @method Phaser.Scenes.Systems#isVisible\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} `true` if this Scene is visible, otherwise `false`.\r\n   */\n  isVisible: function () {\n    return this.settings.visible;\n  },\n\n  /**\r\n   * Sets the visible state of this Scene.\r\n   * An invisible Scene will not render, but will still process updates.\r\n   *\r\n   * @method Phaser.Scenes.Systems#setVisible\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - `true` to render this Scene, otherwise `false`.\r\n   *\r\n   * @return {Phaser.Scenes.Systems} This Systems object.\r\n   */\n  setVisible: function (value) {\n    this.settings.visible = value;\n    return this;\n  },\n\n  /**\r\n   * Set the active state of this Scene.\r\n   * \r\n   * An active Scene will run its core update loop.\r\n   *\r\n   * @method Phaser.Scenes.Systems#setActive\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - If `true` the Scene will be resumed, if previously paused. If `false` it will be paused.\r\n   * @param {object} [data] - A data object that will be passed in the 'resume' or 'pause' events.\r\n   *\r\n   * @return {Phaser.Scenes.Systems} This Systems object.\r\n   */\n  setActive: function (value, data) {\n    if (value) {\n      return this.resume(data);\n    } else {\n      return this.pause(data);\n    }\n  },\n\n  /**\r\n   * Start this Scene running and rendering.\r\n   * Called automatically by the SceneManager.\r\n   *\r\n   * @method Phaser.Scenes.Systems#start\r\n   * @fires Phaser.Scenes.Events#START\r\n   * @fires Phaser.Scenes.Events#READY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} data - Optional data object that may have been passed to this Scene from another.\r\n   */\n  start: function (data) {\n    if (data) {\n      this.settings.data = data;\n    }\n\n    this.settings.status = CONST.START;\n    this.settings.active = true;\n    this.settings.visible = true; //  For plugins to listen out for\n\n    this.events.emit(Events.START, this); //  For user-land code to listen out for\n\n    this.events.emit(Events.READY, this, data);\n  },\n\n  /**\r\n   * Shutdown this Scene and send a shutdown event to all of its systems.\r\n   * A Scene that has been shutdown will not run its update loop or render, but it does\r\n   * not destroy any of its plugins or references. It is put into hibernation for later use.\r\n   * If you don't ever plan to use this Scene again, then it should be destroyed instead\r\n   * to free-up resources.\r\n   *\r\n   * @method Phaser.Scenes.Systems#shutdown\r\n   * @fires Phaser.Scenes.Events#SHUTDOWN\r\n   * @since 3.0.0\r\n   * \r\n   * @param {object} [data] - A data object that will be passed in the 'shutdown' event.\r\n   */\n  shutdown: function (data) {\n    this.events.off(Events.TRANSITION_INIT);\n    this.events.off(Events.TRANSITION_START);\n    this.events.off(Events.TRANSITION_COMPLETE);\n    this.events.off(Events.TRANSITION_OUT);\n    this.settings.status = CONST.SHUTDOWN;\n    this.settings.active = false;\n    this.settings.visible = false;\n    this.events.emit(Events.SHUTDOWN, this, data);\n  },\n\n  /**\r\n   * Destroy this Scene and send a destroy event all of its systems.\r\n   * A destroyed Scene cannot be restarted.\r\n   * You should not call this directly, instead use `SceneManager.remove`.\r\n   *\r\n   * @method Phaser.Scenes.Systems#destroy\r\n   * @private\r\n   * @fires Phaser.Scenes.Events#DESTROY\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.settings.status = CONST.DESTROYED;\n    this.settings.active = false;\n    this.settings.visible = false;\n    this.events.emit(Events.DESTROY, this);\n    this.events.removeAllListeners();\n    var props = ['scene', 'game', 'anims', 'cache', 'plugins', 'registry', 'sound', 'textures', 'add', 'camera', 'displayList', 'events', 'make', 'scenePlugin', 'updateList'];\n\n    for (var i = 0; i < props.length; i++) {\n      this[props[i]] = null;\n    }\n  }\n});\nmodule.exports = Systems;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/scene/Systems.js"],"names":["Class","require","CONST","DefaultPlugins","Events","GetPhysicsPlugins","GetScenePlugins","NOOP","Settings","Systems","initialize","scene","config","game","renderer","PLUGIN_FBINSTANT","facebook","settings","create","canvas","context","anims","cache","plugins","registry","scale","sound","textures","add","cameras","displayList","events","make","scenePlugin","updateList","sceneUpdate","init","status","INIT","pluginManager","addToScene","Global","CoreScene","emit","BOOT","isBooted","install","plugin","Array","isArray","installLocal","step","time","delta","PRE_UPDATE","UPDATE","call","POST_UPDATE","render","depthSort","RENDER","queueDepthSort","pause","data","active","PAUSED","PAUSE","resume","RUNNING","RESUME","sleep","SLEEPING","visible","SLEEP","wake","WAKE","isTransition","TRANSITION_WAKE","transitionFrom","transitionDuration","getData","isSleeping","isActive","isPaused","isTransitioning","_target","isTransitionOut","_duration","isTransitionIn","isVisible","setVisible","value","setActive","start","START","READY","shutdown","off","TRANSITION_INIT","TRANSITION_START","TRANSITION_COMPLETE","TRANSITION_OUT","SHUTDOWN","destroy","DESTROYED","DESTROY","removeAllListeners","props","i","length","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar DefaultPlugins = require('../plugins/DefaultPlugins');\r\nvar Events = require('./events');\r\nvar GetPhysicsPlugins = require('./GetPhysicsPlugins');\r\nvar GetScenePlugins = require('./GetScenePlugins');\r\nvar NOOP = require('../utils/NOOP');\r\nvar Settings = require('./Settings');\r\n\r\n/**\r\n * @classdesc\r\n * The Scene Systems class.\r\n *\r\n * This class is available from within a Scene under the property `sys`.\r\n * It is responsible for managing all of the plugins a Scene has running, including the display list, and\r\n * handling the update step and renderer. It also contains references to global systems belonging to Game.\r\n *\r\n * @class Systems\r\n * @memberof Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that owns this Systems instance.\r\n * @param {(string|Phaser.Types.Scenes.SettingsConfig)} config - Scene specific configuration settings.\r\n */\r\nvar Systems = new Class({\r\n\r\n    initialize:\r\n\r\n    function Systems (scene, config)\r\n    {\r\n        /**\r\n         * A reference to the Scene that these Systems belong to.\r\n         *\r\n         * @name Phaser.Scenes.Systems#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Phaser Game instance.\r\n         *\r\n         * @name Phaser.Scenes.Systems#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */\r\n        this.game;\r\n\r\n        /**\r\n         * A reference to either the Canvas or WebGL Renderer that this Game is using.\r\n         *\r\n         * @name Phaser.Scenes.Systems#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.17.0\r\n         */\r\n        this.renderer;\r\n\r\n        if (typeof PLUGIN_FBINSTANT)\r\n        {\r\n            /**\r\n             * The Facebook Instant Games Plugin.\r\n             *\r\n             * @name Phaser.Scenes.Systems#facebook\r\n             * @type {Phaser.FacebookInstantGamesPlugin}\r\n             * @since 3.12.0\r\n             */\r\n            this.facebook;\r\n        }\r\n\r\n        /**\r\n         * The Scene Configuration object, as passed in when creating the Scene.\r\n         *\r\n         * @name Phaser.Scenes.Systems#config\r\n         * @type {(string|Phaser.Types.Scenes.SettingsConfig)}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = config;\r\n\r\n        /**\r\n         * The Scene Settings. This is the parsed output based on the Scene configuration.\r\n         *\r\n         * @name Phaser.Scenes.Systems#settings\r\n         * @type {Phaser.Types.Scenes.SettingsObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.settings = Settings.create(config);\r\n\r\n        /**\r\n         * A handy reference to the Scene canvas / context.\r\n         *\r\n         * @name Phaser.Scenes.Systems#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */\r\n        this.canvas;\r\n\r\n        /**\r\n         * A reference to the Canvas Rendering Context being used by the renderer.\r\n         *\r\n         * @name Phaser.Scenes.Systems#context\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */\r\n        this.context;\r\n\r\n        //  Global Systems - these are single-instance global managers that belong to Game\r\n\r\n        /**\r\n         * A reference to the global Animations Manager.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.anims` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#anims\r\n         * @type {Phaser.Animations.AnimationManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.anims;\r\n\r\n        /**\r\n         * A reference to the global Cache. The Cache stores all files bought in to Phaser via\r\n         * the Loader, with the exception of images. Images are stored in the Texture Manager.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.cache` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#cache\r\n         * @type {Phaser.Cache.CacheManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.cache;\r\n\r\n        /**\r\n         * A reference to the global Plugins Manager.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.plugins` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#plugins\r\n         * @type {Phaser.Plugins.PluginManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.plugins;\r\n\r\n        /**\r\n         * A reference to the global registry. This is a game-wide instance of the Data Manager, allowing\r\n         * you to exchange data between Scenes via a universal and shared point.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.registry` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#registry\r\n         * @type {Phaser.Data.DataManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.registry;\r\n\r\n        /**\r\n         * A reference to the global Scale Manager.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.scale` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#scale\r\n         * @type {Phaser.Scale.ScaleManager}\r\n         * @since 3.15.0\r\n         */\r\n        this.scale;\r\n\r\n        /**\r\n         * A reference to the global Sound Manager.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.sound` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#sound\r\n         * @type {(Phaser.Sound.NoAudioSoundManager|Phaser.Sound.HTML5AudioSoundManager|Phaser.Sound.WebAudioSoundManager)}\r\n         * @since 3.0.0\r\n         */\r\n        this.sound;\r\n\r\n        /**\r\n         * A reference to the global Texture Manager.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.textures` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#textures\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.textures;\r\n\r\n        //  Core Plugins - these are non-optional Scene plugins, needed by lots of the other systems\r\n\r\n        /**\r\n         * A reference to the Scene's Game Object Factory.\r\n         * \r\n         * Use this to quickly and easily create new Game Object's.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.add` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#add\r\n         * @type {Phaser.GameObjects.GameObjectFactory}\r\n         * @since 3.0.0\r\n         */\r\n        this.add;\r\n\r\n        /**\r\n         * A reference to the Scene's Camera Manager.\r\n         * \r\n         * Use this to manipulate and create Cameras for this specific Scene.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.cameras` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#cameras\r\n         * @type {Phaser.Cameras.Scene2D.CameraManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.cameras;\r\n\r\n        /**\r\n         * A reference to the Scene's Display List.\r\n         * \r\n         * Use this to organize the children contained in the display list.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.children` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @since 3.0.0\r\n         */\r\n        this.displayList;\r\n\r\n        /**\r\n         * A reference to the Scene's Event Manager.\r\n         * \r\n         * Use this to listen for Scene specific events, such as `pause` and `shutdown`.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.events` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.events;\r\n\r\n        /**\r\n         * A reference to the Scene's Game Object Creator.\r\n         * \r\n         * Use this to quickly and easily create new Game Object's. The difference between this and the\r\n         * Game Object Factory, is that the Creator just creates and returns Game Object instances, it\r\n         * doesn't then add them to the Display List or Update List.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.make` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#make\r\n         * @type {Phaser.GameObjects.GameObjectCreator}\r\n         * @since 3.0.0\r\n         */\r\n        this.make;\r\n\r\n        /**\r\n         * A reference to the Scene Manager Plugin.\r\n         * \r\n         * Use this to manipulate both this and other Scene's in your game, for example to launch a parallel Scene,\r\n         * or pause or resume a Scene, or switch from this Scene to another.\r\n         * \r\n         * In the default set-up you can access this from within a Scene via the `this.scene` property.\r\n         *\r\n         * @name Phaser.Scenes.Systems#scenePlugin\r\n         * @type {Phaser.Scenes.ScenePlugin}\r\n         * @since 3.0.0\r\n         */\r\n        this.scenePlugin;\r\n\r\n        /**\r\n         * A reference to the Scene's Update List.\r\n         * \r\n         * Use this to organize the children contained in the update list.\r\n         * \r\n         * The Update List is responsible for managing children that need their `preUpdate` methods called,\r\n         * in order to process so internal components, such as Sprites with Animations.\r\n         * \r\n         * In the default set-up there is no reference to this from within the Scene itself.\r\n         *\r\n         * @name Phaser.Scenes.Systems#updateList\r\n         * @type {Phaser.GameObjects.UpdateList}\r\n         * @since 3.0.0\r\n         */\r\n        this.updateList;\r\n\r\n        /**\r\n         * The Scene Update function.\r\n         *\r\n         * This starts out as NOOP during init, preload and create, and at the end of create\r\n         * it swaps to be whatever the Scene.update function is.\r\n         *\r\n         * @name Phaser.Scenes.Systems#sceneUpdate\r\n         * @type {function}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this.sceneUpdate = NOOP;\r\n    },\r\n\r\n    /**\r\n     * This method is called only once by the Scene Manager when the Scene is instantiated.\r\n     * It is responsible for setting up all of the Scene plugins and references.\r\n     * It should never be called directly.\r\n     *\r\n     * @method Phaser.Scenes.Systems#init\r\n     * @protected\r\n     * @fires Phaser.Scenes.Events#BOOT\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Game} game - A reference to the Phaser Game instance.\r\n     */\r\n    init: function (game)\r\n    {\r\n        this.settings.status = CONST.INIT;\r\n\r\n        //  This will get replaced by the SceneManager with the actual update function, if it exists, once create is over.\r\n        this.sceneUpdate = NOOP;\r\n\r\n        this.game = game;\r\n        this.renderer = game.renderer;\r\n\r\n        this.canvas = game.canvas;\r\n        this.context = game.context;\r\n\r\n        var pluginManager = game.plugins;\r\n\r\n        this.plugins = pluginManager;\r\n\r\n        pluginManager.addToScene(this, DefaultPlugins.Global, [ DefaultPlugins.CoreScene, GetScenePlugins(this), GetPhysicsPlugins(this) ]);\r\n\r\n        this.events.emit(Events.BOOT, this);\r\n\r\n        this.settings.isBooted = true;\r\n    },\r\n\r\n    /**\r\n     * Called by a plugin, it tells the System to install the plugin locally.\r\n     *\r\n     * @method Phaser.Scenes.Systems#install\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} plugin - An array of plugins to install into this Scene.\r\n     */\r\n    install: function (plugin)\r\n    {\r\n        if (!Array.isArray(plugin))\r\n        {\r\n            plugin = [ plugin ];\r\n        }\r\n\r\n        this.plugins.installLocal(this, plugin);\r\n    },\r\n\r\n    /**\r\n     * A single game step. Called automatically by the Scene Manager as a result of a Request Animation\r\n     * Frame or Set Timeout call to the main Game instance.\r\n     *\r\n     * @method Phaser.Scenes.Systems#step\r\n     * @fires Phaser.Scenes.Events#PRE_UPDATE\r\n     * @fires Phaser.Scenes.Events#_UPDATE\r\n     * @fires Phaser.Scenes.Events#POST_UPDATE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().\r\n     * @param {number} delta - The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.\r\n     */\r\n    step: function (time, delta)\r\n    {\r\n        this.events.emit(Events.PRE_UPDATE, time, delta);\r\n\r\n        this.events.emit(Events.UPDATE, time, delta);\r\n\r\n        this.sceneUpdate.call(this.scene, time, delta);\r\n\r\n        this.events.emit(Events.POST_UPDATE, time, delta);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by the Scene Manager.\r\n     * Instructs the Scene to render itself via its Camera Manager to the renderer given.\r\n     *\r\n     * @method Phaser.Scenes.Systems#render\r\n     * @fires Phaser.Scenes.Events#RENDER\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer that invoked the render call.\r\n     */\r\n    render: function (renderer)\r\n    {\r\n        var displayList = this.displayList;\r\n\r\n        displayList.depthSort();\r\n\r\n        this.cameras.render(renderer, displayList);\r\n\r\n        this.events.emit(Events.RENDER, renderer);\r\n    },\r\n\r\n    /**\r\n     * Force a sort of the display list on the next render.\r\n     *\r\n     * @method Phaser.Scenes.Systems#queueDepthSort\r\n     * @since 3.0.0\r\n     */\r\n    queueDepthSort: function ()\r\n    {\r\n        this.displayList.queueDepthSort();\r\n    },\r\n\r\n    /**\r\n     * Immediately sorts the display list if the flag is set.\r\n     *\r\n     * @method Phaser.Scenes.Systems#depthSort\r\n     * @since 3.0.0\r\n     */\r\n    depthSort: function ()\r\n    {\r\n        this.displayList.depthSort();\r\n    },\r\n\r\n    /**\r\n     * Pause this Scene.\r\n     * A paused Scene still renders, it just doesn't run ANY of its update handlers or systems.\r\n     *\r\n     * @method Phaser.Scenes.Systems#pause\r\n     * @fires Phaser.Scenes.Events#PAUSE\r\n     * @since 3.0.0\r\n     * \r\n     * @param {object} [data] - A data object that will be passed in the 'pause' event.\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */\r\n    pause: function (data)\r\n    {\r\n        if (this.settings.active)\r\n        {\r\n            this.settings.status = CONST.PAUSED;\r\n\r\n            this.settings.active = false;\r\n\r\n            this.events.emit(Events.PAUSE, this, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resume this Scene from a paused state.\r\n     *\r\n     * @method Phaser.Scenes.Systems#resume\r\n     * @fires Phaser.Scenes.Events#RESUME\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} [data] - A data object that will be passed in the 'resume' event.\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */\r\n    resume: function (data)\r\n    {\r\n        if (!this.settings.active)\r\n        {\r\n            this.settings.status = CONST.RUNNING;\r\n\r\n            this.settings.active = true;\r\n\r\n            this.events.emit(Events.RESUME, this, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Send this Scene to sleep.\r\n     *\r\n     * A sleeping Scene doesn't run its update step or render anything, but it also isn't shut down\r\n     * or has any of its systems or children removed, meaning it can be re-activated at any point and\r\n     * will carry on from where it left off. It also keeps everything in memory and events and callbacks\r\n     * from other Scenes may still invoke changes within it, so be careful what is left active.\r\n     *\r\n     * @method Phaser.Scenes.Systems#sleep\r\n     * @fires Phaser.Scenes.Events#SLEEP\r\n     * @since 3.0.0\r\n     * \r\n     * @param {object} [data] - A data object that will be passed in the 'sleep' event.\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */\r\n    sleep: function (data)\r\n    {\r\n        this.settings.status = CONST.SLEEPING;\r\n\r\n        this.settings.active = false;\r\n        this.settings.visible = false;\r\n\r\n        this.events.emit(Events.SLEEP, this, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Wake-up this Scene if it was previously asleep.\r\n     *\r\n     * @method Phaser.Scenes.Systems#wake\r\n     * @fires Phaser.Scenes.Events#WAKE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} [data] - A data object that will be passed in the 'wake' event.\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */\r\n    wake: function (data)\r\n    {\r\n        var settings = this.settings;\r\n\r\n        settings.status = CONST.RUNNING;\r\n\r\n        settings.active = true;\r\n        settings.visible = true;\r\n\r\n        this.events.emit(Events.WAKE, this, data);\r\n\r\n        if (settings.isTransition)\r\n        {\r\n            this.events.emit(Events.TRANSITION_WAKE, settings.transitionFrom, settings.transitionDuration);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns any data that was sent to this Scene by another Scene.\r\n     * \r\n     * The data is also passed to `Scene.init` and in various Scene events, but\r\n     * you can access it at any point via this method.\r\n     *\r\n     * @method Phaser.Scenes.Systems#getData\r\n     * @since 3.22.0\r\n     *\r\n     * @return {any} \r\n     */\r\n    getData: function ()\r\n    {\r\n        return this.settings.data;\r\n    },\r\n\r\n    /**\r\n     * Is this Scene sleeping?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isSleeping\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if this Scene is asleep, otherwise `false`.\r\n     */\r\n    isSleeping: function ()\r\n    {\r\n        return (this.settings.status === CONST.SLEEPING);\r\n    },\r\n\r\n    /**\r\n     * Is this Scene running?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isActive\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if this Scene is running, otherwise `false`.\r\n     */\r\n    isActive: function ()\r\n    {\r\n        return (this.settings.status === CONST.RUNNING);\r\n    },\r\n\r\n    /**\r\n     * Is this Scene paused?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isPaused\r\n     * @since 3.13.0\r\n     *\r\n     * @return {boolean} `true` if this Scene is paused, otherwise `false`.\r\n     */\r\n    isPaused: function ()\r\n    {\r\n        return (this.settings.status === CONST.PAUSED);\r\n    },\r\n\r\n    /**\r\n     * Is this Scene currently transitioning out to, or in from another Scene?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isTransitioning\r\n     * @since 3.5.0\r\n     *\r\n     * @return {boolean} `true` if this Scene is currently transitioning, otherwise `false`.\r\n     */\r\n    isTransitioning: function ()\r\n    {\r\n        return (this.settings.isTransition || this.scenePlugin._target !== null);\r\n    },\r\n\r\n    /**\r\n     * Is this Scene currently transitioning out from itself to another Scene?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isTransitionOut\r\n     * @since 3.5.0\r\n     *\r\n     * @return {boolean} `true` if this Scene is in transition to another Scene, otherwise `false`.\r\n     */\r\n    isTransitionOut: function ()\r\n    {\r\n        return (this.scenePlugin._target !== null && this.scenePlugin._duration > 0);\r\n    },\r\n\r\n    /**\r\n     * Is this Scene currently transitioning in from another Scene?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isTransitionIn\r\n     * @since 3.5.0\r\n     *\r\n     * @return {boolean} `true` if this Scene is transitioning in from another Scene, otherwise `false`.\r\n     */\r\n    isTransitionIn: function ()\r\n    {\r\n        return (this.settings.isTransition);\r\n    },\r\n\r\n    /**\r\n     * Is this Scene visible and rendering?\r\n     *\r\n     * @method Phaser.Scenes.Systems#isVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if this Scene is visible, otherwise `false`.\r\n     */\r\n    isVisible: function ()\r\n    {\r\n        return this.settings.visible;\r\n    },\r\n\r\n    /**\r\n     * Sets the visible state of this Scene.\r\n     * An invisible Scene will not render, but will still process updates.\r\n     *\r\n     * @method Phaser.Scenes.Systems#setVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - `true` to render this Scene, otherwise `false`.\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */\r\n    setVisible: function (value)\r\n    {\r\n        this.settings.visible = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the active state of this Scene.\r\n     * \r\n     * An active Scene will run its core update loop.\r\n     *\r\n     * @method Phaser.Scenes.Systems#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - If `true` the Scene will be resumed, if previously paused. If `false` it will be paused.\r\n     * @param {object} [data] - A data object that will be passed in the 'resume' or 'pause' events.\r\n     *\r\n     * @return {Phaser.Scenes.Systems} This Systems object.\r\n     */\r\n    setActive: function (value, data)\r\n    {\r\n        if (value)\r\n        {\r\n            return this.resume(data);\r\n        }\r\n        else\r\n        {\r\n            return this.pause(data);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Start this Scene running and rendering.\r\n     * Called automatically by the SceneManager.\r\n     *\r\n     * @method Phaser.Scenes.Systems#start\r\n     * @fires Phaser.Scenes.Events#START\r\n     * @fires Phaser.Scenes.Events#READY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} data - Optional data object that may have been passed to this Scene from another.\r\n     */\r\n    start: function (data)\r\n    {\r\n        if (data)\r\n        {\r\n            this.settings.data = data;\r\n        }\r\n\r\n        this.settings.status = CONST.START;\r\n\r\n        this.settings.active = true;\r\n        this.settings.visible = true;\r\n\r\n        //  For plugins to listen out for\r\n        this.events.emit(Events.START, this);\r\n\r\n        //  For user-land code to listen out for\r\n        this.events.emit(Events.READY, this, data);\r\n    },\r\n\r\n    /**\r\n     * Shutdown this Scene and send a shutdown event to all of its systems.\r\n     * A Scene that has been shutdown will not run its update loop or render, but it does\r\n     * not destroy any of its plugins or references. It is put into hibernation for later use.\r\n     * If you don't ever plan to use this Scene again, then it should be destroyed instead\r\n     * to free-up resources.\r\n     *\r\n     * @method Phaser.Scenes.Systems#shutdown\r\n     * @fires Phaser.Scenes.Events#SHUTDOWN\r\n     * @since 3.0.0\r\n     * \r\n     * @param {object} [data] - A data object that will be passed in the 'shutdown' event.\r\n     */\r\n    shutdown: function (data)\r\n    {\r\n        this.events.off(Events.TRANSITION_INIT);\r\n        this.events.off(Events.TRANSITION_START);\r\n        this.events.off(Events.TRANSITION_COMPLETE);\r\n        this.events.off(Events.TRANSITION_OUT);\r\n\r\n        this.settings.status = CONST.SHUTDOWN;\r\n\r\n        this.settings.active = false;\r\n        this.settings.visible = false;\r\n\r\n        this.events.emit(Events.SHUTDOWN, this, data);\r\n    },\r\n\r\n    /**\r\n     * Destroy this Scene and send a destroy event all of its systems.\r\n     * A destroyed Scene cannot be restarted.\r\n     * You should not call this directly, instead use `SceneManager.remove`.\r\n     *\r\n     * @method Phaser.Scenes.Systems#destroy\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#DESTROY\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.settings.status = CONST.DESTROYED;\r\n\r\n        this.settings.active = false;\r\n        this.settings.visible = false;\r\n\r\n        this.events.emit(Events.DESTROY, this);\r\n\r\n        this.events.removeAllListeners();\r\n\r\n        var props = [ 'scene', 'game', 'anims', 'cache', 'plugins', 'registry', 'sound', 'textures', 'add', 'camera', 'displayList', 'events', 'make', 'scenePlugin', 'updateList' ];\r\n\r\n        for (var i = 0; i < props.length; i++)\r\n        {\r\n            this[props[i]] = null;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Systems;\r\n"]},"metadata":{},"sourceType":"script"}