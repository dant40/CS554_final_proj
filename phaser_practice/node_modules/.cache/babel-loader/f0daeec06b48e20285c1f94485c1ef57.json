{"ast":null,"code":"/**\r\n* The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.\r\n*\r\n* @class Detector\r\n*/\n// TODO: speculative contacts\nvar Detector = {};\nmodule.exports = Detector;\n\nvar SAT = require('./SAT');\n\nvar Pair = require('./Pair');\n\nvar Bounds = require('../geometry/Bounds');\n\n(function () {\n  /**\r\n   * Finds all collisions given a list of pairs.\r\n   * @method collisions\r\n   * @param {pair[]} broadphasePairs\r\n   * @param {engine} engine\r\n   * @return {array} collisions\r\n   */\n  Detector.collisions = function (broadphasePairs, engine) {\n    var collisions = [],\n        pairsTable = engine.pairs.table; // @if DEBUG\n\n    var metrics = engine.metrics; // @endif\n\n    for (var i = 0; i < broadphasePairs.length; i++) {\n      var bodyA = broadphasePairs[i][0],\n          bodyB = broadphasePairs[i][1];\n      if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping)) continue;\n      if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter)) continue; // @if DEBUG\n\n      metrics.midphaseTests += 1; // @endif\n      // mid phase\n\n      if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {\n        for (var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++) {\n          var partA = bodyA.parts[j];\n\n          for (var k = bodyB.parts.length > 1 ? 1 : 0; k < bodyB.parts.length; k++) {\n            var partB = bodyB.parts[k];\n\n            if (partA === bodyA && partB === bodyB || Bounds.overlaps(partA.bounds, partB.bounds)) {\n              // find a previous collision we could reuse\n              var pairId = Pair.id(partA, partB),\n                  pair = pairsTable[pairId],\n                  previousCollision;\n\n              if (pair && pair.isActive) {\n                previousCollision = pair.collision;\n              } else {\n                previousCollision = null;\n              } // narrow phase\n\n\n              var collision = SAT.collides(partA, partB, previousCollision); // @if DEBUG\n\n              metrics.narrowphaseTests += 1;\n              if (collision.reused) metrics.narrowReuseCount += 1; // @endif\n\n              if (collision.collided) {\n                collisions.push(collision); // @if DEBUG\n\n                metrics.narrowDetections += 1; // @endif\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return collisions;\n  };\n  /**\r\n   * Returns `true` if both supplied collision filters will allow a collision to occur.\r\n   * See `body.collisionFilter` for more information.\r\n   * @method canCollide\r\n   * @param {} filterA\r\n   * @param {} filterB\r\n   * @return {bool} `true` if collision can occur\r\n   */\n\n\n  Detector.canCollide = function (filterA, filterB) {\n    if (filterA.group === filterB.group && filterA.group !== 0) return filterA.group > 0;\n    return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;\n  };\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/lib/collision/Detector.js"],"names":["Detector","module","exports","SAT","require","Pair","Bounds","collisions","broadphasePairs","engine","pairsTable","pairs","table","metrics","i","length","bodyA","bodyB","isStatic","isSleeping","canCollide","collisionFilter","midphaseTests","overlaps","bounds","j","parts","partA","k","partB","pairId","id","pair","previousCollision","isActive","collision","collides","narrowphaseTests","reused","narrowReuseCount","collided","push","narrowDetections","filterA","filterB","group","mask","category"],"mappings":"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","sourcesContent":["/**\r\n* The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.\r\n*\r\n* @class Detector\r\n*/\r\n\r\n// TODO: speculative contacts\r\n\r\nvar Detector = {};\r\n\r\nmodule.exports = Detector;\r\n\r\nvar SAT = require('./SAT');\r\nvar Pair = require('./Pair');\r\nvar Bounds = require('../geometry/Bounds');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Finds all collisions given a list of pairs.\r\n     * @method collisions\r\n     * @param {pair[]} broadphasePairs\r\n     * @param {engine} engine\r\n     * @return {array} collisions\r\n     */\r\n    Detector.collisions = function(broadphasePairs, engine) {\r\n        var collisions = [],\r\n            pairsTable = engine.pairs.table;\r\n\r\n        // @if DEBUG\r\n        var metrics = engine.metrics;\r\n        // @endif\r\n        \r\n        for (var i = 0; i < broadphasePairs.length; i++) {\r\n            var bodyA = broadphasePairs[i][0], \r\n                bodyB = broadphasePairs[i][1];\r\n\r\n            if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping))\r\n                continue;\r\n            \r\n            if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter))\r\n                continue;\r\n\r\n            // @if DEBUG\r\n            metrics.midphaseTests += 1;\r\n            // @endif\r\n\r\n            // mid phase\r\n            if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {\r\n                for (var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++) {\r\n                    var partA = bodyA.parts[j];\r\n\r\n                    for (var k = bodyB.parts.length > 1 ? 1 : 0; k < bodyB.parts.length; k++) {\r\n                        var partB = bodyB.parts[k];\r\n\r\n                        if ((partA === bodyA && partB === bodyB) || Bounds.overlaps(partA.bounds, partB.bounds)) {\r\n                            // find a previous collision we could reuse\r\n                            var pairId = Pair.id(partA, partB),\r\n                                pair = pairsTable[pairId],\r\n                                previousCollision;\r\n\r\n                            if (pair && pair.isActive) {\r\n                                previousCollision = pair.collision;\r\n                            } else {\r\n                                previousCollision = null;\r\n                            }\r\n\r\n                            // narrow phase\r\n                            var collision = SAT.collides(partA, partB, previousCollision);\r\n\r\n                            // @if DEBUG\r\n                            metrics.narrowphaseTests += 1;\r\n                            if (collision.reused)\r\n                                metrics.narrowReuseCount += 1;\r\n                            // @endif\r\n\r\n                            if (collision.collided) {\r\n                                collisions.push(collision);\r\n                                // @if DEBUG\r\n                                metrics.narrowDetections += 1;\r\n                                // @endif\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return collisions;\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if both supplied collision filters will allow a collision to occur.\r\n     * See `body.collisionFilter` for more information.\r\n     * @method canCollide\r\n     * @param {} filterA\r\n     * @param {} filterB\r\n     * @return {bool} `true` if collision can occur\r\n     */\r\n    Detector.canCollide = function(filterA, filterB) {\r\n        if (filterA.group === filterB.group && filterA.group !== 0)\r\n            return filterA.group > 0;\r\n\r\n        return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;\r\n    };\r\n\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}