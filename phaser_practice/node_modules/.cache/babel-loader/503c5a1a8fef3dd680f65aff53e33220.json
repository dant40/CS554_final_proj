{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar DegToRad = require('../math/DegToRad');\n\nvar DynamicTilemapLayer = require('./dynamiclayer/DynamicTilemapLayer');\n\nvar Extend = require('../utils/object/Extend');\n\nvar Formats = require('./Formats');\n\nvar LayerData = require('./mapdata/LayerData');\n\nvar Rotate = require('../math/Rotate');\n\nvar SpliceOne = require('../utils/array/SpliceOne');\n\nvar StaticTilemapLayer = require('./staticlayer/StaticTilemapLayer');\n\nvar Tile = require('./Tile');\n\nvar TilemapComponents = require('./components');\n\nvar Tileset = require('./Tileset');\n/**\r\n * @callback TilemapFilterCallback\r\n *\r\n * @param {Phaser.GameObjects.GameObject} value - An object found in the filtered area.\r\n * @param {number} index - The index of the object within the array.\r\n * @param {Phaser.GameObjects.GameObject[]} array - An array of all the objects found.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The object.\r\n */\n\n/**\r\n * @callback TilemapFindCallback\r\n *\r\n * @param {Phaser.GameObjects.GameObject} value - An object found.\r\n * @param {number} index - The index of the object within the array.\r\n * @param {Phaser.GameObjects.GameObject[]} array - An array of all the objects found.\r\n *\r\n * @return {boolean} `true` if the callback should be invoked, otherwise `false`.\r\n */\n\n/**\r\n * @classdesc\r\n * A Tilemap is a container for Tilemap data. This isn't a display object, rather, it holds data\r\n * about the map and allows you to add tilesets and tilemap layers to it. A map can have one or\r\n * more tilemap layers (StaticTilemapLayer or DynamicTilemapLayer), which are the display\r\n * objects that actually render tiles.\r\n *\r\n * The Tilemap data be parsed from a Tiled JSON file, a CSV file or a 2D array. Tiled is a free\r\n * software package specifically for creating tile maps, and is available from:\r\n * http://www.mapeditor.org\r\n *\r\n * A Tilemap has handy methods for getting & manipulating the tiles within a layer. You can only\r\n * use the methods that change tiles (e.g. removeTileAt) on a DynamicTilemapLayer.\r\n *\r\n * Note that all Tilemaps use a base tile size to calculate dimensions from, but that a\r\n * StaticTilemapLayer or DynamicTilemapLayer may have its own unique tile size that overrides\r\n * it.\r\n *\r\n * As of Phaser 3.21.0, if your tilemap includes layer groups (a feature of Tiled 1.2.0+) these\r\n * will be traversed and the following properties will affect children:\r\n * - opacity (blended with parent) and visibility (parent overrides child)\r\n * - Vertical and horizontal offset\r\n * The grouping hierarchy is not preserved and all layers will be flattened into a single array.\r\n * Group layers are parsed during Tilemap construction but are discarded after parsing so dynamic\r\n * layers will NOT continue to be affected by a parent.\r\n *\r\n * To avoid duplicate layer names, a layer that is a child of a group layer will have its parent\r\n * group name prepended with a '/'.  For example, consider a group called 'ParentGroup' with a\r\n * child called 'Layer 1'. In the Tilemap object, 'Layer 1' will have the name\r\n * 'ParentGroup/Layer 1'.\r\n *\r\n * @class Tilemap\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Tilemap belongs.\r\n * @param {Phaser.Tilemaps.MapData} mapData - A MapData instance containing Tilemap data.\r\n */\n\n\nvar Tilemap = new Class({\n  initialize: function Tilemap(scene, mapData) {\n    /**\r\n     * @name Phaser.Tilemaps.Tilemap#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n    this.scene = scene;\n    /**\r\n     * The base width of a tile in pixels. Note that individual layers may have a different tile\r\n     * width.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#tileWidth\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.tileWidth = mapData.tileWidth;\n    /**\r\n     * The base height of a tile in pixels. Note that individual layers may have a different\r\n     * tile height.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#tileHeight\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.tileHeight = mapData.tileHeight;\n    /**\r\n     * The width of the map (in tiles).\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#width\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.width = mapData.width;\n    /**\r\n     * The height of the map (in tiles).\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#height\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.height = mapData.height;\n    /**\r\n     * The orientation of the map data (as specified in Tiled), usually 'orthogonal'.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#orientation\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\n\n    this.orientation = mapData.orientation;\n    /**\r\n     * The render (draw) order of the map data (as specified in Tiled), usually 'right-down'.\r\n     *\r\n     * The draw orders are:\r\n     *\r\n     * right-down\r\n     * left-down\r\n     * right-up\r\n     * left-up\r\n     *\r\n     * This can be changed via the `setRenderOrder` method.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#renderOrder\r\n     * @type {string}\r\n     * @since 3.12.0\r\n     */\n\n    this.renderOrder = mapData.renderOrder;\n    /**\r\n     * The format of the map data.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#format\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.format = mapData.format;\n    /**\r\n     * The version of the map data (as specified in Tiled, usually 1).\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#version\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.version = mapData.version;\n    /**\r\n     * Map specific properties as specified in Tiled.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#properties\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.properties = mapData.properties;\n    /**\r\n     * The width of the map in pixels based on width * tileWidth.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#widthInPixels\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.widthInPixels = mapData.widthInPixels;\n    /**\r\n     * The height of the map in pixels based on height * tileHeight.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#heightInPixels\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.heightInPixels = mapData.heightInPixels;\n    /**\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#imageCollections\r\n     * @type {Phaser.Tilemaps.ImageCollection[]}\r\n     * @since 3.0.0\r\n     */\n\n    this.imageCollections = mapData.imageCollections;\n    /**\r\n     * An array of Tiled Image Layers.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#images\r\n     * @type {array}\r\n     * @since 3.0.0\r\n     */\n\n    this.images = mapData.images;\n    /**\r\n     * An array of Tilemap layer data.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#layers\r\n     * @type {Phaser.Tilemaps.LayerData[]}\r\n     * @since 3.0.0\r\n     */\n\n    this.layers = mapData.layers;\n    /**\r\n     * An array of Tilesets used in the map.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#tilesets\r\n     * @type {Phaser.Tilemaps.Tileset[]}\r\n     * @since 3.0.0\r\n     */\n\n    this.tilesets = mapData.tilesets;\n    /**\r\n     * An array of ObjectLayer instances parsed from Tiled object layers.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#objects\r\n     * @type {Phaser.Tilemaps.ObjectLayer[]}\r\n     * @since 3.0.0\r\n     */\n\n    this.objects = mapData.objects;\n    /**\r\n     * The index of the currently selected LayerData object.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#currentLayerIndex\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.currentLayerIndex = 0;\n  },\n\n  /**\r\n   * Sets the rendering (draw) order of the tiles in this map.\r\n   *\r\n   * The default is 'right-down', meaning it will order the tiles starting from the top-left,\r\n   * drawing to the right and then moving down to the next row.\r\n   *\r\n   * The draw orders are:\r\n   *\r\n   * 0 = right-down\r\n   * 1 = left-down\r\n   * 2 = right-up\r\n   * 3 = left-up\r\n   *\r\n   * Setting the render order does not change the tiles or how they are stored in the layer,\r\n   * it purely impacts the order in which they are rendered.\r\n   *\r\n   * You can provide either an integer (0 to 3), or the string version of the order.\r\n   *\r\n   * Calling this method _after_ creating Static or Dynamic Tilemap Layers will **not** automatically\r\n   * update them to use the new render order. If you call this method after creating layers, use their\r\n   * own `setRenderOrder` methods to change them as needed.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#setRenderOrder\r\n   * @since 3.12.0\r\n   *\r\n   * @param {(integer|string)} renderOrder - The render (draw) order value. Either an integer between 0 and 3, or a string: 'right-down', 'left-down', 'right-up' or 'left-up'.\r\n   *\r\n   * @return {this} This Tilemap object.\r\n   */\n  setRenderOrder: function (renderOrder) {\n    var orders = ['right-down', 'left-down', 'right-up', 'left-up'];\n\n    if (typeof renderOrder === 'number') {\n      renderOrder = orders[renderOrder];\n    }\n\n    if (orders.indexOf(renderOrder) > -1) {\n      this.renderOrder = renderOrder;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Adds an image to the map to be used as a tileset. A single map may use multiple tilesets.\r\n   * Note that the tileset name can be found in the JSON file exported from Tiled, or in the Tiled\r\n   * editor.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#addTilesetImage\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} tilesetName - The name of the tileset as specified in the map data.\r\n   * @param {string} [key] - The key of the Phaser.Cache image used for this tileset. If\r\n   * `undefined` or `null` it will look for an image with a key matching the tilesetName parameter.\r\n   * @param {integer} [tileWidth] - The width of the tile (in pixels) in the Tileset Image. If not\r\n   * given it will default to the map's tileWidth value, or the tileWidth specified in the Tiled\r\n   * JSON file.\r\n   * @param {integer} [tileHeight] - The height of the tiles (in pixels) in the Tileset Image. If\r\n   * not given it will default to the map's tileHeight value, or the tileHeight specified in the\r\n   * Tiled JSON file.\r\n   * @param {integer} [tileMargin] - The margin around the tiles in the sheet (in pixels). If not\r\n   * specified, it will default to 0 or the value specified in the Tiled JSON file.\r\n   * @param {integer} [tileSpacing] - The spacing between each the tile in the sheet (in pixels).\r\n   * If not specified, it will default to 0 or the value specified in the Tiled JSON file.\r\n   * @param {integer} [gid=0] - If adding multiple tilesets to a blank map, specify the starting\r\n   * GID this set will use here.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tileset} Returns the Tileset object that was created or updated, or null if it\r\n   * failed.\r\n   */\n  addTilesetImage: function (tilesetName, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid) {\n    if (tilesetName === undefined) {\n      return null;\n    }\n\n    if (key === undefined || key === null) {\n      key = tilesetName;\n    }\n\n    if (!this.scene.sys.textures.exists(key)) {\n      console.warn('Invalid Tileset Image: ' + key);\n      return null;\n    }\n\n    var texture = this.scene.sys.textures.get(key);\n    var index = this.getTilesetIndex(tilesetName);\n\n    if (index === null && this.format === Formats.TILED_JSON) {\n      console.warn('No data found for Tileset: ' + tilesetName);\n      return null;\n    }\n\n    var tileset = this.tilesets[index];\n\n    if (tileset) {\n      tileset.setTileSize(tileWidth, tileHeight);\n      tileset.setSpacing(tileMargin, tileSpacing);\n      tileset.setImage(texture);\n      return tileset;\n    }\n\n    if (tileWidth === undefined) {\n      tileWidth = this.tileWidth;\n    }\n\n    if (tileHeight === undefined) {\n      tileHeight = this.tileHeight;\n    }\n\n    if (tileMargin === undefined) {\n      tileMargin = 0;\n    }\n\n    if (tileSpacing === undefined) {\n      tileSpacing = 0;\n    }\n\n    if (gid === undefined) {\n      gid = 0;\n    }\n\n    tileset = new Tileset(tilesetName, gid, tileWidth, tileHeight, tileMargin, tileSpacing);\n    tileset.setImage(texture);\n    this.tilesets.push(tileset);\n    return tileset;\n  },\n\n  /**\r\n   * Turns the DynamicTilemapLayer associated with the given layer into a StaticTilemapLayer. If\r\n   * no layer specified, the map's current layer is used. This is useful if you want to manipulate\r\n   * a map at the start of a scene, but then make it non-manipulable and optimize it for speed.\r\n   * Note: the DynamicTilemapLayer passed in is destroyed, so make sure to store the value\r\n   * returned from this method if you want to manipulate the new StaticTilemapLayer.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#convertLayerToStatic\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer)} [layer] - The name of the layer from Tiled, the\r\n   * index of the layer in the map, or a DynamicTilemapLayer.\r\n   *\r\n   * @return {?Phaser.Tilemaps.StaticTilemapLayer} Returns the new layer that was created, or null if it\r\n   * failed.\r\n   */\n  convertLayerToStatic: function (layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    var dynamicLayer = layer.tilemapLayer;\n\n    if (!dynamicLayer || !(dynamicLayer instanceof DynamicTilemapLayer)) {\n      return null;\n    }\n\n    var staticLayer = new StaticTilemapLayer(dynamicLayer.scene, dynamicLayer.tilemap, dynamicLayer.layerIndex, dynamicLayer.tileset, dynamicLayer.x, dynamicLayer.y);\n    this.scene.sys.displayList.add(staticLayer);\n    dynamicLayer.destroy();\n    return staticLayer;\n  },\n\n  /**\r\n   * Copies the tiles in the source rectangular area to a new destination (all specified in tile\r\n   * coordinates) within the layer. This copies all tile properties & recalculates collision\r\n   * information in the destination region.\r\n   *\r\n   * If no layer specified, the map's current layer is used. This cannot be applied to StaticTilemapLayers.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#copy\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} srcTileX - The x coordinate of the area to copy from, in tiles, not pixels.\r\n   * @param {integer} srcTileY - The y coordinate of the area to copy from, in tiles, not pixels.\r\n   * @param {integer} width - The width of the area to copy, in tiles, not pixels.\r\n   * @param {integer} height - The height of the area to copy, in tiles, not pixels.\r\n   * @param {integer} destTileX - The x coordinate of the area to copy to, in tiles, not pixels.\r\n   * @param {integer} destTileY - The y coordinate of the area to copy to, in tiles, not pixels.\r\n   * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n   */\n  copy: function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer) {\n    layer = this.getLayer(layer);\n\n    if (this._isStaticCall(layer, 'copy')) {\n      return this;\n    }\n\n    if (layer !== null) {\n      TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer);\n      return this;\n    } else {\n      return null;\n    }\n  },\n\n  /**\r\n   * Creates a new and empty DynamicTilemapLayer. The currently selected layer in the map is set to this new layer.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#createBlankDynamicLayer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} name - The name of this layer. Must be unique within the map.\r\n   * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n   * @param {number} [x=0] - The world x position where the top left of this layer will be placed.\r\n   * @param {number} [y=0] - The world y position where the top left of this layer will be placed.\r\n   * @param {integer} [width] - The width of the layer in tiles. If not specified, it will default to the map's width.\r\n   * @param {integer} [height] - The height of the layer in tiles. If not specified, it will default to the map's height.\r\n   * @param {integer} [tileWidth] - The width of the tiles the layer uses for calculations. If not specified, it will default to the map's tileWidth.\r\n   * @param {integer} [tileHeight] - The height of the tiles the layer uses for calculations. If not specified, it will default to the map's tileHeight.\r\n   *\r\n   * @return {?Phaser.Tilemaps.DynamicTilemapLayer} Returns the new layer that was created, or `null` if it failed.\r\n   */\n  createBlankDynamicLayer: function (name, tileset, x, y, width, height, tileWidth, tileHeight) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = this.width;\n    }\n\n    if (height === undefined) {\n      height = this.height;\n    }\n\n    if (tileWidth === undefined) {\n      tileWidth = this.tileWidth;\n    }\n\n    if (tileHeight === undefined) {\n      tileHeight = this.tileHeight;\n    }\n\n    var index = this.getLayerIndex(name);\n\n    if (index !== null) {\n      console.warn('Invalid Tilemap Layer ID: ' + name);\n      return null;\n    }\n\n    var layerData = new LayerData({\n      name: name,\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n      width: width,\n      height: height\n    });\n    var row;\n\n    for (var tileY = 0; tileY < height; tileY++) {\n      row = [];\n\n      for (var tileX = 0; tileX < width; tileX++) {\n        row.push(new Tile(layerData, -1, tileX, tileY, tileWidth, tileHeight, this.tileWidth, this.tileHeight));\n      }\n\n      layerData.data.push(row);\n    }\n\n    this.layers.push(layerData);\n    this.currentLayerIndex = this.layers.length - 1;\n    var dynamicLayer = new DynamicTilemapLayer(this.scene, this, this.currentLayerIndex, tileset, x, y);\n    dynamicLayer.setRenderOrder(this.renderOrder);\n    this.scene.sys.displayList.add(dynamicLayer);\n    return dynamicLayer;\n  },\n\n  /**\r\n   * Creates a new DynamicTilemapLayer that renders the LayerData associated with the given\r\n   * `layerID`. The currently selected layer in the map is set to this new layer.\r\n   *\r\n   * The `layerID` is important. If you've created your map in Tiled then you can get this by\r\n   * looking in Tiled and looking at the layer name. Or you can open the JSON file it exports and\r\n   * look at the layers[].name value. Either way it must match.\r\n   *\r\n   * Unlike a static layer, a dynamic layer can be modified. See DynamicTilemapLayer for more\r\n   * information.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#createDynamicLayer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(integer|string)} layerID - The layer array index value, or if a string is given, the layer name from Tiled.\r\n   * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n   * @param {number} [x=0] - The x position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.\r\n   * @param {number} [y=0] - The y position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.\r\n   *\r\n   * @return {?Phaser.Tilemaps.DynamicTilemapLayer} Returns the new layer was created, or null if it failed.\r\n   */\n  createDynamicLayer: function (layerID, tileset, x, y) {\n    var index = this.getLayerIndex(layerID);\n\n    if (index === null) {\n      console.warn('Invalid Tilemap Layer ID: ' + layerID);\n\n      if (typeof layerID === 'string') {\n        console.warn('Valid tilelayer names:\\n\\t' + this.getTileLayerNames().join(',\\n\\t'));\n      }\n\n      return null;\n    }\n\n    var layerData = this.layers[index]; // Check for an associated static or dynamic tilemap layer\n\n    if (layerData.tilemapLayer) {\n      console.warn('Tilemap Layer ID already exists:' + layerID);\n      return null;\n    }\n\n    this.currentLayerIndex = index; //  Default the x/y position to match Tiled layer offset, if it exists.\n\n    if (x === undefined) {\n      x = layerData.x;\n    }\n\n    if (y === undefined) {\n      y = layerData.y;\n    }\n\n    var layer = new DynamicTilemapLayer(this.scene, this, index, tileset, x, y);\n    layer.setRenderOrder(this.renderOrder);\n    this.scene.sys.displayList.add(layer);\n    return layer;\n  },\n\n  /**\r\n   * Creates a Sprite for every object matching the given gid in the map data. All properties from\r\n   * the map data objectgroup are copied into the `spriteConfig`, so you can use this as an easy\r\n   * way to configure Sprite properties from within the map editor. For example giving an object a\r\n   * property of alpha: 0.5 in the map editor will duplicate that when the Sprite is created.\r\n   *\r\n   * Custom object properties not sharing names with the Sprite's own properties are copied to the\r\n   * Sprite's {@link Phaser.GameObjects.Sprite#data data store}.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#createFromObjects\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} name - The name of the object layer (from Tiled) to create Sprites from.\r\n   * @param {(integer|string)} id - Either the id (object), gid (tile object) or name (object or\r\n   * tile object) from Tiled. Ids are unique in Tiled, but a gid is shared by all tile objects\r\n   * with the same graphic. The same name can be used on multiple objects.\r\n   * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e.\r\n   * scene.make.sprite).\r\n   * @param {Phaser.Scene} [scene=the scene the map is within] - The Scene to create the Sprites within.\r\n   *\r\n   * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.\r\n   */\n  createFromObjects: function (name, id, spriteConfig, scene) {\n    if (spriteConfig === undefined) {\n      spriteConfig = {};\n    }\n\n    if (scene === undefined) {\n      scene = this.scene;\n    }\n\n    var objectLayer = this.getObjectLayer(name);\n\n    if (!objectLayer) {\n      console.warn('Cannot create from object. Invalid objectgroup name given: ' + name);\n\n      if (typeof layerID === 'string') {\n        console.warn('Valid objectgroup names:\\n\\t' + this.getObjectLayerNames().join(',\\n\\t'));\n      }\n\n      return null;\n    }\n\n    var objects = objectLayer.objects;\n    var sprites = [];\n\n    for (var i = 0; i < objects.length; i++) {\n      var found = false;\n      var obj = objects[i];\n\n      if (obj.gid !== undefined && typeof id === 'number' && obj.gid === id || obj.id !== undefined && typeof id === 'number' && obj.id === id || obj.name !== undefined && typeof id === 'string' && obj.name === id) {\n        found = true;\n      }\n\n      if (found) {\n        var config = Extend({}, spriteConfig, obj.properties);\n        config.x = obj.x;\n        config.y = obj.y;\n        var sprite = scene.make.sprite(config);\n        sprite.name = obj.name;\n\n        if (obj.width) {\n          sprite.displayWidth = obj.width;\n        }\n\n        if (obj.height) {\n          sprite.displayHeight = obj.height;\n        } // Origin is (0, 1) in Tiled, so find the offset that matches the Sprite's origin.\n\n\n        var offset = {\n          x: sprite.originX * sprite.displayWidth,\n          y: (sprite.originY - 1) * sprite.displayHeight\n        }; // If the object is rotated, then the origin offset also needs to be rotated.\n\n        if (obj.rotation) {\n          var angle = DegToRad(obj.rotation);\n          Rotate(offset, angle);\n          sprite.rotation = angle;\n        }\n\n        sprite.x += offset.x;\n        sprite.y += offset.y;\n\n        if (obj.flippedHorizontal !== undefined || obj.flippedVertical !== undefined) {\n          sprite.setFlip(obj.flippedHorizontal, obj.flippedVertical);\n        }\n\n        if (!obj.visible) {\n          sprite.visible = false;\n        }\n\n        for (var key in obj.properties) {\n          if (sprite.hasOwnProperty(key)) {\n            continue;\n          }\n\n          sprite.setData(key, obj.properties[key]);\n        }\n\n        sprites.push(sprite);\n      }\n    }\n\n    return sprites;\n  },\n\n  /**\r\n   * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n   * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n   * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n   * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#createFromTiles\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(integer|array)} indexes - The tile index, or array of indexes, to create Sprites from.\r\n   * @param {(integer|array)} replacements - The tile index, or array of indexes, to change a converted\r\n   * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a\r\n   * one-to-one mapping with the indexes array.\r\n   * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e. scene.make.sprite).\r\n   * @param {Phaser.Scene} [scene=scene the map is within] - The Scene to create the Sprites within.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.GameObjects.Sprite[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n   */\n  createFromTiles: function (indexes, replacements, spriteConfig, scene, camera, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, layer);\n  },\n\n  /**\r\n   * Creates a new StaticTilemapLayer that renders the LayerData associated with the given\r\n   * `layerID`. The currently selected layer in the map is set to this new layer.\r\n   *\r\n   * The `layerID` is important. If you've created your map in Tiled then you can get this by\r\n   * looking in Tiled and looking at the layer name. Or you can open the JSON file it exports and\r\n   * look at the layers[].name value. Either way it must match.\r\n   *\r\n   * It's important to remember that a static layer cannot be modified. See StaticTilemapLayer for\r\n   * more information.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#createStaticLayer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(integer|string)} layerID - The layer array index value, or if a string is given, the layer name from Tiled.\r\n   * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n   * @param {number} [x=0] - The x position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.\r\n   * @param {number} [y=0] - The y position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.\r\n   *\r\n   * @return {?Phaser.Tilemaps.StaticTilemapLayer} Returns the new layer was created, or null if it failed.\r\n   */\n  createStaticLayer: function (layerID, tileset, x, y) {\n    var index = this.getLayerIndex(layerID);\n\n    if (index === null) {\n      console.warn('Invalid Tilemap Layer ID: ' + layerID);\n\n      if (typeof layerID === 'string') {\n        console.warn('Valid tilelayer names:\\n\\t' + this.getTileLayerNames().join(',\\n\\t'));\n      }\n\n      return null;\n    }\n\n    var layerData = this.layers[index]; //  Check for an associated static or dynamic tilemap layer\n\n    if (layerData.tilemapLayer) {\n      console.warn('Tilemap Layer ID already exists:' + layerID);\n      return null;\n    }\n\n    this.currentLayerIndex = index; //  Default the x/y position to match Tiled layer offset, if it exists.\n\n    if (x === undefined && this.layers[index].x) {\n      x = this.layers[index].x;\n    }\n\n    if (y === undefined && this.layers[index].y) {\n      y = this.layers[index].y;\n    }\n\n    var layer = new StaticTilemapLayer(this.scene, this, index, tileset, x, y);\n    layer.setRenderOrder(this.renderOrder);\n    this.scene.sys.displayList.add(layer);\n    return layer;\n  },\n\n  /**\r\n   * Removes all layer data from this Tilemap and nulls the scene reference. This will destroy any\r\n   * StaticTilemapLayers or DynamicTilemapLayers that have been linked to LayerData.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.removeAllLayers();\n    this.tilesets.length = 0;\n    this.objects.length = 0;\n    this.scene = undefined;\n  },\n\n  /**\r\n   * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the\r\n   * specified index. Tiles will be set to collide if the given index is a colliding index.\r\n   * Collision information in the region will be recalculated.\r\n   *\r\n   * If no layer specified, the map's current layer is used.\r\n   * This cannot be applied to StaticTilemapLayers.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#fill\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} index - The tile index to fill the area with.\r\n   * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n   * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n   * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n   */\n  fill: function (index, tileX, tileY, width, height, recalculateFaces, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    if (this._isStaticCall(layer, 'fill')) {\n      return this;\n    }\n\n    TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, layer);\n    return this;\n  },\n\n  /**\r\n   * For each object in the given object layer, run the given filter callback function. Any\r\n   * objects that pass the filter test (i.e. where the callback returns true) will returned as a\r\n   * new array. Similar to Array.prototype.Filter in vanilla JS.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#filterObjects\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Tilemaps.ObjectLayer|string)} objectLayer - The name of an object layer (from Tiled) or an ObjectLayer instance.\r\n   * @param {TilemapFilterCallback} callback - The callback. Each object in the given area will be passed to this callback as the first and only parameter.\r\n   * @param {object} [context] - The context under which the callback should be run.\r\n   *\r\n   * @return {?Phaser.GameObjects.GameObject[]} An array of object that match the search, or null if the objectLayer given was invalid.\r\n   */\n  filterObjects: function (objectLayer, callback, context) {\n    if (typeof objectLayer === 'string') {\n      var name = objectLayer;\n      objectLayer = this.getObjectLayer(objectLayer);\n\n      if (!objectLayer) {\n        console.warn('No object layer found with the name: ' + name);\n        return null;\n      }\n    }\n\n    return objectLayer.objects.filter(callback, context);\n  },\n\n  /**\r\n   * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n   * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns\r\n   * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.\r\n   * If no layer specified, the map's current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#filterTiles\r\n   * @since 3.0.0\r\n   *\r\n   * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n   * callback as the first and only parameter. The callback should return true for tiles that pass the\r\n   * filter.\r\n   * @param {object} [context] - The context under which the callback should be run.\r\n   * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n   * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n   * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n   * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n   * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n   */\n  filterTiles: function (callback, context, tileX, tileY, width, height, filteringOptions, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, layer);\n  },\n\n  /**\r\n   * Searches the entire map layer for the first tile matching the given index, then returns that Tile\r\n   * object. If no match is found, it returns null. The search starts from the top-left tile and\r\n   * continues horizontally until it hits the end of the row, then it drops down to the next column.\r\n   * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to\r\n   * the top-left.\r\n   * If no layer specified, the map's current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#findByIndex\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} index - The tile index value to search for.\r\n   * @param {integer} [skip=0] - The number of times to skip a matching tile before returning.\r\n   * @param {boolean} [reverse=false] - If true it will scan the layer in reverse, starting at the bottom-right. Otherwise it scans from the top-left.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tile} Returns a Tiles, or null if the layer given was invalid.\r\n   */\n  findByIndex: function (findIndex, skip, reverse, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.FindByIndex(findIndex, skip, reverse, layer);\n  },\n\n  /**\r\n   * Find the first object in the given object layer that satisfies the provided testing function.\r\n   * I.e. finds the first object for which `callback` returns true. Similar to\r\n   * Array.prototype.find in vanilla JS.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#findObject\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Tilemaps.ObjectLayer|string)} objectLayer - The name of an object layer (from Tiled) or an ObjectLayer instance.\r\n   * @param {TilemapFindCallback} callback - The callback. Each object in the given area will be passed to this callback as the first and only parameter.\r\n   * @param {object} [context] - The context under which the callback should be run.\r\n   *\r\n   * @return {?Phaser.GameObjects.GameObject} An object that matches the search, or null if no object found.\r\n   */\n  findObject: function (objectLayer, callback, context) {\n    if (typeof objectLayer === 'string') {\n      var name = objectLayer;\n      objectLayer = this.getObjectLayer(objectLayer);\n\n      if (!objectLayer) {\n        console.warn('No object layer found with the name: ' + name);\n        return null;\n      }\n    }\n\n    return objectLayer.objects.find(callback, context) || null;\n  },\n\n  /**\r\n   * Find the first tile in the given rectangular area (in tile coordinates) of the layer that\r\n   * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns\r\n   * true. Similar to Array.prototype.find in vanilla JS.\r\n   * If no layer specified, the maps current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#findTile\r\n   * @since 3.0.0\r\n   *\r\n   * @param {FindTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n   * @param {object} [context] - The context under which the callback should be run.\r\n   * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area to search.\r\n   * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area to search.\r\n   * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n   * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n   * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The Tile layer to run the search on. If not provided will use the current layer.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tile} Returns a Tiles, or null if the layer given was invalid.\r\n   */\n  findTile: function (callback, context, tileX, tileY, width, height, filteringOptions, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);\n  },\n\n  /**\r\n   * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n   * callback. Similar to Array.prototype.forEach in vanilla JS.\r\n   *\r\n   * If no layer specified, the map's current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#forEachTile\r\n   * @since 3.0.0\r\n   *\r\n   * @param {EachTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n   * @param {object} [context] - The context under which the callback should be run.\r\n   * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area to search.\r\n   * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area to search.\r\n   * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n   * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n   * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The Tile layer to run the search on. If not provided will use the current layer.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n   */\n  forEachTile: function (callback, context, tileX, tileY, width, height, filteringOptions, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);\n    return this;\n  },\n\n  /**\r\n   * Gets the image layer index based on its name.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#getImageIndex\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} name - The name of the image to get.\r\n   *\r\n   * @return {integer} The index of the image in this tilemap, or null if not found.\r\n   */\n  getImageIndex: function (name) {\n    return this.getIndex(this.images, name);\n  },\n\n  /**\r\n   * Return a list of all valid imagelayer names loaded in this Tilemap.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#getImageLayerNames\r\n   * @since 3.21.0\r\n   *\r\n   * @return {string[]} Array of valid imagelayer names / IDs loaded into this Tilemap.\r\n   */\n  getImageLayerNames: function () {\n    if (!this.images || !Array.isArray(this.images)) {\n      return [];\n    }\n\n    return this.images.map(function (image) {\n      return image.name;\n    });\n  },\n\n  /**\r\n   * Internally used. Returns the index of the object in one of the Tilemaps arrays whose name\r\n   * property matches the given `name`.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#getIndex\r\n   * @since 3.0.0\r\n   *\r\n   * @param {array} location - The Tilemap array to search.\r\n   * @param {string} name - The name of the array element to get.\r\n   *\r\n   * @return {number} The index of the element in the array, or null if not found.\r\n   */\n  getIndex: function (location, name) {\n    for (var i = 0; i < location.length; i++) {\n      if (location[i].name === name) {\n        return i;\n      }\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Gets the LayerData from this.layers that is associated with `layer`, or null if an invalid\r\n   * `layer` is given.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#getLayer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The name of the\r\n   * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a\r\n   * StaticTilemapLayer. If not given will default to the maps current layer index.\r\n   *\r\n   * @return {Phaser.Tilemaps.LayerData} The corresponding LayerData within this.layers.\r\n   */\n  getLayer: function (layer) {\n    var index = this.getLayerIndex(layer);\n    return index !== null ? this.layers[index] : null;\n  },\n\n  /**\r\n   * Gets the ObjectLayer from this.objects that has the given `name`, or null if no ObjectLayer\r\n   * is found with that name.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#getObjectLayer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [name] - The name of the object layer from Tiled.\r\n   *\r\n   * @return {?Phaser.Tilemaps.ObjectLayer} The corresponding ObjectLayer within this.objects or null.\r\n   */\n  getObjectLayer: function (name) {\n    var index = this.getIndex(this.objects, name);\n    return index !== null ? this.objects[index] : null;\n  },\n\n  /**\r\n   * Return a list of all valid objectgroup names loaded in this Tilemap.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#getObjectLayerNames\r\n   * @since 3.21.0\r\n   *\r\n   * @return {string[]} Array of valid objectgroup names / IDs loaded into this Tilemap.\r\n   */\n  getObjectLayerNames: function () {\n    if (!this.objects || !Array.isArray(this.objects)) {\n      return [];\n    }\n\n    return this.objects.map(function (object) {\n      return object.name;\n    });\n  },\n\n  /**\r\n   * Gets the LayerData index of the given `layer` within this.layers, or null if an invalid\r\n   * `layer` is given.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#getLayerIndex\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The name of the\r\n   * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a\r\n   * StaticTilemapLayer. If not given will default to the map's current layer index.\r\n   *\r\n   * @return {integer} The LayerData index within this.layers.\r\n   */\n  getLayerIndex: function (layer) {\n    if (layer === undefined) {\n      return this.currentLayerIndex;\n    } else if (typeof layer === 'string') {\n      return this.getLayerIndexByName(layer);\n    } else if (typeof layer === 'number' && layer < this.layers.length) {\n      return layer;\n    } else if (layer instanceof StaticTilemapLayer || layer instanceof DynamicTilemapLayer) {\n      return layer.layerIndex;\n    } else {\n      return null;\n    }\n  },\n\n  /**\r\n   * Gets the index of the LayerData within this.layers that has the given `name`, or null if an\r\n   * invalid `name` is given.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#getLayerIndexByName\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} name - The name of the layer to get.\r\n   *\r\n   * @return {integer} The LayerData index within this.layers.\r\n   */\n  getLayerIndexByName: function (name) {\n    return this.getIndex(this.layers, name);\n  },\n\n  /**\r\n   * Gets a tile at the given tile coordinates from the given layer.\r\n   * If no layer specified, the map's current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#getTileAt\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} tileX - X position to get the tile from (given in tile units, not pixels).\r\n   * @param {integer} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n   * @param {boolean} [nonNull=false] - If true getTile won't return null for empty tiles, but a Tile object with an index of -1.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n   */\n  getTileAt: function (tileX, tileY, nonNull, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.GetTileAt(tileX, tileY, nonNull, layer);\n  },\n\n  /**\r\n   * Gets a tile at the given world coordinates from the given layer.\r\n   * If no layer specified, the map's current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#getTileAtWorldXY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} worldX - X position to get the tile from (given in pixels)\r\n   * @param {number} worldY - Y position to get the tile from (given in pixels)\r\n   * @param {boolean} [nonNull=false] - If true, function won't return null for empty tiles, but a Tile object with an index of -1.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n   */\n  getTileAtWorldXY: function (worldX, worldY, nonNull, camera, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, layer);\n  },\n\n  /**\r\n   * Return a list of all valid tilelayer names loaded in this Tilemap.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#getTileLayerNames\r\n   * @since 3.21.0\r\n   *\r\n   * @return {string[]} Array of valid tilelayer names / IDs loaded into this Tilemap.\r\n   */\n  getTileLayerNames: function () {\n    if (!this.layers || !Array.isArray(this.layers)) {\n      return [];\n    }\n\n    return this.layers.map(function (layer) {\n      return layer.name;\n    });\n  },\n\n  /**\r\n   * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n   * If no layer specified, the maps current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#getTilesWithin\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n   * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n   * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n   */\n  getTilesWithin: function (tileX, tileY, width, height, filteringOptions, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);\n  },\n\n  /**\r\n   * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,\r\n   * Line, Rectangle or Triangle. The shape should be in world coordinates.\r\n   * If no layer specified, the maps current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#getTilesWithinShape\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates\r\n   * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when factoring in which tiles to return.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n   */\n  getTilesWithinShape: function (shape, filteringOptions, camera, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, layer);\n  },\n\n  /**\r\n   * Gets the tiles in the given rectangular area (in world coordinates) of the layer.\r\n   * If no layer specified, the maps current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#getTilesWithinWorldXY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} worldX - The world x coordinate for the top-left of the area.\r\n   * @param {number} worldY - The world y coordinate for the top-left of the area.\r\n   * @param {number} width - The width of the area.\r\n   * @param {number} height - The height of the area.\r\n   * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when factoring in which tiles to return.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n   */\n  getTilesWithinWorldXY: function (worldX, worldY, width, height, filteringOptions, camera, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, layer);\n  },\n\n  /**\r\n   * Gets the Tileset that has the given `name`, or null if an invalid `name` is given.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#getTileset\r\n   * @since 3.14.0\r\n   *\r\n   * @param {string} name - The name of the Tileset to get.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tileset} The Tileset, or `null` if no matching named tileset was found.\r\n   */\n  getTileset: function (name) {\n    var index = this.getIndex(this.tilesets, name);\n    return index !== null ? this.tilesets[index] : null;\n  },\n\n  /**\r\n   * Gets the index of the Tileset within this.tilesets that has the given `name`, or null if an\r\n   * invalid `name` is given.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#getTilesetIndex\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} name - The name of the Tileset to get.\r\n   *\r\n   * @return {integer} The Tileset index within this.tilesets.\r\n   */\n  getTilesetIndex: function (name) {\n    return this.getIndex(this.tilesets, name);\n  },\n\n  /**\r\n   * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns\r\n   * false if there is no tile or if the tile at that location has an index of -1.\r\n   *\r\n   * If no layer specified, the map's current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#hasTileAt\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n   * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n   */\n  hasTileAt: function (tileX, tileY, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.HasTileAt(tileX, tileY, layer);\n  },\n\n  /**\r\n   * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns\r\n   * false if there is no tile or if the tile at that location has an index of -1.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#hasTileAtWorldXY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} worldX - The x coordinate, in pixels.\r\n   * @param {number} worldY - The y coordinate, in pixels.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when factoring in which tiles to return.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n   */\n  hasTileAtWorldXY: function (worldX, worldY, camera, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, layer);\n  },\n\n  /**\r\n   * The LayerData object that is currently selected in the map. You can set this property using\r\n   * any type supported by setLayer.\r\n   *\r\n   * @name Phaser.Tilemaps.Tilemap#layer\r\n   * @type {Phaser.Tilemaps.LayerData}\r\n   * @since 3.0.0\r\n   */\n  layer: {\n    get: function () {\n      return this.layers[this.currentLayerIndex];\n    },\n    set: function (layer) {\n      this.setLayer(layer);\n    }\n  },\n\n  /**\r\n   * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n   * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n   * location. If you pass in an index, only the index at the specified location will be changed.\r\n   * Collision information will be recalculated at the specified location.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   *\r\n   * This cannot be applied to StaticTilemapLayers.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#putTileAt\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n   * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n   * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n   * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid or the coordinates were out of bounds.\r\n   */\n  putTileAt: function (tile, tileX, tileY, recalculateFaces, layer) {\n    layer = this.getLayer(layer);\n\n    if (this._isStaticCall(layer, 'putTileAt')) {\n      return null;\n    }\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, layer);\n  },\n\n  /**\r\n   * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either\r\n   * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the\r\n   * specified location. If you pass in an index, only the index at the specified location will be\r\n   * changed. Collision information will be recalculated at the specified location.\r\n   *\r\n   * If no layer specified, the maps current layer is used. This\r\n   * cannot be applied to StaticTilemapLayers.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#putTileAtWorldXY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n   * @param {number} worldX - The x coordinate, in pixels.\r\n   * @param {number} worldY - The y coordinate, in pixels.\r\n   * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n   */\n  putTileAtWorldXY: function (tile, worldX, worldY, recalculateFaces, camera, layer) {\n    layer = this.getLayer(layer);\n\n    if (this._isStaticCall(layer, 'putTileAtWorldXY')) {\n      return null;\n    }\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, layer);\n  },\n\n  /**\r\n   * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified\r\n   * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,\r\n   * all attributes will be copied over to the specified location. If you pass in an index, only the\r\n   * index at the specified location will be changed. Collision information will be recalculated\r\n   * within the region tiles were changed.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   * This cannot be applied to StaticTilemapLayers.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#putTilesAt\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(integer[]|integer[][]|Phaser.Tilemaps.Tile[]|Phaser.Tilemaps.Tile[][])} tile - A row (array) or grid (2D array) of Tiles or tile indexes to place.\r\n   * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n   * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n   * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n   */\n  putTilesAt: function (tilesArray, tileX, tileY, recalculateFaces, layer) {\n    layer = this.getLayer(layer);\n\n    if (this._isStaticCall(layer, 'putTilesAt')) {\n      return this;\n    }\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, layer);\n    return this;\n  },\n\n  /**\r\n   * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n   * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then\r\n   * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n   * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n   * indexes. This method only modifies tile indexes and does not change collision information.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   * This cannot be applied to StaticTilemapLayers.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#randomize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n   * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n   * @param {integer[]} [indexes] - An array of indexes to randomly draw from during randomization.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n   */\n  randomize: function (tileX, tileY, width, height, indexes, layer) {\n    layer = this.getLayer(layer);\n\n    if (this._isStaticCall(layer, 'randomize')) {\n      return this;\n    }\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.Randomize(tileX, tileY, width, height, indexes, layer);\n    return this;\n  },\n\n  /**\r\n   * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting\r\n   * faces are used internally for optimizing collisions against tiles. This method is mostly used\r\n   * internally to optimize recalculating faces when only one tile has been changed.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#calculateFacesAt\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n   * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n   */\n  calculateFacesAt: function (tileX, tileY, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.CalculateFacesAt(tileX, tileY, layer);\n    return this;\n  },\n\n  /**\r\n   * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the\r\n   * layer. Interesting faces are used internally for optimizing collisions against tiles. This method\r\n   * is mostly used internally.\r\n   *\r\n   * If no layer specified, the map's current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#calculateFacesWithin\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n   * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n   */\n  calculateFacesWithin: function (tileX, tileY, width, height, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, layer);\n    return this;\n  },\n\n  /**\r\n   * Removes the given TilemapLayer from this Tilemap without destroying it.\r\n   *\r\n   * If no layer specified, the map's current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#removeLayer\r\n   * @since 3.17.0\r\n   *\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to be removed.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n   */\n  removeLayer: function (layer) {\n    var index = this.getLayerIndex(layer);\n\n    if (index !== null) {\n      SpliceOne(this.layers, index);\n\n      for (var i = index; i < this.layers.length; i++) {\n        if (this.layers[i].tilemapLayer) {\n          this.layers[i].tilemapLayer.layerIndex--;\n        }\n      }\n\n      if (this.currentLayerIndex === index) {\n        this.currentLayerIndex = 0;\n      }\n\n      return this;\n    } else {\n      return null;\n    }\n  },\n\n  /**\r\n   * Destroys the given TilemapLayer and removes it from this Tilemap.\r\n   *\r\n   * If no layer specified, the map's current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#destroyLayer\r\n   * @since 3.17.0\r\n   *\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to be destroyed.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n   */\n  destroyLayer: function (layer) {\n    var index = this.getLayerIndex(layer);\n\n    if (index !== null) {\n      layer = this.layers[index];\n      layer.destroy();\n      SpliceOne(this.layers, index);\n\n      if (this.currentLayerIndex === index) {\n        this.currentLayerIndex = 0;\n      }\n\n      return this;\n    } else {\n      return null;\n    }\n  },\n\n  /**\r\n   * Removes all layers from this Tilemap and destroys any associated StaticTilemapLayers or\r\n   * DynamicTilemapLayers.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#removeAllLayers\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Tilemaps.Tilemap} This Tilemap object.\r\n   */\n  removeAllLayers: function () {\n    var layers = this.layers; // Destroy any StaticTilemapLayers or DynamicTilemapLayers that are stored in LayerData\n\n    for (var i = 0; i < layers.length; i++) {\n      if (layers[i].tilemapLayer) {\n        layers[i].tilemapLayer.destroy(false);\n      }\n    }\n\n    layers.length = 0;\n    this.currentLayerIndex = 0;\n    return this;\n  },\n\n  /**\r\n   * Removes the given Tile, or an array of Tiles, from the layer to which they belong,\r\n   * and optionally recalculates the collision information.\r\n   *\r\n   * This cannot be applied to Tiles that belong to Static Tilemap Layers.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#removeTile\r\n   * @since 3.17.0\r\n   *\r\n   * @param {(Phaser.Tilemaps.Tile|Phaser.Tilemaps.Tile[])} tiles - The Tile to remove, or an array of Tiles.\r\n   * @param {integer} [replaceIndex=-1] - After removing the Tile, insert a brand new Tile into its location with the given index. Leave as -1 to just remove the tile.\r\n   * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n   *\r\n   * @return {Phaser.Tilemaps.Tile[]} Returns an array of Tiles that were removed.\r\n   */\n  removeTile: function (tiles, replaceIndex, recalculateFaces) {\n    if (replaceIndex === undefined) {\n      replaceIndex = -1;\n    }\n\n    if (recalculateFaces === undefined) {\n      recalculateFaces = true;\n    }\n\n    var removed = [];\n\n    if (!Array.isArray(tiles)) {\n      tiles = [tiles];\n    }\n\n    for (var i = 0; i < tiles.length; i++) {\n      var tile = tiles[i];\n      removed.push(this.removeTileAt(tile.x, tile.y, true, recalculateFaces, tile.tilemapLayer));\n\n      if (replaceIndex > -1) {\n        this.putTileAt(replaceIndex, tile.x, tile.y, recalculateFaces, tile.tilemapLayer);\n      }\n    }\n\n    return removed;\n  },\n\n  /**\r\n   * Removes the tile at the given tile coordinates in the specified layer and updates the layer's\r\n   * collision information.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   * This cannot be applied to StaticTilemapLayers.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#removeTileAt\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n   * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n   * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n   * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tile} Returns the Tile that was removed, or null if the layer given was invalid.\r\n   */\n  removeTileAt: function (tileX, tileY, replaceWithNull, recalculateFaces, layer) {\n    layer = this.getLayer(layer);\n\n    if (this._isStaticCall(layer, 'removeTileAt')) {\n      return null;\n    }\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, layer);\n  },\n\n  /**\r\n   * Removes the tile at the given world coordinates in the specified layer and updates the layer's\r\n   * collision information.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   * This cannot be applied to StaticTilemapLayers.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#removeTileAtWorldXY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} worldX - The x coordinate, in pixels.\r\n   * @param {number} worldY - The y coordinate, in pixels.\r\n   * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n   * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n   */\n  removeTileAtWorldXY: function (worldX, worldY, replaceWithNull, recalculateFaces, camera, layer) {\n    layer = this.getLayer(layer);\n\n    if (this._isStaticCall(layer, 'removeTileAtWorldXY')) {\n      return null;\n    }\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer);\n  },\n\n  /**\r\n   * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to\r\n   * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles\r\n   * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation\r\n   * wherever you want on the screen.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#renderDebug\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n   * @param {Phaser.Types.Tilemaps.StyleConfig} styleConfig - An object specifying the colors to use for the debug drawing.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n   */\n  renderDebug: function (graphics, styleConfig, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.RenderDebug(graphics, styleConfig, layer);\n    return this;\n  },\n\n  /**\r\n   * Draws a debug representation of all layers within this Tilemap to the given Graphics object.\r\n   *\r\n   * This is helpful when you want to get a quick idea of which of your tiles are colliding and which\r\n   * have interesting faces. The tiles are drawn starting at (0, 0) in the Graphics, allowing you to\r\n   * place the debug representation wherever you want on the screen.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#renderDebugFull\r\n   * @since 3.17.0\r\n   *\r\n   * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n   * @param {Phaser.Types.Tilemaps.StyleConfig} styleConfig - An object specifying the colors to use for the debug drawing.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n   */\n  renderDebugFull: function (graphics, styleConfig) {\n    var layers = this.layers; // Destroy any StaticTilemapLayers or DynamicTilemapLayers that are stored in LayerData\n\n    for (var i = 0; i < layers.length; i++) {\n      TilemapComponents.RenderDebug(graphics, styleConfig, layers[i]);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n   * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does\r\n   * not change collision information.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   * This cannot be applied to StaticTilemapLayers.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#replaceByIndex\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} findIndex - The index of the tile to search for.\r\n   * @param {integer} newIndex - The index of the tile to replace it with.\r\n   * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n   * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n   */\n  replaceByIndex: function (findIndex, newIndex, tileX, tileY, width, height, layer) {\n    layer = this.getLayer(layer);\n\n    if (this._isStaticCall(layer, 'replaceByIndex')) {\n      return this;\n    }\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, layer);\n    return this;\n  },\n\n  /**\r\n   * Sets collision on the given tile or tiles within a layer by index. You can pass in either a\r\n   * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if\r\n   * collision will be enabled (true) or disabled (false).\r\n   *\r\n   * If no layer specified, the map's current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#setCollision\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes.\r\n   * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n   * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to false if no tiles have been placed for significant performance boost.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n   */\n  setCollision: function (indexes, collides, recalculateFaces, layer, updateLayer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.SetCollision(indexes, collides, recalculateFaces, layer, updateLayer);\n    return this;\n  },\n\n  /**\r\n   * Sets collision on a range of tiles in a layer whose index is between the specified `start` and\r\n   * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set\r\n   * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be\r\n   * enabled (true) or disabled (false).\r\n   *\r\n   * If no layer specified, the map's current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#setCollisionBetween\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} start - The first index of the tile to be set for collision.\r\n   * @param {integer} stop - The last index of the tile to be set for collision.\r\n   * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n   * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n   */\n  setCollisionBetween: function (start, stop, collides, recalculateFaces, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, layer);\n    return this;\n  },\n\n  /**\r\n   * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property\r\n   * that matches the given properties object, its collision flag will be set. The `collides`\r\n   * parameter controls if collision will be enabled (true) or disabled (false). Passing in\r\n   * `{ collides: true }` would update the collision flag on any tiles with a \"collides\" property that\r\n   * has a value of true. Any tile that doesn't have \"collides\" set to true will be ignored. You can\r\n   * also use an array of values, e.g. `{ types: [\"stone\", \"lava\", \"sand\" ] }`. If a tile has a\r\n   * \"types\" property that matches any of those values, its collision flag will be updated.\r\n   *\r\n   * If no layer specified, the map's current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#setCollisionByProperty\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} properties - An object with tile properties and corresponding values that should be checked.\r\n   * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n   * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n   */\n  setCollisionByProperty: function (properties, collides, recalculateFaces, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, layer);\n    return this;\n  },\n\n  /**\r\n   * Sets collision on all tiles in the given layer, except for tiles that have an index specified in\r\n   * the given array. The `collides` parameter controls if collision will be enabled (true) or\r\n   * disabled (false).\r\n   *\r\n   * If no layer specified, the map's current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#setCollisionByExclusion\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer[]} indexes - An array of the tile indexes to not be counted for collision.\r\n   * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n   * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n   */\n  setCollisionByExclusion: function (indexes, collides, recalculateFaces, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, layer);\n    return this;\n  },\n\n  /**\r\n   * Sets collision on the tiles within a layer by checking each tile's collision group data\r\n   * (typically defined in Tiled within the tileset collision editor). If any objects are found within\r\n   * a tile's collision group, the tile's colliding information will be set. The `collides` parameter\r\n   * controls if collision will be enabled (true) or disabled (false).\r\n   *\r\n   * If no layer specified, the map's current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#setCollisionFromCollisionGroup\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n   * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n   */\n  setCollisionFromCollisionGroup: function (collides, recalculateFaces, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, layer);\n    return this;\n  },\n\n  /**\r\n   * Sets a global collision callback for the given tile index within the layer. This will affect all\r\n   * tiles on this layer that have the same index. If a callback is already set for the tile index it\r\n   * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile\r\n   * at a specific location on the map then see setTileLocationCallback.\r\n   *\r\n   * If no layer specified, the map's current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#setTileIndexCallback\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes to have a collision callback set for.\r\n   * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n   * @param {object} callbackContext - The context under which the callback is called.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n   */\n  setTileIndexCallback: function (indexes, callback, callbackContext, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, layer);\n    return this;\n  },\n\n  /**\r\n   * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.\r\n   * If a callback is already set for the tile index it will be replaced. Set the callback to null to\r\n   * remove it.\r\n   *\r\n   * If no layer specified, the map's current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#setTileLocationCallback\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} width - How many tiles wide from the `tileX` index the area will be.\r\n   * @param {integer} height - How many tiles tall from the `tileY` index the area will be.\r\n   * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n   * @param {object} [callbackContext] - The context under which the callback is called.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n   */\n  setTileLocationCallback: function (tileX, tileY, width, height, callback, callbackContext, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, layer);\n    return this;\n  },\n\n  /**\r\n   * Sets the current layer to the LayerData associated with `layer`.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#setLayer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The name of the\r\n   * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a\r\n   * StaticTilemapLayer. If not given will default to the map's current layer index.\r\n   *\r\n   * @return {Phaser.Tilemaps.Tilemap} This Tilemap object.\r\n   */\n  setLayer: function (layer) {\n    var index = this.getLayerIndex(layer);\n\n    if (index !== null) {\n      this.currentLayerIndex = index;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the base tile size for the map. Note: this does not necessarily match the tileWidth and\r\n   * tileHeight for all layers. This also updates the base size on all tiles across all layers.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#setBaseTileSize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} tileWidth - The width of the tiles the map uses for calculations.\r\n   * @param {integer} tileHeight - The height of the tiles the map uses for calculations.\r\n   *\r\n   * @return {Phaser.Tilemaps.Tilemap} This Tilemap object.\r\n   */\n  setBaseTileSize: function (tileWidth, tileHeight) {\n    this.tileWidth = tileWidth;\n    this.tileHeight = tileHeight;\n    this.widthInPixels = this.width * tileWidth;\n    this.heightInPixels = this.height * tileHeight; // Update the base tile size on all layers & tiles\n\n    for (var i = 0; i < this.layers.length; i++) {\n      this.layers[i].baseTileWidth = tileWidth;\n      this.layers[i].baseTileHeight = tileHeight;\n      var mapData = this.layers[i].data;\n      var mapWidth = this.layers[i].width;\n      var mapHeight = this.layers[i].height;\n\n      for (var row = 0; row < mapHeight; row++) {\n        for (var col = 0; col < mapWidth; col++) {\n          var tile = mapData[row][col];\n\n          if (tile !== null) {\n            tile.setSize(undefined, undefined, tileWidth, tileHeight);\n          }\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the tile size for a specific `layer`. Note: this does not necessarily match the map's\r\n   * tileWidth and tileHeight for all layers. This will set the tile size for the layer and any\r\n   * tiles the layer has.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#setLayerTileSize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} tileWidth - The width of the tiles (in pixels) in the layer.\r\n   * @param {integer} tileHeight - The height of the tiles (in pixels) in the layer.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The name of the\r\n   * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a\r\n   * StaticTilemapLayer. If not given will default to the map's current layer index.\r\n   *\r\n   * @return {Phaser.Tilemaps.Tilemap} This Tilemap object.\r\n   */\n  setLayerTileSize: function (tileWidth, tileHeight, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return this;\n    }\n\n    layer.tileWidth = tileWidth;\n    layer.tileHeight = tileHeight;\n    var mapData = layer.data;\n    var mapWidth = layer.width;\n    var mapHeight = layer.height;\n\n    for (var row = 0; row < mapHeight; row++) {\n      for (var col = 0; col < mapWidth; col++) {\n        var tile = mapData[row][col];\n\n        if (tile !== null) {\n          tile.setSize(tileWidth, tileHeight);\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given\r\n   * layer. It will only randomize the tiles in that area, so if they're all the same nothing will\r\n   * appear to have changed! This method only modifies tile indexes and does not change collision\r\n   * information.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   * This cannot be applied to StaticTilemapLayers.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#shuffle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n   * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n   */\n  shuffle: function (tileX, tileY, width, height, layer) {\n    layer = this.getLayer(layer);\n\n    if (this._isStaticCall(layer, 'shuffle')) {\n      return this;\n    }\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.Shuffle(tileX, tileY, width, height, layer);\n    return this;\n  },\n\n  /**\r\n   * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n   * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision\r\n   * information.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   * This cannot be applied to StaticTilemapLayers.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#swapByIndex\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} tileA - First tile index.\r\n   * @param {integer} tileB - Second tile index.\r\n   * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n   * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n   */\n  swapByIndex: function (indexA, indexB, tileX, tileY, width, height, layer) {\n    layer = this.getLayer(layer);\n\n    if (this._isStaticCall(layer, 'swapByIndex')) {\n      return this;\n    }\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, layer);\n    return this;\n  },\n\n  /**\r\n   * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the\r\n   * layers position, scale and scroll.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#tileToWorldX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?number} Returns a number, or null if the layer given was invalid.\r\n   */\n  tileToWorldX: function (tileX, camera, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.TileToWorldX(tileX, camera, layer);\n  },\n\n  /**\r\n   * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n   * layers position, scale and scroll.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#tileToWorldY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer\r\n   * to use. If not given the current layer is used.\r\n   *\r\n   * @return {?number} Returns a number, or null if the layer given was invalid.\r\n   */\n  tileToWorldY: function (tileX, camera, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.TileToWorldY(tileX, camera, layer);\n  },\n\n  /**\r\n   * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n   * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n   * `point` object.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#tileToWorldXY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n   * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n   * @param {Phaser.Math.Vector2} [point] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Math.Vector2} Returns a point, or null if the layer given was invalid.\r\n   */\n  tileToWorldXY: function (tileX, tileY, point, camera, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.TileToWorldXY(tileX, tileY, point, camera, layer);\n  },\n\n  /**\r\n   * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n   * specified layer. Each tile will receive a new index. New indexes are drawn from the given\r\n   * weightedIndexes array. An example weighted array:\r\n   *\r\n   * [\r\n   *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8\r\n   *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8\r\n   *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8\r\n   *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8\r\n   * ]\r\n   *\r\n   * The probability of any index being choose is (the index's weight) / (sum of all weights). This\r\n   * method only modifies tile indexes and does not change collision information.\r\n   *\r\n   * If no layer specified, the map's current layer is used. This\r\n   * cannot be applied to StaticTilemapLayers.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#weightedRandomize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n   * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n   * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n   * @param {object[]} [weightedIndexes] - An array of objects to randomly draw from during\r\n   * randomization. They should be in the form: { index: 0, weight: 4 } or\r\n   * { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n   */\n  weightedRandomize: function (tileX, tileY, width, height, weightedIndexes, layer) {\n    layer = this.getLayer(layer);\n\n    if (this._isStaticCall(layer, 'weightedRandomize')) {\n      return this;\n    }\n\n    if (layer === null) {\n      return null;\n    }\n\n    TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, layer);\n    return this;\n  },\n\n  /**\r\n   * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the\r\n   * layers position, scale and scroll.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#worldToTileX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n   * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the nearest integer.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer\r\n   * to use. If not given the current layer is used.\r\n   *\r\n   * @return {?number} Returns a number, or null if the layer given was invalid.\r\n   */\n  worldToTileX: function (worldX, snapToFloor, camera, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.WorldToTileX(worldX, snapToFloor, camera, layer);\n  },\n\n  /**\r\n   * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the\r\n   * layers position, scale and scroll.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#worldToTileY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n   * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the nearest integer.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?number} Returns a number, or null if the layer given was invalid.\r\n   */\n  worldToTileY: function (worldY, snapToFloor, camera, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.WorldToTileY(worldY, snapToFloor, camera, layer);\n  },\n\n  /**\r\n   * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the\r\n   * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n   * `point` object.\r\n   *\r\n   * If no layer specified, the maps current layer is used.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#worldToTileXY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n   * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n   * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the nearest integer.\r\n   * @param {Phaser.Math.Vector2} [point] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n   * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n   *\r\n   * @return {?Phaser.Math.Vector2} Returns a point, or null if the layer given was invalid.\r\n   */\n  worldToTileXY: function (worldX, worldY, snapToFloor, point, camera, layer) {\n    layer = this.getLayer(layer);\n\n    if (layer === null) {\n      return null;\n    }\n\n    return TilemapComponents.WorldToTileXY(worldX, worldY, snapToFloor, point, camera, layer);\n  },\n\n  /**\r\n   * Used internally to check if a layer is static and prints out a warning.\r\n   *\r\n   * @method Phaser.Tilemaps.Tilemap#_isStaticCall\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean}\r\n   */\n  _isStaticCall: function (layer, functionName) {\n    if (layer.tilemapLayer instanceof StaticTilemapLayer) {\n      console.warn(functionName + ': You cannot change the tiles in a static tilemap layer');\n      return true;\n    } else {\n      return false;\n    }\n  }\n});\nmodule.exports = Tilemap;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/tilemaps/Tilemap.js"],"names":["Class","require","DegToRad","DynamicTilemapLayer","Extend","Formats","LayerData","Rotate","SpliceOne","StaticTilemapLayer","Tile","TilemapComponents","Tileset","Tilemap","initialize","scene","mapData","tileWidth","tileHeight","width","height","orientation","renderOrder","format","version","properties","widthInPixels","heightInPixels","imageCollections","images","layers","tilesets","objects","currentLayerIndex","setRenderOrder","orders","indexOf","addTilesetImage","tilesetName","key","tileMargin","tileSpacing","gid","undefined","sys","textures","exists","console","warn","texture","get","index","getTilesetIndex","TILED_JSON","tileset","setTileSize","setSpacing","setImage","push","convertLayerToStatic","layer","getLayer","dynamicLayer","tilemapLayer","staticLayer","tilemap","layerIndex","x","y","displayList","add","destroy","copy","srcTileX","srcTileY","destTileX","destTileY","recalculateFaces","_isStaticCall","Copy","createBlankDynamicLayer","name","getLayerIndex","layerData","row","tileY","tileX","data","length","createDynamicLayer","layerID","getTileLayerNames","join","createFromObjects","id","spriteConfig","objectLayer","getObjectLayer","getObjectLayerNames","sprites","i","found","obj","config","sprite","make","displayWidth","displayHeight","offset","originX","originY","rotation","angle","flippedHorizontal","flippedVertical","setFlip","visible","hasOwnProperty","setData","createFromTiles","indexes","replacements","camera","CreateFromTiles","createStaticLayer","removeAllLayers","fill","Fill","filterObjects","callback","context","filter","filterTiles","filteringOptions","FilterTiles","findByIndex","findIndex","skip","reverse","FindByIndex","findObject","find","findTile","FindTile","forEachTile","ForEachTile","getImageIndex","getIndex","getImageLayerNames","Array","isArray","map","image","location","object","getLayerIndexByName","getTileAt","nonNull","GetTileAt","getTileAtWorldXY","worldX","worldY","GetTileAtWorldXY","getTilesWithin","GetTilesWithin","getTilesWithinShape","shape","GetTilesWithinShape","getTilesWithinWorldXY","GetTilesWithinWorldXY","getTileset","hasTileAt","HasTileAt","hasTileAtWorldXY","HasTileAtWorldXY","set","setLayer","putTileAt","tile","PutTileAt","putTileAtWorldXY","PutTileAtWorldXY","putTilesAt","tilesArray","PutTilesAt","randomize","Randomize","calculateFacesAt","CalculateFacesAt","calculateFacesWithin","CalculateFacesWithin","removeLayer","destroyLayer","removeTile","tiles","replaceIndex","removed","removeTileAt","replaceWithNull","RemoveTileAt","removeTileAtWorldXY","RemoveTileAtWorldXY","renderDebug","graphics","styleConfig","RenderDebug","renderDebugFull","replaceByIndex","newIndex","ReplaceByIndex","setCollision","collides","updateLayer","SetCollision","setCollisionBetween","start","stop","SetCollisionBetween","setCollisionByProperty","SetCollisionByProperty","setCollisionByExclusion","SetCollisionByExclusion","setCollisionFromCollisionGroup","SetCollisionFromCollisionGroup","setTileIndexCallback","callbackContext","SetTileIndexCallback","setTileLocationCallback","SetTileLocationCallback","setBaseTileSize","baseTileWidth","baseTileHeight","mapWidth","mapHeight","col","setSize","setLayerTileSize","shuffle","Shuffle","swapByIndex","indexA","indexB","SwapByIndex","tileToWorldX","TileToWorldX","tileToWorldY","TileToWorldY","tileToWorldXY","point","TileToWorldXY","weightedRandomize","weightedIndexes","WeightedRandomize","worldToTileX","snapToFloor","WorldToTileX","worldToTileY","WorldToTileY","worldToTileXY","WorldToTileXY","functionName","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar DegToRad = require('../math/DegToRad');\r\nvar DynamicTilemapLayer = require('./dynamiclayer/DynamicTilemapLayer');\r\nvar Extend = require('../utils/object/Extend');\r\nvar Formats = require('./Formats');\r\nvar LayerData = require('./mapdata/LayerData');\r\nvar Rotate = require('../math/Rotate');\r\nvar SpliceOne = require('../utils/array/SpliceOne');\r\nvar StaticTilemapLayer = require('./staticlayer/StaticTilemapLayer');\r\nvar Tile = require('./Tile');\r\nvar TilemapComponents = require('./components');\r\nvar Tileset = require('./Tileset');\r\n\r\n/**\r\n * @callback TilemapFilterCallback\r\n *\r\n * @param {Phaser.GameObjects.GameObject} value - An object found in the filtered area.\r\n * @param {number} index - The index of the object within the array.\r\n * @param {Phaser.GameObjects.GameObject[]} array - An array of all the objects found.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The object.\r\n */\r\n\r\n/**\r\n * @callback TilemapFindCallback\r\n *\r\n * @param {Phaser.GameObjects.GameObject} value - An object found.\r\n * @param {number} index - The index of the object within the array.\r\n * @param {Phaser.GameObjects.GameObject[]} array - An array of all the objects found.\r\n *\r\n * @return {boolean} `true` if the callback should be invoked, otherwise `false`.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A Tilemap is a container for Tilemap data. This isn't a display object, rather, it holds data\r\n * about the map and allows you to add tilesets and tilemap layers to it. A map can have one or\r\n * more tilemap layers (StaticTilemapLayer or DynamicTilemapLayer), which are the display\r\n * objects that actually render tiles.\r\n *\r\n * The Tilemap data be parsed from a Tiled JSON file, a CSV file or a 2D array. Tiled is a free\r\n * software package specifically for creating tile maps, and is available from:\r\n * http://www.mapeditor.org\r\n *\r\n * A Tilemap has handy methods for getting & manipulating the tiles within a layer. You can only\r\n * use the methods that change tiles (e.g. removeTileAt) on a DynamicTilemapLayer.\r\n *\r\n * Note that all Tilemaps use a base tile size to calculate dimensions from, but that a\r\n * StaticTilemapLayer or DynamicTilemapLayer may have its own unique tile size that overrides\r\n * it.\r\n *\r\n * As of Phaser 3.21.0, if your tilemap includes layer groups (a feature of Tiled 1.2.0+) these\r\n * will be traversed and the following properties will affect children:\r\n * - opacity (blended with parent) and visibility (parent overrides child)\r\n * - Vertical and horizontal offset\r\n * The grouping hierarchy is not preserved and all layers will be flattened into a single array.\r\n * Group layers are parsed during Tilemap construction but are discarded after parsing so dynamic\r\n * layers will NOT continue to be affected by a parent.\r\n *\r\n * To avoid duplicate layer names, a layer that is a child of a group layer will have its parent\r\n * group name prepended with a '/'.  For example, consider a group called 'ParentGroup' with a\r\n * child called 'Layer 1'. In the Tilemap object, 'Layer 1' will have the name\r\n * 'ParentGroup/Layer 1'.\r\n *\r\n * @class Tilemap\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Tilemap belongs.\r\n * @param {Phaser.Tilemaps.MapData} mapData - A MapData instance containing Tilemap data.\r\n */\r\nvar Tilemap = new Class({\r\n\r\n    initialize:\r\n\r\n    function Tilemap (scene, mapData)\r\n    {\r\n        /**\r\n         * @name Phaser.Tilemaps.Tilemap#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The base width of a tile in pixels. Note that individual layers may have a different tile\r\n         * width.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#tileWidth\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileWidth = mapData.tileWidth;\r\n\r\n        /**\r\n         * The base height of a tile in pixels. Note that individual layers may have a different\r\n         * tile height.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#tileHeight\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileHeight = mapData.tileHeight;\r\n\r\n        /**\r\n         * The width of the map (in tiles).\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = mapData.width;\r\n\r\n        /**\r\n         * The height of the map (in tiles).\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = mapData.height;\r\n\r\n        /**\r\n         * The orientation of the map data (as specified in Tiled), usually 'orthogonal'.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#orientation\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.orientation = mapData.orientation;\r\n\r\n        /**\r\n         * The render (draw) order of the map data (as specified in Tiled), usually 'right-down'.\r\n         *\r\n         * The draw orders are:\r\n         *\r\n         * right-down\r\n         * left-down\r\n         * right-up\r\n         * left-up\r\n         *\r\n         * This can be changed via the `setRenderOrder` method.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#renderOrder\r\n         * @type {string}\r\n         * @since 3.12.0\r\n         */\r\n        this.renderOrder = mapData.renderOrder;\r\n\r\n        /**\r\n         * The format of the map data.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#format\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.format = mapData.format;\r\n\r\n        /**\r\n         * The version of the map data (as specified in Tiled, usually 1).\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#version\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.version = mapData.version;\r\n\r\n        /**\r\n         * Map specific properties as specified in Tiled.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = mapData.properties;\r\n\r\n        /**\r\n         * The width of the map in pixels based on width * tileWidth.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#widthInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.widthInPixels = mapData.widthInPixels;\r\n\r\n        /**\r\n         * The height of the map in pixels based on height * tileHeight.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#heightInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.heightInPixels = mapData.heightInPixels;\r\n\r\n        /**\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#imageCollections\r\n         * @type {Phaser.Tilemaps.ImageCollection[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.imageCollections = mapData.imageCollections;\r\n\r\n        /**\r\n         * An array of Tiled Image Layers.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#images\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.images = mapData.images;\r\n\r\n        /**\r\n         * An array of Tilemap layer data.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#layers\r\n         * @type {Phaser.Tilemaps.LayerData[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.layers = mapData.layers;\r\n\r\n        /**\r\n         * An array of Tilesets used in the map.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#tilesets\r\n         * @type {Phaser.Tilemaps.Tileset[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.tilesets = mapData.tilesets;\r\n\r\n        /**\r\n         * An array of ObjectLayer instances parsed from Tiled object layers.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#objects\r\n         * @type {Phaser.Tilemaps.ObjectLayer[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.objects = mapData.objects;\r\n\r\n        /**\r\n         * The index of the currently selected LayerData object.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#currentLayerIndex\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.currentLayerIndex = 0;\r\n    },\r\n\r\n    /**\r\n     * Sets the rendering (draw) order of the tiles in this map.\r\n     *\r\n     * The default is 'right-down', meaning it will order the tiles starting from the top-left,\r\n     * drawing to the right and then moving down to the next row.\r\n     *\r\n     * The draw orders are:\r\n     *\r\n     * 0 = right-down\r\n     * 1 = left-down\r\n     * 2 = right-up\r\n     * 3 = left-up\r\n     *\r\n     * Setting the render order does not change the tiles or how they are stored in the layer,\r\n     * it purely impacts the order in which they are rendered.\r\n     *\r\n     * You can provide either an integer (0 to 3), or the string version of the order.\r\n     *\r\n     * Calling this method _after_ creating Static or Dynamic Tilemap Layers will **not** automatically\r\n     * update them to use the new render order. If you call this method after creating layers, use their\r\n     * own `setRenderOrder` methods to change them as needed.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setRenderOrder\r\n     * @since 3.12.0\r\n     *\r\n     * @param {(integer|string)} renderOrder - The render (draw) order value. Either an integer between 0 and 3, or a string: 'right-down', 'left-down', 'right-up' or 'left-up'.\r\n     *\r\n     * @return {this} This Tilemap object.\r\n     */\r\n    setRenderOrder: function (renderOrder)\r\n    {\r\n        var orders = [ 'right-down', 'left-down', 'right-up', 'left-up' ];\r\n\r\n        if (typeof renderOrder === 'number')\r\n        {\r\n            renderOrder = orders[renderOrder];\r\n        }\r\n\r\n        if (orders.indexOf(renderOrder) > -1)\r\n        {\r\n            this.renderOrder = renderOrder;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds an image to the map to be used as a tileset. A single map may use multiple tilesets.\r\n     * Note that the tileset name can be found in the JSON file exported from Tiled, or in the Tiled\r\n     * editor.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#addTilesetImage\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} tilesetName - The name of the tileset as specified in the map data.\r\n     * @param {string} [key] - The key of the Phaser.Cache image used for this tileset. If\r\n     * `undefined` or `null` it will look for an image with a key matching the tilesetName parameter.\r\n     * @param {integer} [tileWidth] - The width of the tile (in pixels) in the Tileset Image. If not\r\n     * given it will default to the map's tileWidth value, or the tileWidth specified in the Tiled\r\n     * JSON file.\r\n     * @param {integer} [tileHeight] - The height of the tiles (in pixels) in the Tileset Image. If\r\n     * not given it will default to the map's tileHeight value, or the tileHeight specified in the\r\n     * Tiled JSON file.\r\n     * @param {integer} [tileMargin] - The margin around the tiles in the sheet (in pixels). If not\r\n     * specified, it will default to 0 or the value specified in the Tiled JSON file.\r\n     * @param {integer} [tileSpacing] - The spacing between each the tile in the sheet (in pixels).\r\n     * If not specified, it will default to 0 or the value specified in the Tiled JSON file.\r\n     * @param {integer} [gid=0] - If adding multiple tilesets to a blank map, specify the starting\r\n     * GID this set will use here.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tileset} Returns the Tileset object that was created or updated, or null if it\r\n     * failed.\r\n     */\r\n    addTilesetImage: function (tilesetName, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid)\r\n    {\r\n        if (tilesetName === undefined) { return null; }\r\n        if (key === undefined || key === null) { key = tilesetName; }\r\n\r\n        if (!this.scene.sys.textures.exists(key))\r\n        {\r\n            console.warn('Invalid Tileset Image: ' + key);\r\n            return null;\r\n        }\r\n\r\n        var texture = this.scene.sys.textures.get(key);\r\n\r\n        var index = this.getTilesetIndex(tilesetName);\r\n\r\n        if (index === null && this.format === Formats.TILED_JSON)\r\n        {\r\n            console.warn('No data found for Tileset: ' + tilesetName);\r\n            return null;\r\n        }\r\n\r\n        var tileset = this.tilesets[index];\r\n\r\n        if (tileset)\r\n        {\r\n            tileset.setTileSize(tileWidth, tileHeight);\r\n            tileset.setSpacing(tileMargin, tileSpacing);\r\n            tileset.setImage(texture);\r\n\r\n            return tileset;\r\n        }\r\n\r\n        if (tileWidth === undefined) { tileWidth = this.tileWidth; }\r\n        if (tileHeight === undefined) { tileHeight = this.tileHeight; }\r\n        if (tileMargin === undefined) { tileMargin = 0; }\r\n        if (tileSpacing === undefined) { tileSpacing = 0; }\r\n        if (gid === undefined) { gid = 0; }\r\n\r\n        tileset = new Tileset(tilesetName, gid, tileWidth, tileHeight, tileMargin, tileSpacing);\r\n\r\n        tileset.setImage(texture);\r\n\r\n        this.tilesets.push(tileset);\r\n\r\n        return tileset;\r\n    },\r\n\r\n    /**\r\n     * Turns the DynamicTilemapLayer associated with the given layer into a StaticTilemapLayer. If\r\n     * no layer specified, the map's current layer is used. This is useful if you want to manipulate\r\n     * a map at the start of a scene, but then make it non-manipulable and optimize it for speed.\r\n     * Note: the DynamicTilemapLayer passed in is destroyed, so make sure to store the value\r\n     * returned from this method if you want to manipulate the new StaticTilemapLayer.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#convertLayerToStatic\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer)} [layer] - The name of the layer from Tiled, the\r\n     * index of the layer in the map, or a DynamicTilemapLayer.\r\n     *\r\n     * @return {?Phaser.Tilemaps.StaticTilemapLayer} Returns the new layer that was created, or null if it\r\n     * failed.\r\n     */\r\n    convertLayerToStatic: function (layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        var dynamicLayer = layer.tilemapLayer;\r\n\r\n        if (!dynamicLayer || !(dynamicLayer instanceof DynamicTilemapLayer))\r\n        {\r\n            return null;\r\n        }\r\n\r\n        var staticLayer = new StaticTilemapLayer(\r\n            dynamicLayer.scene,\r\n            dynamicLayer.tilemap,\r\n            dynamicLayer.layerIndex,\r\n            dynamicLayer.tileset,\r\n            dynamicLayer.x,\r\n            dynamicLayer.y\r\n        );\r\n\r\n        this.scene.sys.displayList.add(staticLayer);\r\n\r\n        dynamicLayer.destroy();\r\n\r\n        return staticLayer;\r\n    },\r\n\r\n    /**\r\n     * Copies the tiles in the source rectangular area to a new destination (all specified in tile\r\n     * coordinates) within the layer. This copies all tile properties & recalculates collision\r\n     * information in the destination region.\r\n     *\r\n     * If no layer specified, the map's current layer is used. This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} srcTileX - The x coordinate of the area to copy from, in tiles, not pixels.\r\n     * @param {integer} srcTileY - The y coordinate of the area to copy from, in tiles, not pixels.\r\n     * @param {integer} width - The width of the area to copy, in tiles, not pixels.\r\n     * @param {integer} height - The height of the area to copy, in tiles, not pixels.\r\n     * @param {integer} destTileX - The x coordinate of the area to copy to, in tiles, not pixels.\r\n     * @param {integer} destTileY - The y coordinate of the area to copy to, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    copy: function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (this._isStaticCall(layer, 'copy')) { return this; }\r\n\r\n        if (layer !== null)\r\n        {\r\n            TilemapComponents.Copy(\r\n                srcTileX, srcTileY,\r\n                width, height,\r\n                destTileX, destTileY,\r\n                recalculateFaces, layer\r\n            );\r\n\r\n            return this;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a new and empty DynamicTilemapLayer. The currently selected layer in the map is set to this new layer.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createBlankDynamicLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of this layer. Must be unique within the map.\r\n     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n     * @param {number} [x=0] - The world x position where the top left of this layer will be placed.\r\n     * @param {number} [y=0] - The world y position where the top left of this layer will be placed.\r\n     * @param {integer} [width] - The width of the layer in tiles. If not specified, it will default to the map's width.\r\n     * @param {integer} [height] - The height of the layer in tiles. If not specified, it will default to the map's height.\r\n     * @param {integer} [tileWidth] - The width of the tiles the layer uses for calculations. If not specified, it will default to the map's tileWidth.\r\n     * @param {integer} [tileHeight] - The height of the tiles the layer uses for calculations. If not specified, it will default to the map's tileHeight.\r\n     *\r\n     * @return {?Phaser.Tilemaps.DynamicTilemapLayer} Returns the new layer that was created, or `null` if it failed.\r\n     */\r\n    createBlankDynamicLayer: function (name, tileset, x, y, width, height, tileWidth, tileHeight)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.width; }\r\n        if (height === undefined) { height = this.height; }\r\n        if (tileWidth === undefined) { tileWidth = this.tileWidth; }\r\n        if (tileHeight === undefined) { tileHeight = this.tileHeight; }\r\n\r\n        var index = this.getLayerIndex(name);\r\n\r\n        if (index !== null)\r\n        {\r\n            console.warn('Invalid Tilemap Layer ID: ' + name);\r\n            return null;\r\n        }\r\n\r\n        var layerData = new LayerData({\r\n            name: name,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: height\r\n        });\r\n\r\n        var row;\r\n\r\n        for (var tileY = 0; tileY < height; tileY++)\r\n        {\r\n            row = [];\r\n\r\n            for (var tileX = 0; tileX < width; tileX++)\r\n            {\r\n                row.push(new Tile(layerData, -1, tileX, tileY, tileWidth, tileHeight, this.tileWidth, this.tileHeight));\r\n            }\r\n\r\n            layerData.data.push(row);\r\n        }\r\n\r\n        this.layers.push(layerData);\r\n\r\n        this.currentLayerIndex = this.layers.length - 1;\r\n\r\n        var dynamicLayer = new DynamicTilemapLayer(this.scene, this, this.currentLayerIndex, tileset, x, y);\r\n\r\n        dynamicLayer.setRenderOrder(this.renderOrder);\r\n\r\n        this.scene.sys.displayList.add(dynamicLayer);\r\n\r\n        return dynamicLayer;\r\n    },\r\n\r\n    /**\r\n     * Creates a new DynamicTilemapLayer that renders the LayerData associated with the given\r\n     * `layerID`. The currently selected layer in the map is set to this new layer.\r\n     *\r\n     * The `layerID` is important. If you've created your map in Tiled then you can get this by\r\n     * looking in Tiled and looking at the layer name. Or you can open the JSON file it exports and\r\n     * look at the layers[].name value. Either way it must match.\r\n     *\r\n     * Unlike a static layer, a dynamic layer can be modified. See DynamicTilemapLayer for more\r\n     * information.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createDynamicLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|string)} layerID - The layer array index value, or if a string is given, the layer name from Tiled.\r\n     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n     * @param {number} [x=0] - The x position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.\r\n     * @param {number} [y=0] - The y position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.\r\n     *\r\n     * @return {?Phaser.Tilemaps.DynamicTilemapLayer} Returns the new layer was created, or null if it failed.\r\n     */\r\n    createDynamicLayer: function (layerID, tileset, x, y)\r\n    {\r\n        var index = this.getLayerIndex(layerID);\r\n\r\n        if (index === null)\r\n        {\r\n            console.warn('Invalid Tilemap Layer ID: ' + layerID);\r\n\r\n            if (typeof layerID === 'string')\r\n            {\r\n                console.warn('Valid tilelayer names:\\n\\t' + this.getTileLayerNames().join(',\\n\\t'));\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        var layerData = this.layers[index];\r\n\r\n        // Check for an associated static or dynamic tilemap layer\r\n        if (layerData.tilemapLayer)\r\n        {\r\n            console.warn('Tilemap Layer ID already exists:' + layerID);\r\n            return null;\r\n        }\r\n\r\n        this.currentLayerIndex = index;\r\n\r\n        //  Default the x/y position to match Tiled layer offset, if it exists.\r\n\r\n        if (x === undefined)\r\n        {\r\n            x = layerData.x;\r\n        }\r\n\r\n        if (y === undefined)\r\n        {\r\n            y = layerData.y;\r\n        }\r\n\r\n        var layer = new DynamicTilemapLayer(this.scene, this, index, tileset, x, y);\r\n\r\n        layer.setRenderOrder(this.renderOrder);\r\n\r\n        this.scene.sys.displayList.add(layer);\r\n\r\n        return layer;\r\n    },\r\n\r\n    /**\r\n     * Creates a Sprite for every object matching the given gid in the map data. All properties from\r\n     * the map data objectgroup are copied into the `spriteConfig`, so you can use this as an easy\r\n     * way to configure Sprite properties from within the map editor. For example giving an object a\r\n     * property of alpha: 0.5 in the map editor will duplicate that when the Sprite is created.\r\n     *\r\n     * Custom object properties not sharing names with the Sprite's own properties are copied to the\r\n     * Sprite's {@link Phaser.GameObjects.Sprite#data data store}.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createFromObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the object layer (from Tiled) to create Sprites from.\r\n     * @param {(integer|string)} id - Either the id (object), gid (tile object) or name (object or\r\n     * tile object) from Tiled. Ids are unique in Tiled, but a gid is shared by all tile objects\r\n     * with the same graphic. The same name can be used on multiple objects.\r\n     * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e.\r\n     * scene.make.sprite).\r\n     * @param {Phaser.Scene} [scene=the scene the map is within] - The Scene to create the Sprites within.\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.\r\n     */\r\n    createFromObjects: function (name, id, spriteConfig, scene)\r\n    {\r\n        if (spriteConfig === undefined) { spriteConfig = {}; }\r\n        if (scene === undefined) { scene = this.scene; }\r\n\r\n        var objectLayer = this.getObjectLayer(name);\r\n\r\n        if (!objectLayer)\r\n        {\r\n            console.warn('Cannot create from object. Invalid objectgroup name given: ' + name);\r\n\r\n            if (typeof layerID === 'string')\r\n            {\r\n                console.warn('Valid objectgroup names:\\n\\t' + this.getObjectLayerNames().join(',\\n\\t'));\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        var objects = objectLayer.objects;\r\n        var sprites = [];\r\n\r\n        for (var i = 0; i < objects.length; i++)\r\n        {\r\n            var found = false;\r\n            var obj = objects[i];\r\n\r\n            if (obj.gid !== undefined && typeof id === 'number' && obj.gid === id ||\r\n                obj.id !== undefined && typeof id === 'number' && obj.id === id ||\r\n                obj.name !== undefined && typeof id === 'string' && obj.name === id)\r\n            {\r\n                found = true;\r\n            }\r\n\r\n            if (found)\r\n            {\r\n                var config = Extend({}, spriteConfig, obj.properties);\r\n\r\n                config.x = obj.x;\r\n                config.y = obj.y;\r\n\r\n                var sprite = scene.make.sprite(config);\r\n\r\n                sprite.name = obj.name;\r\n\r\n                if (obj.width) { sprite.displayWidth = obj.width; }\r\n                if (obj.height) { sprite.displayHeight = obj.height; }\r\n\r\n                // Origin is (0, 1) in Tiled, so find the offset that matches the Sprite's origin.\r\n                var offset = {\r\n                    x: sprite.originX * sprite.displayWidth,\r\n                    y: (sprite.originY - 1) * sprite.displayHeight\r\n                };\r\n\r\n                // If the object is rotated, then the origin offset also needs to be rotated.\r\n                if (obj.rotation)\r\n                {\r\n                    var angle = DegToRad(obj.rotation);\r\n                    Rotate(offset, angle);\r\n                    sprite.rotation = angle;\r\n                }\r\n\r\n                sprite.x += offset.x;\r\n                sprite.y += offset.y;\r\n\r\n                if (obj.flippedHorizontal !== undefined || obj.flippedVertical !== undefined)\r\n                {\r\n                    sprite.setFlip(obj.flippedHorizontal, obj.flippedVertical);\r\n                }\r\n\r\n                if (!obj.visible) { sprite.visible = false; }\r\n\r\n                for (var key in obj.properties)\r\n                {\r\n                    if (sprite.hasOwnProperty(key))\r\n                    {\r\n                        continue;\r\n                    }\r\n\r\n                    sprite.setData(key, obj.properties[key]);\r\n                }\r\n\r\n                sprites.push(sprite);\r\n            }\r\n        }\r\n\r\n        return sprites;\r\n    },\r\n\r\n    /**\r\n     * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n     * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n     * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n     * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createFromTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|array)} indexes - The tile index, or array of indexes, to create Sprites from.\r\n     * @param {(integer|array)} replacements - The tile index, or array of indexes, to change a converted\r\n     * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a\r\n     * one-to-one mapping with the indexes array.\r\n     * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e. scene.make.sprite).\r\n     * @param {Phaser.Scene} [scene=scene the map is within] - The Scene to create the Sprites within.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.GameObjects.Sprite[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    createFromTiles: function (indexes, replacements, spriteConfig, scene, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Creates a new StaticTilemapLayer that renders the LayerData associated with the given\r\n     * `layerID`. The currently selected layer in the map is set to this new layer.\r\n     *\r\n     * The `layerID` is important. If you've created your map in Tiled then you can get this by\r\n     * looking in Tiled and looking at the layer name. Or you can open the JSON file it exports and\r\n     * look at the layers[].name value. Either way it must match.\r\n     *\r\n     * It's important to remember that a static layer cannot be modified. See StaticTilemapLayer for\r\n     * more information.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createStaticLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|string)} layerID - The layer array index value, or if a string is given, the layer name from Tiled.\r\n     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n     * @param {number} [x=0] - The x position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.\r\n     * @param {number} [y=0] - The y position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.\r\n     *\r\n     * @return {?Phaser.Tilemaps.StaticTilemapLayer} Returns the new layer was created, or null if it failed.\r\n     */\r\n    createStaticLayer: function (layerID, tileset, x, y)\r\n    {\r\n        var index = this.getLayerIndex(layerID);\r\n\r\n        if (index === null)\r\n        {\r\n            console.warn('Invalid Tilemap Layer ID: ' + layerID);\r\n            if (typeof layerID === 'string')\r\n            {\r\n                console.warn('Valid tilelayer names:\\n\\t' + this.getTileLayerNames().join(',\\n\\t'));\r\n            }\r\n            return null;\r\n        }\r\n\r\n        var layerData = this.layers[index];\r\n\r\n        //  Check for an associated static or dynamic tilemap layer\r\n        if (layerData.tilemapLayer)\r\n        {\r\n            console.warn('Tilemap Layer ID already exists:' + layerID);\r\n            return null;\r\n        }\r\n\r\n        this.currentLayerIndex = index;\r\n\r\n        //  Default the x/y position to match Tiled layer offset, if it exists.\r\n        if (x === undefined && this.layers[index].x) { x = this.layers[index].x; }\r\n        if (y === undefined && this.layers[index].y) { y = this.layers[index].y; }\r\n\r\n        var layer = new StaticTilemapLayer(this.scene, this, index, tileset, x, y);\r\n\r\n        layer.setRenderOrder(this.renderOrder);\r\n\r\n        this.scene.sys.displayList.add(layer);\r\n\r\n        return layer;\r\n    },\r\n\r\n    /**\r\n     * Removes all layer data from this Tilemap and nulls the scene reference. This will destroy any\r\n     * StaticTilemapLayers or DynamicTilemapLayers that have been linked to LayerData.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAllLayers();\r\n        this.tilesets.length = 0;\r\n        this.objects.length = 0;\r\n        this.scene = undefined;\r\n    },\r\n\r\n    /**\r\n     * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the\r\n     * specified index. Tiles will be set to collide if the given index is a colliding index.\r\n     * Collision information in the region will be recalculated.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#fill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The tile index to fill the area with.\r\n     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    fill: function (index, tileX, tileY, width, height, recalculateFaces, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        if (this._isStaticCall(layer, 'fill')) { return this; }\r\n\r\n        TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * For each object in the given object layer, run the given filter callback function. Any\r\n     * objects that pass the filter test (i.e. where the callback returns true) will returned as a\r\n     * new array. Similar to Array.prototype.Filter in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#filterObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.ObjectLayer|string)} objectLayer - The name of an object layer (from Tiled) or an ObjectLayer instance.\r\n     * @param {TilemapFilterCallback} callback - The callback. Each object in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject[]} An array of object that match the search, or null if the objectLayer given was invalid.\r\n     */\r\n    filterObjects: function (objectLayer, callback, context)\r\n    {\r\n        if (typeof objectLayer === 'string')\r\n        {\r\n            var name = objectLayer;\r\n\r\n            objectLayer = this.getObjectLayer(objectLayer);\r\n\r\n            if (!objectLayer)\r\n            {\r\n                console.warn('No object layer found with the name: ' + name);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return objectLayer.objects.filter(callback, context);\r\n    },\r\n\r\n    /**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns\r\n     * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#filterTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n     * callback as the first and only parameter. The callback should return true for tiles that pass the\r\n     * filter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    filterTiles: function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, layer);\r\n    },\r\n\r\n    /**\r\n     * Searches the entire map layer for the first tile matching the given index, then returns that Tile\r\n     * object. If no match is found, it returns null. The search starts from the top-left tile and\r\n     * continues horizontally until it hits the end of the row, then it drops down to the next column.\r\n     * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to\r\n     * the top-left.\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#findByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The tile index value to search for.\r\n     * @param {integer} [skip=0] - The number of times to skip a matching tile before returning.\r\n     * @param {boolean} [reverse=false] - If true it will scan the layer in reverse, starting at the bottom-right. Otherwise it scans from the top-left.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tiles, or null if the layer given was invalid.\r\n     */\r\n    findByIndex: function (findIndex, skip, reverse, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.FindByIndex(findIndex, skip, reverse, layer);\r\n    },\r\n\r\n    /**\r\n     * Find the first object in the given object layer that satisfies the provided testing function.\r\n     * I.e. finds the first object for which `callback` returns true. Similar to\r\n     * Array.prototype.find in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#findObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.ObjectLayer|string)} objectLayer - The name of an object layer (from Tiled) or an ObjectLayer instance.\r\n     * @param {TilemapFindCallback} callback - The callback. Each object in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} An object that matches the search, or null if no object found.\r\n     */\r\n    findObject: function (objectLayer, callback, context)\r\n    {\r\n        if (typeof objectLayer === 'string')\r\n        {\r\n            var name = objectLayer;\r\n\r\n            objectLayer = this.getObjectLayer(objectLayer);\r\n\r\n            if (!objectLayer)\r\n            {\r\n                console.warn('No object layer found with the name: ' + name);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return objectLayer.objects.find(callback, context) || null;\r\n    },\r\n\r\n    /**\r\n     * Find the first tile in the given rectangular area (in tile coordinates) of the layer that\r\n     * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns\r\n     * true. Similar to Array.prototype.find in vanilla JS.\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#findTile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {FindTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The Tile layer to run the search on. If not provided will use the current layer.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tiles, or null if the layer given was invalid.\r\n     */\r\n    findTile: function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);\r\n    },\r\n\r\n    /**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * callback. Similar to Array.prototype.forEach in vanilla JS.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#forEachTile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {EachTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The Tile layer to run the search on. If not provided will use the current layer.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    forEachTile: function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the image layer index based on its name.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getImageIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the image to get.\r\n     *\r\n     * @return {integer} The index of the image in this tilemap, or null if not found.\r\n     */\r\n    getImageIndex: function (name)\r\n    {\r\n        return this.getIndex(this.images, name);\r\n    },\r\n\r\n    /**\r\n     * Return a list of all valid imagelayer names loaded in this Tilemap.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getImageLayerNames\r\n     * @since 3.21.0\r\n     *\r\n     * @return {string[]} Array of valid imagelayer names / IDs loaded into this Tilemap.\r\n     */\r\n    getImageLayerNames: function ()\r\n    {\r\n        if (!this.images || !Array.isArray(this.images))\r\n        {\r\n            return [];\r\n        }\r\n\r\n        return this.images.map(function (image)\r\n        {\r\n            return image.name;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Internally used. Returns the index of the object in one of the Tilemaps arrays whose name\r\n     * property matches the given `name`.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} location - The Tilemap array to search.\r\n     * @param {string} name - The name of the array element to get.\r\n     *\r\n     * @return {number} The index of the element in the array, or null if not found.\r\n     */\r\n    getIndex: function (location, name)\r\n    {\r\n        for (var i = 0; i < location.length; i++)\r\n        {\r\n            if (location[i].name === name)\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Gets the LayerData from this.layers that is associated with `layer`, or null if an invalid\r\n     * `layer` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The name of the\r\n     * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a\r\n     * StaticTilemapLayer. If not given will default to the maps current layer index.\r\n     *\r\n     * @return {Phaser.Tilemaps.LayerData} The corresponding LayerData within this.layers.\r\n     */\r\n    getLayer: function (layer)\r\n    {\r\n        var index = this.getLayerIndex(layer);\r\n\r\n        return (index !== null) ? this.layers[index] : null;\r\n    },\r\n\r\n    /**\r\n     * Gets the ObjectLayer from this.objects that has the given `name`, or null if no ObjectLayer\r\n     * is found with that name.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getObjectLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [name] - The name of the object layer from Tiled.\r\n     *\r\n     * @return {?Phaser.Tilemaps.ObjectLayer} The corresponding ObjectLayer within this.objects or null.\r\n     */\r\n    getObjectLayer: function (name)\r\n    {\r\n        var index = this.getIndex(this.objects, name);\r\n\r\n        return (index !== null) ? this.objects[index] : null;\r\n    },\r\n\r\n    /**\r\n     * Return a list of all valid objectgroup names loaded in this Tilemap.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getObjectLayerNames\r\n     * @since 3.21.0\r\n     *\r\n     * @return {string[]} Array of valid objectgroup names / IDs loaded into this Tilemap.\r\n     */\r\n    getObjectLayerNames: function ()\r\n    {\r\n        if (!this.objects || !Array.isArray(this.objects))\r\n        {\r\n            return [];\r\n        }\r\n\r\n        return this.objects.map(function (object)\r\n        {\r\n            return object.name;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Gets the LayerData index of the given `layer` within this.layers, or null if an invalid\r\n     * `layer` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getLayerIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The name of the\r\n     * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a\r\n     * StaticTilemapLayer. If not given will default to the map's current layer index.\r\n     *\r\n     * @return {integer} The LayerData index within this.layers.\r\n     */\r\n    getLayerIndex: function (layer)\r\n    {\r\n        if (layer === undefined)\r\n        {\r\n            return this.currentLayerIndex;\r\n        }\r\n        else if (typeof layer === 'string')\r\n        {\r\n            return this.getLayerIndexByName(layer);\r\n        }\r\n        else if (typeof layer === 'number' && layer < this.layers.length)\r\n        {\r\n            return layer;\r\n        }\r\n        else if (layer instanceof StaticTilemapLayer || layer instanceof DynamicTilemapLayer)\r\n        {\r\n            return layer.layerIndex;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Gets the index of the LayerData within this.layers that has the given `name`, or null if an\r\n     * invalid `name` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getLayerIndexByName\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the layer to get.\r\n     *\r\n     * @return {integer} The LayerData index within this.layers.\r\n     */\r\n    getLayerIndexByName: function (name)\r\n    {\r\n        return this.getIndex(this.layers, name);\r\n    },\r\n\r\n    /**\r\n     * Gets a tile at the given tile coordinates from the given layer.\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - X position to get the tile from (given in tile units, not pixels).\r\n     * @param {integer} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n     * @param {boolean} [nonNull=false] - If true getTile won't return null for empty tiles, but a Tile object with an index of -1.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */\r\n    getTileAt: function (tileX, tileY, nonNull, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTileAt(tileX, tileY, nonNull, layer);\r\n    },\r\n\r\n    /**\r\n     * Gets a tile at the given world coordinates from the given layer.\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - X position to get the tile from (given in pixels)\r\n     * @param {number} worldY - Y position to get the tile from (given in pixels)\r\n     * @param {boolean} [nonNull=false] - If true, function won't return null for empty tiles, but a Tile object with an index of -1.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */\r\n    getTileAtWorldXY: function (worldX, worldY, nonNull, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Return a list of all valid tilelayer names loaded in this Tilemap.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileLayerNames\r\n     * @since 3.21.0\r\n     *\r\n     * @return {string[]} Array of valid tilelayer names / IDs loaded into this Tilemap.\r\n     */\r\n    getTileLayerNames: function ()\r\n    {\r\n        if (!this.layers || !Array.isArray(this.layers))\r\n        {\r\n            return [];\r\n        }\r\n\r\n        return this.layers.map(function (layer)\r\n        {\r\n            return layer.name;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesWithin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    getTilesWithin: function (tileX, tileY, width, height, filteringOptions, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,\r\n     * Line, Rectangle or Triangle. The shape should be in world coordinates.\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesWithinShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when factoring in which tiles to return.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    getTilesWithinShape: function (shape, filteringOptions, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles in the given rectangular area (in world coordinates) of the layer.\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesWithinWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The world x coordinate for the top-left of the area.\r\n     * @param {number} worldY - The world y coordinate for the top-left of the area.\r\n     * @param {number} width - The width of the area.\r\n     * @param {number} height - The height of the area.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when factoring in which tiles to return.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    getTilesWithinWorldXY: function (worldX, worldY, width, height, filteringOptions, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the Tileset that has the given `name`, or null if an invalid `name` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileset\r\n     * @since 3.14.0\r\n     *\r\n     * @param {string} name - The name of the Tileset to get.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tileset} The Tileset, or `null` if no matching named tileset was found.\r\n     */\r\n    getTileset: function (name)\r\n    {\r\n        var index = this.getIndex(this.tilesets, name);\r\n\r\n        return (index !== null) ? this.tilesets[index] : null;\r\n    },\r\n\r\n    /**\r\n     * Gets the index of the Tileset within this.tilesets that has the given `name`, or null if an\r\n     * invalid `name` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesetIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the Tileset to get.\r\n     *\r\n     * @return {integer} The Tileset index within this.tilesets.\r\n     */\r\n    getTilesetIndex: function (name)\r\n    {\r\n        return this.getIndex(this.tilesets, name);\r\n    },\r\n\r\n    /**\r\n     * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#hasTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n     */\r\n    hasTileAt: function (tileX, tileY, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.HasTileAt(tileX, tileY, layer);\r\n    },\r\n\r\n    /**\r\n     * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#hasTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when factoring in which tiles to return.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n     */\r\n    hasTileAtWorldXY: function (worldX, worldY, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * The LayerData object that is currently selected in the map. You can set this property using\r\n     * any type supported by setLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#layer\r\n     * @type {Phaser.Tilemaps.LayerData}\r\n     * @since 3.0.0\r\n     */\r\n    layer: {\r\n        get: function ()\r\n        {\r\n            return this.layers[this.currentLayerIndex];\r\n        },\r\n\r\n        set: function (layer)\r\n        {\r\n            this.setLayer(layer);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n     * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n     * location. If you pass in an index, only the index at the specified location will be changed.\r\n     * Collision information will be recalculated at the specified location.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#putTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid or the coordinates were out of bounds.\r\n     */\r\n    putTileAt: function (tile, tileX, tileY, recalculateFaces, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (this._isStaticCall(layer, 'putTileAt')) { return null; }\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, layer);\r\n    },\r\n\r\n    /**\r\n     * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either\r\n     * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the\r\n     * specified location. If you pass in an index, only the index at the specified location will be\r\n     * changed. Collision information will be recalculated at the specified location.\r\n     *\r\n     * If no layer specified, the maps current layer is used. This\r\n     * cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#putTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */\r\n    putTileAtWorldXY: function (tile, worldX, worldY, recalculateFaces, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (this._isStaticCall(layer, 'putTileAtWorldXY')) { return null; }\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified\r\n     * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,\r\n     * all attributes will be copied over to the specified location. If you pass in an index, only the\r\n     * index at the specified location will be changed. Collision information will be recalculated\r\n     * within the region tiles were changed.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#putTilesAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer[]|integer[][]|Phaser.Tilemaps.Tile[]|Phaser.Tilemaps.Tile[][])} tile - A row (array) or grid (2D array) of Tiles or tile indexes to place.\r\n     * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    putTilesAt: function (tilesArray, tileX, tileY, recalculateFaces, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (this._isStaticCall(layer, 'putTilesAt')) { return this; }\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then\r\n     * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n     * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n     * indexes. This method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#randomize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {integer[]} [indexes] - An array of indexes to randomly draw from during randomization.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    randomize: function (tileX, tileY, width, height, indexes, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (this._isStaticCall(layer, 'randomize')) { return this; }\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.Randomize(tileX, tileY, width, height, indexes, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting\r\n     * faces are used internally for optimizing collisions against tiles. This method is mostly used\r\n     * internally to optimize recalculating faces when only one tile has been changed.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#calculateFacesAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    calculateFacesAt: function (tileX, tileY, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.CalculateFacesAt(tileX, tileY, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the\r\n     * layer. Interesting faces are used internally for optimizing collisions against tiles. This method\r\n     * is mostly used internally.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#calculateFacesWithin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    calculateFacesWithin: function (tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the given TilemapLayer from this Tilemap without destroying it.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeLayer\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to be removed.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    removeLayer: function (layer)\r\n    {\r\n        var index = this.getLayerIndex(layer);\r\n\r\n        if (index !== null)\r\n        {\r\n            SpliceOne(this.layers, index);\r\n            for (var i = index; i < this.layers.length; i++)\r\n            {\r\n                if (this.layers[i].tilemapLayer)\r\n                {\r\n                    this.layers[i].tilemapLayer.layerIndex--;\r\n                }\r\n            }\r\n\r\n            if (this.currentLayerIndex === index)\r\n            {\r\n                this.currentLayerIndex = 0;\r\n            }\r\n\r\n            return this;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys the given TilemapLayer and removes it from this Tilemap.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#destroyLayer\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to be destroyed.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    destroyLayer: function (layer)\r\n    {\r\n        var index = this.getLayerIndex(layer);\r\n\r\n        if (index !== null)\r\n        {\r\n            layer = this.layers[index];\r\n\r\n            layer.destroy();\r\n\r\n            SpliceOne(this.layers, index);\r\n\r\n            if (this.currentLayerIndex === index)\r\n            {\r\n                this.currentLayerIndex = 0;\r\n            }\r\n\r\n            return this;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Removes all layers from this Tilemap and destroys any associated StaticTilemapLayers or\r\n     * DynamicTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeAllLayers\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tilemaps.Tilemap} This Tilemap object.\r\n     */\r\n    removeAllLayers: function ()\r\n    {\r\n        var layers = this.layers;\r\n\r\n        // Destroy any StaticTilemapLayers or DynamicTilemapLayers that are stored in LayerData\r\n        for (var i = 0; i < layers.length; i++)\r\n        {\r\n            if (layers[i].tilemapLayer)\r\n            {\r\n                layers[i].tilemapLayer.destroy(false);\r\n            }\r\n        }\r\n\r\n        layers.length = 0;\r\n\r\n        this.currentLayerIndex = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the given Tile, or an array of Tiles, from the layer to which they belong,\r\n     * and optionally recalculates the collision information.\r\n     *\r\n     * This cannot be applied to Tiles that belong to Static Tilemap Layers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeTile\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.Tile|Phaser.Tilemaps.Tile[])} tiles - The Tile to remove, or an array of Tiles.\r\n     * @param {integer} [replaceIndex=-1] - After removing the Tile, insert a brand new Tile into its location with the given index. Leave as -1 to just remove the tile.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} Returns an array of Tiles that were removed.\r\n     */\r\n    removeTile: function (tiles, replaceIndex, recalculateFaces)\r\n    {\r\n        if (replaceIndex === undefined) { replaceIndex = -1; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        var removed = [];\r\n\r\n        if (!Array.isArray(tiles))\r\n        {\r\n            tiles = [ tiles ];\r\n        }\r\n\r\n        for (var i = 0; i < tiles.length; i++)\r\n        {\r\n            var tile = tiles[i];\r\n\r\n            removed.push(this.removeTileAt(tile.x, tile.y, true, recalculateFaces, tile.tilemapLayer));\r\n\r\n            if (replaceIndex > -1)\r\n            {\r\n                this.putTileAt(replaceIndex, tile.x, tile.y, recalculateFaces, tile.tilemapLayer);\r\n            }\r\n        }\r\n\r\n        return removed;\r\n    },\r\n\r\n    /**\r\n     * Removes the tile at the given tile coordinates in the specified layer and updates the layer's\r\n     * collision information.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns the Tile that was removed, or null if the layer given was invalid.\r\n     */\r\n    removeTileAt: function (tileX, tileY, replaceWithNull, recalculateFaces, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (this._isStaticCall(layer, 'removeTileAt')) { return null; }\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, layer);\r\n    },\r\n\r\n    /**\r\n     * Removes the tile at the given world coordinates in the specified layer and updates the layer's\r\n     * collision information.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */\r\n    removeTileAtWorldXY: function (worldX, worldY, replaceWithNull, recalculateFaces, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (this._isStaticCall(layer, 'removeTileAtWorldXY')) { return null; }\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to\r\n     * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles\r\n     * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation\r\n     * wherever you want on the screen.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#renderDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n     * @param {Phaser.Types.Tilemaps.StyleConfig} styleConfig - An object specifying the colors to use for the debug drawing.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    renderDebug: function (graphics, styleConfig, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.RenderDebug(graphics, styleConfig, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws a debug representation of all layers within this Tilemap to the given Graphics object.\r\n     *\r\n     * This is helpful when you want to get a quick idea of which of your tiles are colliding and which\r\n     * have interesting faces. The tiles are drawn starting at (0, 0) in the Graphics, allowing you to\r\n     * place the debug representation wherever you want on the screen.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#renderDebugFull\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n     * @param {Phaser.Types.Tilemaps.StyleConfig} styleConfig - An object specifying the colors to use for the debug drawing.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    renderDebugFull: function (graphics, styleConfig)\r\n    {\r\n        var layers = this.layers;\r\n\r\n        // Destroy any StaticTilemapLayers or DynamicTilemapLayers that are stored in LayerData\r\n        for (var i = 0; i < layers.length; i++)\r\n        {\r\n            TilemapComponents.RenderDebug(graphics, styleConfig, layers[i]);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does\r\n     * not change collision information.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#replaceByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} findIndex - The index of the tile to search for.\r\n     * @param {integer} newIndex - The index of the tile to replace it with.\r\n     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    replaceByIndex: function (findIndex, newIndex, tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (this._isStaticCall(layer, 'replaceByIndex')) { return this; }\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the given tile or tiles within a layer by index. You can pass in either a\r\n     * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if\r\n     * collision will be enabled (true) or disabled (false).\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to false if no tiles have been placed for significant performance boost.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollision: function (indexes, collides, recalculateFaces, layer, updateLayer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollision(indexes, collides, recalculateFaces, layer, updateLayer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on a range of tiles in a layer whose index is between the specified `start` and\r\n     * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set\r\n     * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be\r\n     * enabled (true) or disabled (false).\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionBetween\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} start - The first index of the tile to be set for collision.\r\n     * @param {integer} stop - The last index of the tile to be set for collision.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollisionBetween: function (start, stop, collides, recalculateFaces, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property\r\n     * that matches the given properties object, its collision flag will be set. The `collides`\r\n     * parameter controls if collision will be enabled (true) or disabled (false). Passing in\r\n     * `{ collides: true }` would update the collision flag on any tiles with a \"collides\" property that\r\n     * has a value of true. Any tile that doesn't have \"collides\" set to true will be ignored. You can\r\n     * also use an array of values, e.g. `{ types: [\"stone\", \"lava\", \"sand\" ] }`. If a tile has a\r\n     * \"types\" property that matches any of those values, its collision flag will be updated.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionByProperty\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} properties - An object with tile properties and corresponding values that should be checked.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollisionByProperty: function (properties, collides, recalculateFaces, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on all tiles in the given layer, except for tiles that have an index specified in\r\n     * the given array. The `collides` parameter controls if collision will be enabled (true) or\r\n     * disabled (false).\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionByExclusion\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer[]} indexes - An array of the tile indexes to not be counted for collision.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollisionByExclusion: function (indexes, collides, recalculateFaces, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the tiles within a layer by checking each tile's collision group data\r\n     * (typically defined in Tiled within the tileset collision editor). If any objects are found within\r\n     * a tile's collision group, the tile's colliding information will be set. The `collides` parameter\r\n     * controls if collision will be enabled (true) or disabled (false).\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionFromCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollisionFromCollisionGroup: function (collides, recalculateFaces, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a global collision callback for the given tile index within the layer. This will affect all\r\n     * tiles on this layer that have the same index. If a callback is already set for the tile index it\r\n     * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile\r\n     * at a specific location on the map then see setTileLocationCallback.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setTileIndexCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(integer|array)} indexes - Either a single tile index, or an array of tile indexes to have a collision callback set for.\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} callbackContext - The context under which the callback is called.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setTileIndexCallback: function (indexes, callback, callbackContext, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.\r\n     * If a callback is already set for the tile index it will be replaced. Set the callback to null to\r\n     * remove it.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setTileLocationCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} width - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {integer} height - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} [callbackContext] - The context under which the callback is called.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setTileLocationCallback: function (tileX, tileY, width, height, callback, callbackContext, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current layer to the LayerData associated with `layer`.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The name of the\r\n     * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a\r\n     * StaticTilemapLayer. If not given will default to the map's current layer index.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tilemap} This Tilemap object.\r\n     */\r\n    setLayer: function (layer)\r\n    {\r\n        var index = this.getLayerIndex(layer);\r\n\r\n        if (index !== null)\r\n        {\r\n            this.currentLayerIndex = index;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the base tile size for the map. Note: this does not necessarily match the tileWidth and\r\n     * tileHeight for all layers. This also updates the base size on all tiles across all layers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setBaseTileSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileWidth - The width of the tiles the map uses for calculations.\r\n     * @param {integer} tileHeight - The height of the tiles the map uses for calculations.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tilemap} This Tilemap object.\r\n     */\r\n    setBaseTileSize: function (tileWidth, tileHeight)\r\n    {\r\n        this.tileWidth = tileWidth;\r\n        this.tileHeight = tileHeight;\r\n        this.widthInPixels = this.width * tileWidth;\r\n        this.heightInPixels = this.height * tileHeight;\r\n\r\n        // Update the base tile size on all layers & tiles\r\n        for (var i = 0; i < this.layers.length; i++)\r\n        {\r\n            this.layers[i].baseTileWidth = tileWidth;\r\n            this.layers[i].baseTileHeight = tileHeight;\r\n\r\n            var mapData = this.layers[i].data;\r\n            var mapWidth = this.layers[i].width;\r\n            var mapHeight = this.layers[i].height;\r\n\r\n            for (var row = 0; row < mapHeight; row++)\r\n            {\r\n                for (var col = 0; col < mapWidth; col++)\r\n                {\r\n                    var tile = mapData[row][col];\r\n\r\n                    if (tile !== null)\r\n                    {\r\n                        tile.setSize(undefined, undefined, tileWidth, tileHeight);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tile size for a specific `layer`. Note: this does not necessarily match the map's\r\n     * tileWidth and tileHeight for all layers. This will set the tile size for the layer and any\r\n     * tiles the layer has.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setLayerTileSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileWidth - The width of the tiles (in pixels) in the layer.\r\n     * @param {integer} tileHeight - The height of the tiles (in pixels) in the layer.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The name of the\r\n     * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a\r\n     * StaticTilemapLayer. If not given will default to the map's current layer index.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tilemap} This Tilemap object.\r\n     */\r\n    setLayerTileSize: function (tileWidth, tileHeight, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return this; }\r\n\r\n        layer.tileWidth = tileWidth;\r\n        layer.tileHeight = tileHeight;\r\n\r\n        var mapData = layer.data;\r\n        var mapWidth = layer.width;\r\n        var mapHeight = layer.height;\r\n\r\n        for (var row = 0; row < mapHeight; row++)\r\n        {\r\n            for (var col = 0; col < mapWidth; col++)\r\n            {\r\n                var tile = mapData[row][col];\r\n\r\n                if (tile !== null)\r\n                {\r\n                    tile.setSize(tileWidth, tileHeight);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given\r\n     * layer. It will only randomize the tiles in that area, so if they're all the same nothing will\r\n     * appear to have changed! This method only modifies tile indexes and does not change collision\r\n     * information.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#shuffle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    shuffle: function (tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (this._isStaticCall(layer, 'shuffle')) { return this; }\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.Shuffle(tileX, tileY, width, height, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision\r\n     * information.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#swapByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileA - First tile index.\r\n     * @param {integer} tileB - Second tile index.\r\n     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    swapByIndex: function (indexA, indexB, tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (this._isStaticCall(layer, 'swapByIndex')) { return this; }\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#tileToWorldX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */\r\n    tileToWorldX: function (tileX, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.TileToWorldX(tileX, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#tileToWorldY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer\r\n     * to use. If not given the current layer is used.\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */\r\n    tileToWorldY: function (tileX, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.TileToWorldY(tileX, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#tileToWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Math.Vector2} [point] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Math.Vector2} Returns a point, or null if the layer given was invalid.\r\n     */\r\n    tileToWorldXY: function (tileX, tileY, point, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.TileToWorldXY(tileX, tileY, point, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will receive a new index. New indexes are drawn from the given\r\n     * weightedIndexes array. An example weighted array:\r\n     *\r\n     * [\r\n     *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8\r\n     *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8\r\n     *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8\r\n     *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8\r\n     * ]\r\n     *\r\n     * The probability of any index being choose is (the index's weight) / (sum of all weights). This\r\n     * method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * If no layer specified, the map's current layer is used. This\r\n     * cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#weightedRandomize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {object[]} [weightedIndexes] - An array of objects to randomly draw from during\r\n     * randomization. They should be in the form: { index: 0, weight: 4 } or\r\n     * { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    weightedRandomize: function (tileX, tileY, width, height, weightedIndexes, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (this._isStaticCall(layer, 'weightedRandomize')) { return this; }\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#worldToTileX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer\r\n     * to use. If not given the current layer is used.\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */\r\n    worldToTileX: function (worldX, snapToFloor, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.WorldToTileX(worldX, snapToFloor, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#worldToTileY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */\r\n    worldToTileY: function (worldY, snapToFloor, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.WorldToTileY(worldY, snapToFloor, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#worldToTileXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor=true] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Math.Vector2} [point] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|integer|Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Math.Vector2} Returns a point, or null if the layer given was invalid.\r\n     */\r\n    worldToTileXY: function (worldX, worldY, snapToFloor, point, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.WorldToTileXY(worldX, worldY, snapToFloor, point, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Used internally to check if a layer is static and prints out a warning.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#_isStaticCall\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean}\r\n     */\r\n    _isStaticCall: function (layer, functionName)\r\n    {\r\n        if (layer.tilemapLayer instanceof StaticTilemapLayer)\r\n        {\r\n            console.warn(functionName + ': You cannot change the tiles in a static tilemap layer');\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Tilemap;\r\n"]},"metadata":{},"sourceType":"script"}