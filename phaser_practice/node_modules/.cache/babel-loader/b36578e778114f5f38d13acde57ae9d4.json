{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar CanvasPool = require('../../display/canvas/CanvasPool');\n\nvar Class = require('../../utils/Class');\n\nvar Components = require('../components');\n\nvar GameEvents = require('../../core/events');\n\nvar GameObject = require('../GameObject');\n\nvar GetPowerOfTwo = require('../../math/pow2/GetPowerOfTwo');\n\nvar Smoothing = require('../../display/canvas/Smoothing');\n\nvar TileSpriteRender = require('./TileSpriteRender');\n\nvar Vector2 = require('../../math/Vector2'); //  bitmask flag for GameObject.renderMask\n\n\nvar _FLAG = 8; // 1000\n\n/**\r\n * @classdesc\r\n * A TileSprite is a Sprite that has a repeating texture.\r\n *\r\n * The texture can be scrolled and scaled independently of the TileSprite itself. Textures will automatically wrap and\r\n * are designed so that you can create game backdrops using seamless textures as a source.\r\n *\r\n * You shouldn't ever create a TileSprite any larger than your actual canvas size. If you want to create a large repeating background\r\n * that scrolls across the whole map of your game, then you create a TileSprite that fits the canvas size and then use the `tilePosition`\r\n * property to scroll the texture as the player moves. If you create a TileSprite that is thousands of pixels in size then it will \r\n * consume huge amounts of memory and cause performance issues. Remember: use `tilePosition` to scroll your texture and `tileScale` to\r\n * adjust the scale of the texture - don't resize the sprite itself or make it larger than it needs.\r\n * \r\n * An important note about Tile Sprites and NPOT textures: Internally, TileSprite textures use GL_REPEAT to provide\r\n * seamless repeating of the textures. This, combined with the way in which the textures are handled in WebGL, means\r\n * they need to be POT (power-of-two) sizes in order to wrap. If you provide a NPOT (non power-of-two) texture to a\r\n * TileSprite it will generate a POT sized canvas and draw your texture to it, scaled up to the POT size. It's then\r\n * scaled back down again during rendering to the original dimensions. While this works, in that it allows you to use\r\n * any size texture for a Tile Sprite, it does mean that NPOT textures are going to appear anti-aliased when rendered,\r\n * due to the interpolation that took place when it was resized into a POT texture. This is especially visible in\r\n * pixel art graphics. If you notice it and it becomes an issue, the only way to avoid it is to ensure that you\r\n * provide POT textures for Tile Sprites.\r\n *\r\n * @class TileSprite\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Crop\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {integer} width - The width of the Game Object. If zero it will use the size of the texture frame.\r\n * @param {integer} height - The height of the Game Object. If zero it will use the size of the texture frame.\r\n * @param {string} textureKey - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frameKey] - An optional frame from the Texture this Game Object is rendering with.\r\n */\n\nvar TileSprite = new Class({\n  Extends: GameObject,\n  Mixins: [Components.Alpha, Components.BlendMode, Components.ComputedSize, Components.Crop, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Tint, Components.Transform, Components.Visible, TileSpriteRender],\n  initialize: function TileSprite(scene, x, y, width, height, textureKey, frameKey) {\n    var renderer = scene.sys.game.renderer;\n    GameObject.call(this, scene, 'TileSprite');\n    var displayTexture = scene.sys.textures.get(textureKey);\n    var displayFrame = displayTexture.get(frameKey);\n\n    if (!width || !height) {\n      width = displayFrame.width;\n      height = displayFrame.height;\n    } else {\n      width = Math.floor(width);\n      height = Math.floor(height);\n    }\n    /**\r\n     * Internal tile position vector.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#_tilePosition\r\n     * @type {Phaser.Math.Vector2}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n\n    this._tilePosition = new Vector2();\n    /**\r\n     * Internal tile scale vector.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#_tileScale\r\n     * @type {Phaser.Math.Vector2}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._tileScale = new Vector2(1, 1);\n    /**\r\n     * Whether the Tile Sprite has changed in some way, requiring an re-render of its tile texture.\r\n     *\r\n     * Such changes include the texture frame and scroll position of the Tile Sprite.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#dirty\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.dirty = false;\n    /**\r\n     * The renderer in use by this Tile Sprite.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#renderer\r\n     * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n     * @since 3.0.0\r\n     */\n\n    this.renderer = renderer;\n    /**\r\n     * The Canvas element that the TileSprite renders its fill pattern in to.\r\n     * Only used in Canvas mode.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#canvas\r\n     * @type {?HTMLCanvasElement}\r\n     * @since 3.12.0\r\n     */\n\n    this.canvas = CanvasPool.create(this, width, height);\n    /**\r\n     * The Context of the Canvas element that the TileSprite renders its fill pattern in to.\r\n     * Only used in Canvas mode.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#context\r\n     * @type {CanvasRenderingContext2D}\r\n     * @since 3.12.0\r\n     */\n\n    this.context = this.canvas.getContext('2d');\n    /**\r\n     * The Texture the TileSprite is using as its fill pattern.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#displayTexture\r\n     * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this.displayTexture = displayTexture;\n    /**\r\n     * The Frame the TileSprite is using as its fill pattern.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#displayFrame\r\n     * @type {Phaser.Textures.Frame}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this.displayFrame = displayFrame;\n    /**\r\n     * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#_crop\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._crop = this.resetCropObject();\n    /**\r\n     * The Texture this Game Object is using to render with.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#texture\r\n     * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}\r\n     * @since 3.0.0\r\n     */\n\n    this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);\n    /**\r\n     * The Texture Frame this Game Object is using to render with.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#frame\r\n     * @type {Phaser.Textures.Frame}\r\n     * @since 3.0.0\r\n     */\n\n    this.frame = this.texture.get();\n    /**\r\n     * The next power of two value from the width of the Fill Pattern frame.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#potWidth\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.potWidth = GetPowerOfTwo(displayFrame.width);\n    /**\r\n     * The next power of two value from the height of the Fill Pattern frame.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#potHeight\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.potHeight = GetPowerOfTwo(displayFrame.height);\n    /**\r\n     * The Canvas that the TileSprites texture is rendered to.\r\n     * This is used to create a WebGL texture from.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#fillCanvas\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.12.0\r\n     */\n\n    this.fillCanvas = CanvasPool.create2D(this, this.potWidth, this.potHeight);\n    /**\r\n     * The Canvas Context used to render the TileSprites texture.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#fillContext\r\n     * @type {CanvasRenderingContext2D}\r\n     * @since 3.12.0\r\n     */\n\n    this.fillContext = this.fillCanvas.getContext('2d');\n    /**\r\n     * The texture that the Tile Sprite is rendered to, which is then rendered to a Scene.\r\n     * In WebGL this is a WebGLTexture. In Canvas it's a Canvas Fill Pattern.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#fillPattern\r\n     * @type {?(WebGLTexture|CanvasPattern)}\r\n     * @since 3.12.0\r\n     */\n\n    this.fillPattern = null;\n    this.setPosition(x, y);\n    this.setSize(width, height);\n    this.setFrame(frameKey);\n    this.setOriginFromFrame();\n    this.initPipeline();\n    scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function (renderer) {\n      var gl = renderer.gl;\n      this.dirty = true;\n      this.fillPattern = null;\n      this.fillPattern = renderer.createTexture2D(0, gl.LINEAR, gl.LINEAR, gl.REPEAT, gl.REPEAT, gl.RGBA, this.fillCanvas, this.potWidth, this.potHeight);\n    }, this);\n  },\n\n  /**\r\n   * Sets the texture and frame this Game Object will use to render with.\r\n   *\r\n   * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n   *\r\n   * @method Phaser.GameObjects.TileSprite#setTexture\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n   * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setTexture: function (key, frame) {\n    this.displayTexture = this.scene.sys.textures.get(key);\n    return this.setFrame(frame);\n  },\n\n  /**\r\n   * Sets the frame this Game Object will use to render with.\r\n   *\r\n   * The Frame has to belong to the current Texture being used.\r\n   *\r\n   * It can be either a string or an index.\r\n   *\r\n   * @method Phaser.GameObjects.TileSprite#setFrame\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|integer)} frame - The name or index of the frame within the Texture.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setFrame: function (frame) {\n    var newFrame = this.displayTexture.get(frame);\n    this.potWidth = GetPowerOfTwo(newFrame.width);\n    this.potHeight = GetPowerOfTwo(newFrame.height); //  So updateCanvas is triggered\n\n    this.canvas.width = 0;\n\n    if (!newFrame.cutWidth || !newFrame.cutHeight) {\n      this.renderFlags &= ~_FLAG;\n    } else {\n      this.renderFlags |= _FLAG;\n    }\n\n    this.displayFrame = newFrame;\n    this.dirty = true;\n    this.updateTileTexture();\n    return this;\n  },\n\n  /**\r\n   * Sets {@link Phaser.GameObjects.TileSprite#tilePositionX} and {@link Phaser.GameObjects.TileSprite#tilePositionY}.\r\n   *\r\n   * @method Phaser.GameObjects.TileSprite#setTilePosition\r\n   * @since 3.3.0\r\n   *\r\n   * @param {number} [x] - The x position of this sprite's tiling texture.\r\n   * @param {number} [y] - The y position of this sprite's tiling texture.\r\n   *\r\n   * @return {this} This Tile Sprite instance.\r\n   */\n  setTilePosition: function (x, y) {\n    if (x !== undefined) {\n      this.tilePositionX = x;\n    }\n\n    if (y !== undefined) {\n      this.tilePositionY = y;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets {@link Phaser.GameObjects.TileSprite#tileScaleX} and {@link Phaser.GameObjects.TileSprite#tileScaleY}.\r\n   *\r\n   * @method Phaser.GameObjects.TileSprite#setTileScale\r\n   * @since 3.12.0\r\n   *\r\n   * @param {number} [x] - The horizontal scale of the tiling texture. If not given it will use the current `tileScaleX` value.\r\n   * @param {number} [y=x] - The vertical scale of the tiling texture. If not given it will use the `x` value.\r\n   *\r\n   * @return {this} This Tile Sprite instance.\r\n   */\n  setTileScale: function (x, y) {\n    if (x === undefined) {\n      x = this.tileScaleX;\n    }\n\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.tileScaleX = x;\n    this.tileScaleY = y;\n    return this;\n  },\n\n  /**\r\n   * Render the tile texture if it is dirty, or if the frame has changed.\r\n   *\r\n   * @method Phaser.GameObjects.TileSprite#updateTileTexture\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  updateTileTexture: function () {\n    if (!this.dirty || !this.renderer) {\n      return;\n    } //  Draw the displayTexture to our fillCanvas\n\n\n    var frame = this.displayFrame;\n\n    if (frame.source.isRenderTexture || frame.source.isGLTexture) {\n      console.warn('TileSprites can only use Image or Canvas based textures');\n      this.dirty = false;\n      return;\n    }\n\n    var ctx = this.fillContext;\n    var canvas = this.fillCanvas;\n    var fw = this.potWidth;\n    var fh = this.potHeight;\n\n    if (!this.renderer.gl) {\n      fw = frame.cutWidth;\n      fh = frame.cutHeight;\n    }\n\n    ctx.clearRect(0, 0, fw, fh);\n    canvas.width = fw;\n    canvas.height = fh;\n    ctx.drawImage(frame.source.image, frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight, 0, 0, fw, fh);\n\n    if (this.renderer.gl) {\n      this.fillPattern = this.renderer.canvasToTexture(canvas, this.fillPattern);\n    } else {\n      this.fillPattern = ctx.createPattern(canvas, 'repeat');\n    }\n\n    this.updateCanvas();\n    this.dirty = false;\n  },\n\n  /**\r\n   * Draw the fill pattern to the internal canvas.\r\n   *\r\n   * @method Phaser.GameObjects.TileSprite#updateCanvas\r\n   * @private\r\n   * @since 3.12.0\r\n   */\n  updateCanvas: function () {\n    var canvas = this.canvas;\n\n    if (canvas.width !== this.width || canvas.height !== this.height) {\n      canvas.width = this.width;\n      canvas.height = this.height;\n      this.frame.setSize(this.width, this.height);\n      this.updateDisplayOrigin();\n      this.dirty = true;\n    }\n\n    if (!this.dirty || this.renderer && this.renderer.gl) {\n      this.dirty = false;\n      return;\n    }\n\n    var ctx = this.context;\n\n    if (!this.scene.sys.game.config.antialias) {\n      Smoothing.disable(ctx);\n    }\n\n    var scaleX = this._tileScale.x;\n    var scaleY = this._tileScale.y;\n    var positionX = this._tilePosition.x;\n    var positionY = this._tilePosition.y;\n    ctx.clearRect(0, 0, this.width, this.height);\n    ctx.save();\n    ctx.scale(scaleX, scaleY);\n    ctx.translate(-positionX, -positionY);\n    ctx.fillStyle = this.fillPattern;\n    ctx.fillRect(positionX, positionY, this.width / scaleX, this.height / scaleY);\n    ctx.restore();\n    this.dirty = false;\n  },\n\n  /**\r\n   * Internal destroy handler, called as part of the destroy process.\r\n   *\r\n   * @method Phaser.GameObjects.TileSprite#preDestroy\r\n   * @protected\r\n   * @since 3.9.0\r\n   */\n  preDestroy: function () {\n    if (this.renderer && this.renderer.gl) {\n      this.renderer.deleteTexture(this.fillPattern);\n    }\n\n    CanvasPool.remove(this.canvas);\n    CanvasPool.remove(this.fillCanvas);\n    this.fillPattern = null;\n    this.fillContext = null;\n    this.fillCanvas = null;\n    this.displayTexture = null;\n    this.displayFrame = null;\n    this.texture.destroy();\n    this.renderer = null;\n  },\n\n  /**\r\n   * The horizontal scroll position of the Tile Sprite.\r\n   *\r\n   * @name Phaser.GameObjects.TileSprite#tilePositionX\r\n   * @type {number}\r\n   * @default 0\r\n   * @since 3.0.0\r\n   */\n  tilePositionX: {\n    get: function () {\n      return this._tilePosition.x;\n    },\n    set: function (value) {\n      this._tilePosition.x = value;\n      this.dirty = true;\n    }\n  },\n\n  /**\r\n   * The vertical scroll position of the Tile Sprite.\r\n   *\r\n   * @name Phaser.GameObjects.TileSprite#tilePositionY\r\n   * @type {number}\r\n   * @default 0\r\n   * @since 3.0.0\r\n   */\n  tilePositionY: {\n    get: function () {\n      return this._tilePosition.y;\n    },\n    set: function (value) {\n      this._tilePosition.y = value;\n      this.dirty = true;\n    }\n  },\n\n  /**\r\n   * The horizontal scale of the Tile Sprite texture.\r\n   *\r\n   * @name Phaser.GameObjects.TileSprite#tileScaleX\r\n   * @type {number}\r\n   * @default 1\r\n   * @since 3.11.0\r\n   */\n  tileScaleX: {\n    get: function () {\n      return this._tileScale.x;\n    },\n    set: function (value) {\n      this._tileScale.x = value;\n      this.dirty = true;\n    }\n  },\n\n  /**\r\n   * The vertical scale of the Tile Sprite texture.\r\n   *\r\n   * @name Phaser.GameObjects.TileSprite#tileScaleY\r\n   * @type {number}\r\n   * @default 1\r\n   * @since 3.11.0\r\n   */\n  tileScaleY: {\n    get: function () {\n      return this._tileScale.y;\n    },\n    set: function (value) {\n      this._tileScale.y = value;\n      this.dirty = true;\n    }\n  }\n});\nmodule.exports = TileSprite;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/tilesprite/TileSprite.js"],"names":["CanvasPool","require","Class","Components","GameEvents","GameObject","GetPowerOfTwo","Smoothing","TileSpriteRender","Vector2","_FLAG","TileSprite","Extends","Mixins","Alpha","BlendMode","ComputedSize","Crop","Depth","Flip","GetBounds","Mask","Origin","Pipeline","ScrollFactor","Tint","Transform","Visible","initialize","scene","x","y","width","height","textureKey","frameKey","renderer","sys","game","call","displayTexture","textures","get","displayFrame","Math","floor","_tilePosition","_tileScale","dirty","canvas","create","context","getContext","_crop","resetCropObject","texture","addCanvas","frame","potWidth","potHeight","fillCanvas","create2D","fillContext","fillPattern","setPosition","setSize","setFrame","setOriginFromFrame","initPipeline","events","on","CONTEXT_RESTORED","gl","createTexture2D","LINEAR","REPEAT","RGBA","setTexture","key","newFrame","cutWidth","cutHeight","renderFlags","updateTileTexture","setTilePosition","undefined","tilePositionX","tilePositionY","setTileScale","tileScaleX","tileScaleY","source","isRenderTexture","isGLTexture","console","warn","ctx","fw","fh","clearRect","drawImage","image","cutX","cutY","canvasToTexture","createPattern","updateCanvas","updateDisplayOrigin","config","antialias","disable","scaleX","scaleY","positionX","positionY","save","scale","translate","fillStyle","fillRect","restore","preDestroy","deleteTexture","remove","destroy","set","value","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CanvasPool = require('../../display/canvas/CanvasPool');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameEvents = require('../../core/events');\r\nvar GameObject = require('../GameObject');\r\nvar GetPowerOfTwo = require('../../math/pow2/GetPowerOfTwo');\r\nvar Smoothing = require('../../display/canvas/Smoothing');\r\nvar TileSpriteRender = require('./TileSpriteRender');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n//  bitmask flag for GameObject.renderMask\r\nvar _FLAG = 8; // 1000\r\n\r\n/**\r\n * @classdesc\r\n * A TileSprite is a Sprite that has a repeating texture.\r\n *\r\n * The texture can be scrolled and scaled independently of the TileSprite itself. Textures will automatically wrap and\r\n * are designed so that you can create game backdrops using seamless textures as a source.\r\n *\r\n * You shouldn't ever create a TileSprite any larger than your actual canvas size. If you want to create a large repeating background\r\n * that scrolls across the whole map of your game, then you create a TileSprite that fits the canvas size and then use the `tilePosition`\r\n * property to scroll the texture as the player moves. If you create a TileSprite that is thousands of pixels in size then it will \r\n * consume huge amounts of memory and cause performance issues. Remember: use `tilePosition` to scroll your texture and `tileScale` to\r\n * adjust the scale of the texture - don't resize the sprite itself or make it larger than it needs.\r\n * \r\n * An important note about Tile Sprites and NPOT textures: Internally, TileSprite textures use GL_REPEAT to provide\r\n * seamless repeating of the textures. This, combined with the way in which the textures are handled in WebGL, means\r\n * they need to be POT (power-of-two) sizes in order to wrap. If you provide a NPOT (non power-of-two) texture to a\r\n * TileSprite it will generate a POT sized canvas and draw your texture to it, scaled up to the POT size. It's then\r\n * scaled back down again during rendering to the original dimensions. While this works, in that it allows you to use\r\n * any size texture for a Tile Sprite, it does mean that NPOT textures are going to appear anti-aliased when rendered,\r\n * due to the interpolation that took place when it was resized into a POT texture. This is especially visible in\r\n * pixel art graphics. If you notice it and it becomes an issue, the only way to avoid it is to ensure that you\r\n * provide POT textures for Tile Sprites.\r\n *\r\n * @class TileSprite\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Crop\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {integer} width - The width of the Game Object. If zero it will use the size of the texture frame.\r\n * @param {integer} height - The height of the Game Object. If zero it will use the size of the texture frame.\r\n * @param {string} textureKey - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frameKey] - An optional frame from the Texture this Game Object is rendering with.\r\n */\r\nvar TileSprite = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.ComputedSize,\r\n        Components.Crop,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        TileSpriteRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function TileSprite (scene, x, y, width, height, textureKey, frameKey)\r\n    {\r\n        var renderer = scene.sys.game.renderer;\r\n\r\n        GameObject.call(this, scene, 'TileSprite');\r\n\r\n        var displayTexture = scene.sys.textures.get(textureKey);\r\n        var displayFrame = displayTexture.get(frameKey);\r\n\r\n        if (!width || !height)\r\n        {\r\n            width = displayFrame.width;\r\n            height = displayFrame.height;\r\n        }\r\n        else\r\n        {\r\n            width = Math.floor(width);\r\n            height = Math.floor(height);\r\n        }\r\n\r\n        /**\r\n         * Internal tile position vector.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#_tilePosition\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._tilePosition = new Vector2();\r\n\r\n        /**\r\n         * Internal tile scale vector.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#_tileScale\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._tileScale = new Vector2(1, 1);\r\n\r\n        /**\r\n         * Whether the Tile Sprite has changed in some way, requiring an re-render of its tile texture.\r\n         *\r\n         * Such changes include the texture frame and scroll position of the Tile Sprite.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#dirty\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.dirty = false;\r\n\r\n        /**\r\n         * The renderer in use by this Tile Sprite.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.0.0\r\n         */\r\n        this.renderer = renderer;\r\n\r\n        /**\r\n         * The Canvas element that the TileSprite renders its fill pattern in to.\r\n         * Only used in Canvas mode.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#canvas\r\n         * @type {?HTMLCanvasElement}\r\n         * @since 3.12.0\r\n         */\r\n        this.canvas = CanvasPool.create(this, width, height);\r\n\r\n        /**\r\n         * The Context of the Canvas element that the TileSprite renders its fill pattern in to.\r\n         * Only used in Canvas mode.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#context\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.12.0\r\n         */\r\n        this.context = this.canvas.getContext('2d');\r\n\r\n        /**\r\n         * The Texture the TileSprite is using as its fill pattern.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#displayTexture\r\n         * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this.displayTexture = displayTexture;\r\n\r\n        /**\r\n         * The Frame the TileSprite is using as its fill pattern.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#displayFrame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this.displayFrame = displayFrame;\r\n\r\n        /**\r\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#_crop\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._crop = this.resetCropObject();\r\n\r\n        /**\r\n         * The Texture this Game Object is using to render with.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#texture\r\n         * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}\r\n         * @since 3.0.0\r\n         */\r\n        this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);\r\n\r\n        /**\r\n         * The Texture Frame this Game Object is using to render with.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @since 3.0.0\r\n         */\r\n        this.frame = this.texture.get();\r\n\r\n        /**\r\n         * The next power of two value from the width of the Fill Pattern frame.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#potWidth\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.potWidth = GetPowerOfTwo(displayFrame.width);\r\n\r\n        /**\r\n         * The next power of two value from the height of the Fill Pattern frame.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#potHeight\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.potHeight = GetPowerOfTwo(displayFrame.height);\r\n\r\n        /**\r\n         * The Canvas that the TileSprites texture is rendered to.\r\n         * This is used to create a WebGL texture from.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#fillCanvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.12.0\r\n         */\r\n        this.fillCanvas = CanvasPool.create2D(this, this.potWidth, this.potHeight);\r\n\r\n        /**\r\n         * The Canvas Context used to render the TileSprites texture.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#fillContext\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.12.0\r\n         */\r\n        this.fillContext = this.fillCanvas.getContext('2d');\r\n\r\n        /**\r\n         * The texture that the Tile Sprite is rendered to, which is then rendered to a Scene.\r\n         * In WebGL this is a WebGLTexture. In Canvas it's a Canvas Fill Pattern.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#fillPattern\r\n         * @type {?(WebGLTexture|CanvasPattern)}\r\n         * @since 3.12.0\r\n         */\r\n        this.fillPattern = null;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(width, height);\r\n        this.setFrame(frameKey);\r\n        this.setOriginFromFrame();\r\n        this.initPipeline();\r\n\r\n        scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function (renderer)\r\n        {\r\n            var gl = renderer.gl;\r\n\r\n            this.dirty = true;\r\n            this.fillPattern = null;\r\n            this.fillPattern = renderer.createTexture2D(0, gl.LINEAR, gl.LINEAR, gl.REPEAT, gl.REPEAT, gl.RGBA, this.fillCanvas, this.potWidth, this.potHeight);\r\n\r\n        }, this);\r\n    },\r\n\r\n    /**\r\n     * Sets the texture and frame this Game Object will use to render with.\r\n     *\r\n     * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#setTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setTexture: function (key, frame)\r\n    {\r\n        this.displayTexture = this.scene.sys.textures.get(key);\r\n\r\n        return this.setFrame(frame);\r\n    },\r\n\r\n    /**\r\n     * Sets the frame this Game Object will use to render with.\r\n     *\r\n     * The Frame has to belong to the current Texture being used.\r\n     *\r\n     * It can be either a string or an index.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer)} frame - The name or index of the frame within the Texture.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFrame: function (frame)\r\n    {\r\n        var newFrame = this.displayTexture.get(frame);\r\n\r\n        this.potWidth = GetPowerOfTwo(newFrame.width);\r\n        this.potHeight = GetPowerOfTwo(newFrame.height);\r\n\r\n        //  So updateCanvas is triggered\r\n        this.canvas.width = 0;\r\n\r\n        if (!newFrame.cutWidth || !newFrame.cutHeight)\r\n        {\r\n            this.renderFlags &= ~_FLAG;\r\n        }\r\n        else\r\n        {\r\n            this.renderFlags |= _FLAG;\r\n        }\r\n\r\n        this.displayFrame = newFrame;\r\n\r\n        this.dirty = true;\r\n\r\n        this.updateTileTexture();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets {@link Phaser.GameObjects.TileSprite#tilePositionX} and {@link Phaser.GameObjects.TileSprite#tilePositionY}.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#setTilePosition\r\n     * @since 3.3.0\r\n     *\r\n     * @param {number} [x] - The x position of this sprite's tiling texture.\r\n     * @param {number} [y] - The y position of this sprite's tiling texture.\r\n     *\r\n     * @return {this} This Tile Sprite instance.\r\n     */\r\n    setTilePosition: function (x, y)\r\n    {\r\n        if (x !== undefined)\r\n        {\r\n            this.tilePositionX = x;\r\n        }\r\n\r\n        if (y !== undefined)\r\n        {\r\n            this.tilePositionY = y;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets {@link Phaser.GameObjects.TileSprite#tileScaleX} and {@link Phaser.GameObjects.TileSprite#tileScaleY}.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#setTileScale\r\n     * @since 3.12.0\r\n     *\r\n     * @param {number} [x] - The horizontal scale of the tiling texture. If not given it will use the current `tileScaleX` value.\r\n     * @param {number} [y=x] - The vertical scale of the tiling texture. If not given it will use the `x` value.\r\n     *\r\n     * @return {this} This Tile Sprite instance.\r\n     */\r\n    setTileScale: function (x, y)\r\n    {\r\n        if (x === undefined) { x = this.tileScaleX; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.tileScaleX = x;\r\n        this.tileScaleY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Render the tile texture if it is dirty, or if the frame has changed.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#updateTileTexture\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    updateTileTexture: function ()\r\n    {\r\n        if (!this.dirty || !this.renderer)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  Draw the displayTexture to our fillCanvas\r\n\r\n        var frame = this.displayFrame;\r\n\r\n        if (frame.source.isRenderTexture || frame.source.isGLTexture)\r\n        {\r\n            console.warn('TileSprites can only use Image or Canvas based textures');\r\n\r\n            this.dirty = false;\r\n\r\n            return;\r\n        }\r\n\r\n        var ctx = this.fillContext;\r\n        var canvas = this.fillCanvas;\r\n\r\n        var fw = this.potWidth;\r\n        var fh = this.potHeight;\r\n\r\n        if (!this.renderer.gl)\r\n        {\r\n            fw = frame.cutWidth;\r\n            fh = frame.cutHeight;\r\n        }\r\n\r\n        ctx.clearRect(0, 0, fw, fh);\r\n\r\n        canvas.width = fw;\r\n        canvas.height = fh;\r\n\r\n        ctx.drawImage(\r\n            frame.source.image,\r\n            frame.cutX, frame.cutY,\r\n            frame.cutWidth, frame.cutHeight,\r\n            0, 0,\r\n            fw, fh\r\n        );\r\n\r\n        if (this.renderer.gl)\r\n        {\r\n            this.fillPattern = this.renderer.canvasToTexture(canvas, this.fillPattern);\r\n        }\r\n        else\r\n        {\r\n            this.fillPattern = ctx.createPattern(canvas, 'repeat');\r\n        }\r\n\r\n        this.updateCanvas();\r\n\r\n        this.dirty = false;\r\n    },\r\n\r\n    /**\r\n     * Draw the fill pattern to the internal canvas.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#updateCanvas\r\n     * @private\r\n     * @since 3.12.0\r\n     */\r\n    updateCanvas: function ()\r\n    {\r\n        var canvas = this.canvas;\r\n\r\n        if (canvas.width !== this.width || canvas.height !== this.height)\r\n        {\r\n            canvas.width = this.width;\r\n            canvas.height = this.height;\r\n\r\n            this.frame.setSize(this.width, this.height);\r\n            this.updateDisplayOrigin();\r\n\r\n            this.dirty = true;\r\n        }\r\n\r\n        if (!this.dirty || this.renderer && this.renderer.gl)\r\n        {\r\n            this.dirty = false;\r\n            return;\r\n        }\r\n\r\n        var ctx = this.context;\r\n\r\n        if (!this.scene.sys.game.config.antialias)\r\n        {\r\n            Smoothing.disable(ctx);\r\n        }\r\n\r\n        var scaleX = this._tileScale.x;\r\n        var scaleY = this._tileScale.y;\r\n\r\n        var positionX = this._tilePosition.x;\r\n        var positionY = this._tilePosition.y;\r\n\r\n        ctx.clearRect(0, 0, this.width, this.height);\r\n\r\n        ctx.save();\r\n\r\n        ctx.scale(scaleX, scaleY);\r\n\r\n        ctx.translate(-positionX, -positionY);\r\n\r\n        ctx.fillStyle = this.fillPattern;\r\n\r\n        ctx.fillRect(positionX, positionY, this.width / scaleX, this.height / scaleY);\r\n\r\n        ctx.restore();\r\n\r\n        this.dirty = false;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#preDestroy\r\n     * @protected\r\n     * @since 3.9.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        if (this.renderer && this.renderer.gl)\r\n        {\r\n            this.renderer.deleteTexture(this.fillPattern);\r\n        }\r\n\r\n        CanvasPool.remove(this.canvas);\r\n        CanvasPool.remove(this.fillCanvas);\r\n\r\n        this.fillPattern = null;\r\n        this.fillContext = null;\r\n        this.fillCanvas = null;\r\n\r\n        this.displayTexture = null;\r\n        this.displayFrame = null;\r\n\r\n        this.texture.destroy();\r\n\r\n        this.renderer = null;\r\n    },\r\n\r\n    /**\r\n     * The horizontal scroll position of the Tile Sprite.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#tilePositionX\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    tilePositionX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._tilePosition.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tilePosition.x = value;\r\n            this.dirty = true;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scroll position of the Tile Sprite.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#tilePositionY\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    tilePositionY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._tilePosition.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tilePosition.y = value;\r\n            this.dirty = true;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The horizontal scale of the Tile Sprite texture.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#tileScaleX\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.11.0\r\n     */\r\n    tileScaleX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._tileScale.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tileScale.x = value;\r\n            this.dirty = true;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scale of the Tile Sprite texture.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#tileScaleY\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.11.0\r\n     */\r\n    tileScaleY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._tileScale.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tileScale.y = value;\r\n            this.dirty = true;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = TileSprite;\r\n"]},"metadata":{},"sourceType":"script"}