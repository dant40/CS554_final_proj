{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Base64Decode = require('./Base64Decode');\n\nvar GetFastValue = require('../../../utils/object/GetFastValue');\n\nvar LayerData = require('../../mapdata/LayerData');\n\nvar ParseGID = require('./ParseGID');\n\nvar Tile = require('../../Tile');\n\nvar CreateGroupLayer = require('./CreateGroupLayer');\n/**\r\n * Parses all tilemap layers in a Tiled JSON object into new LayerData objects.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseTileLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Tiled JSON object.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled (see {@link Phaser.Tilemaps.Parsers.Tiled.ParseJSONTiled}).\r\n *\r\n * @return {Phaser.Tilemaps.LayerData[]} - An array of LayerData objects, one for each entry in\r\n * json.layers with the type 'tilelayer'.\r\n */\n\n\nvar ParseTileLayers = function (json, insertNull) {\n  var infiniteMap = GetFastValue(json, 'infinite', false);\n  var tileLayers = []; // State inherited from a parent group\n\n  var groupStack = [];\n  var curGroupState = CreateGroupLayer(json);\n\n  while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0) {\n    if (curGroupState.i >= curGroupState.layers.length) {\n      // Ensure recursion stack is not empty first\n      if (groupStack.length < 1) {\n        console.warn('TilemapParser.parseTiledJSON - Invalid layer group hierarchy');\n        break;\n      } // Return to previous recursive state\n\n\n      curGroupState = groupStack.pop();\n      continue;\n    }\n\n    var curl = curGroupState.layers[curGroupState.i];\n    curGroupState.i++;\n\n    if (curl.type !== 'tilelayer') {\n      if (curl.type === 'group') {\n        // Compute next state inherited from group\n        var nextGroupState = CreateGroupLayer(json, curl, curGroupState); // Preserve current state before recursing\n\n        groupStack.push(curGroupState);\n        curGroupState = nextGroupState;\n      } // Skip this layer OR 'recurse' (iterative style) into the group\n\n\n      continue;\n    } // Base64 decode data if necessary. NOTE: uncompressed base64 only.\n\n\n    if (curl.compression) {\n      console.warn('TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer \\'' + curl.name + '\\'');\n      continue;\n    } else if (curl.encoding && curl.encoding === 'base64') {\n      // Chunks for an infinite map\n      if (curl.chunks) {\n        for (var i = 0; i < curl.chunks.length; i++) {\n          curl.chunks[i].data = Base64Decode(curl.chunks[i].data);\n        }\n      } // Non-infinite map data\n\n\n      if (curl.data) {\n        curl.data = Base64Decode(curl.data);\n      }\n\n      delete curl.encoding; // Allow the same map to be parsed multiple times\n    } //  This is an array containing the tile indexes, one after the other. -1 = no tile,\n    //  everything else = the tile index (starting at 1 for Tiled, 0 for CSV) If the map\n    //  contains multiple tilesets then the indexes are relative to that which the set starts\n    //  from. Need to set which tileset in the cache = which tileset in the JSON, if you do this\n    //  manually it means you can use the same map data but a new tileset.\n\n\n    var layerData;\n    var gidInfo;\n    var tile;\n    var blankTile;\n    var output = [];\n    var x = 0;\n\n    if (infiniteMap) {\n      var layerOffsetX = GetFastValue(curl, 'startx', 0) + curl.x;\n      var layerOffsetY = GetFastValue(curl, 'starty', 0) + curl.y;\n      layerData = new LayerData({\n        name: curGroupState.name + curl.name,\n        x: curGroupState.x + GetFastValue(curl, 'offsetx', 0) + layerOffsetX * json.tilewidth,\n        y: curGroupState.y + GetFastValue(curl, 'offsety', 0) + layerOffsetY * json.tileheight,\n        width: curl.width,\n        height: curl.height,\n        tileWidth: json.tilewidth,\n        tileHeight: json.tileheight,\n        alpha: curGroupState.opacity * curl.opacity,\n        visible: curGroupState.visible && curl.visible,\n        properties: GetFastValue(curl, 'properties', {})\n      });\n\n      for (var c = 0; c < curl.height; c++) {\n        output.push([null]);\n\n        for (var j = 0; j < curl.width; j++) {\n          output[c][j] = null;\n        }\n      }\n\n      for (c = 0, len = curl.chunks.length; c < len; c++) {\n        var chunk = curl.chunks[c];\n        var offsetX = chunk.x - layerOffsetX;\n        var offsetY = chunk.y - layerOffsetY;\n        var y = 0;\n\n        for (var t = 0, len2 = chunk.data.length; t < len2; t++) {\n          var newOffsetX = x + offsetX;\n          var newOffsetY = y + offsetY;\n          gidInfo = ParseGID(chunk.data[t]); //  index, x, y, width, height\n\n          if (gidInfo.gid > 0) {\n            tile = new Tile(layerData, gidInfo.gid, newOffsetX, newOffsetY, json.tilewidth, json.tileheight); // Turning Tiled's FlippedHorizontal, FlippedVertical and FlippedAntiDiagonal\n            // propeties into flipX, flipY and rotation\n\n            tile.rotation = gidInfo.rotation;\n            tile.flipX = gidInfo.flipped;\n            output[newOffsetY][newOffsetX] = tile;\n          } else {\n            blankTile = insertNull ? null : new Tile(layerData, -1, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);\n            output[newOffsetY][newOffsetX] = blankTile;\n          }\n\n          x++;\n\n          if (x === chunk.width) {\n            y++;\n            x = 0;\n          }\n        }\n      }\n    } else {\n      layerData = new LayerData({\n        name: curGroupState.name + curl.name,\n        x: curGroupState.x + GetFastValue(curl, 'offsetx', 0) + curl.x,\n        y: curGroupState.y + GetFastValue(curl, 'offsety', 0) + curl.y,\n        width: curl.width,\n        height: curl.height,\n        tileWidth: json.tilewidth,\n        tileHeight: json.tileheight,\n        alpha: curGroupState.opacity * curl.opacity,\n        visible: curGroupState.visible && curl.visible,\n        properties: GetFastValue(curl, 'properties', {})\n      });\n      var row = []; //  Loop through the data field in the JSON.\n\n      for (var k = 0, len = curl.data.length; k < len; k++) {\n        gidInfo = ParseGID(curl.data[k]); //  index, x, y, width, height\n\n        if (gidInfo.gid > 0) {\n          tile = new Tile(layerData, gidInfo.gid, x, output.length, json.tilewidth, json.tileheight); // Turning Tiled's FlippedHorizontal, FlippedVertical and FlippedAntiDiagonal\n          // propeties into flipX, flipY and rotation\n\n          tile.rotation = gidInfo.rotation;\n          tile.flipX = gidInfo.flipped;\n          row.push(tile);\n        } else {\n          blankTile = insertNull ? null : new Tile(layerData, -1, x, output.length, json.tilewidth, json.tileheight);\n          row.push(blankTile);\n        }\n\n        x++;\n\n        if (x === curl.width) {\n          output.push(row);\n          x = 0;\n          row = [];\n        }\n      }\n    }\n\n    layerData.data = output;\n    tileLayers.push(layerData);\n  }\n\n  return tileLayers;\n};\n\nmodule.exports = ParseTileLayers;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/tilemaps/parsers/tiled/ParseTileLayers.js"],"names":["Base64Decode","require","GetFastValue","LayerData","ParseGID","Tile","CreateGroupLayer","ParseTileLayers","json","insertNull","infiniteMap","tileLayers","groupStack","curGroupState","i","layers","length","console","warn","pop","curl","type","nextGroupState","push","compression","name","encoding","chunks","data","layerData","gidInfo","tile","blankTile","output","x","layerOffsetX","layerOffsetY","y","tilewidth","tileheight","width","height","tileWidth","tileHeight","alpha","opacity","visible","properties","c","j","len","chunk","offsetX","offsetY","t","len2","newOffsetX","newOffsetY","gid","rotation","flipX","flipped","row","k","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Base64Decode = require('./Base64Decode');\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar LayerData = require('../../mapdata/LayerData');\r\nvar ParseGID = require('./ParseGID');\r\nvar Tile = require('../../Tile');\r\nvar CreateGroupLayer = require('./CreateGroupLayer');\r\n\r\n/**\r\n * Parses all tilemap layers in a Tiled JSON object into new LayerData objects.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseTileLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Tiled JSON object.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled (see {@link Phaser.Tilemaps.Parsers.Tiled.ParseJSONTiled}).\r\n *\r\n * @return {Phaser.Tilemaps.LayerData[]} - An array of LayerData objects, one for each entry in\r\n * json.layers with the type 'tilelayer'.\r\n */\r\nvar ParseTileLayers = function (json, insertNull)\r\n{\r\n    var infiniteMap = GetFastValue(json, 'infinite', false);\r\n    var tileLayers = [];\r\n\r\n    // State inherited from a parent group\r\n    var groupStack = [];\r\n    var curGroupState = CreateGroupLayer(json);\r\n\r\n    while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0)\r\n    {\r\n        if (curGroupState.i >= curGroupState.layers.length)\r\n        {\r\n            // Ensure recursion stack is not empty first\r\n            if (groupStack.length < 1)\r\n            {\r\n                console.warn(\r\n                    'TilemapParser.parseTiledJSON - Invalid layer group hierarchy'\r\n                );\r\n                break;\r\n            }\r\n\r\n            // Return to previous recursive state\r\n            curGroupState = groupStack.pop();\r\n            continue;\r\n        }\r\n\r\n        var curl = curGroupState.layers[curGroupState.i];\r\n        curGroupState.i++;\r\n\r\n        if (curl.type !== 'tilelayer')\r\n        {\r\n            if (curl.type === 'group')\r\n            {\r\n                // Compute next state inherited from group\r\n                var nextGroupState = CreateGroupLayer(json, curl, curGroupState);\r\n\r\n                // Preserve current state before recursing\r\n                groupStack.push(curGroupState);\r\n                curGroupState = nextGroupState;\r\n            }\r\n\r\n            // Skip this layer OR 'recurse' (iterative style) into the group\r\n            continue;\r\n        }\r\n\r\n        // Base64 decode data if necessary. NOTE: uncompressed base64 only.\r\n        if (curl.compression)\r\n        {\r\n            console.warn(\r\n                'TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer \\''\r\n                + curl.name + '\\''\r\n            );\r\n            continue;\r\n        }\r\n        else if (curl.encoding && curl.encoding === 'base64')\r\n        {\r\n            // Chunks for an infinite map\r\n            if (curl.chunks)\r\n            {\r\n                for (var i = 0; i < curl.chunks.length; i++)\r\n                {\r\n                    curl.chunks[i].data = Base64Decode(curl.chunks[i].data);\r\n                }\r\n            }\r\n\r\n            // Non-infinite map data\r\n            if (curl.data)\r\n            {\r\n                curl.data = Base64Decode(curl.data);\r\n            }\r\n\r\n            delete curl.encoding; // Allow the same map to be parsed multiple times\r\n        }\r\n\r\n        //  This is an array containing the tile indexes, one after the other. -1 = no tile,\r\n        //  everything else = the tile index (starting at 1 for Tiled, 0 for CSV) If the map\r\n        //  contains multiple tilesets then the indexes are relative to that which the set starts\r\n        //  from. Need to set which tileset in the cache = which tileset in the JSON, if you do this\r\n        //  manually it means you can use the same map data but a new tileset.\r\n\r\n        var layerData;\r\n        var gidInfo;\r\n        var tile;\r\n        var blankTile;\r\n\r\n        var output = [];\r\n        var x = 0;\r\n\r\n        if (infiniteMap)\r\n        {\r\n            var layerOffsetX = (GetFastValue(curl, 'startx', 0) + curl.x);\r\n            var layerOffsetY = (GetFastValue(curl, 'starty', 0) + curl.y);\r\n            layerData = new LayerData({\r\n                name: (curGroupState.name + curl.name),\r\n                x: (curGroupState.x + GetFastValue(curl, 'offsetx', 0) + layerOffsetX * json.tilewidth),\r\n                y: (curGroupState.y + GetFastValue(curl, 'offsety', 0) + layerOffsetY * json.tileheight),\r\n                width: curl.width,\r\n                height: curl.height,\r\n                tileWidth: json.tilewidth,\r\n                tileHeight: json.tileheight,\r\n                alpha: (curGroupState.opacity * curl.opacity),\r\n                visible: (curGroupState.visible && curl.visible),\r\n                properties: GetFastValue(curl, 'properties', {})\r\n            });\r\n\r\n            for (var c = 0; c < curl.height; c++)\r\n            {\r\n                output.push([ null ]);\r\n\r\n                for (var j = 0; j < curl.width; j++)\r\n                {\r\n                    output[c][j] = null;\r\n                }\r\n            }\r\n\r\n            for (c = 0, len = curl.chunks.length; c < len; c++)\r\n            {\r\n                var chunk = curl.chunks[c];\r\n\r\n                var offsetX = (chunk.x - layerOffsetX);\r\n                var offsetY = (chunk.y - layerOffsetY);\r\n\r\n                var y = 0;\r\n\r\n                for (var t = 0, len2 = chunk.data.length; t < len2; t++)\r\n                {\r\n                    var newOffsetX = x + offsetX;\r\n                    var newOffsetY = y + offsetY;\r\n\r\n                    gidInfo = ParseGID(chunk.data[t]);\r\n\r\n                    //  index, x, y, width, height\r\n                    if (gidInfo.gid > 0)\r\n                    {\r\n                        tile = new Tile(layerData, gidInfo.gid, newOffsetX, newOffsetY, json.tilewidth,\r\n                            json.tileheight);\r\n\r\n                        // Turning Tiled's FlippedHorizontal, FlippedVertical and FlippedAntiDiagonal\r\n                        // propeties into flipX, flipY and rotation\r\n                        tile.rotation = gidInfo.rotation;\r\n                        tile.flipX = gidInfo.flipped;\r\n\r\n                        output[newOffsetY][newOffsetX] = tile;\r\n                    }\r\n                    else\r\n                    {\r\n                        blankTile = insertNull\r\n                            ? null\r\n                            : new Tile(layerData, -1, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);\r\n\r\n                        output[newOffsetY][newOffsetX] = blankTile;\r\n                    }\r\n\r\n                    x++;\r\n\r\n                    if (x === chunk.width)\r\n                    {\r\n                        y++;\r\n                        x = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            layerData = new LayerData({\r\n                name: (curGroupState.name + curl.name),\r\n                x: (curGroupState.x + GetFastValue(curl, 'offsetx', 0) + curl.x),\r\n                y: (curGroupState.y + GetFastValue(curl, 'offsety', 0) + curl.y),\r\n                width: curl.width,\r\n                height: curl.height,\r\n                tileWidth: json.tilewidth,\r\n                tileHeight: json.tileheight,\r\n                alpha: (curGroupState.opacity * curl.opacity),\r\n                visible: (curGroupState.visible && curl.visible),\r\n                properties: GetFastValue(curl, 'properties', {})\r\n            });\r\n\r\n            var row = [];\r\n\r\n            //  Loop through the data field in the JSON.\r\n            for (var k = 0, len = curl.data.length; k < len; k++)\r\n            {\r\n                gidInfo = ParseGID(curl.data[k]);\r\n\r\n                //  index, x, y, width, height\r\n                if (gidInfo.gid > 0)\r\n                {\r\n                    tile = new Tile(layerData, gidInfo.gid, x, output.length, json.tilewidth,\r\n                        json.tileheight);\r\n\r\n                    // Turning Tiled's FlippedHorizontal, FlippedVertical and FlippedAntiDiagonal\r\n                    // propeties into flipX, flipY and rotation\r\n                    tile.rotation = gidInfo.rotation;\r\n                    tile.flipX = gidInfo.flipped;\r\n\r\n                    row.push(tile);\r\n                }\r\n                else\r\n                {\r\n                    blankTile = insertNull\r\n                        ? null\r\n                        : new Tile(layerData, -1, x, output.length, json.tilewidth, json.tileheight);\r\n                    row.push(blankTile);\r\n                }\r\n\r\n                x++;\r\n\r\n                if (x === curl.width)\r\n                {\r\n                    output.push(row);\r\n                    x = 0;\r\n                    row = [];\r\n                }\r\n            }\r\n        }\r\n\r\n        layerData.data = output;\r\n        tileLayers.push(layerData);\r\n    }\r\n\r\n    return tileLayers;\r\n};\r\n\r\nmodule.exports = ParseTileLayers;\r\n"]},"metadata":{},"sourceType":"script"}