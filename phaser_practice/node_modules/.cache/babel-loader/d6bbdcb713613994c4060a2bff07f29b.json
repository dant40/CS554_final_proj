{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Benjamin D. Richards <benjamindrichards@gmail.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar CONST = require('./const');\n\nvar Events = require('./events');\n\nvar RadToDeg = require('../../math/RadToDeg');\n\nvar Rectangle = require('../../geom/rectangle/Rectangle');\n\nvar RectangleContains = require('../../geom/rectangle/Contains');\n\nvar Vector2 = require('../../math/Vector2');\n/**\r\n * @classdesc\r\n * A Dynamic Arcade Body.\r\n *\r\n * Its static counterpart is {@link Phaser.Physics.Arcade.StaticBody}.\r\n *\r\n * @class Body\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - The Arcade Physics simulation this Body belongs to.\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object this Body belongs to.\r\n */\n\n\nvar Body = new Class({\n  initialize: function Body(world, gameObject) {\n    var width = gameObject.width ? gameObject.width : 64;\n    var height = gameObject.height ? gameObject.height : 64;\n    /**\r\n     * The Arcade Physics simulation this Body belongs to.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#world\r\n     * @type {Phaser.Physics.Arcade.World}\r\n     * @since 3.0.0\r\n     */\n\n    this.world = world;\n    /**\r\n     * The Game Object this Body belongs to.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#gameObject\r\n     * @type {Phaser.GameObjects.GameObject}\r\n     * @since 3.0.0\r\n     */\n\n    this.gameObject = gameObject;\n    /**\r\n     * Transformations applied to this Body.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#transform\r\n     * @type {object}\r\n     * @since 3.4.0\r\n     */\n\n    this.transform = {\n      x: gameObject.x,\n      y: gameObject.y,\n      rotation: gameObject.angle,\n      scaleX: gameObject.scaleX,\n      scaleY: gameObject.scaleY,\n      displayOriginX: gameObject.displayOriginX,\n      displayOriginY: gameObject.displayOriginY\n    };\n    /**\r\n     * Whether the Body's boundary is drawn to the debug display.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#debugShowBody\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.debugShowBody = world.defaults.debugShowBody;\n    /**\r\n     * Whether the Body's velocity is drawn to the debug display.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#debugShowVelocity\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.debugShowVelocity = world.defaults.debugShowVelocity;\n    /**\r\n     * The color of this Body on the debug display.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#debugBodyColor\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.debugBodyColor = world.defaults.bodyDebugColor;\n    /**\r\n     * Whether this Body is updated by the physics simulation.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#enable\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.enable = true;\n    /**\r\n     * Whether this Body's boundary is circular (true) or rectangular (false).\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#isCircle\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#setCircle\r\n     */\n\n    this.isCircle = false;\n    /**\r\n     * If this Body is circular, this is the unscaled radius of the Body's boundary, as set by setCircle(), in source pixels.\r\n     * The true radius is equal to `halfWidth`.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#radius\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#setCircle\r\n     */\n\n    this.radius = 0;\n    /**\r\n     * The offset of this Body's position from its Game Object's position, in source pixels.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#offset\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#setOffset\r\n     */\n\n    this.offset = new Vector2();\n    /**\r\n     * The position of this Body within the simulation.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#position\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.position = new Vector2(gameObject.x, gameObject.y);\n    /**\r\n     * The position of this Body during the previous step.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#prev\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.prev = new Vector2(gameObject.x, gameObject.y);\n    /**\r\n     * The position of this Body during the previous frame.\r\n     * \r\n     * @name Phaser.Physics.Arcade.Body#prevFrame\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.20.0\r\n     */\n\n    this.prevFrame = new Vector2(gameObject.x, gameObject.y);\n    /**\r\n     * Whether this Body's `rotation` is affected by its angular acceleration and angular velocity.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#allowRotation\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.allowRotation = true;\n    /**\r\n     * This body's rotation, in degrees, based on its angular acceleration and angular velocity.\r\n     * The Body's rotation controls the `angle` of its Game Object.\r\n     * It doesn't rotate the Body's boundary, which is always an axis-aligned rectangle or a circle.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#rotation\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.rotation = gameObject.angle;\n    /**\r\n     * The Body rotation, in degrees, during the previous step.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#preRotation\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.preRotation = gameObject.angle;\n    /**\r\n     * The width of the Body boundary, in pixels.\r\n     * If the Body is circular, this is also the diameter.\r\n     * If you wish to change the width use the `Body.setSize` method.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#width\r\n     * @type {number}\r\n     * @readonly\r\n     * @default 64\r\n     * @since 3.0.0\r\n     */\n\n    this.width = width;\n    /**\r\n     * The height of the Body boundary, in pixels.\r\n     * If the Body is circular, this is also the diameter.\r\n     * If you wish to change the height use the `Body.setSize` method.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#height\r\n     * @type {number}\r\n     * @readonly\r\n     * @default 64\r\n     * @since 3.0.0\r\n     */\n\n    this.height = height;\n    /**\r\n     * The unscaled width of the Body, in source pixels, as set by setSize().\r\n     * The default is the width of the Body's Game Object's texture frame.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#sourceWidth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#setSize\r\n     */\n\n    this.sourceWidth = width;\n    /**\r\n     * The unscaled height of the Body, in source pixels, as set by setSize().\r\n     * The default is the height of the Body's Game Object's texture frame.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#sourceHeight\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#setSize\r\n     */\n\n    this.sourceHeight = height;\n\n    if (gameObject.frame) {\n      this.sourceWidth = gameObject.frame.realWidth;\n      this.sourceHeight = gameObject.frame.realHeight;\n    }\n    /**\r\n     * Half the Body's width, in pixels.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#halfWidth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.halfWidth = Math.abs(width / 2);\n    /**\r\n     * Half the Body's height, in pixels.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#halfHeight\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.halfHeight = Math.abs(height / 2);\n    /**\r\n     * The center of the Body's boundary.\r\n     * The midpoint of its `position` (top-left corner) and its bottom-right corner.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#center\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.center = new Vector2(gameObject.x + this.halfWidth, gameObject.y + this.halfHeight);\n    /**\r\n     * The Body's velocity, in pixels per second.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#velocity\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.velocity = new Vector2();\n    /**\r\n     * The Body's change in position (due to velocity) at the last step, in pixels.\r\n     *\r\n     * The size of this value depends on the simulation's step rate.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#newVelocity\r\n     * @type {Phaser.Math.Vector2}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\n\n    this.newVelocity = new Vector2();\n    /**\r\n     * The Body's absolute maximum change in position, in pixels per step.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#deltaMax\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.deltaMax = new Vector2();\n    /**\r\n     * The Body's change in velocity, in pixels per second squared.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#acceleration\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.acceleration = new Vector2();\n    /**\r\n     * Whether this Body's velocity is affected by its `drag`.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#allowDrag\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.allowDrag = true;\n    /**\r\n     * Absolute loss of velocity due to movement, in pixels per second squared.\r\n     * The x and y components are applied separately.\r\n     *\r\n     * When `useDamping` is true, this is 1 minus the damping factor.\r\n     * A value of 1 means the Body loses no velocity.\r\n     * A value of 0.95 means the Body loses 5% of its velocity per step.\r\n     * A value of 0.5 means the Body loses 50% of its velocity per step.\r\n     *\r\n     * Drag is applied only when `acceleration` is zero.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#drag\r\n     * @type {(Phaser.Math.Vector2|number)}\r\n     * @since 3.0.0\r\n     */\n\n    this.drag = new Vector2();\n    /**\r\n     * Whether this Body's position is affected by gravity (local or world).\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#allowGravity\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#gravity\r\n     * @see Phaser.Physics.Arcade.World#gravity\r\n     */\n\n    this.allowGravity = true;\n    /**\r\n     * Acceleration due to gravity (specific to this Body), in pixels per second squared.\r\n     * Total gravity is the sum of this vector and the simulation's `gravity`.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#gravity\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.World#gravity\r\n     */\n\n    this.gravity = new Vector2();\n    /**\r\n     * Rebound following a collision, relative to 1.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#bounce\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.bounce = new Vector2();\n    /**\r\n     * Rebound following a collision with the world boundary, relative to 1.\r\n     * If null, `bounce` is used instead.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#worldBounce\r\n     * @type {?Phaser.Math.Vector2}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.worldBounce = null;\n    /**\r\n     * The rectangle used for world boundary collisions.\r\n     * \r\n     * By default it is set to the world boundary rectangle. Or, if this Body was\r\n     * created by a Physics Group, then whatever rectangle that Group defined.\r\n     * \r\n     * You can also change it by using the `Body.setBoundsRectangle` method.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#customBoundsRectangle\r\n     * @type {?Phaser.Geom.Rectangle}\r\n     * @since 3.20\r\n     */\n\n    this.customBoundsRectangle = world.bounds; //  If true this Body will dispatch events\n\n    /**\r\n     * Whether the simulation emits a `worldbounds` event when this Body collides with the world boundary (and `collideWorldBounds` is also true).\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#onWorldBounds\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.World#worldboundsEvent\r\n     */\n\n    this.onWorldBounds = false;\n    /**\r\n     * Whether the simulation emits a `collide` event when this Body collides with another.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#onCollide\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.World#collideEvent\r\n     */\n\n    this.onCollide = false;\n    /**\r\n     * Whether the simulation emits an `overlap` event when this Body overlaps with another.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#onOverlap\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.World#overlapEvent\r\n     */\n\n    this.onOverlap = false;\n    /**\r\n     * The Body's absolute maximum velocity, in pixels per second.\r\n     * The horizontal and vertical components are applied separately.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#maxVelocity\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.maxVelocity = new Vector2(10000, 10000);\n    /**\r\n     * The maximum speed this Body is allowed to reach, in pixels per second.\r\n     *\r\n     * If not negative it limits the scalar value of speed.\r\n     *\r\n     * Any negative value means no maximum is being applied (the default).\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#maxSpeed\r\n     * @type {number}\r\n     * @default -1\r\n     * @since 3.16.0\r\n     */\n\n    this.maxSpeed = -1;\n    /**\r\n     * If this Body is `immovable` and in motion, `friction` is the proportion of this Body's motion received by the riding Body on each axis, relative to 1.\r\n     * The horizontal component (x) is applied only when two colliding Bodies are separated vertically.\r\n     * The vertical component (y) is applied only when two colliding Bodies are separated horizontally.\r\n     * The default value (1, 0) moves the riding Body horizontally in equal proportion to this Body and vertically not at all.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#friction\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.friction = new Vector2(1, 0);\n    /**\r\n     * If this Body is using `drag` for deceleration this property controls how the drag is applied.\r\n     * If set to `true` drag will use a damping effect rather than a linear approach. If you are\r\n     * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in\r\n     * the game Asteroids) then you will get a far smoother and more visually correct deceleration\r\n     * by using damping, avoiding the axis-drift that is prone with linear deceleration.\r\n     *\r\n     * If you enable this property then you should use far smaller `drag` values than with linear, as\r\n     * they are used as a multiplier on the velocity. Values such as 0.95 will give a nice slow\r\n     * deceleration, where-as smaller values, such as 0.5 will stop an object almost immediately.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#useDamping\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.10.0\r\n     */\n\n    this.useDamping = false;\n    /**\r\n     * The rate of change of this Body's `rotation`, in degrees per second.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#angularVelocity\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.angularVelocity = 0;\n    /**\r\n     * The Body's angular acceleration (change in angular velocity), in degrees per second squared.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#angularAcceleration\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.angularAcceleration = 0;\n    /**\r\n     * Loss of angular velocity due to angular movement, in degrees per second.\r\n     *\r\n     * Angular drag is applied only when angular acceleration is zero.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#angularDrag\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.angularDrag = 0;\n    /**\r\n     * The Body's maximum angular velocity, in degrees per second.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#maxAngular\r\n     * @type {number}\r\n     * @default 1000\r\n     * @since 3.0.0\r\n     */\n\n    this.maxAngular = 1000;\n    /**\r\n     * The Body's inertia, relative to a default unit (1).\r\n     * With `bounce`, this affects the exchange of momentum (velocities) during collisions.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#mass\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\n\n    this.mass = 1;\n    /**\r\n     * The calculated angle of this Body's velocity vector, in radians, during the last step.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#angle\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.angle = 0;\n    /**\r\n     * The calculated magnitude of the Body's velocity, in pixels per second, during the last step.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#speed\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.speed = 0;\n    /**\r\n     * The direction of the Body's velocity, as calculated during the last step.\r\n     * If the Body is moving on both axes (diagonally), this describes motion on the vertical axis only.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#facing\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.facing = CONST.FACING_NONE;\n    /**\r\n     * Whether this Body can be moved by collisions with another Body.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#immovable\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.immovable = false;\n    /**\r\n     * Whether the Body's position and rotation are affected by its velocity, acceleration, drag, and gravity.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#moves\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.moves = true;\n    /**\r\n     * A flag disabling the default horizontal separation of colliding bodies.\r\n     * Pass your own `collideCallback` to the collider.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#customSeparateX\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.customSeparateX = false;\n    /**\r\n     * A flag disabling the default vertical separation of colliding bodies.\r\n     * Pass your own `collideCallback` to the collider.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#customSeparateY\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.customSeparateY = false;\n    /**\r\n     * The amount of horizontal overlap (before separation), if this Body is colliding with another.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#overlapX\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.overlapX = 0;\n    /**\r\n     * The amount of vertical overlap (before separation), if this Body is colliding with another.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#overlapY\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.overlapY = 0;\n    /**\r\n     * The amount of overlap (before separation), if this Body is circular and colliding with another circular body.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#overlapR\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.overlapR = 0;\n    /**\r\n     * Whether this Body is overlapped with another and both are not moving, on at least one axis.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#embedded\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.embedded = false;\n    /**\r\n     * Whether this Body interacts with the world boundary.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#collideWorldBounds\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.collideWorldBounds = false;\n    /**\r\n     * Whether this Body is checked for collisions and for which directions.\r\n     * You can set `checkCollision.none = true` to disable collision checks.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#checkCollision\r\n     * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\r\n     * @since 3.0.0\r\n     */\n\n    this.checkCollision = {\n      none: false,\n      up: true,\n      down: true,\n      left: true,\n      right: true\n    };\n    /**\r\n     * Whether this Body is colliding with a Body or Static Body and in which direction.\r\n     * In a collision where both bodies have zero velocity, `embedded` will be set instead.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#touching\r\n     * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\r\n     * @since 3.0.0\r\n     *\r\n     * @see Phaser.Physics.Arcade.Body#blocked\r\n     * @see Phaser.Physics.Arcade.Body#embedded\r\n     */\n\n    this.touching = {\n      none: true,\n      up: false,\n      down: false,\n      left: false,\n      right: false\n    };\n    /**\r\n     * This Body's `touching` value during the previous step.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#wasTouching\r\n     * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\r\n     * @since 3.0.0\r\n     *\r\n     * @see Phaser.Physics.Arcade.Body#touching\r\n     */\n\n    this.wasTouching = {\n      none: true,\n      up: false,\n      down: false,\n      left: false,\n      right: false\n    };\n    /**\r\n     * Whether this Body is colliding with a Static Body, a tile, or the world boundary.\r\n     * In a collision with a Static Body, if this Body has zero velocity then `embedded` will be set instead.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#blocked\r\n     * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\r\n     * @since 3.0.0\r\n     *\r\n     * @see Phaser.Physics.Arcade.Body#embedded\r\n     * @see Phaser.Physics.Arcade.Body#touching\r\n     */\n\n    this.blocked = {\n      none: true,\n      up: false,\n      down: false,\n      left: false,\n      right: false\n    };\n    /**\r\n     * Whether to automatically synchronize this Body's dimensions to the dimensions of its Game Object's visual bounds.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#syncBounds\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     * @see Phaser.GameObjects.Components.GetBounds#getBounds\r\n     */\n\n    this.syncBounds = false;\n    /**\r\n     * The Body's physics type (dynamic or static).\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#physicsType\r\n     * @type {integer}\r\n     * @readonly\r\n     * @default Phaser.Physics.Arcade.DYNAMIC_BODY\r\n     * @since 3.0.0\r\n     */\n\n    this.physicsType = CONST.DYNAMIC_BODY;\n    /**\r\n     * Cached horizontal scale of the Body's Game Object.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#_sx\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._sx = gameObject.scaleX;\n    /**\r\n     * Cached vertical scale of the Body's Game Object.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#_sy\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._sy = gameObject.scaleY;\n    /**\r\n     * The calculated change in the Body's horizontal position during the last step.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#_dx\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this._dx = 0;\n    /**\r\n     * The calculated change in the Body's vertical position during the last step.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#_dy\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this._dy = 0;\n    /**\r\n     * The final calculated change in the Body's horizontal position as of `postUpdate`.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#_tx\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.22.0\r\n     */\n\n    this._tx = 0;\n    /**\r\n     * The final calculated change in the Body's vertical position as of `postUpdate`.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#_ty\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.22.0\r\n     */\n\n    this._ty = 0;\n    /**\r\n     * Stores the Game Object's bounds.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#_bounds\r\n     * @type {Phaser.Geom.Rectangle}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._bounds = new Rectangle();\n  },\n\n  /**\r\n   * Updates the Body's `transform`, `width`, `height`, and `center` from its Game Object.\r\n   * The Body's `position` isn't changed.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#updateBounds\r\n   * @since 3.0.0\r\n   */\n  updateBounds: function () {\n    var sprite = this.gameObject; //  Container?\n\n    var transform = this.transform;\n\n    if (sprite.parentContainer) {\n      var matrix = sprite.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2);\n      transform.x = matrix.tx;\n      transform.y = matrix.ty;\n      transform.rotation = RadToDeg(matrix.rotation);\n      transform.scaleX = matrix.scaleX;\n      transform.scaleY = matrix.scaleY;\n      transform.displayOriginX = sprite.displayOriginX;\n      transform.displayOriginY = sprite.displayOriginY;\n    } else {\n      transform.x = sprite.x;\n      transform.y = sprite.y;\n      transform.rotation = sprite.angle;\n      transform.scaleX = sprite.scaleX;\n      transform.scaleY = sprite.scaleY;\n      transform.displayOriginX = sprite.displayOriginX;\n      transform.displayOriginY = sprite.displayOriginY;\n    }\n\n    var recalc = false;\n\n    if (this.syncBounds) {\n      var b = sprite.getBounds(this._bounds);\n      this.width = b.width;\n      this.height = b.height;\n      recalc = true;\n    } else {\n      var asx = Math.abs(transform.scaleX);\n      var asy = Math.abs(transform.scaleY);\n\n      if (this._sx !== asx || this._sy !== asy) {\n        this.width = this.sourceWidth * asx;\n        this.height = this.sourceHeight * asy;\n        this._sx = asx;\n        this._sy = asy;\n        recalc = true;\n      }\n    }\n\n    if (recalc) {\n      this.halfWidth = Math.floor(this.width / 2);\n      this.halfHeight = Math.floor(this.height / 2);\n      this.updateCenter();\n    }\n  },\n\n  /**\r\n   * Updates the Body's `center` from its `position`, `width`, and `height`.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#updateCenter\r\n   * @since 3.0.0\r\n   */\n  updateCenter: function () {\n    this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\n  },\n\n  /**\r\n   * Prepares the Body for a physics step by resetting the `wasTouching`, `touching` and `blocked` states.\r\n   *\r\n   * This method is only called if the physics world is going to run a step this frame.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#resetFlags\r\n   * @since 3.18.0\r\n   */\n  resetFlags: function () {\n    //  Store and reset collision flags\n    this.wasTouching.none = this.touching.none;\n    this.wasTouching.up = this.touching.up;\n    this.wasTouching.down = this.touching.down;\n    this.wasTouching.left = this.touching.left;\n    this.wasTouching.right = this.touching.right;\n    this.touching.none = true;\n    this.touching.up = false;\n    this.touching.down = false;\n    this.touching.left = false;\n    this.touching.right = false;\n    this.blocked.none = true;\n    this.blocked.up = false;\n    this.blocked.down = false;\n    this.blocked.left = false;\n    this.blocked.right = false;\n    this.overlapR = 0;\n    this.overlapX = 0;\n    this.overlapY = 0;\n    this.embedded = false;\n  },\n\n  /**\r\n   * Syncs the position body position with the parent Game Object.\r\n   *\r\n   * This method is called every game frame, regardless if the world steps or not.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#preUpdate\r\n   * @since 3.17.0\r\n   *\r\n   * @param {boolean} willStep - Will this Body run an update as well?\r\n   * @param {number} delta - The delta time, in seconds, elapsed since the last frame.\r\n   */\n  preUpdate: function (willStep, delta) {\n    if (willStep) {\n      this.resetFlags();\n    }\n\n    this.updateBounds();\n    var sprite = this.transform;\n    this.position.x = sprite.x + sprite.scaleX * (this.offset.x - sprite.displayOriginX);\n    this.position.y = sprite.y + sprite.scaleY * (this.offset.y - sprite.displayOriginY);\n    this.updateCenter();\n    this.rotation = sprite.rotation;\n    this.preRotation = this.rotation;\n\n    if (this.moves) {\n      this.prev.x = this.position.x;\n      this.prev.y = this.position.y;\n      this.prevFrame.x = this.position.x;\n      this.prevFrame.y = this.position.y;\n    }\n\n    if (willStep) {\n      this.update(delta);\n    }\n  },\n\n  /**\r\n   * Performs a single physics step and updates the body velocity, angle, speed and other properties.\r\n   *\r\n   * This method can be called multiple times per game frame, depending on the physics step rate.\r\n   *\r\n   * The results are synced back to the Game Object in `postUpdate`.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#update\r\n   * @fires Phaser.Physics.Arcade.Events#WORLD_BOUNDS\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} delta - The delta time, in seconds, elapsed since the last frame.\r\n   */\n  update: function (delta) {\n    this.prev.x = this.position.x;\n    this.prev.y = this.position.y;\n\n    if (this.moves) {\n      this.world.updateMotion(this, delta);\n      var vx = this.velocity.x;\n      var vy = this.velocity.y;\n      this.newVelocity.set(vx * delta, vy * delta);\n      this.position.add(this.newVelocity);\n      this.updateCenter();\n      this.angle = Math.atan2(vy, vx);\n      this.speed = Math.sqrt(vx * vx + vy * vy); //  Now the update will throw collision checks at the Body\n      //  And finally we'll integrate the new position back to the Sprite in postUpdate\n\n      if (this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds) {\n        this.world.emit(Events.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right);\n      }\n    }\n\n    this._dx = this.position.x - this.prev.x;\n    this._dy = this.position.y - this.prev.y;\n  },\n\n  /**\r\n   * Feeds the Body results back into the parent Game Object.\r\n   *\r\n   * This method is called every game frame, regardless if the world steps or not.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#postUpdate\r\n   * @since 3.0.0\r\n   */\n  postUpdate: function () {\n    var dx = this.position.x - this.prevFrame.x;\n    var dy = this.position.y - this.prevFrame.y;\n\n    if (this.moves) {\n      var mx = this.deltaMax.x;\n      var my = this.deltaMax.y;\n\n      if (mx !== 0 && dx !== 0) {\n        if (dx < 0 && dx < -mx) {\n          dx = -mx;\n        } else if (dx > 0 && dx > mx) {\n          dx = mx;\n        }\n      }\n\n      if (my !== 0 && dy !== 0) {\n        if (dy < 0 && dy < -my) {\n          dy = -my;\n        } else if (dy > 0 && dy > my) {\n          dy = my;\n        }\n      }\n\n      this.gameObject.x += dx;\n      this.gameObject.y += dy;\n    }\n\n    if (dx < 0) {\n      this.facing = CONST.FACING_LEFT;\n    } else if (dx > 0) {\n      this.facing = CONST.FACING_RIGHT;\n    }\n\n    if (dy < 0) {\n      this.facing = CONST.FACING_UP;\n    } else if (dy > 0) {\n      this.facing = CONST.FACING_DOWN;\n    }\n\n    if (this.allowRotation) {\n      this.gameObject.angle += this.deltaZ();\n    }\n\n    this._tx = dx;\n    this._ty = dy;\n  },\n\n  /**\r\n   * Sets a custom collision boundary rectangle. Use if you want to have a custom\r\n   * boundary instead of the world boundaries.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setBoundsRectangle\r\n   * @since 3.20\r\n   *\r\n   * @param {?Phaser.Geom.Rectangle} [bounds] - The new boundary rectangle. Pass `null` to use the World bounds.\r\n   * \r\n   * @return {this} This Body object.\r\n   */\n  setBoundsRectangle: function (bounds) {\n    this.customBoundsRectangle = !bounds ? this.world.bounds : bounds;\n    return this;\n  },\n\n  /**\r\n   * Checks for collisions between this Body and the world boundary and separates them.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#checkWorldBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} True if this Body is colliding with the world boundary.\r\n   */\n  checkWorldBounds: function () {\n    var pos = this.position;\n    var bounds = this.customBoundsRectangle;\n    var check = this.world.checkCollision;\n    var bx = this.worldBounce ? -this.worldBounce.x : -this.bounce.x;\n    var by = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;\n    var wasSet = false;\n\n    if (pos.x < bounds.x && check.left) {\n      pos.x = bounds.x;\n      this.velocity.x *= bx;\n      this.blocked.left = true;\n      wasSet = true;\n    } else if (this.right > bounds.right && check.right) {\n      pos.x = bounds.right - this.width;\n      this.velocity.x *= bx;\n      this.blocked.right = true;\n      wasSet = true;\n    }\n\n    if (pos.y < bounds.y && check.up) {\n      pos.y = bounds.y;\n      this.velocity.y *= by;\n      this.blocked.up = true;\n      wasSet = true;\n    } else if (this.bottom > bounds.bottom && check.down) {\n      pos.y = bounds.bottom - this.height;\n      this.velocity.y *= by;\n      this.blocked.down = true;\n      wasSet = true;\n    }\n\n    if (wasSet) {\n      this.blocked.none = false;\n    }\n\n    return wasSet;\n  },\n\n  /**\r\n   * Sets the offset of the Body's position from its Game Object's position.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setOffset\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal offset, in source pixels.\r\n   * @param {number} [y=x] - The vertical offset, in source pixels.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setOffset: function (x, y) {\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.offset.set(x, y);\n    this.updateCenter();\n    return this;\n  },\n\n  /**\r\n   * Sizes and positions this Body's boundary, as a rectangle.\r\n   * Modifies the Body `offset` if `center` is true (the default).\r\n   * Resets the width and height to match current frame, if no width and height provided and a frame is found.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setSize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} [width] - The width of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame width.\r\n   * @param {integer} [height] - The height of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame height.\r\n   * @param {boolean} [center=true] - Modify the Body's `offset`, placing the Body's center on its Game Object's center. Only works if the Game Object has the `getCenter` method.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setSize: function (width, height, center) {\n    if (center === undefined) {\n      center = true;\n    }\n\n    var gameObject = this.gameObject;\n\n    if (!width && gameObject.frame) {\n      width = gameObject.frame.realWidth;\n    }\n\n    if (!height && gameObject.frame) {\n      height = gameObject.frame.realHeight;\n    }\n\n    this.sourceWidth = width;\n    this.sourceHeight = height;\n    this.width = this.sourceWidth * this._sx;\n    this.height = this.sourceHeight * this._sy;\n    this.halfWidth = Math.floor(this.width / 2);\n    this.halfHeight = Math.floor(this.height / 2);\n    this.updateCenter();\n\n    if (center && gameObject.getCenter) {\n      var ox = gameObject.displayWidth / 2;\n      var oy = gameObject.displayHeight / 2;\n      this.offset.set(ox - this.halfWidth, oy - this.halfHeight);\n    }\n\n    this.isCircle = false;\n    this.radius = 0;\n    return this;\n  },\n\n  /**\r\n   * Sizes and positions this Body's boundary, as a circle.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setCircle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} radius - The radius of the Body, in source pixels.\r\n   * @param {number} [offsetX] - The horizontal offset of the Body from its Game Object, in source pixels.\r\n   * @param {number} [offsetY] - The vertical offset of the Body from its Game Object, in source pixels.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setCircle: function (radius, offsetX, offsetY) {\n    if (offsetX === undefined) {\n      offsetX = this.offset.x;\n    }\n\n    if (offsetY === undefined) {\n      offsetY = this.offset.y;\n    }\n\n    if (radius > 0) {\n      this.isCircle = true;\n      this.radius = radius;\n      this.sourceWidth = radius * 2;\n      this.sourceHeight = radius * 2;\n      this.width = this.sourceWidth * this._sx;\n      this.height = this.sourceHeight * this._sy;\n      this.halfWidth = Math.floor(this.width / 2);\n      this.halfHeight = Math.floor(this.height / 2);\n      this.offset.set(offsetX, offsetY);\n      this.updateCenter();\n    } else {\n      this.isCircle = false;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Resets this Body to the given coordinates. Also positions its parent Game Object to the same coordinates.\r\n   * If the Body had any velocity or acceleration it is lost as a result of calling this.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#reset\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal position to place the Game Object and Body.\r\n   * @param {number} y - The vertical position to place the Game Object and Body.\r\n   */\n  reset: function (x, y) {\n    this.stop();\n    var gameObject = this.gameObject;\n    gameObject.setPosition(x, y);\n\n    if (gameObject.getTopLeft) {\n      gameObject.getTopLeft(this.position);\n    } else {\n      this.position.set(x, y);\n    }\n\n    this.prev.copy(this.position);\n    this.prevFrame.copy(this.position);\n    this.rotation = gameObject.angle;\n    this.preRotation = gameObject.angle;\n    this.updateBounds();\n    this.updateCenter();\n  },\n\n  /**\r\n   * Sets acceleration, velocity, and speed to zero.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#stop\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  stop: function () {\n    this.velocity.set(0);\n    this.acceleration.set(0);\n    this.speed = 0;\n    this.angularVelocity = 0;\n    this.angularAcceleration = 0;\n    return this;\n  },\n\n  /**\r\n   * Copies the coordinates of this Body's edges into an object.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#getBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} obj - An object to copy the values into.\r\n   *\r\n   * @return {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} - An object with {x, y, right, bottom}.\r\n   */\n  getBounds: function (obj) {\n    obj.x = this.x;\n    obj.y = this.y;\n    obj.right = this.right;\n    obj.bottom = this.bottom;\n    return obj;\n  },\n\n  /**\r\n   * Tests if the coordinates are within this Body's boundary.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#hitTest\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal coordinate.\r\n   * @param {number} y - The vertical coordinate.\r\n   *\r\n   * @return {boolean} True if (x, y) is within this Body.\r\n   */\n  hitTest: function (x, y) {\n    if (!this.isCircle) {\n      return RectangleContains(this, x, y);\n    } //  Check if x/y are within the bounds first\n\n\n    if (this.radius > 0 && x >= this.left && x <= this.right && y >= this.top && y <= this.bottom) {\n      var dx = (this.center.x - x) * (this.center.x - x);\n      var dy = (this.center.y - y) * (this.center.y - y);\n      return dx + dy <= this.radius * this.radius;\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Whether this Body is touching a tile or the world boundary while moving down.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#onFloor\r\n   * @since 3.0.0\r\n   * @see Phaser.Physics.Arcade.Body#blocked\r\n   *\r\n   * @return {boolean} True if touching.\r\n   */\n  onFloor: function () {\n    return this.blocked.down;\n  },\n\n  /**\r\n   * Whether this Body is touching a tile or the world boundary while moving up.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#onCeiling\r\n   * @since 3.0.0\r\n   * @see Phaser.Physics.Arcade.Body#blocked\r\n   *\r\n   * @return {boolean} True if touching.\r\n   */\n  onCeiling: function () {\n    return this.blocked.up;\n  },\n\n  /**\r\n   * Whether this Body is touching a tile or the world boundary while moving left or right.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#onWall\r\n   * @since 3.0.0\r\n   * @see Phaser.Physics.Arcade.Body#blocked\r\n   *\r\n   * @return {boolean} True if touching.\r\n   */\n  onWall: function () {\n    return this.blocked.left || this.blocked.right;\n  },\n\n  /**\r\n   * The absolute (non-negative) change in this Body's horizontal position from the previous step.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#deltaAbsX\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The delta value.\r\n   */\n  deltaAbsX: function () {\n    return this._dx > 0 ? this._dx : -this._dx;\n  },\n\n  /**\r\n   * The absolute (non-negative) change in this Body's vertical position from the previous step.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#deltaAbsY\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The delta value.\r\n   */\n  deltaAbsY: function () {\n    return this._dy > 0 ? this._dy : -this._dy;\n  },\n\n  /**\r\n   * The change in this Body's horizontal position from the previous step.\r\n   * This value is set during the Body's update phase.\r\n   * \r\n   * As a Body can update multiple times per step this may not hold the final\r\n   * delta value for the Body. In this case, please see the `deltaXFinal` method.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#deltaX\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The delta value.\r\n   */\n  deltaX: function () {\n    return this._dx;\n  },\n\n  /**\r\n   * The change in this Body's vertical position from the previous step.\r\n   * This value is set during the Body's update phase.\r\n   * \r\n   * As a Body can update multiple times per step this may not hold the final\r\n   * delta value for the Body. In this case, please see the `deltaYFinal` method.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#deltaY\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The delta value.\r\n   */\n  deltaY: function () {\n    return this._dy;\n  },\n\n  /**\r\n   * The change in this Body's horizontal position from the previous game update.\r\n   * \r\n   * This value is set during the `postUpdate` phase and takes into account the\r\n   * `deltaMax` and final position of the Body.\r\n   * \r\n   * Because this value is not calculated until `postUpdate`, you must listen for it\r\n   * during a Scene `POST_UPDATE` or `RENDER` event, and not in `update`, as it will\r\n   * not be calculated by that point. If you _do_ use these values in `update` they\r\n   * will represent the delta from the _previous_ game frame.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#deltaXFinal\r\n   * @since 3.22.0\r\n   *\r\n   * @return {number} The final delta x value.\r\n   */\n  deltaXFinal: function () {\n    return this._tx;\n  },\n\n  /**\r\n   * The change in this Body's vertical position from the previous game update.\r\n   * \r\n   * This value is set during the `postUpdate` phase and takes into account the\r\n   * `deltaMax` and final position of the Body.\r\n   * \r\n   * Because this value is not calculated until `postUpdate`, you must listen for it\r\n   * during a Scene `POST_UPDATE` or `RENDER` event, and not in `update`, as it will\r\n   * not be calculated by that point. If you _do_ use these values in `update` they\r\n   * will represent the delta from the _previous_ game frame.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#deltaYFinal\r\n   * @since 3.22.0\r\n   *\r\n   * @return {number} The final delta y value.\r\n   */\n  deltaYFinal: function () {\n    return this._ty;\n  },\n\n  /**\r\n   * The change in this Body's rotation from the previous step, in degrees.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#deltaZ\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The delta value.\r\n   */\n  deltaZ: function () {\n    return this.rotation - this.preRotation;\n  },\n\n  /**\r\n   * Disables this Body and marks it for deletion by the simulation.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.enable = false;\n\n    if (this.world) {\n      this.world.pendingDestroy.set(this);\n    }\n  },\n\n  /**\r\n   * Draws this Body's boundary and velocity, if enabled.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#drawDebug\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Graphics} graphic - The Graphics object to draw on.\r\n   */\n  drawDebug: function (graphic) {\n    var pos = this.position;\n    var x = pos.x + this.halfWidth;\n    var y = pos.y + this.halfHeight;\n\n    if (this.debugShowBody) {\n      graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor);\n\n      if (this.isCircle) {\n        graphic.strokeCircle(x, y, this.width / 2);\n      } else {\n        //  Only draw the sides where checkCollision is true, similar to debugger in layer\n        if (this.checkCollision.up) {\n          graphic.lineBetween(pos.x, pos.y, pos.x + this.width, pos.y);\n        }\n\n        if (this.checkCollision.right) {\n          graphic.lineBetween(pos.x + this.width, pos.y, pos.x + this.width, pos.y + this.height);\n        }\n\n        if (this.checkCollision.down) {\n          graphic.lineBetween(pos.x, pos.y + this.height, pos.x + this.width, pos.y + this.height);\n        }\n\n        if (this.checkCollision.left) {\n          graphic.lineBetween(pos.x, pos.y, pos.x, pos.y + this.height);\n        }\n      }\n    }\n\n    if (this.debugShowVelocity) {\n      graphic.lineStyle(graphic.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1);\n      graphic.lineBetween(x, y, x + this.velocity.x / 2, y + this.velocity.y / 2);\n    }\n  },\n\n  /**\r\n   * Whether this Body will be drawn to the debug display.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#willDrawDebug\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} True if either `debugShowBody` or `debugShowVelocity` are enabled.\r\n   */\n  willDrawDebug: function () {\n    return this.debugShowBody || this.debugShowVelocity;\n  },\n\n  /**\r\n   * Sets whether this Body collides with the world boundary.\r\n   *\r\n   * Optionally also sets the World Bounce values. If the `Body.worldBounce` is null, it's set to a new Phaser.Math.Vector2 first.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setCollideWorldBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [value=true] - `true` if this body should collide with the world bounds, otherwise `false`.\r\n   * @param {number} [bounceX] - If given this will be replace the `worldBounce.x` value.\r\n   * @param {number} [bounceY] - If given this will be replace the `worldBounce.y` value.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setCollideWorldBounds: function (value, bounceX, bounceY) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.collideWorldBounds = value;\n    var setBounceX = bounceX !== undefined;\n    var setBounceY = bounceY !== undefined;\n\n    if (setBounceX || setBounceY) {\n      if (!this.worldBounce) {\n        this.worldBounce = new Vector2();\n      }\n\n      if (setBounceX) {\n        this.worldBounce.x = bounceX;\n      }\n\n      if (setBounceY) {\n        this.worldBounce.y = bounceY;\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's velocity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setVelocity\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal velocity, in pixels per second.\r\n   * @param {number} [y=x] - The vertical velocity, in pixels per second.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setVelocity: function (x, y) {\n    this.velocity.set(x, y);\n    x = this.velocity.x;\n    y = this.velocity.y;\n    this.speed = Math.sqrt(x * x + y * y);\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's horizontal velocity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setVelocityX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The velocity, in pixels per second.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setVelocityX: function (value) {\n    this.velocity.x = value;\n    var x = value;\n    var y = this.velocity.y;\n    this.speed = Math.sqrt(x * x + y * y);\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's vertical velocity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setVelocityY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The velocity, in pixels per second.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setVelocityY: function (value) {\n    this.velocity.y = value;\n    var x = this.velocity.x;\n    var y = value;\n    this.speed = Math.sqrt(x * x + y * y);\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's maximum velocity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setMaxVelocity\r\n   * @since 3.10.0\r\n   *\r\n   * @param {number} x - The horizontal velocity, in pixels per second.\r\n   * @param {number} [y=x] - The vertical velocity, in pixels per second.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setMaxVelocity: function (x, y) {\n    this.maxVelocity.set(x, y);\n    return this;\n  },\n\n  /**\r\n   * Sets the maximum speed the Body can move.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setMaxSpeed\r\n   * @since 3.16.0\r\n   *\r\n   * @param {number} value - The maximum speed value, in pixels per second. Set to a negative value to disable.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setMaxSpeed: function (value) {\n    this.maxSpeed = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's bounce.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setBounce\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal bounce, relative to 1.\r\n   * @param {number} y - The vertical bounce, relative to 1.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setBounce: function (x, y) {\n    this.bounce.set(x, y);\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's horizontal bounce.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setBounceX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The bounce, relative to 1.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setBounceX: function (value) {\n    this.bounce.x = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's vertical bounce.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setBounceY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The bounce, relative to 1.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setBounceY: function (value) {\n    this.bounce.y = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's acceleration.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAcceleration\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal component, in pixels per second squared.\r\n   * @param {number} y - The vertical component, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAcceleration: function (x, y) {\n    this.acceleration.set(x, y);\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's horizontal acceleration.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAccelerationX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The acceleration, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAccelerationX: function (value) {\n    this.acceleration.x = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's vertical acceleration.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAccelerationY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The acceleration, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAccelerationY: function (value) {\n    this.acceleration.y = value;\n    return this;\n  },\n\n  /**\r\n   * Enables or disables drag.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAllowDrag\r\n   * @since 3.9.0\r\n   * @see Phaser.Physics.Arcade.Body#allowDrag\r\n   *\r\n   * @param {boolean} [value=true] - `true` to allow drag on this body, or `false` to disable it.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAllowDrag: function (value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.allowDrag = value;\n    return this;\n  },\n\n  /**\r\n   * Enables or disables gravity's effect on this Body.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAllowGravity\r\n   * @since 3.9.0\r\n   * @see Phaser.Physics.Arcade.Body#allowGravity\r\n   *\r\n   * @param {boolean} [value=true] - `true` to allow gravity on this body, or `false` to disable it.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAllowGravity: function (value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.allowGravity = value;\n    return this;\n  },\n\n  /**\r\n   * Enables or disables rotation.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAllowRotation\r\n   * @since 3.9.0\r\n   * @see Phaser.Physics.Arcade.Body#allowRotation\r\n   *\r\n   * @param {boolean} [value=true] - `true` to allow rotation on this body, or `false` to disable it.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAllowRotation: function (value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.allowRotation = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's drag.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setDrag\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal component, in pixels per second squared.\r\n   * @param {number} y - The vertical component, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setDrag: function (x, y) {\n    this.drag.set(x, y);\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's horizontal drag.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setDragX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The drag, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setDragX: function (value) {\n    this.drag.x = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's vertical drag.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setDragY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The drag, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setDragY: function (value) {\n    this.drag.y = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's gravity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setGravity\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal component, in pixels per second squared.\r\n   * @param {number} y - The vertical component, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setGravity: function (x, y) {\n    this.gravity.set(x, y);\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's horizontal gravity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setGravityX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The gravity, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setGravityX: function (value) {\n    this.gravity.x = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's vertical gravity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setGravityY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The gravity, in pixels per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setGravityY: function (value) {\n    this.gravity.y = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's friction.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setFriction\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal component, relative to 1.\r\n   * @param {number} y - The vertical component, relative to 1.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setFriction: function (x, y) {\n    this.friction.set(x, y);\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's horizontal friction.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setFrictionX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The friction value, relative to 1.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setFrictionX: function (value) {\n    this.friction.x = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's vertical friction.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setFrictionY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The friction value, relative to 1.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setFrictionY: function (value) {\n    this.friction.y = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's angular velocity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAngularVelocity\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The velocity, in degrees per second.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAngularVelocity: function (value) {\n    this.angularVelocity = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's angular acceleration.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAngularAcceleration\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The acceleration, in degrees per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAngularAcceleration: function (value) {\n    this.angularAcceleration = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's angular drag.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setAngularDrag\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The drag, in degrees per second squared.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setAngularDrag: function (value) {\n    this.angularDrag = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's mass.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setMass\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The mass value, relative to 1.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setMass: function (value) {\n    this.mass = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's `immovable` property.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setImmovable\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [value=true] - The value to assign to `immovable`.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setImmovable: function (value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.immovable = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Body's `enable` property.\r\n   *\r\n   * @method Phaser.Physics.Arcade.Body#setEnable\r\n   * @since 3.15.0\r\n   *\r\n   * @param {boolean} [value=true] - The value to assign to `enable`.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n   */\n  setEnable: function (value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.enable = value;\n    return this;\n  },\n\n  /**\r\n   * The Body's horizontal position (left edge).\r\n   *\r\n   * @name Phaser.Physics.Arcade.Body#x\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  x: {\n    get: function () {\n      return this.position.x;\n    },\n    set: function (value) {\n      this.position.x = value;\n    }\n  },\n\n  /**\r\n   * The Body's vertical position (top edge).\r\n   *\r\n   * @name Phaser.Physics.Arcade.Body#y\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  y: {\n    get: function () {\n      return this.position.y;\n    },\n    set: function (value) {\n      this.position.y = value;\n    }\n  },\n\n  /**\r\n   * The left edge of the Body's boundary. Identical to x.\r\n   *\r\n   * @name Phaser.Physics.Arcade.Body#left\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  left: {\n    get: function () {\n      return this.position.x;\n    }\n  },\n\n  /**\r\n   * The right edge of the Body's boundary.\r\n   *\r\n   * @name Phaser.Physics.Arcade.Body#right\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  right: {\n    get: function () {\n      return this.position.x + this.width;\n    }\n  },\n\n  /**\r\n   * The top edge of the Body's boundary. Identical to y.\r\n   *\r\n   * @name Phaser.Physics.Arcade.Body#top\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  top: {\n    get: function () {\n      return this.position.y;\n    }\n  },\n\n  /**\r\n   * The bottom edge of this Body's boundary.\r\n   *\r\n   * @name Phaser.Physics.Arcade.Body#bottom\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  bottom: {\n    get: function () {\n      return this.position.y + this.height;\n    }\n  }\n});\nmodule.exports = Body;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/arcade/Body.js"],"names":["Class","require","CONST","Events","RadToDeg","Rectangle","RectangleContains","Vector2","Body","initialize","world","gameObject","width","height","transform","x","y","rotation","angle","scaleX","scaleY","displayOriginX","displayOriginY","debugShowBody","defaults","debugShowVelocity","debugBodyColor","bodyDebugColor","enable","isCircle","radius","offset","position","prev","prevFrame","allowRotation","preRotation","sourceWidth","sourceHeight","frame","realWidth","realHeight","halfWidth","Math","abs","halfHeight","center","velocity","newVelocity","deltaMax","acceleration","allowDrag","drag","allowGravity","gravity","bounce","worldBounce","customBoundsRectangle","bounds","onWorldBounds","onCollide","onOverlap","maxVelocity","maxSpeed","friction","useDamping","angularVelocity","angularAcceleration","angularDrag","maxAngular","mass","speed","facing","FACING_NONE","immovable","moves","customSeparateX","customSeparateY","overlapX","overlapY","overlapR","embedded","collideWorldBounds","checkCollision","none","up","down","left","right","touching","wasTouching","blocked","syncBounds","physicsType","DYNAMIC_BODY","_sx","_sy","_dx","_dy","_tx","_ty","_bounds","updateBounds","sprite","parentContainer","matrix","getWorldTransformMatrix","_tempMatrix","_tempMatrix2","tx","ty","recalc","b","getBounds","asx","asy","floor","updateCenter","set","resetFlags","preUpdate","willStep","delta","update","updateMotion","vx","vy","add","atan2","sqrt","checkWorldBounds","emit","WORLD_BOUNDS","postUpdate","dx","dy","mx","my","FACING_LEFT","FACING_RIGHT","FACING_UP","FACING_DOWN","deltaZ","setBoundsRectangle","pos","check","bx","by","wasSet","bottom","setOffset","undefined","setSize","getCenter","ox","displayWidth","oy","displayHeight","setCircle","offsetX","offsetY","reset","stop","setPosition","getTopLeft","copy","obj","hitTest","top","onFloor","onCeiling","onWall","deltaAbsX","deltaAbsY","deltaX","deltaY","deltaXFinal","deltaYFinal","destroy","pendingDestroy","drawDebug","graphic","lineStyle","defaultStrokeWidth","strokeCircle","lineBetween","velocityDebugColor","willDrawDebug","setCollideWorldBounds","value","bounceX","bounceY","setBounceX","setBounceY","setVelocity","setVelocityX","setVelocityY","setMaxVelocity","setMaxSpeed","setBounce","setAcceleration","setAccelerationX","setAccelerationY","setAllowDrag","setAllowGravity","setAllowRotation","setDrag","setDragX","setDragY","setGravity","setGravityX","setGravityY","setFriction","setFrictionX","setFrictionY","setAngularVelocity","setAngularAcceleration","setAngularDrag","setMass","setImmovable","setEnable","get","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Benjamin D. Richards <benjamindrichards@gmail.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('./const');\r\nvar Events = require('./events');\r\nvar RadToDeg = require('../../math/RadToDeg');\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar RectangleContains = require('../../geom/rectangle/Contains');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Dynamic Arcade Body.\r\n *\r\n * Its static counterpart is {@link Phaser.Physics.Arcade.StaticBody}.\r\n *\r\n * @class Body\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - The Arcade Physics simulation this Body belongs to.\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object this Body belongs to.\r\n */\r\nvar Body = new Class({\r\n\r\n    initialize:\r\n\r\n    function Body (world, gameObject)\r\n    {\r\n        var width = (gameObject.width) ? gameObject.width : 64;\r\n        var height = (gameObject.height) ? gameObject.height : 64;\r\n\r\n        /**\r\n         * The Arcade Physics simulation this Body belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        /**\r\n         * The Game Object this Body belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#gameObject\r\n         * @type {Phaser.GameObjects.GameObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.gameObject = gameObject;\r\n\r\n        /**\r\n         * Transformations applied to this Body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#transform\r\n         * @type {object}\r\n         * @since 3.4.0\r\n         */\r\n        this.transform = {\r\n            x: gameObject.x,\r\n            y: gameObject.y,\r\n            rotation: gameObject.angle,\r\n            scaleX: gameObject.scaleX,\r\n            scaleY: gameObject.scaleY,\r\n            displayOriginX: gameObject.displayOriginX,\r\n            displayOriginY: gameObject.displayOriginY\r\n        };\r\n\r\n        /**\r\n         * Whether the Body's boundary is drawn to the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#debugShowBody\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugShowBody = world.defaults.debugShowBody;\r\n\r\n        /**\r\n         * Whether the Body's velocity is drawn to the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#debugShowVelocity\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugShowVelocity = world.defaults.debugShowVelocity;\r\n\r\n        /**\r\n         * The color of this Body on the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#debugBodyColor\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugBodyColor = world.defaults.bodyDebugColor;\r\n\r\n        /**\r\n         * Whether this Body is updated by the physics simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#enable\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enable = true;\r\n\r\n        /**\r\n         * Whether this Body's boundary is circular (true) or rectangular (false).\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#isCircle\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#setCircle\r\n         */\r\n        this.isCircle = false;\r\n\r\n        /**\r\n         * If this Body is circular, this is the unscaled radius of the Body's boundary, as set by setCircle(), in source pixels.\r\n         * The true radius is equal to `halfWidth`.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#radius\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#setCircle\r\n         */\r\n        this.radius = 0;\r\n\r\n        /**\r\n         * The offset of this Body's position from its Game Object's position, in source pixels.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#offset\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#setOffset\r\n         */\r\n        this.offset = new Vector2();\r\n\r\n        /**\r\n         * The position of this Body within the simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#position\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.position = new Vector2(gameObject.x, gameObject.y);\r\n\r\n        /**\r\n         * The position of this Body during the previous step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#prev\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.prev = new Vector2(gameObject.x, gameObject.y);\r\n\r\n        /**\r\n         * The position of this Body during the previous frame.\r\n         * \r\n         * @name Phaser.Physics.Arcade.Body#prevFrame\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.20.0\r\n         */\r\n        this.prevFrame = new Vector2(gameObject.x, gameObject.y);\r\n\r\n        /**\r\n         * Whether this Body's `rotation` is affected by its angular acceleration and angular velocity.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#allowRotation\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.allowRotation = true;\r\n\r\n        /**\r\n         * This body's rotation, in degrees, based on its angular acceleration and angular velocity.\r\n         * The Body's rotation controls the `angle` of its Game Object.\r\n         * It doesn't rotate the Body's boundary, which is always an axis-aligned rectangle or a circle.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#rotation\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.rotation = gameObject.angle;\r\n\r\n        /**\r\n         * The Body rotation, in degrees, during the previous step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#preRotation\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.preRotation = gameObject.angle;\r\n\r\n        /**\r\n         * The width of the Body boundary, in pixels.\r\n         * If the Body is circular, this is also the diameter.\r\n         * If you wish to change the width use the `Body.setSize` method.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#width\r\n         * @type {number}\r\n         * @readonly\r\n         * @default 64\r\n         * @since 3.0.0\r\n         */\r\n        this.width = width;\r\n\r\n        /**\r\n         * The height of the Body boundary, in pixels.\r\n         * If the Body is circular, this is also the diameter.\r\n         * If you wish to change the height use the `Body.setSize` method.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#height\r\n         * @type {number}\r\n         * @readonly\r\n         * @default 64\r\n         * @since 3.0.0\r\n         */\r\n        this.height = height;\r\n\r\n        /**\r\n         * The unscaled width of the Body, in source pixels, as set by setSize().\r\n         * The default is the width of the Body's Game Object's texture frame.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#sourceWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#setSize\r\n         */\r\n        this.sourceWidth = width;\r\n\r\n        /**\r\n         * The unscaled height of the Body, in source pixels, as set by setSize().\r\n         * The default is the height of the Body's Game Object's texture frame.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#sourceHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#setSize\r\n         */\r\n        this.sourceHeight = height;\r\n\r\n        if (gameObject.frame)\r\n        {\r\n            this.sourceWidth = gameObject.frame.realWidth;\r\n            this.sourceHeight = gameObject.frame.realHeight;\r\n        }\r\n\r\n        /**\r\n         * Half the Body's width, in pixels.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#halfWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.halfWidth = Math.abs(width / 2);\r\n\r\n        /**\r\n         * Half the Body's height, in pixels.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#halfHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.halfHeight = Math.abs(height / 2);\r\n\r\n        /**\r\n         * The center of the Body's boundary.\r\n         * The midpoint of its `position` (top-left corner) and its bottom-right corner.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#center\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.center = new Vector2(gameObject.x + this.halfWidth, gameObject.y + this.halfHeight);\r\n\r\n        /**\r\n         * The Body's velocity, in pixels per second.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#velocity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.velocity = new Vector2();\r\n\r\n        /**\r\n         * The Body's change in position (due to velocity) at the last step, in pixels.\r\n         *\r\n         * The size of this value depends on the simulation's step rate.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#newVelocity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.newVelocity = new Vector2();\r\n\r\n        /**\r\n         * The Body's absolute maximum change in position, in pixels per step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#deltaMax\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.deltaMax = new Vector2();\r\n\r\n        /**\r\n         * The Body's change in velocity, in pixels per second squared.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#acceleration\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.acceleration = new Vector2();\r\n\r\n        /**\r\n         * Whether this Body's velocity is affected by its `drag`.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#allowDrag\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.allowDrag = true;\r\n\r\n        /**\r\n         * Absolute loss of velocity due to movement, in pixels per second squared.\r\n         * The x and y components are applied separately.\r\n         *\r\n         * When `useDamping` is true, this is 1 minus the damping factor.\r\n         * A value of 1 means the Body loses no velocity.\r\n         * A value of 0.95 means the Body loses 5% of its velocity per step.\r\n         * A value of 0.5 means the Body loses 50% of its velocity per step.\r\n         *\r\n         * Drag is applied only when `acceleration` is zero.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#drag\r\n         * @type {(Phaser.Math.Vector2|number)}\r\n         * @since 3.0.0\r\n         */\r\n        this.drag = new Vector2();\r\n\r\n        /**\r\n         * Whether this Body's position is affected by gravity (local or world).\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#allowGravity\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#gravity\r\n         * @see Phaser.Physics.Arcade.World#gravity\r\n         */\r\n        this.allowGravity = true;\r\n\r\n        /**\r\n         * Acceleration due to gravity (specific to this Body), in pixels per second squared.\r\n         * Total gravity is the sum of this vector and the simulation's `gravity`.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#gravity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.World#gravity\r\n         */\r\n        this.gravity = new Vector2();\r\n\r\n        /**\r\n         * Rebound following a collision, relative to 1.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#bounce\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.bounce = new Vector2();\r\n\r\n        /**\r\n         * Rebound following a collision with the world boundary, relative to 1.\r\n         * If null, `bounce` is used instead.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#worldBounce\r\n         * @type {?Phaser.Math.Vector2}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.worldBounce = null;\r\n\r\n        /**\r\n         * The rectangle used for world boundary collisions.\r\n         * \r\n         * By default it is set to the world boundary rectangle. Or, if this Body was\r\n         * created by a Physics Group, then whatever rectangle that Group defined.\r\n         * \r\n         * You can also change it by using the `Body.setBoundsRectangle` method.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#customBoundsRectangle\r\n         * @type {?Phaser.Geom.Rectangle}\r\n         * @since 3.20\r\n         */\r\n        this.customBoundsRectangle = world.bounds;\r\n\r\n        //  If true this Body will dispatch events\r\n\r\n        /**\r\n         * Whether the simulation emits a `worldbounds` event when this Body collides with the world boundary (and `collideWorldBounds` is also true).\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#onWorldBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.World#worldboundsEvent\r\n         */\r\n        this.onWorldBounds = false;\r\n\r\n        /**\r\n         * Whether the simulation emits a `collide` event when this Body collides with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#onCollide\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.World#collideEvent\r\n         */\r\n        this.onCollide = false;\r\n\r\n        /**\r\n         * Whether the simulation emits an `overlap` event when this Body overlaps with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#onOverlap\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.World#overlapEvent\r\n         */\r\n        this.onOverlap = false;\r\n\r\n        /**\r\n         * The Body's absolute maximum velocity, in pixels per second.\r\n         * The horizontal and vertical components are applied separately.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#maxVelocity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.maxVelocity = new Vector2(10000, 10000);\r\n\r\n        /**\r\n         * The maximum speed this Body is allowed to reach, in pixels per second.\r\n         *\r\n         * If not negative it limits the scalar value of speed.\r\n         *\r\n         * Any negative value means no maximum is being applied (the default).\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#maxSpeed\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.16.0\r\n         */\r\n        this.maxSpeed = -1;\r\n\r\n        /**\r\n         * If this Body is `immovable` and in motion, `friction` is the proportion of this Body's motion received by the riding Body on each axis, relative to 1.\r\n         * The horizontal component (x) is applied only when two colliding Bodies are separated vertically.\r\n         * The vertical component (y) is applied only when two colliding Bodies are separated horizontally.\r\n         * The default value (1, 0) moves the riding Body horizontally in equal proportion to this Body and vertically not at all.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#friction\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.friction = new Vector2(1, 0);\r\n\r\n        /**\r\n         * If this Body is using `drag` for deceleration this property controls how the drag is applied.\r\n         * If set to `true` drag will use a damping effect rather than a linear approach. If you are\r\n         * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in\r\n         * the game Asteroids) then you will get a far smoother and more visually correct deceleration\r\n         * by using damping, avoiding the axis-drift that is prone with linear deceleration.\r\n         *\r\n         * If you enable this property then you should use far smaller `drag` values than with linear, as\r\n         * they are used as a multiplier on the velocity. Values such as 0.95 will give a nice slow\r\n         * deceleration, where-as smaller values, such as 0.5 will stop an object almost immediately.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#useDamping\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.10.0\r\n         */\r\n        this.useDamping = false;\r\n\r\n        /**\r\n         * The rate of change of this Body's `rotation`, in degrees per second.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#angularVelocity\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.angularVelocity = 0;\r\n\r\n        /**\r\n         * The Body's angular acceleration (change in angular velocity), in degrees per second squared.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#angularAcceleration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.angularAcceleration = 0;\r\n\r\n        /**\r\n         * Loss of angular velocity due to angular movement, in degrees per second.\r\n         *\r\n         * Angular drag is applied only when angular acceleration is zero.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#angularDrag\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.angularDrag = 0;\r\n\r\n        /**\r\n         * The Body's maximum angular velocity, in degrees per second.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#maxAngular\r\n         * @type {number}\r\n         * @default 1000\r\n         * @since 3.0.0\r\n         */\r\n        this.maxAngular = 1000;\r\n\r\n        /**\r\n         * The Body's inertia, relative to a default unit (1).\r\n         * With `bounce`, this affects the exchange of momentum (velocities) during collisions.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#mass\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.mass = 1;\r\n\r\n        /**\r\n         * The calculated angle of this Body's velocity vector, in radians, during the last step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#angle\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.angle = 0;\r\n\r\n        /**\r\n         * The calculated magnitude of the Body's velocity, in pixels per second, during the last step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#speed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.speed = 0;\r\n\r\n        /**\r\n         * The direction of the Body's velocity, as calculated during the last step.\r\n         * If the Body is moving on both axes (diagonally), this describes motion on the vertical axis only.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#facing\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.facing = CONST.FACING_NONE;\r\n\r\n        /**\r\n         * Whether this Body can be moved by collisions with another Body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#immovable\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.immovable = false;\r\n\r\n        /**\r\n         * Whether the Body's position and rotation are affected by its velocity, acceleration, drag, and gravity.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#moves\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.moves = true;\r\n\r\n        /**\r\n         * A flag disabling the default horizontal separation of colliding bodies.\r\n         * Pass your own `collideCallback` to the collider.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#customSeparateX\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.customSeparateX = false;\r\n\r\n        /**\r\n         * A flag disabling the default vertical separation of colliding bodies.\r\n         * Pass your own `collideCallback` to the collider.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#customSeparateY\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.customSeparateY = false;\r\n\r\n        /**\r\n         * The amount of horizontal overlap (before separation), if this Body is colliding with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#overlapX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.overlapX = 0;\r\n\r\n        /**\r\n         * The amount of vertical overlap (before separation), if this Body is colliding with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#overlapY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.overlapY = 0;\r\n\r\n        /**\r\n         * The amount of overlap (before separation), if this Body is circular and colliding with another circular body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#overlapR\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.overlapR = 0;\r\n\r\n        /**\r\n         * Whether this Body is overlapped with another and both are not moving, on at least one axis.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#embedded\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.embedded = false;\r\n\r\n        /**\r\n         * Whether this Body interacts with the world boundary.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#collideWorldBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.collideWorldBounds = false;\r\n\r\n        /**\r\n         * Whether this Body is checked for collisions and for which directions.\r\n         * You can set `checkCollision.none = true` to disable collision checks.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#checkCollision\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */\r\n        this.checkCollision = { none: false, up: true, down: true, left: true, right: true };\r\n\r\n        /**\r\n         * Whether this Body is colliding with a Body or Static Body and in which direction.\r\n         * In a collision where both bodies have zero velocity, `embedded` will be set instead.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#touching\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         *\r\n         * @see Phaser.Physics.Arcade.Body#blocked\r\n         * @see Phaser.Physics.Arcade.Body#embedded\r\n         */\r\n        this.touching = { none: true, up: false, down: false, left: false, right: false };\r\n\r\n        /**\r\n         * This Body's `touching` value during the previous step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#wasTouching\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         *\r\n         * @see Phaser.Physics.Arcade.Body#touching\r\n         */\r\n        this.wasTouching = { none: true, up: false, down: false, left: false, right: false };\r\n\r\n        /**\r\n         * Whether this Body is colliding with a Static Body, a tile, or the world boundary.\r\n         * In a collision with a Static Body, if this Body has zero velocity then `embedded` will be set instead.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#blocked\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         *\r\n         * @see Phaser.Physics.Arcade.Body#embedded\r\n         * @see Phaser.Physics.Arcade.Body#touching\r\n         */\r\n        this.blocked = { none: true, up: false, down: false, left: false, right: false };\r\n\r\n        /**\r\n         * Whether to automatically synchronize this Body's dimensions to the dimensions of its Game Object's visual bounds.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#syncBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Components.GetBounds#getBounds\r\n         */\r\n        this.syncBounds = false;\r\n\r\n        /**\r\n         * The Body's physics type (dynamic or static).\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#physicsType\r\n         * @type {integer}\r\n         * @readonly\r\n         * @default Phaser.Physics.Arcade.DYNAMIC_BODY\r\n         * @since 3.0.0\r\n         */\r\n        this.physicsType = CONST.DYNAMIC_BODY;\r\n\r\n        /**\r\n         * Cached horizontal scale of the Body's Game Object.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_sx\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._sx = gameObject.scaleX;\r\n\r\n        /**\r\n         * Cached vertical scale of the Body's Game Object.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_sy\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._sy = gameObject.scaleY;\r\n\r\n        /**\r\n         * The calculated change in the Body's horizontal position during the last step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_dx\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._dx = 0;\r\n\r\n        /**\r\n         * The calculated change in the Body's vertical position during the last step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_dy\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._dy = 0;\r\n\r\n        /**\r\n         * The final calculated change in the Body's horizontal position as of `postUpdate`.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_tx\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.22.0\r\n         */\r\n        this._tx = 0;\r\n\r\n        /**\r\n         * The final calculated change in the Body's vertical position as of `postUpdate`.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_ty\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.22.0\r\n         */\r\n        this._ty = 0;\r\n\r\n        /**\r\n         * Stores the Game Object's bounds.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_bounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._bounds = new Rectangle();\r\n    },\r\n\r\n    /**\r\n     * Updates the Body's `transform`, `width`, `height`, and `center` from its Game Object.\r\n     * The Body's `position` isn't changed.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#updateBounds\r\n     * @since 3.0.0\r\n     */\r\n    updateBounds: function ()\r\n    {\r\n        var sprite = this.gameObject;\r\n\r\n        //  Container?\r\n\r\n        var transform = this.transform;\r\n\r\n        if (sprite.parentContainer)\r\n        {\r\n            var matrix = sprite.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2);\r\n\r\n            transform.x = matrix.tx;\r\n            transform.y = matrix.ty;\r\n            transform.rotation = RadToDeg(matrix.rotation);\r\n            transform.scaleX = matrix.scaleX;\r\n            transform.scaleY = matrix.scaleY;\r\n            transform.displayOriginX = sprite.displayOriginX;\r\n            transform.displayOriginY = sprite.displayOriginY;\r\n        }\r\n        else\r\n        {\r\n            transform.x = sprite.x;\r\n            transform.y = sprite.y;\r\n            transform.rotation = sprite.angle;\r\n            transform.scaleX = sprite.scaleX;\r\n            transform.scaleY = sprite.scaleY;\r\n            transform.displayOriginX = sprite.displayOriginX;\r\n            transform.displayOriginY = sprite.displayOriginY;\r\n        }\r\n\r\n        var recalc = false;\r\n\r\n        if (this.syncBounds)\r\n        {\r\n            var b = sprite.getBounds(this._bounds);\r\n\r\n            this.width = b.width;\r\n            this.height = b.height;\r\n            recalc = true;\r\n        }\r\n        else\r\n        {\r\n            var asx = Math.abs(transform.scaleX);\r\n            var asy = Math.abs(transform.scaleY);\r\n\r\n            if (this._sx !== asx || this._sy !== asy)\r\n            {\r\n                this.width = this.sourceWidth * asx;\r\n                this.height = this.sourceHeight * asy;\r\n                this._sx = asx;\r\n                this._sy = asy;\r\n                recalc = true;\r\n            }\r\n        }\r\n\r\n        if (recalc)\r\n        {\r\n            this.halfWidth = Math.floor(this.width / 2);\r\n            this.halfHeight = Math.floor(this.height / 2);\r\n            this.updateCenter();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Updates the Body's `center` from its `position`, `width`, and `height`.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#updateCenter\r\n     * @since 3.0.0\r\n     */\r\n    updateCenter: function ()\r\n    {\r\n        this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\r\n    },\r\n\r\n    /**\r\n     * Prepares the Body for a physics step by resetting the `wasTouching`, `touching` and `blocked` states.\r\n     *\r\n     * This method is only called if the physics world is going to run a step this frame.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#resetFlags\r\n     * @since 3.18.0\r\n     */\r\n    resetFlags: function ()\r\n    {\r\n        //  Store and reset collision flags\r\n        this.wasTouching.none = this.touching.none;\r\n        this.wasTouching.up = this.touching.up;\r\n        this.wasTouching.down = this.touching.down;\r\n        this.wasTouching.left = this.touching.left;\r\n        this.wasTouching.right = this.touching.right;\r\n\r\n        this.touching.none = true;\r\n        this.touching.up = false;\r\n        this.touching.down = false;\r\n        this.touching.left = false;\r\n        this.touching.right = false;\r\n\r\n        this.blocked.none = true;\r\n        this.blocked.up = false;\r\n        this.blocked.down = false;\r\n        this.blocked.left = false;\r\n        this.blocked.right = false;\r\n\r\n        this.overlapR = 0;\r\n        this.overlapX = 0;\r\n        this.overlapY = 0;\r\n\r\n        this.embedded = false;\r\n    },\r\n\r\n    /**\r\n     * Syncs the position body position with the parent Game Object.\r\n     *\r\n     * This method is called every game frame, regardless if the world steps or not.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#preUpdate\r\n     * @since 3.17.0\r\n     *\r\n     * @param {boolean} willStep - Will this Body run an update as well?\r\n     * @param {number} delta - The delta time, in seconds, elapsed since the last frame.\r\n     */\r\n    preUpdate: function (willStep, delta)\r\n    {\r\n        if (willStep)\r\n        {\r\n            this.resetFlags();\r\n        }\r\n\r\n        this.updateBounds();\r\n\r\n        var sprite = this.transform;\r\n\r\n        this.position.x = sprite.x + sprite.scaleX * (this.offset.x - sprite.displayOriginX);\r\n        this.position.y = sprite.y + sprite.scaleY * (this.offset.y - sprite.displayOriginY);\r\n\r\n        this.updateCenter();\r\n\r\n        this.rotation = sprite.rotation;\r\n\r\n        this.preRotation = this.rotation;\r\n\r\n        if (this.moves)\r\n        {\r\n            this.prev.x = this.position.x;\r\n            this.prev.y = this.position.y;\r\n            this.prevFrame.x = this.position.x;\r\n            this.prevFrame.y = this.position.y;\r\n        }\r\n\r\n        if (willStep)\r\n        {\r\n            this.update(delta);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Performs a single physics step and updates the body velocity, angle, speed and other properties.\r\n     *\r\n     * This method can be called multiple times per game frame, depending on the physics step rate.\r\n     *\r\n     * The results are synced back to the Game Object in `postUpdate`.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#update\r\n     * @fires Phaser.Physics.Arcade.Events#WORLD_BOUNDS\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} delta - The delta time, in seconds, elapsed since the last frame.\r\n     */\r\n    update: function (delta)\r\n    {\r\n        this.prev.x = this.position.x;\r\n        this.prev.y = this.position.y;\r\n\r\n        if (this.moves)\r\n        {\r\n            this.world.updateMotion(this, delta);\r\n\r\n            var vx = this.velocity.x;\r\n            var vy = this.velocity.y;\r\n\r\n            this.newVelocity.set(vx * delta, vy * delta);\r\n\r\n            this.position.add(this.newVelocity);\r\n\r\n            this.updateCenter();\r\n\r\n            this.angle = Math.atan2(vy, vx);\r\n            this.speed = Math.sqrt(vx * vx + vy * vy);\r\n\r\n            //  Now the update will throw collision checks at the Body\r\n            //  And finally we'll integrate the new position back to the Sprite in postUpdate\r\n\r\n            if (this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds)\r\n            {\r\n                this.world.emit(Events.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right);\r\n            }\r\n        }\r\n\r\n        this._dx = this.position.x - this.prev.x;\r\n        this._dy = this.position.y - this.prev.y;\r\n    },\r\n\r\n    /**\r\n     * Feeds the Body results back into the parent Game Object.\r\n     *\r\n     * This method is called every game frame, regardless if the world steps or not.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#postUpdate\r\n     * @since 3.0.0\r\n     */\r\n    postUpdate: function ()\r\n    {\r\n        var dx = this.position.x - this.prevFrame.x;\r\n        var dy = this.position.y - this.prevFrame.y;\r\n\r\n        if (this.moves)\r\n        {\r\n            var mx = this.deltaMax.x;\r\n            var my = this.deltaMax.y;\r\n\r\n            if (mx !== 0 && dx !== 0)\r\n            {\r\n                if (dx < 0 && dx < -mx)\r\n                {\r\n                    dx = -mx;\r\n                }\r\n                else if (dx > 0 && dx > mx)\r\n                {\r\n                    dx = mx;\r\n                }\r\n            }\r\n\r\n            if (my !== 0 && dy !== 0)\r\n            {\r\n                if (dy < 0 && dy < -my)\r\n                {\r\n                    dy = -my;\r\n                }\r\n                else if (dy > 0 && dy > my)\r\n                {\r\n                    dy = my;\r\n                }\r\n            }\r\n\r\n            this.gameObject.x += dx;\r\n            this.gameObject.y += dy;\r\n        }\r\n\r\n        if (dx < 0)\r\n        {\r\n            this.facing = CONST.FACING_LEFT;\r\n        }\r\n        else if (dx > 0)\r\n        {\r\n            this.facing = CONST.FACING_RIGHT;\r\n        }\r\n\r\n        if (dy < 0)\r\n        {\r\n            this.facing = CONST.FACING_UP;\r\n        }\r\n        else if (dy > 0)\r\n        {\r\n            this.facing = CONST.FACING_DOWN;\r\n        }\r\n\r\n        if (this.allowRotation)\r\n        {\r\n            this.gameObject.angle += this.deltaZ();\r\n        }\r\n\r\n        this._tx = dx;\r\n        this._ty = dy;\r\n    },\r\n\r\n    /**\r\n     * Sets a custom collision boundary rectangle. Use if you want to have a custom\r\n     * boundary instead of the world boundaries.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setBoundsRectangle\r\n     * @since 3.20\r\n     *\r\n     * @param {?Phaser.Geom.Rectangle} [bounds] - The new boundary rectangle. Pass `null` to use the World bounds.\r\n     * \r\n     * @return {this} This Body object.\r\n     */\r\n    setBoundsRectangle: function (bounds)\r\n    {\r\n        this.customBoundsRectangle = (!bounds) ? this.world.bounds : bounds;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Checks for collisions between this Body and the world boundary and separates them.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#checkWorldBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} True if this Body is colliding with the world boundary.\r\n     */\r\n    checkWorldBounds: function ()\r\n    {\r\n        var pos = this.position;\r\n        var bounds = this.customBoundsRectangle;\r\n        var check = this.world.checkCollision;\r\n\r\n        var bx = (this.worldBounce) ? -this.worldBounce.x : -this.bounce.x;\r\n        var by = (this.worldBounce) ? -this.worldBounce.y : -this.bounce.y;\r\n\r\n        var wasSet = false;\r\n\r\n        if (pos.x < bounds.x && check.left)\r\n        {\r\n            pos.x = bounds.x;\r\n            this.velocity.x *= bx;\r\n            this.blocked.left = true;\r\n            wasSet = true;\r\n        }\r\n        else if (this.right > bounds.right && check.right)\r\n        {\r\n            pos.x = bounds.right - this.width;\r\n            this.velocity.x *= bx;\r\n            this.blocked.right = true;\r\n            wasSet = true;\r\n        }\r\n\r\n        if (pos.y < bounds.y && check.up)\r\n        {\r\n            pos.y = bounds.y;\r\n            this.velocity.y *= by;\r\n            this.blocked.up = true;\r\n            wasSet = true;\r\n        }\r\n        else if (this.bottom > bounds.bottom && check.down)\r\n        {\r\n            pos.y = bounds.bottom - this.height;\r\n            this.velocity.y *= by;\r\n            this.blocked.down = true;\r\n            wasSet = true;\r\n        }\r\n\r\n        if (wasSet)\r\n        {\r\n            this.blocked.none = false;\r\n        }\r\n\r\n        return wasSet;\r\n    },\r\n\r\n    /**\r\n     * Sets the offset of the Body's position from its Game Object's position.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setOffset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal offset, in source pixels.\r\n     * @param {number} [y=x] - The vertical offset, in source pixels.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setOffset: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.offset.set(x, y);\r\n        this.updateCenter();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sizes and positions this Body's boundary, as a rectangle.\r\n     * Modifies the Body `offset` if `center` is true (the default).\r\n     * Resets the width and height to match current frame, if no width and height provided and a frame is found.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [width] - The width of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame width.\r\n     * @param {integer} [height] - The height of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame height.\r\n     * @param {boolean} [center=true] - Modify the Body's `offset`, placing the Body's center on its Game Object's center. Only works if the Game Object has the `getCenter` method.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setSize: function (width, height, center)\r\n    {\r\n        if (center === undefined) { center = true; }\r\n\r\n        var gameObject = this.gameObject;\r\n\r\n        if (!width && gameObject.frame)\r\n        {\r\n            width = gameObject.frame.realWidth;\r\n        }\r\n\r\n        if (!height && gameObject.frame)\r\n        {\r\n            height = gameObject.frame.realHeight;\r\n        }\r\n\r\n        this.sourceWidth = width;\r\n        this.sourceHeight = height;\r\n\r\n        this.width = this.sourceWidth * this._sx;\r\n        this.height = this.sourceHeight * this._sy;\r\n\r\n        this.halfWidth = Math.floor(this.width / 2);\r\n        this.halfHeight = Math.floor(this.height / 2);\r\n\r\n        this.updateCenter();\r\n\r\n        if (center && gameObject.getCenter)\r\n        {\r\n            var ox = gameObject.displayWidth / 2;\r\n            var oy = gameObject.displayHeight / 2;\r\n\r\n            this.offset.set(ox - this.halfWidth, oy - this.halfHeight);\r\n        }\r\n\r\n        this.isCircle = false;\r\n        this.radius = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sizes and positions this Body's boundary, as a circle.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - The radius of the Body, in source pixels.\r\n     * @param {number} [offsetX] - The horizontal offset of the Body from its Game Object, in source pixels.\r\n     * @param {number} [offsetY] - The vertical offset of the Body from its Game Object, in source pixels.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setCircle: function (radius, offsetX, offsetY)\r\n    {\r\n        if (offsetX === undefined) { offsetX = this.offset.x; }\r\n        if (offsetY === undefined) { offsetY = this.offset.y; }\r\n\r\n        if (radius > 0)\r\n        {\r\n            this.isCircle = true;\r\n            this.radius = radius;\r\n\r\n            this.sourceWidth = radius * 2;\r\n            this.sourceHeight = radius * 2;\r\n\r\n            this.width = this.sourceWidth * this._sx;\r\n            this.height = this.sourceHeight * this._sy;\r\n\r\n            this.halfWidth = Math.floor(this.width / 2);\r\n            this.halfHeight = Math.floor(this.height / 2);\r\n\r\n            this.offset.set(offsetX, offsetY);\r\n\r\n            this.updateCenter();\r\n        }\r\n        else\r\n        {\r\n            this.isCircle = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets this Body to the given coordinates. Also positions its parent Game Object to the same coordinates.\r\n     * If the Body had any velocity or acceleration it is lost as a result of calling this.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position to place the Game Object and Body.\r\n     * @param {number} y - The vertical position to place the Game Object and Body.\r\n     */\r\n    reset: function (x, y)\r\n    {\r\n        this.stop();\r\n\r\n        var gameObject = this.gameObject;\r\n\r\n        gameObject.setPosition(x, y);\r\n\r\n        if (gameObject.getTopLeft)\r\n        {\r\n            gameObject.getTopLeft(this.position);\r\n        }\r\n        else\r\n        {\r\n            this.position.set(x, y);\r\n        }\r\n\r\n        this.prev.copy(this.position);\r\n        this.prevFrame.copy(this.position);\r\n\r\n        this.rotation = gameObject.angle;\r\n        this.preRotation = gameObject.angle;\r\n\r\n        this.updateBounds();\r\n        this.updateCenter();\r\n    },\r\n\r\n    /**\r\n     * Sets acceleration, velocity, and speed to zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    stop: function ()\r\n    {\r\n        this.velocity.set(0);\r\n        this.acceleration.set(0);\r\n        this.speed = 0;\r\n        this.angularVelocity = 0;\r\n        this.angularAcceleration = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Copies the coordinates of this Body's edges into an object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} obj - An object to copy the values into.\r\n     *\r\n     * @return {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} - An object with {x, y, right, bottom}.\r\n     */\r\n    getBounds: function (obj)\r\n    {\r\n        obj.x = this.x;\r\n        obj.y = this.y;\r\n        obj.right = this.right;\r\n        obj.bottom = this.bottom;\r\n\r\n        return obj;\r\n    },\r\n\r\n    /**\r\n     * Tests if the coordinates are within this Body's boundary.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#hitTest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal coordinate.\r\n     * @param {number} y - The vertical coordinate.\r\n     *\r\n     * @return {boolean} True if (x, y) is within this Body.\r\n     */\r\n    hitTest: function (x, y)\r\n    {\r\n        if (!this.isCircle)\r\n        {\r\n            return RectangleContains(this, x, y);\r\n        }\r\n\r\n        //  Check if x/y are within the bounds first\r\n        if (this.radius > 0 && x >= this.left && x <= this.right && y >= this.top && y <= this.bottom)\r\n        {\r\n            var dx = (this.center.x - x) * (this.center.x - x);\r\n            var dy = (this.center.y - y) * (this.center.y - y);\r\n\r\n            return (dx + dy) <= (this.radius * this.radius);\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Whether this Body is touching a tile or the world boundary while moving down.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#onFloor\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#blocked\r\n     *\r\n     * @return {boolean} True if touching.\r\n     */\r\n    onFloor: function ()\r\n    {\r\n        return this.blocked.down;\r\n    },\r\n\r\n    /**\r\n     * Whether this Body is touching a tile or the world boundary while moving up.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#onCeiling\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#blocked\r\n     *\r\n     * @return {boolean} True if touching.\r\n     */\r\n    onCeiling: function ()\r\n    {\r\n        return this.blocked.up;\r\n    },\r\n\r\n    /**\r\n     * Whether this Body is touching a tile or the world boundary while moving left or right.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#onWall\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#blocked\r\n     *\r\n     * @return {boolean} True if touching.\r\n     */\r\n    onWall: function ()\r\n    {\r\n        return (this.blocked.left || this.blocked.right);\r\n    },\r\n\r\n    /**\r\n     * The absolute (non-negative) change in this Body's horizontal position from the previous step.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaAbsX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The delta value.\r\n     */\r\n    deltaAbsX: function ()\r\n    {\r\n        return (this._dx > 0) ? this._dx : -this._dx;\r\n    },\r\n\r\n    /**\r\n     * The absolute (non-negative) change in this Body's vertical position from the previous step.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaAbsY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The delta value.\r\n     */\r\n    deltaAbsY: function ()\r\n    {\r\n        return (this._dy > 0) ? this._dy : -this._dy;\r\n    },\r\n\r\n    /**\r\n     * The change in this Body's horizontal position from the previous step.\r\n     * This value is set during the Body's update phase.\r\n     * \r\n     * As a Body can update multiple times per step this may not hold the final\r\n     * delta value for the Body. In this case, please see the `deltaXFinal` method.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The delta value.\r\n     */\r\n    deltaX: function ()\r\n    {\r\n        return this._dx;\r\n    },\r\n\r\n    /**\r\n     * The change in this Body's vertical position from the previous step.\r\n     * This value is set during the Body's update phase.\r\n     * \r\n     * As a Body can update multiple times per step this may not hold the final\r\n     * delta value for the Body. In this case, please see the `deltaYFinal` method.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The delta value.\r\n     */\r\n    deltaY: function ()\r\n    {\r\n        return this._dy;\r\n    },\r\n\r\n    /**\r\n     * The change in this Body's horizontal position from the previous game update.\r\n     * \r\n     * This value is set during the `postUpdate` phase and takes into account the\r\n     * `deltaMax` and final position of the Body.\r\n     * \r\n     * Because this value is not calculated until `postUpdate`, you must listen for it\r\n     * during a Scene `POST_UPDATE` or `RENDER` event, and not in `update`, as it will\r\n     * not be calculated by that point. If you _do_ use these values in `update` they\r\n     * will represent the delta from the _previous_ game frame.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaXFinal\r\n     * @since 3.22.0\r\n     *\r\n     * @return {number} The final delta x value.\r\n     */\r\n    deltaXFinal: function ()\r\n    {\r\n        return this._tx;\r\n    },\r\n\r\n    /**\r\n     * The change in this Body's vertical position from the previous game update.\r\n     * \r\n     * This value is set during the `postUpdate` phase and takes into account the\r\n     * `deltaMax` and final position of the Body.\r\n     * \r\n     * Because this value is not calculated until `postUpdate`, you must listen for it\r\n     * during a Scene `POST_UPDATE` or `RENDER` event, and not in `update`, as it will\r\n     * not be calculated by that point. If you _do_ use these values in `update` they\r\n     * will represent the delta from the _previous_ game frame.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaYFinal\r\n     * @since 3.22.0\r\n     *\r\n     * @return {number} The final delta y value.\r\n     */\r\n    deltaYFinal: function ()\r\n    {\r\n        return this._ty;\r\n    },\r\n\r\n    /**\r\n     * The change in this Body's rotation from the previous step, in degrees.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaZ\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The delta value.\r\n     */\r\n    deltaZ: function ()\r\n    {\r\n        return this.rotation - this.preRotation;\r\n    },\r\n\r\n    /**\r\n     * Disables this Body and marks it for deletion by the simulation.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.enable = false;\r\n\r\n        if (this.world)\r\n        {\r\n            this.world.pendingDestroy.set(this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Draws this Body's boundary and velocity, if enabled.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#drawDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphic - The Graphics object to draw on.\r\n     */\r\n    drawDebug: function (graphic)\r\n    {\r\n        var pos = this.position;\r\n\r\n        var x = pos.x + this.halfWidth;\r\n        var y = pos.y + this.halfHeight;\r\n\r\n        if (this.debugShowBody)\r\n        {\r\n            graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor);\r\n\r\n            if (this.isCircle)\r\n            {\r\n                graphic.strokeCircle(x, y, this.width / 2);\r\n            }\r\n            else\r\n            {\r\n                //  Only draw the sides where checkCollision is true, similar to debugger in layer\r\n                if (this.checkCollision.up)\r\n                {\r\n                    graphic.lineBetween(pos.x, pos.y, pos.x + this.width, pos.y);\r\n                }\r\n\r\n                if (this.checkCollision.right)\r\n                {\r\n                    graphic.lineBetween(pos.x + this.width, pos.y, pos.x + this.width, pos.y + this.height);\r\n                }\r\n\r\n                if (this.checkCollision.down)\r\n                {\r\n                    graphic.lineBetween(pos.x, pos.y + this.height, pos.x + this.width, pos.y + this.height);\r\n                }\r\n\r\n                if (this.checkCollision.left)\r\n                {\r\n                    graphic.lineBetween(pos.x, pos.y, pos.x, pos.y + this.height);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.debugShowVelocity)\r\n        {\r\n            graphic.lineStyle(graphic.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1);\r\n            graphic.lineBetween(x, y, x + this.velocity.x / 2, y + this.velocity.y / 2);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Whether this Body will be drawn to the debug display.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#willDrawDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} True if either `debugShowBody` or `debugShowVelocity` are enabled.\r\n     */\r\n    willDrawDebug: function ()\r\n    {\r\n        return (this.debugShowBody || this.debugShowVelocity);\r\n    },\r\n\r\n    /**\r\n     * Sets whether this Body collides with the world boundary.\r\n     *\r\n     * Optionally also sets the World Bounce values. If the `Body.worldBounce` is null, it's set to a new Phaser.Math.Vector2 first.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setCollideWorldBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [value=true] - `true` if this body should collide with the world bounds, otherwise `false`.\r\n     * @param {number} [bounceX] - If given this will be replace the `worldBounce.x` value.\r\n     * @param {number} [bounceY] - If given this will be replace the `worldBounce.y` value.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setCollideWorldBounds: function (value, bounceX, bounceY)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.collideWorldBounds = value;\r\n\r\n        var setBounceX = (bounceX !== undefined);\r\n        var setBounceY = (bounceY !== undefined);\r\n\r\n        if (setBounceX || setBounceY)\r\n        {\r\n            if (!this.worldBounce)\r\n            {\r\n                this.worldBounce = new Vector2();\r\n            }\r\n\r\n            if (setBounceX)\r\n            {\r\n                this.worldBounce.x = bounceX;\r\n            }\r\n\r\n            if (setBounceY)\r\n            {\r\n                this.worldBounce.y = bounceY;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal velocity, in pixels per second.\r\n     * @param {number} [y=x] - The vertical velocity, in pixels per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setVelocity: function (x, y)\r\n    {\r\n        this.velocity.set(x, y);\r\n\r\n        x = this.velocity.x;\r\n        y = this.velocity.y;\r\n\r\n        this.speed = Math.sqrt(x * x + y * y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setVelocityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The velocity, in pixels per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setVelocityX: function (value)\r\n    {\r\n        this.velocity.x = value;\r\n\r\n        var x = value;\r\n        var y = this.velocity.y;\r\n\r\n        this.speed = Math.sqrt(x * x + y * y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setVelocityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The velocity, in pixels per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setVelocityY: function (value)\r\n    {\r\n        this.velocity.y = value;\r\n\r\n        var x = this.velocity.x;\r\n        var y = value;\r\n\r\n        this.speed = Math.sqrt(x * x + y * y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's maximum velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setMaxVelocity\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} x - The horizontal velocity, in pixels per second.\r\n     * @param {number} [y=x] - The vertical velocity, in pixels per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setMaxVelocity: function (x, y)\r\n    {\r\n        this.maxVelocity.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the maximum speed the Body can move.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setMaxSpeed\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} value - The maximum speed value, in pixels per second. Set to a negative value to disable.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setMaxSpeed: function (value)\r\n    {\r\n        this.maxSpeed = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's bounce.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setBounce\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal bounce, relative to 1.\r\n     * @param {number} y - The vertical bounce, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setBounce: function (x, y)\r\n    {\r\n        this.bounce.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal bounce.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setBounceX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The bounce, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setBounceX: function (value)\r\n    {\r\n        this.bounce.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical bounce.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setBounceY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The bounce, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setBounceY: function (value)\r\n    {\r\n        this.bounce.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's acceleration.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAcceleration\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal component, in pixels per second squared.\r\n     * @param {number} y - The vertical component, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAcceleration: function (x, y)\r\n    {\r\n        this.acceleration.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal acceleration.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAccelerationX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The acceleration, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAccelerationX: function (value)\r\n    {\r\n        this.acceleration.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical acceleration.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAccelerationY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The acceleration, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAccelerationY: function (value)\r\n    {\r\n        this.acceleration.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enables or disables drag.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAllowDrag\r\n     * @since 3.9.0\r\n     * @see Phaser.Physics.Arcade.Body#allowDrag\r\n     *\r\n     * @param {boolean} [value=true] - `true` to allow drag on this body, or `false` to disable it.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAllowDrag: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.allowDrag = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enables or disables gravity's effect on this Body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAllowGravity\r\n     * @since 3.9.0\r\n     * @see Phaser.Physics.Arcade.Body#allowGravity\r\n     *\r\n     * @param {boolean} [value=true] - `true` to allow gravity on this body, or `false` to disable it.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAllowGravity: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.allowGravity = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enables or disables rotation.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAllowRotation\r\n     * @since 3.9.0\r\n     * @see Phaser.Physics.Arcade.Body#allowRotation\r\n     *\r\n     * @param {boolean} [value=true] - `true` to allow rotation on this body, or `false` to disable it.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAllowRotation: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.allowRotation = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's drag.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setDrag\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal component, in pixels per second squared.\r\n     * @param {number} y - The vertical component, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setDrag: function (x, y)\r\n    {\r\n        this.drag.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal drag.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setDragX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The drag, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setDragX: function (value)\r\n    {\r\n        this.drag.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical drag.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setDragY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The drag, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setDragY: function (value)\r\n    {\r\n        this.drag.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's gravity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal component, in pixels per second squared.\r\n     * @param {number} y - The vertical component, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setGravity: function (x, y)\r\n    {\r\n        this.gravity.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal gravity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setGravityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The gravity, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setGravityX: function (value)\r\n    {\r\n        this.gravity.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical gravity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setGravityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The gravity, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setGravityY: function (value)\r\n    {\r\n        this.gravity.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's friction.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setFriction\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal component, relative to 1.\r\n     * @param {number} y - The vertical component, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setFriction: function (x, y)\r\n    {\r\n        this.friction.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal friction.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setFrictionX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The friction value, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setFrictionX: function (value)\r\n    {\r\n        this.friction.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical friction.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setFrictionY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The friction value, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setFrictionY: function (value)\r\n    {\r\n        this.friction.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's angular velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAngularVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The velocity, in degrees per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAngularVelocity: function (value)\r\n    {\r\n        this.angularVelocity = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's angular acceleration.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAngularAcceleration\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The acceleration, in degrees per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAngularAcceleration: function (value)\r\n    {\r\n        this.angularAcceleration = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's angular drag.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAngularDrag\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The drag, in degrees per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAngularDrag: function (value)\r\n    {\r\n        this.angularDrag = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's mass.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setMass\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The mass value, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setMass: function (value)\r\n    {\r\n        this.mass = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's `immovable` property.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setImmovable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [value=true] - The value to assign to `immovable`.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setImmovable: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.immovable = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's `enable` property.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setEnable\r\n     * @since 3.15.0\r\n     *\r\n     * @param {boolean} [value=true] - The value to assign to `enable`.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setEnable: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.enable = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The Body's horizontal position (left edge).\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.position.x = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Body's vertical position (top edge).\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.position.y = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The left edge of the Body's boundary. Identical to x.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#left\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    left: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.x;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The right edge of the Body's boundary.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#right\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    right: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.x + this.width;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The top edge of the Body's boundary. Identical to y.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#top\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    top: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.y;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The bottom edge of this Body's boundary.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#bottom\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    bottom: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.y + this.height;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Body;\r\n"]},"metadata":{},"sourceType":"script"}