{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\n//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\nvar Class = require('../utils/Class');\n\nvar Curve = require('./Curve');\n\nvar FromPoints = require('../geom/rectangle/FromPoints');\n\nvar Rectangle = require('../geom/rectangle/Rectangle');\n\nvar Vector2 = require('../math/Vector2');\n\nvar tmpVec2 = new Vector2();\n/**\r\n * @classdesc\r\n * A LineCurve is a \"curve\" comprising exactly two points (a line segment).\r\n *\r\n * @class Line\r\n * @extends Phaser.Curves.Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Math.Vector2|number[])} p0 - The first endpoint.\r\n * @param {Phaser.Math.Vector2} [p1] - The second endpoint.\r\n */\n\nvar LineCurve = new Class({\n  Extends: Curve,\n  initialize: //  vec2s or array\n  function LineCurve(p0, p1) {\n    Curve.call(this, 'LineCurve');\n\n    if (Array.isArray(p0)) {\n      p1 = new Vector2(p0[2], p0[3]);\n      p0 = new Vector2(p0[0], p0[1]);\n    }\n    /**\r\n     * The first endpoint.\r\n     *\r\n     * @name Phaser.Curves.Line#p0\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.p0 = p0;\n    /**\r\n     * The second endpoint.\r\n     *\r\n     * @name Phaser.Curves.Line#p1\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.p1 = p1; //  Override default Curve.arcLengthDivisions\n\n    /**\r\n     * The quantity of arc length divisions within the curve.\r\n     *\r\n     * @name Phaser.Curves.Line#arcLengthDivisions\r\n     * @type {integer}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\n\n    this.arcLengthDivisions = 1;\n  },\n\n  /**\r\n   * Returns a Rectangle where the position and dimensions match the bounds of this Curve.\r\n   *\r\n   * @method Phaser.Curves.Line#getBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n   *\r\n   * @param {Phaser.Geom.Rectangle} [out] - A Rectangle object to store the bounds in. If not given a new Rectangle will be created.\r\n   *\r\n   * @return {Phaser.Geom.Rectangle} A Rectangle object holding the bounds of this curve. If `out` was given it will be this object.\r\n   */\n  getBounds: function (out) {\n    if (out === undefined) {\n      out = new Rectangle();\n    }\n\n    return FromPoints([this.p0, this.p1], out);\n  },\n\n  /**\r\n   * Gets the starting point on the curve.\r\n   *\r\n   * @method Phaser.Curves.Line#getStartPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n   */\n  getStartPoint: function (out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    return out.copy(this.p0);\n  },\n\n  /**\r\n   * Gets the resolution of the line.\r\n   *\r\n   * @method Phaser.Curves.Line#getResolution\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [divisions=1] - The number of divisions to consider.\r\n   *\r\n   * @return {number} The resolution. Equal to the number of divisions.\r\n   */\n  getResolution: function (divisions) {\n    if (divisions === undefined) {\n      divisions = 1;\n    }\n\n    return divisions;\n  },\n\n  /**\r\n   * Get point at relative position in curve according to length.\r\n   *\r\n   * @method Phaser.Curves.Line#getPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n   * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n   */\n  getPoint: function (t, out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    if (t === 1) {\n      return out.copy(this.p1);\n    }\n\n    out.copy(this.p1).subtract(this.p0).scale(t).add(this.p0);\n    return out;\n  },\n  // Line curve is linear, so we can overwrite default getPointAt\n\n  /**\r\n   * Gets a point at a given position on the line.\r\n   *\r\n   * @method Phaser.Curves.Line#getPointAt\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {number} u - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n   * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n   */\n  getPointAt: function (u, out) {\n    return this.getPoint(u, out);\n  },\n\n  /**\r\n   * Gets the slope of the line as a unit vector.\r\n   *\r\n   * @method Phaser.Curves.Line#getTangent\r\n   * @since 3.0.0\r\n   * \r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @return {Phaser.Math.Vector2} The tangent vector.\r\n   */\n  getTangent: function () {\n    var tangent = tmpVec2.copy(this.p1).subtract(this.p0);\n    return tangent.normalize();\n  },\n  //  Override default Curve.getUtoTmapping\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Line#getUtoTmapping\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} u - [description]\r\n   * @param {integer} distance - [description]\r\n   * @param {integer} [divisions] - [description]\r\n   *\r\n   * @return {number} [description]\r\n   */\n  getUtoTmapping: function (u, distance, divisions) {\n    var t;\n\n    if (distance) {\n      var arcLengths = this.getLengths(divisions);\n      var lineLength = arcLengths[arcLengths.length - 1]; //  Cannot overshoot the curve\n\n      var targetLineLength = Math.min(distance, lineLength);\n      t = targetLineLength / lineLength;\n    } else {\n      t = u;\n    }\n\n    return t;\n  },\n  //  Override default Curve.draw because this is better than calling getPoints on a line!\n\n  /**\r\n   * Draws this curve on the given Graphics object.\r\n   *\r\n   * The curve is drawn using `Graphics.lineBetween` so will be drawn at whatever the present Graphics line color is.\r\n   * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.\r\n   *\r\n   * @method Phaser.Curves.Line#draw\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]\r\n   *\r\n   * @param {Phaser.GameObjects.Graphics} graphics - The Graphics instance onto which this curve will be drawn.\r\n   *\r\n   * @return {Phaser.GameObjects.Graphics} The Graphics object to which the curve was drawn.\r\n   */\n  draw: function (graphics) {\n    graphics.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y); //  So you can chain graphics calls\n\n    return graphics;\n  },\n\n  /**\r\n   * Gets a JSON representation of the line.\r\n   *\r\n   * @method Phaser.Curves.Line#toJSON\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Types.Curves.JSONCurve} The JSON object containing this curve data.\r\n   */\n  toJSON: function () {\n    return {\n      type: this.type,\n      points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y]\n    };\n  }\n});\n/**\r\n * Configures this line from a JSON representation.\r\n *\r\n * @function Phaser.Curves.Line.fromJSON\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Curves.JSONCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.Line} A new LineCurve object.\r\n */\n\nLineCurve.fromJSON = function (data) {\n  var points = data.points;\n  var p0 = new Vector2(points[0], points[1]);\n  var p1 = new Vector2(points[2], points[3]);\n  return new LineCurve(p0, p1);\n};\n\nmodule.exports = LineCurve;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/curves/LineCurve.js"],"names":["Class","require","Curve","FromPoints","Rectangle","Vector2","tmpVec2","LineCurve","Extends","initialize","p0","p1","call","Array","isArray","arcLengthDivisions","getBounds","out","undefined","getStartPoint","copy","getResolution","divisions","getPoint","t","subtract","scale","add","getPointAt","u","getTangent","tangent","normalize","getUtoTmapping","distance","arcLengths","getLengths","lineLength","length","targetLineLength","Math","min","draw","graphics","lineBetween","x","y","toJSON","type","points","fromJSON","data","module","exports"],"mappings":"AAAA;;;;;AAMA;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,gBAAD,CAAnB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAIE,UAAU,GAAGF,OAAO,CAAC,8BAAD,CAAxB;;AACA,IAAIG,SAAS,GAAGH,OAAO,CAAC,6BAAD,CAAvB;;AACA,IAAII,OAAO,GAAGJ,OAAO,CAAC,iBAAD,CAArB;;AAEA,IAAIK,OAAO,GAAG,IAAID,OAAJ,EAAd;AAEA;;;;;;;;;;;;;;AAaA,IAAIE,SAAS,GAAG,IAAIP,KAAJ,CAAU;AAEtBQ,EAAAA,OAAO,EAAEN,KAFa;AAItBO,EAAAA,UAAU,EAEV;AACA,WAASF,SAAT,CAAoBG,EAApB,EAAwBC,EAAxB,EACA;AACIT,IAAAA,KAAK,CAACU,IAAN,CAAW,IAAX,EAAiB,WAAjB;;AAEA,QAAIC,KAAK,CAACC,OAAN,CAAcJ,EAAd,CAAJ,EACA;AACIC,MAAAA,EAAE,GAAG,IAAIN,OAAJ,CAAYK,EAAE,CAAC,CAAD,CAAd,EAAmBA,EAAE,CAAC,CAAD,CAArB,CAAL;AACAA,MAAAA,EAAE,GAAG,IAAIL,OAAJ,CAAYK,EAAE,CAAC,CAAD,CAAd,EAAmBA,EAAE,CAAC,CAAD,CAArB,CAAL;AACH;AAED;;;;;;;;;AAOA,SAAKA,EAAL,GAAUA,EAAV;AAEA;;;;;;;;AAOA,SAAKC,EAAL,GAAUA,EAAV,CAzBJ,CA2BI;;AAEA;;;;;;;;;AAQA,SAAKI,kBAAL,GAA0B,CAA1B;AACH,GA9CqB;;AAgDtB;;;;;;;;;;;;AAYAC,EAAAA,SAAS,EAAE,UAAUC,GAAV,EACX;AACI,QAAIA,GAAG,KAAKC,SAAZ,EAAuB;AAAED,MAAAA,GAAG,GAAG,IAAIb,SAAJ,EAAN;AAAwB;;AAEjD,WAAOD,UAAU,CAAC,CAAE,KAAKO,EAAP,EAAW,KAAKC,EAAhB,CAAD,EAAuBM,GAAvB,CAAjB;AACH,GAjEqB;;AAmEtB;;;;;;;;;;;;AAYAE,EAAAA,aAAa,EAAE,UAAUF,GAAV,EACf;AACI,QAAIA,GAAG,KAAKC,SAAZ,EAAuB;AAAED,MAAAA,GAAG,GAAG,IAAIZ,OAAJ,EAAN;AAAsB;;AAE/C,WAAOY,GAAG,CAACG,IAAJ,CAAS,KAAKV,EAAd,CAAP;AACH,GApFqB;;AAsFtB;;;;;;;;;;AAUAW,EAAAA,aAAa,EAAE,UAAUC,SAAV,EACf;AACI,QAAIA,SAAS,KAAKJ,SAAlB,EAA6B;AAAEI,MAAAA,SAAS,GAAG,CAAZ;AAAgB;;AAE/C,WAAOA,SAAP;AACH,GArGqB;;AAuGtB;;;;;;;;;;;;;AAaAC,EAAAA,QAAQ,EAAE,UAAUC,CAAV,EAAaP,GAAb,EACV;AACI,QAAIA,GAAG,KAAKC,SAAZ,EAAuB;AAAED,MAAAA,GAAG,GAAG,IAAIZ,OAAJ,EAAN;AAAsB;;AAE/C,QAAImB,CAAC,KAAK,CAAV,EACA;AACI,aAAOP,GAAG,CAACG,IAAJ,CAAS,KAAKT,EAAd,CAAP;AACH;;AAEDM,IAAAA,GAAG,CAACG,IAAJ,CAAS,KAAKT,EAAd,EAAkBc,QAAlB,CAA2B,KAAKf,EAAhC,EAAoCgB,KAApC,CAA0CF,CAA1C,EAA6CG,GAA7C,CAAiD,KAAKjB,EAAtD;AAEA,WAAOO,GAAP;AACH,GAhIqB;AAkItB;;AAEA;;;;;;;;;;;;;AAaAW,EAAAA,UAAU,EAAE,UAAUC,CAAV,EAAaZ,GAAb,EACZ;AACI,WAAO,KAAKM,QAAL,CAAcM,CAAd,EAAiBZ,GAAjB,CAAP;AACH,GApJqB;;AAsJtB;;;;;;;;;;AAUAa,EAAAA,UAAU,EAAE,YACZ;AACI,QAAIC,OAAO,GAAGzB,OAAO,CAACc,IAAR,CAAa,KAAKT,EAAlB,EAAsBc,QAAtB,CAA+B,KAAKf,EAApC,CAAd;AAEA,WAAOqB,OAAO,CAACC,SAAR,EAAP;AACH,GArKqB;AAuKtB;;AAEA;;;;;;;;;;;;AAYAC,EAAAA,cAAc,EAAE,UAAUJ,CAAV,EAAaK,QAAb,EAAuBZ,SAAvB,EAChB;AACI,QAAIE,CAAJ;;AAEA,QAAIU,QAAJ,EACA;AACI,UAAIC,UAAU,GAAG,KAAKC,UAAL,CAAgBd,SAAhB,CAAjB;AACA,UAAIe,UAAU,GAAGF,UAAU,CAACA,UAAU,CAACG,MAAX,GAAoB,CAArB,CAA3B,CAFJ,CAII;;AACA,UAAIC,gBAAgB,GAAGC,IAAI,CAACC,GAAL,CAASP,QAAT,EAAmBG,UAAnB,CAAvB;AAEAb,MAAAA,CAAC,GAAGe,gBAAgB,GAAGF,UAAvB;AACH,KATD,MAWA;AACIb,MAAAA,CAAC,GAAGK,CAAJ;AACH;;AAED,WAAOL,CAAP;AACH,GAzMqB;AA2MtB;;AAEA;;;;;;;;;;;;;;;AAeAkB,EAAAA,IAAI,EAAE,UAAUC,QAAV,EACN;AACIA,IAAAA,QAAQ,CAACC,WAAT,CAAqB,KAAKlC,EAAL,CAAQmC,CAA7B,EAAgC,KAAKnC,EAAL,CAAQoC,CAAxC,EAA2C,KAAKnC,EAAL,CAAQkC,CAAnD,EAAsD,KAAKlC,EAAL,CAAQmC,CAA9D,EADJ,CAGI;;AACA,WAAOH,QAAP;AACH,GAlOqB;;AAoOtB;;;;;;;;AAQAI,EAAAA,MAAM,EAAE,YACR;AACI,WAAO;AACHC,MAAAA,IAAI,EAAE,KAAKA,IADR;AAEHC,MAAAA,MAAM,EAAE,CACJ,KAAKvC,EAAL,CAAQmC,CADJ,EACO,KAAKnC,EAAL,CAAQoC,CADf,EAEJ,KAAKnC,EAAL,CAAQkC,CAFJ,EAEO,KAAKlC,EAAL,CAAQmC,CAFf;AAFL,KAAP;AAOH;AArPqB,CAAV,CAAhB;AAyPA;;;;;;;;;;;AAUAvC,SAAS,CAAC2C,QAAV,GAAqB,UAAUC,IAAV,EACrB;AACI,MAAIF,MAAM,GAAGE,IAAI,CAACF,MAAlB;AAEA,MAAIvC,EAAE,GAAG,IAAIL,OAAJ,CAAY4C,MAAM,CAAC,CAAD,CAAlB,EAAuBA,MAAM,CAAC,CAAD,CAA7B,CAAT;AACA,MAAItC,EAAE,GAAG,IAAIN,OAAJ,CAAY4C,MAAM,CAAC,CAAD,CAAlB,EAAuBA,MAAM,CAAC,CAAD,CAA7B,CAAT;AAEA,SAAO,IAAI1C,SAAJ,CAAcG,EAAd,EAAkBC,EAAlB,CAAP;AACH,CARD;;AAUAyC,MAAM,CAACC,OAAP,GAAiB9C,SAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\r\n\r\nvar Class = require('../utils/Class');\r\nvar Curve = require('./Curve');\r\nvar FromPoints = require('../geom/rectangle/FromPoints');\r\nvar Rectangle = require('../geom/rectangle/Rectangle');\r\nvar Vector2 = require('../math/Vector2');\r\n\r\nvar tmpVec2 = new Vector2();\r\n\r\n/**\r\n * @classdesc\r\n * A LineCurve is a \"curve\" comprising exactly two points (a line segment).\r\n *\r\n * @class Line\r\n * @extends Phaser.Curves.Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Math.Vector2|number[])} p0 - The first endpoint.\r\n * @param {Phaser.Math.Vector2} [p1] - The second endpoint.\r\n */\r\nvar LineCurve = new Class({\r\n\r\n    Extends: Curve,\r\n\r\n    initialize:\r\n\r\n    //  vec2s or array\r\n    function LineCurve (p0, p1)\r\n    {\r\n        Curve.call(this, 'LineCurve');\r\n\r\n        if (Array.isArray(p0))\r\n        {\r\n            p1 = new Vector2(p0[2], p0[3]);\r\n            p0 = new Vector2(p0[0], p0[1]);\r\n        }\r\n\r\n        /**\r\n         * The first endpoint.\r\n         *\r\n         * @name Phaser.Curves.Line#p0\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.p0 = p0;\r\n\r\n        /**\r\n         * The second endpoint.\r\n         *\r\n         * @name Phaser.Curves.Line#p1\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.p1 = p1;\r\n\r\n        //  Override default Curve.arcLengthDivisions\r\n\r\n        /**\r\n         * The quantity of arc length divisions within the curve.\r\n         *\r\n         * @name Phaser.Curves.Line#arcLengthDivisions\r\n         * @type {integer}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.arcLengthDivisions = 1;\r\n    },\r\n\r\n    /**\r\n     * Returns a Rectangle where the position and dimensions match the bounds of this Curve.\r\n     *\r\n     * @method Phaser.Curves.Line#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} [out] - A Rectangle object to store the bounds in. If not given a new Rectangle will be created.\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} A Rectangle object holding the bounds of this curve. If `out` was given it will be this object.\r\n     */\r\n    getBounds: function (out)\r\n    {\r\n        if (out === undefined) { out = new Rectangle(); }\r\n\r\n        return FromPoints([ this.p0, this.p1 ], out);\r\n    },\r\n\r\n    /**\r\n     * Gets the starting point on the curve.\r\n     *\r\n     * @method Phaser.Curves.Line#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getStartPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return out.copy(this.p0);\r\n    },\r\n\r\n    /**\r\n     * Gets the resolution of the line.\r\n     *\r\n     * @method Phaser.Curves.Line#getResolution\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [divisions=1] - The number of divisions to consider.\r\n     *\r\n     * @return {number} The resolution. Equal to the number of divisions.\r\n     */\r\n    getResolution: function (divisions)\r\n    {\r\n        if (divisions === undefined) { divisions = 1; }\r\n\r\n        return divisions;\r\n    },\r\n\r\n    /**\r\n     * Get point at relative position in curve according to length.\r\n     *\r\n     * @method Phaser.Curves.Line#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getPoint: function (t, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        if (t === 1)\r\n        {\r\n            return out.copy(this.p1);\r\n        }\r\n\r\n        out.copy(this.p1).subtract(this.p0).scale(t).add(this.p0);\r\n\r\n        return out;\r\n    },\r\n\r\n    // Line curve is linear, so we can overwrite default getPointAt\r\n\r\n    /**\r\n     * Gets a point at a given position on the line.\r\n     *\r\n     * @method Phaser.Curves.Line#getPointAt\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} u - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getPointAt: function (u, out)\r\n    {\r\n        return this.getPoint(u, out);\r\n    },\r\n\r\n    /**\r\n     * Gets the slope of the line as a unit vector.\r\n     *\r\n     * @method Phaser.Curves.Line#getTangent\r\n     * @since 3.0.0\r\n     * \r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @return {Phaser.Math.Vector2} The tangent vector.\r\n     */\r\n    getTangent: function ()\r\n    {\r\n        var tangent = tmpVec2.copy(this.p1).subtract(this.p0);\r\n\r\n        return tangent.normalize();\r\n    },\r\n\r\n    //  Override default Curve.getUtoTmapping\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Line#getUtoTmapping\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} u - [description]\r\n     * @param {integer} distance - [description]\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */\r\n    getUtoTmapping: function (u, distance, divisions)\r\n    {\r\n        var t;\r\n\r\n        if (distance)\r\n        {\r\n            var arcLengths = this.getLengths(divisions);\r\n            var lineLength = arcLengths[arcLengths.length - 1];\r\n\r\n            //  Cannot overshoot the curve\r\n            var targetLineLength = Math.min(distance, lineLength);\r\n\r\n            t = targetLineLength / lineLength;\r\n        }\r\n        else\r\n        {\r\n            t = u;\r\n        }\r\n\r\n        return t;\r\n    },\r\n\r\n    //  Override default Curve.draw because this is better than calling getPoints on a line!\r\n\r\n    /**\r\n     * Draws this curve on the given Graphics object.\r\n     *\r\n     * The curve is drawn using `Graphics.lineBetween` so will be drawn at whatever the present Graphics line color is.\r\n     * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.\r\n     *\r\n     * @method Phaser.Curves.Line#draw\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics instance onto which this curve will be drawn.\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The Graphics object to which the curve was drawn.\r\n     */\r\n    draw: function (graphics)\r\n    {\r\n        graphics.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y);\r\n\r\n        //  So you can chain graphics calls\r\n        return graphics;\r\n    },\r\n\r\n    /**\r\n     * Gets a JSON representation of the line.\r\n     *\r\n     * @method Phaser.Curves.Line#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.Curves.JSONCurve} The JSON object containing this curve data.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return {\r\n            type: this.type,\r\n            points: [\r\n                this.p0.x, this.p0.y,\r\n                this.p1.x, this.p1.y\r\n            ]\r\n        };\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Configures this line from a JSON representation.\r\n *\r\n * @function Phaser.Curves.Line.fromJSON\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Curves.JSONCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.Line} A new LineCurve object.\r\n */\r\nLineCurve.fromJSON = function (data)\r\n{\r\n    var points = data.points;\r\n\r\n    var p0 = new Vector2(points[0], points[1]);\r\n    var p1 = new Vector2(points[2], points[3]);\r\n\r\n    return new LineCurve(p0, p1);\r\n};\r\n\r\nmodule.exports = LineCurve;\r\n"]},"metadata":{},"sourceType":"script"}