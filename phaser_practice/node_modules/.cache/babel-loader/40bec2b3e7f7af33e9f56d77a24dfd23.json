{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar Components = require('../gameobjects/components');\n\nvar Rectangle = require('../geom/rectangle');\n/**\r\n * @classdesc\r\n * A Tile is a representation of a single tile within the Tilemap. This is a lightweight data\r\n * representation, so its position information is stored without factoring in scroll, layer\r\n * scale or layer position.\r\n *\r\n * @class Tile\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The LayerData object in the Tilemap that this tile belongs to.\r\n * @param {integer} index - The unique index of this tile within the map.\r\n * @param {integer} x - The x coordinate of this tile in tile coordinates.\r\n * @param {integer} y - The y coordinate of this tile in tile coordinates.\r\n * @param {integer} width - Width of the tile in pixels.\r\n * @param {integer} height - Height of the tile in pixels.\r\n * @param {integer} baseWidth - The base width a tile in the map (in pixels). Tiled maps support\r\n * multiple tileset sizes within one map, but they are still placed at intervals of the base\r\n * tile width.\r\n * @param {integer} baseHeight - The base height of the tile in pixels (in pixels). Tiled maps\r\n * support multiple tileset sizes within one map, but they are still placed at intervals of the\r\n * base tile height.\r\n */\n\n\nvar Tile = new Class({\n  Mixins: [Components.Alpha, Components.Flip, Components.Visible],\n  initialize: function Tile(layer, index, x, y, width, height, baseWidth, baseHeight) {\n    /**\r\n     * The LayerData in the Tilemap data that this tile belongs to.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#layer\r\n     * @type {Phaser.Tilemaps.LayerData}\r\n     * @since 3.0.0\r\n     */\n    this.layer = layer;\n    /**\r\n     * The index of this tile within the map data corresponding to the tileset, or -1 if this\r\n     * represents a blank tile.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#index\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.index = index;\n    /**\r\n     * The x map coordinate of this tile in tile units.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#x\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.x = x;\n    /**\r\n     * The y map coordinate of this tile in tile units.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#y\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.y = y;\n    /**\r\n     * The width of the tile in pixels.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#width\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.width = width;\n    /**\r\n     * The height of the tile in pixels.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#height\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.height = height;\n    /**\r\n     * The map's base width of a tile in pixels. Tiled maps support multiple tileset sizes\r\n     * within one map, but they are still placed at intervals of the base tile size.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#baseWidth\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.baseWidth = baseWidth !== undefined ? baseWidth : width;\n    /**\r\n     * The map's base height of a tile in pixels. Tiled maps support multiple tileset sizes\r\n     * within one map, but they are still placed at intervals of the base tile size.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#baseHeight\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.baseHeight = baseHeight !== undefined ? baseHeight : height;\n    /**\r\n     * The x coordinate of the top left of this tile in pixels. This is relative to the top left\r\n     * of the layer this tile is being rendered within. This property does NOT factor in camera\r\n     * scroll, layer scale or layer position.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#pixelX\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.pixelX = 0;\n    /**\r\n     * The y coordinate of the top left of this tile in pixels. This is relative to the top left\r\n     * of the layer this tile is being rendered within. This property does NOT factor in camera\r\n     * scroll, layer scale or layer position.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#pixelY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.pixelY = 0;\n    this.updatePixelXY();\n    /**\r\n     * Tile specific properties. These usually come from Tiled.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#properties\r\n     * @type {any}\r\n     * @since 3.0.0\r\n     */\n\n    this.properties = {};\n    /**\r\n     * The rotation angle of this tile.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#rotation\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.rotation = 0;\n    /**\r\n     * Whether the tile should collide with any object on the left side.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#collideLeft\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.collideLeft = false;\n    /**\r\n     * Whether the tile should collide with any object on the right side.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#collideRight\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.collideRight = false;\n    /**\r\n     * Whether the tile should collide with any object on the top side.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#collideUp\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.collideUp = false;\n    /**\r\n     * Whether the tile should collide with any object on the bottom side.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#collideDown\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.collideDown = false;\n    /**\r\n     * Whether the tile's left edge is interesting for collisions.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#faceLeft\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.faceLeft = false;\n    /**\r\n     * Whether the tile's right edge is interesting for collisions.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#faceRight\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.faceRight = false;\n    /**\r\n     * Whether the tile's top edge is interesting for collisions.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#faceTop\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.faceTop = false;\n    /**\r\n     * Whether the tile's bottom edge is interesting for collisions.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#faceBottom\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.faceBottom = false;\n    /**\r\n     * Tile collision callback.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#collisionCallback\r\n     * @type {function}\r\n     * @since 3.0.0\r\n     */\n\n    this.collisionCallback = null;\n    /**\r\n     * The context in which the collision callback will be called.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#collisionCallbackContext\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.collisionCallbackContext = this;\n    /**\r\n     * The tint to apply to this tile. Note: tint is currently a single color value instead of\r\n     * the 4 corner tint component on other GameObjects.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tint\r\n     * @type {number}\r\n     * @default\r\n     * @since 3.0.0\r\n     */\n\n    this.tint = 0xffffff;\n    /**\r\n     * An empty object where physics-engine specific information (e.g. bodies) may be stored.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#physics\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.physics = {};\n  },\n\n  /**\r\n   * Check if the given x and y world coordinates are within this Tile. This does not factor in\r\n   * camera scroll, layer scale or layer position.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#containsPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The x coordinate to test.\r\n   * @param {number} y - The y coordinate to test.\r\n   *\r\n   * @return {boolean} True if the coordinates are within this Tile, otherwise false.\r\n   */\n  containsPoint: function (x, y) {\n    return !(x < this.pixelX || y < this.pixelY || x > this.right || y > this.bottom);\n  },\n\n  /**\r\n   * Copies the tile data & properties from the given tile to this tile. This copies everything\r\n   * except for position and interesting faces.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#copy\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Tilemaps.Tile} tile - The tile to copy from.\r\n   *\r\n   * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n   */\n  copy: function (tile) {\n    this.index = tile.index;\n    this.alpha = tile.alpha;\n    this.properties = tile.properties;\n    this.visible = tile.visible;\n    this.setFlip(tile.flipX, tile.flipY);\n    this.tint = tile.tint;\n    this.rotation = tile.rotation;\n    this.collideUp = tile.collideUp;\n    this.collideDown = tile.collideDown;\n    this.collideLeft = tile.collideLeft;\n    this.collideRight = tile.collideRight;\n    this.collisionCallback = tile.collisionCallback;\n    this.collisionCallbackContext = tile.collisionCallbackContext;\n    return this;\n  },\n\n  /**\r\n   * The collision group for this Tile, defined within the Tileset. This returns a reference to\r\n   * the collision group stored within the Tileset, so any modification of the returned object\r\n   * will impact all tiles that have the same index as this tile.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#getCollisionGroup\r\n   * @since 3.0.0\r\n   *\r\n   * @return {?object} tileset\r\n   */\n  getCollisionGroup: function () {\n    return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null;\n  },\n\n  /**\r\n   * The tile data for this Tile, defined within the Tileset. This typically contains Tiled\r\n   * collision data, tile animations and terrain information. This returns a reference to the tile\r\n   * data stored within the Tileset, so any modification of the returned object will impact all\r\n   * tiles that have the same index as this tile.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#getTileData\r\n   * @since 3.0.0\r\n   *\r\n   * @return {?object} tileset\r\n   */\n  getTileData: function () {\n    return this.tileset ? this.tileset.getTileData(this.index) : null;\n  },\n\n  /**\r\n   * Gets the world X position of the left side of the tile, factoring in the layers position,\r\n   * scale and scroll.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#getLeft\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n   *\r\n   * @return {number}\r\n   */\n  getLeft: function (camera) {\n    var tilemapLayer = this.tilemapLayer;\n    return tilemapLayer ? tilemapLayer.tileToWorldX(this.x, camera) : this.x * this.baseWidth;\n  },\n\n  /**\r\n   * Gets the world X position of the right side of the tile, factoring in the layer's position,\r\n   * scale and scroll.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#getRight\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n   *\r\n   * @return {number}\r\n   */\n  getRight: function (camera) {\n    var tilemapLayer = this.tilemapLayer;\n    return tilemapLayer ? this.getLeft(camera) + this.width * tilemapLayer.scaleX : this.getLeft(camera) + this.width;\n  },\n\n  /**\r\n   * Gets the world Y position of the top side of the tile, factoring in the layer's position,\r\n   * scale and scroll.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#getTop\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n   *\r\n   * @return {number}\r\n   */\n  getTop: function (camera) {\n    var tilemapLayer = this.tilemapLayer; // Tiled places tiles on a grid of baseWidth x baseHeight. The origin for a tile in grid\n    // units is the bottom left, so the y coordinate needs to be adjusted by the difference\n    // between the base size and this tile's size.\n\n    return tilemapLayer ? tilemapLayer.tileToWorldY(this.y, camera) - (this.height - this.baseHeight) * tilemapLayer.scaleY : this.y * this.baseHeight - (this.height - this.baseHeight);\n  },\n\n  /**\r\n   * Gets the world Y position of the bottom side of the tile, factoring in the layer's position,\r\n   * scale and scroll.\r\n     * @method Phaser.Tilemaps.Tile#getBottom\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n   *\r\n   * @return {number}\r\n   */\n  getBottom: function (camera) {\n    var tilemapLayer = this.tilemapLayer;\n    return tilemapLayer ? this.getTop(camera) + this.height * tilemapLayer.scaleY : this.getTop(camera) + this.height;\n  },\n\n  /**\r\n   * Gets the world rectangle bounding box for the tile, factoring in the layers position,\r\n   * scale and scroll.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#getBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n   * @param {object} [output] - [description]\r\n   *\r\n   * @return {(Phaser.Geom.Rectangle|object)}\r\n   */\n  getBounds: function (camera, output) {\n    if (output === undefined) {\n      output = new Rectangle();\n    }\n\n    output.x = this.getLeft();\n    output.y = this.getTop();\n    output.width = this.getRight() - output.x;\n    output.height = this.getBottom() - output.y;\n    return output;\n  },\n\n  /**\r\n   * Gets the world X position of the center of the tile, factoring in the layer's position,\r\n   * scale and scroll.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#getCenterX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n   *\r\n   * @return {number}\r\n   */\n  getCenterX: function (camera) {\n    return (this.getLeft(camera) + this.getRight(camera)) / 2;\n  },\n\n  /**\r\n   * Gets the world Y position of the center of the tile, factoring in the layer's position,\r\n   * scale and scroll.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#getCenterY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n   *\r\n   * @return {number}\r\n   */\n  getCenterY: function (camera) {\n    return (this.getTop(camera) + this.getBottom(camera)) / 2;\n  },\n\n  /**\r\n   * Clean up memory.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.collisionCallback = undefined;\n    this.collisionCallbackContext = undefined;\n    this.properties = undefined;\n  },\n\n  /**\r\n   * Check for intersection with this tile. This does not factor in camera scroll, layer scale or\r\n   * layer position.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#intersects\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The x axis in pixels.\r\n   * @param {number} y - The y axis in pixels.\r\n   * @param {number} right - The right point.\r\n   * @param {number} bottom - The bottom point.\r\n   *\r\n   * @return {boolean}\r\n   */\n  intersects: function (x, y, right, bottom) {\n    return !(right <= this.pixelX || bottom <= this.pixelY || x >= this.right || y >= this.bottom);\n  },\n\n  /**\r\n   * Checks if the tile is interesting.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#isInteresting\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} collides - If true, will consider the tile interesting if it collides on any side.\r\n   * @param {boolean} faces - If true, will consider the tile interesting if it has an interesting face.\r\n   *\r\n   * @return {boolean} True if the Tile is interesting, otherwise false.\r\n   */\n  isInteresting: function (collides, faces) {\n    if (collides && faces) {\n      return this.canCollide || this.hasInterestingFace;\n    } else if (collides) {\n      return this.collides;\n    } else if (faces) {\n      return this.hasInterestingFace;\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Reset collision status flags.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#resetCollision\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate interesting faces for this tile and its neighbors.\r\n   *\r\n   * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n   */\n  resetCollision: function (recalculateFaces) {\n    if (recalculateFaces === undefined) {\n      recalculateFaces = true;\n    }\n\n    this.collideLeft = false;\n    this.collideRight = false;\n    this.collideUp = false;\n    this.collideDown = false;\n    this.faceTop = false;\n    this.faceBottom = false;\n    this.faceLeft = false;\n    this.faceRight = false;\n\n    if (recalculateFaces) {\n      var tilemapLayer = this.tilemapLayer;\n\n      if (tilemapLayer) {\n        this.tilemapLayer.calculateFacesAt(this.x, this.y);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Reset faces.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#resetFaces\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n   */\n  resetFaces: function () {\n    this.faceTop = false;\n    this.faceBottom = false;\n    this.faceLeft = false;\n    this.faceRight = false;\n    return this;\n  },\n\n  /**\r\n   * Sets the collision flags for each side of this tile and updates the interesting faces list.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#setCollision\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} left - Indicating collide with any object on the left.\r\n   * @param {boolean} [right] - Indicating collide with any object on the right.\r\n   * @param {boolean} [up] - Indicating collide with any object on the top.\r\n   * @param {boolean} [down] - Indicating collide with any object on the bottom.\r\n   * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate interesting faces\r\n   * for this tile and its neighbors.\r\n   *\r\n   * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n   */\n  setCollision: function (left, right, up, down, recalculateFaces) {\n    if (right === undefined) {\n      right = left;\n    }\n\n    if (up === undefined) {\n      up = left;\n    }\n\n    if (down === undefined) {\n      down = left;\n    }\n\n    if (recalculateFaces === undefined) {\n      recalculateFaces = true;\n    }\n\n    this.collideLeft = left;\n    this.collideRight = right;\n    this.collideUp = up;\n    this.collideDown = down;\n    this.faceLeft = left;\n    this.faceRight = right;\n    this.faceTop = up;\n    this.faceBottom = down;\n\n    if (recalculateFaces) {\n      var tilemapLayer = this.tilemapLayer;\n\n      if (tilemapLayer) {\n        this.tilemapLayer.calculateFacesAt(this.x, this.y);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Set a callback to be called when this tile is hit by an object. The callback must true for\r\n   * collision processing to take place.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#setCollisionCallback\r\n   * @since 3.0.0\r\n   *\r\n   * @param {function} callback - Callback function.\r\n   * @param {object} context - Callback will be called within this context.\r\n   *\r\n   * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n   */\n  setCollisionCallback: function (callback, context) {\n    if (callback === null) {\n      this.collisionCallback = undefined;\n      this.collisionCallbackContext = undefined;\n    } else {\n      this.collisionCallback = callback;\n      this.collisionCallbackContext = context;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the size of the tile and updates its pixelX and pixelY.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#setSize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} tileWidth - The width of the tile in pixels.\r\n   * @param {integer} tileHeight - The height of the tile in pixels.\r\n   * @param {integer} baseWidth - The base width a tile in the map (in pixels).\r\n   * @param {integer} baseHeight - The base height of the tile in pixels (in pixels).\r\n   *\r\n   * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n   */\n  setSize: function (tileWidth, tileHeight, baseWidth, baseHeight) {\n    if (tileWidth !== undefined) {\n      this.width = tileWidth;\n    }\n\n    if (tileHeight !== undefined) {\n      this.height = tileHeight;\n    }\n\n    if (baseWidth !== undefined) {\n      this.baseWidth = baseWidth;\n    }\n\n    if (baseHeight !== undefined) {\n      this.baseHeight = baseHeight;\n    }\n\n    this.updatePixelXY();\n    return this;\n  },\n\n  /**\r\n   * Used internally. Updates the tile's world XY position based on the current tile size.\r\n   *\r\n   * @method Phaser.Tilemaps.Tile#updatePixelXY\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n   */\n  updatePixelXY: function () {\n    // Tiled places tiles on a grid of baseWidth x baseHeight. The origin for a tile is the\n    // bottom left, while the Phaser renderer assumes the origin is the top left. The y\n    // coordinate needs to be adjusted by the difference.\n    this.pixelX = this.x * this.baseWidth;\n    this.pixelY = this.y * this.baseHeight; // this.pixelY = this.y * this.baseHeight - (this.height - this.baseHeight);\n\n    return this;\n  },\n\n  /**\r\n   * True if this tile can collide on any of its faces or has a collision callback set.\r\n   *\r\n   * @name Phaser.Tilemaps.Tile#canCollide\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  canCollide: {\n    get: function () {\n      return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback;\n    }\n  },\n\n  /**\r\n   * True if this tile can collide on any of its faces.\r\n   *\r\n   * @name Phaser.Tilemaps.Tile#collides\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  collides: {\n    get: function () {\n      return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;\n    }\n  },\n\n  /**\r\n   * True if this tile has any interesting faces.\r\n   *\r\n   * @name Phaser.Tilemaps.Tile#hasInterestingFace\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  hasInterestingFace: {\n    get: function () {\n      return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight;\n    }\n  },\n\n  /**\r\n   * The tileset that contains this Tile. This is null if accessed from a LayerData instance\r\n   * before the tile is placed in a StaticTilemapLayer or DynamicTilemapLayer, or if the tile has\r\n   * an index that doesn't correspond to any of the map's tilesets.\r\n   *\r\n   * @name Phaser.Tilemaps.Tile#tileset\r\n   * @type {?Phaser.Tilemaps.Tileset}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  tileset: {\n    get: function () {\n      var tilemapLayer = this.layer.tilemapLayer;\n\n      if (tilemapLayer) {\n        var tileset = tilemapLayer.gidMap[this.index];\n\n        if (tileset) {\n          return tileset;\n        }\n      }\n\n      return null;\n    }\n  },\n\n  /**\r\n   * The tilemap layer that contains this Tile. This will only return null if accessed from a\r\n   * LayerData instance before the tile is placed within a StaticTilemapLayer or\r\n   * DynamicTilemapLayer.\r\n   *\r\n   * @name Phaser.Tilemaps.Tile#tilemapLayer\r\n   * @type {?Phaser.Tilemaps.StaticTilemapLayer|Phaser.Tilemaps.DynamicTilemapLayer}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  tilemapLayer: {\n    get: function () {\n      return this.layer.tilemapLayer;\n    }\n  },\n\n  /**\r\n   * The tilemap that contains this Tile. This will only return null if accessed from a LayerData\r\n   * instance before the tile is placed within a StaticTilemapLayer or DynamicTilemapLayer.\r\n   *\r\n   * @name Phaser.Tilemaps.Tile#tilemap\r\n   * @type {?Phaser.Tilemaps.Tilemap}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  tilemap: {\n    get: function () {\n      var tilemapLayer = this.tilemapLayer;\n      return tilemapLayer ? tilemapLayer.tilemap : null;\n    }\n  }\n});\nmodule.exports = Tile;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/tilemaps/Tile.js"],"names":["Class","require","Components","Rectangle","Tile","Mixins","Alpha","Flip","Visible","initialize","layer","index","x","y","width","height","baseWidth","baseHeight","undefined","pixelX","pixelY","updatePixelXY","properties","rotation","collideLeft","collideRight","collideUp","collideDown","faceLeft","faceRight","faceTop","faceBottom","collisionCallback","collisionCallbackContext","tint","physics","containsPoint","right","bottom","copy","tile","alpha","visible","setFlip","flipX","flipY","getCollisionGroup","tileset","getTileCollisionGroup","getTileData","getLeft","camera","tilemapLayer","tileToWorldX","getRight","scaleX","getTop","tileToWorldY","scaleY","getBottom","getBounds","output","getCenterX","getCenterY","destroy","intersects","isInteresting","collides","faces","canCollide","hasInterestingFace","resetCollision","recalculateFaces","calculateFacesAt","resetFaces","setCollision","left","up","down","setCollisionCallback","callback","context","setSize","tileWidth","tileHeight","get","gidMap","tilemap","module","exports"],"mappings":"AAAA;;;;;AAMA,IAAIA,KAAK,GAAGC,OAAO,CAAC,gBAAD,CAAnB;;AACA,IAAIC,UAAU,GAAGD,OAAO,CAAC,2BAAD,CAAxB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,mBAAD,CAAvB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,IAAIG,IAAI,GAAG,IAAIJ,KAAJ,CAAU;AAEjBK,EAAAA,MAAM,EAAE,CACJH,UAAU,CAACI,KADP,EAEJJ,UAAU,CAACK,IAFP,EAGJL,UAAU,CAACM,OAHP,CAFS;AAQjBC,EAAAA,UAAU,EAEV,SAASL,IAAT,CAAeM,KAAf,EAAsBC,KAAtB,EAA6BC,CAA7B,EAAgCC,CAAhC,EAAmCC,KAAnC,EAA0CC,MAA1C,EAAkDC,SAAlD,EAA6DC,UAA7D,EACA;AACI;;;;;;;AAOA,SAAKP,KAAL,GAAaA,KAAb;AAEA;;;;;;;;;AAQA,SAAKC,KAAL,GAAaA,KAAb;AAEA;;;;;;;;AAOA,SAAKC,CAAL,GAASA,CAAT;AAEA;;;;;;;;AAOA,SAAKC,CAAL,GAASA,CAAT;AAEA;;;;;;;;AAOA,SAAKC,KAAL,GAAaA,KAAb;AAEA;;;;;;;;AAOA,SAAKC,MAAL,GAAcA,MAAd;AAEA;;;;;;;;;AAQA,SAAKC,SAAL,GAAkBA,SAAS,KAAKE,SAAf,GAA4BF,SAA5B,GAAwCF,KAAzD;AAEA;;;;;;;;;AAQA,SAAKG,UAAL,GAAmBA,UAAU,KAAKC,SAAhB,GAA6BD,UAA7B,GAA0CF,MAA5D;AAEA;;;;;;;;;;AASA,SAAKI,MAAL,GAAc,CAAd;AAEA;;;;;;;;;;AASA,SAAKC,MAAL,GAAc,CAAd;AAEA,SAAKC,aAAL;AAEA;;;;;;;;AAOA,SAAKC,UAAL,GAAkB,EAAlB;AAEA;;;;;;;;AAOA,SAAKC,QAAL,GAAgB,CAAhB;AAEA;;;;;;;;AAOA,SAAKC,WAAL,GAAmB,KAAnB;AAEA;;;;;;;;AAOA,SAAKC,YAAL,GAAoB,KAApB;AAEA;;;;;;;;AAOA,SAAKC,SAAL,GAAiB,KAAjB;AAEA;;;;;;;;AAOA,SAAKC,WAAL,GAAmB,KAAnB;AAEA;;;;;;;;AAOA,SAAKC,QAAL,GAAgB,KAAhB;AAEA;;;;;;;;AAOA,SAAKC,SAAL,GAAiB,KAAjB;AAEA;;;;;;;;AAOA,SAAKC,OAAL,GAAe,KAAf;AAEA;;;;;;;;AAOA,SAAKC,UAAL,GAAkB,KAAlB;AAEA;;;;;;;;AAOA,SAAKC,iBAAL,GAAyB,IAAzB;AAEA;;;;;;;;AAOA,SAAKC,wBAAL,GAAgC,IAAhC;AAEA;;;;;;;;;;AASA,SAAKC,IAAL,GAAY,QAAZ;AAEA;;;;;;;;AAOA,SAAKC,OAAL,GAAe,EAAf;AACH,GA9OgB;;AAgPjB;;;;;;;;;;;;AAYAC,EAAAA,aAAa,EAAE,UAAUxB,CAAV,EAAaC,CAAb,EACf;AACI,WAAO,EAAED,CAAC,GAAG,KAAKO,MAAT,IAAmBN,CAAC,GAAG,KAAKO,MAA5B,IAAsCR,CAAC,GAAG,KAAKyB,KAA/C,IAAwDxB,CAAC,GAAG,KAAKyB,MAAnE,CAAP;AACH,GA/PgB;;AAiQjB;;;;;;;;;;;AAWAC,EAAAA,IAAI,EAAE,UAAUC,IAAV,EACN;AACI,SAAK7B,KAAL,GAAa6B,IAAI,CAAC7B,KAAlB;AACA,SAAK8B,KAAL,GAAaD,IAAI,CAACC,KAAlB;AACA,SAAKnB,UAAL,GAAkBkB,IAAI,CAAClB,UAAvB;AACA,SAAKoB,OAAL,GAAeF,IAAI,CAACE,OAApB;AACA,SAAKC,OAAL,CAAaH,IAAI,CAACI,KAAlB,EAAyBJ,IAAI,CAACK,KAA9B;AACA,SAAKX,IAAL,GAAYM,IAAI,CAACN,IAAjB;AACA,SAAKX,QAAL,GAAgBiB,IAAI,CAACjB,QAArB;AACA,SAAKG,SAAL,GAAiBc,IAAI,CAACd,SAAtB;AACA,SAAKC,WAAL,GAAmBa,IAAI,CAACb,WAAxB;AACA,SAAKH,WAAL,GAAmBgB,IAAI,CAAChB,WAAxB;AACA,SAAKC,YAAL,GAAoBe,IAAI,CAACf,YAAzB;AACA,SAAKO,iBAAL,GAAyBQ,IAAI,CAACR,iBAA9B;AACA,SAAKC,wBAAL,GAAgCO,IAAI,CAACP,wBAArC;AAEA,WAAO,IAAP;AACH,GA7RgB;;AA+RjB;;;;;;;;;;AAUAa,EAAAA,iBAAiB,EAAE,YACnB;AACI,WAAO,KAAKC,OAAL,GAAe,KAAKA,OAAL,CAAaC,qBAAb,CAAmC,KAAKrC,KAAxC,CAAf,GAAgE,IAAvE;AACH,GA5SgB;;AA8SjB;;;;;;;;;;;AAWAsC,EAAAA,WAAW,EAAE,YACb;AACI,WAAO,KAAKF,OAAL,GAAe,KAAKA,OAAL,CAAaE,WAAb,CAAyB,KAAKtC,KAA9B,CAAf,GAAsD,IAA7D;AACH,GA5TgB;;AA8TjB;;;;;;;;;;;AAWAuC,EAAAA,OAAO,EAAE,UAAUC,MAAV,EACT;AACI,QAAIC,YAAY,GAAG,KAAKA,YAAxB;AAEA,WAAQA,YAAD,GAAiBA,YAAY,CAACC,YAAb,CAA0B,KAAKzC,CAA/B,EAAkCuC,MAAlC,CAAjB,GAA6D,KAAKvC,CAAL,GAAS,KAAKI,SAAlF;AACH,GA9UgB;;AAgVjB;;;;;;;;;;;AAWAsC,EAAAA,QAAQ,EAAE,UAAUH,MAAV,EACV;AACI,QAAIC,YAAY,GAAG,KAAKA,YAAxB;AAEA,WAAQA,YAAD,GAAiB,KAAKF,OAAL,CAAaC,MAAb,IAAuB,KAAKrC,KAAL,GAAasC,YAAY,CAACG,MAAlE,GAA2E,KAAKL,OAAL,CAAaC,MAAb,IAAuB,KAAKrC,KAA9G;AACH,GAhWgB;;AAkWjB;;;;;;;;;;;AAWA0C,EAAAA,MAAM,EAAE,UAAUL,MAAV,EACR;AACI,QAAIC,YAAY,GAAG,KAAKA,YAAxB,CADJ,CAGI;AACA;AACA;;AACA,WAAOA,YAAY,GACbA,YAAY,CAACK,YAAb,CAA0B,KAAK5C,CAA/B,EAAkCsC,MAAlC,IAA4C,CAAC,KAAKpC,MAAL,GAAc,KAAKE,UAApB,IAAkCmC,YAAY,CAACM,MAD9E,GAEb,KAAK7C,CAAL,GAAS,KAAKI,UAAd,IAA4B,KAAKF,MAAL,GAAc,KAAKE,UAA/C,CAFN;AAGH,GAvXgB;;AAyXjB;;;;;;;;;;AAWA0C,EAAAA,SAAS,EAAE,UAAUR,MAAV,EACX;AACI,QAAIC,YAAY,GAAG,KAAKA,YAAxB;AACA,WAAOA,YAAY,GACb,KAAKI,MAAL,CAAYL,MAAZ,IAAsB,KAAKpC,MAAL,GAAcqC,YAAY,CAACM,MADpC,GAEb,KAAKF,MAAL,CAAYL,MAAZ,IAAsB,KAAKpC,MAFjC;AAGH,GA1YgB;;AA6YjB;;;;;;;;;;;;AAYA6C,EAAAA,SAAS,EAAE,UAAUT,MAAV,EAAkBU,MAAlB,EACX;AACI,QAAIA,MAAM,KAAK3C,SAAf,EAA0B;AAAE2C,MAAAA,MAAM,GAAG,IAAI1D,SAAJ,EAAT;AAA2B;;AAEvD0D,IAAAA,MAAM,CAACjD,CAAP,GAAW,KAAKsC,OAAL,EAAX;AACAW,IAAAA,MAAM,CAAChD,CAAP,GAAW,KAAK2C,MAAL,EAAX;AACAK,IAAAA,MAAM,CAAC/C,KAAP,GAAe,KAAKwC,QAAL,KAAkBO,MAAM,CAACjD,CAAxC;AACAiD,IAAAA,MAAM,CAAC9C,MAAP,GAAgB,KAAK4C,SAAL,KAAmBE,MAAM,CAAChD,CAA1C;AAEA,WAAOgD,MAAP;AACH,GAnagB;;AAqajB;;;;;;;;;;;AAWAC,EAAAA,UAAU,EAAE,UAAUX,MAAV,EACZ;AACI,WAAO,CAAC,KAAKD,OAAL,CAAaC,MAAb,IAAuB,KAAKG,QAAL,CAAcH,MAAd,CAAxB,IAAiD,CAAxD;AACH,GAnbgB;;AAqbjB;;;;;;;;;;;AAWAY,EAAAA,UAAU,EAAE,UAAUZ,MAAV,EACZ;AACI,WAAO,CAAC,KAAKK,MAAL,CAAYL,MAAZ,IAAsB,KAAKQ,SAAL,CAAeR,MAAf,CAAvB,IAAiD,CAAxD;AACH,GAncgB;;AAqcjB;;;;;;AAMAa,EAAAA,OAAO,EAAE,YACT;AACI,SAAKhC,iBAAL,GAAyBd,SAAzB;AACA,SAAKe,wBAAL,GAAgCf,SAAhC;AACA,SAAKI,UAAL,GAAkBJ,SAAlB;AACH,GAhdgB;;AAkdjB;;;;;;;;;;;;;;AAcA+C,EAAAA,UAAU,EAAE,UAAUrD,CAAV,EAAaC,CAAb,EAAgBwB,KAAhB,EAAuBC,MAAvB,EACZ;AACI,WAAO,EACHD,KAAK,IAAI,KAAKlB,MAAd,IAAwBmB,MAAM,IAAI,KAAKlB,MAAvC,IACAR,CAAC,IAAI,KAAKyB,KADV,IACmBxB,CAAC,IAAI,KAAKyB,MAF1B,CAAP;AAIH,GAtegB;;AAwejB;;;;;;;;;;;AAWA4B,EAAAA,aAAa,EAAE,UAAUC,QAAV,EAAoBC,KAApB,EACf;AACI,QAAID,QAAQ,IAAIC,KAAhB,EAAuB;AAAE,aAAQ,KAAKC,UAAL,IAAmB,KAAKC,kBAAhC;AAAsD,KAA/E,MACK,IAAIH,QAAJ,EAAc;AAAE,aAAO,KAAKA,QAAZ;AAAuB,KAAvC,MACA,IAAIC,KAAJ,EAAW;AAAE,aAAO,KAAKE,kBAAZ;AAAiC;;AACnD,WAAO,KAAP;AACH,GAzfgB;;AA2fjB;;;;;;;;;;AAUAC,EAAAA,cAAc,EAAE,UAAUC,gBAAV,EAChB;AACI,QAAIA,gBAAgB,KAAKtD,SAAzB,EAAoC;AAAEsD,MAAAA,gBAAgB,GAAG,IAAnB;AAA0B;;AAEhE,SAAKhD,WAAL,GAAmB,KAAnB;AACA,SAAKC,YAAL,GAAoB,KAApB;AACA,SAAKC,SAAL,GAAiB,KAAjB;AACA,SAAKC,WAAL,GAAmB,KAAnB;AAEA,SAAKG,OAAL,GAAe,KAAf;AACA,SAAKC,UAAL,GAAkB,KAAlB;AACA,SAAKH,QAAL,GAAgB,KAAhB;AACA,SAAKC,SAAL,GAAiB,KAAjB;;AAEA,QAAI2C,gBAAJ,EACA;AACI,UAAIpB,YAAY,GAAG,KAAKA,YAAxB;;AAEA,UAAIA,YAAJ,EACA;AACI,aAAKA,YAAL,CAAkBqB,gBAAlB,CAAmC,KAAK7D,CAAxC,EAA2C,KAAKC,CAAhD;AACH;AACJ;;AAED,WAAO,IAAP;AACH,GA9hBgB;;AAgiBjB;;;;;;;;AAQA6D,EAAAA,UAAU,EAAE,YACZ;AACI,SAAK5C,OAAL,GAAe,KAAf;AACA,SAAKC,UAAL,GAAkB,KAAlB;AACA,SAAKH,QAAL,GAAgB,KAAhB;AACA,SAAKC,SAAL,GAAiB,KAAjB;AAEA,WAAO,IAAP;AACH,GAhjBgB;;AAkjBjB;;;;;;;;;;;;;;;AAeA8C,EAAAA,YAAY,EAAE,UAAUC,IAAV,EAAgBvC,KAAhB,EAAuBwC,EAAvB,EAA2BC,IAA3B,EAAiCN,gBAAjC,EACd;AACI,QAAInC,KAAK,KAAKnB,SAAd,EAAyB;AAAEmB,MAAAA,KAAK,GAAGuC,IAAR;AAAe;;AAC1C,QAAIC,EAAE,KAAK3D,SAAX,EAAsB;AAAE2D,MAAAA,EAAE,GAAGD,IAAL;AAAY;;AACpC,QAAIE,IAAI,KAAK5D,SAAb,EAAwB;AAAE4D,MAAAA,IAAI,GAAGF,IAAP;AAAc;;AACxC,QAAIJ,gBAAgB,KAAKtD,SAAzB,EAAoC;AAAEsD,MAAAA,gBAAgB,GAAG,IAAnB;AAA0B;;AAEhE,SAAKhD,WAAL,GAAmBoD,IAAnB;AACA,SAAKnD,YAAL,GAAoBY,KAApB;AACA,SAAKX,SAAL,GAAiBmD,EAAjB;AACA,SAAKlD,WAAL,GAAmBmD,IAAnB;AAEA,SAAKlD,QAAL,GAAgBgD,IAAhB;AACA,SAAK/C,SAAL,GAAiBQ,KAAjB;AACA,SAAKP,OAAL,GAAe+C,EAAf;AACA,SAAK9C,UAAL,GAAkB+C,IAAlB;;AAEA,QAAIN,gBAAJ,EACA;AACI,UAAIpB,YAAY,GAAG,KAAKA,YAAxB;;AAEA,UAAIA,YAAJ,EACA;AACI,aAAKA,YAAL,CAAkBqB,gBAAlB,CAAmC,KAAK7D,CAAxC,EAA2C,KAAKC,CAAhD;AACH;AACJ;;AAED,WAAO,IAAP;AACH,GA7lBgB;;AA+lBjB;;;;;;;;;;;;AAYAkE,EAAAA,oBAAoB,EAAE,UAAUC,QAAV,EAAoBC,OAApB,EACtB;AACI,QAAID,QAAQ,KAAK,IAAjB,EACA;AACI,WAAKhD,iBAAL,GAAyBd,SAAzB;AACA,WAAKe,wBAAL,GAAgCf,SAAhC;AACH,KAJD,MAMA;AACI,WAAKc,iBAAL,GAAyBgD,QAAzB;AACA,WAAK/C,wBAAL,GAAgCgD,OAAhC;AACH;;AAED,WAAO,IAAP;AACH,GAznBgB;;AA2nBjB;;;;;;;;;;;;;AAaAC,EAAAA,OAAO,EAAE,UAAUC,SAAV,EAAqBC,UAArB,EAAiCpE,SAAjC,EAA4CC,UAA5C,EACT;AACI,QAAIkE,SAAS,KAAKjE,SAAlB,EAA6B;AAAE,WAAKJ,KAAL,GAAaqE,SAAb;AAAyB;;AACxD,QAAIC,UAAU,KAAKlE,SAAnB,EAA8B;AAAE,WAAKH,MAAL,GAAcqE,UAAd;AAA2B;;AAC3D,QAAIpE,SAAS,KAAKE,SAAlB,EAA6B;AAAE,WAAKF,SAAL,GAAiBA,SAAjB;AAA6B;;AAC5D,QAAIC,UAAU,KAAKC,SAAnB,EAA8B;AAAE,WAAKD,UAAL,GAAkBA,UAAlB;AAA+B;;AAE/D,SAAKI,aAAL;AAEA,WAAO,IAAP;AACH,GAlpBgB;;AAopBjB;;;;;;;;AAQAA,EAAAA,aAAa,EAAE,YACf;AACI;AACA;AACA;AACA,SAAKF,MAAL,GAAc,KAAKP,CAAL,GAAS,KAAKI,SAA5B;AACA,SAAKI,MAAL,GAAc,KAAKP,CAAL,GAAS,KAAKI,UAA5B,CALJ,CAOI;;AAEA,WAAO,IAAP;AACH,GAvqBgB;;AAyqBjB;;;;;;;;AAQAoD,EAAAA,UAAU,EAAE;AACRgB,IAAAA,GAAG,EAAE,YACL;AACI,aAAQ,KAAK7D,WAAL,IAAoB,KAAKC,YAAzB,IAAyC,KAAKC,SAA9C,IAA2D,KAAKC,WAAhE,IAA+E,KAAKK,iBAA5F;AACH;AAJO,GAjrBK;;AAwrBjB;;;;;;;;AAQAmC,EAAAA,QAAQ,EAAE;AACNkB,IAAAA,GAAG,EAAE,YACL;AACI,aAAQ,KAAK7D,WAAL,IAAoB,KAAKC,YAAzB,IAAyC,KAAKC,SAA9C,IAA2D,KAAKC,WAAxE;AACH;AAJK,GAhsBO;;AAusBjB;;;;;;;;AAQA2C,EAAAA,kBAAkB,EAAE;AAChBe,IAAAA,GAAG,EAAE,YACL;AACI,aAAQ,KAAKvD,OAAL,IAAgB,KAAKC,UAArB,IAAmC,KAAKH,QAAxC,IAAoD,KAAKC,SAAjE;AACH;AAJe,GA/sBH;;AAstBjB;;;;;;;;;;AAUAkB,EAAAA,OAAO,EAAE;AAELsC,IAAAA,GAAG,EAAE,YACL;AACI,UAAIjC,YAAY,GAAG,KAAK1C,KAAL,CAAW0C,YAA9B;;AAEA,UAAIA,YAAJ,EACA;AACI,YAAIL,OAAO,GAAGK,YAAY,CAACkC,MAAb,CAAoB,KAAK3E,KAAzB,CAAd;;AAEA,YAAIoC,OAAJ,EACA;AACI,iBAAOA,OAAP;AACH;AACJ;;AAED,aAAO,IAAP;AACH;AAjBI,GAhuBQ;;AAqvBjB;;;;;;;;;;AAUAK,EAAAA,YAAY,EAAE;AACViC,IAAAA,GAAG,EAAE,YACL;AACI,aAAO,KAAK3E,KAAL,CAAW0C,YAAlB;AACH;AAJS,GA/vBG;;AAswBjB;;;;;;;;;AASAmC,EAAAA,OAAO,EAAE;AACLF,IAAAA,GAAG,EAAE,YACL;AACI,UAAIjC,YAAY,GAAG,KAAKA,YAAxB;AACA,aAAOA,YAAY,GAAGA,YAAY,CAACmC,OAAhB,GAA0B,IAA7C;AACH;AALI;AA/wBQ,CAAV,CAAX;AAyxBAC,MAAM,CAACC,OAAP,GAAiBrF,IAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar Components = require('../gameobjects/components');\r\nvar Rectangle = require('../geom/rectangle');\r\n\r\n/**\r\n * @classdesc\r\n * A Tile is a representation of a single tile within the Tilemap. This is a lightweight data\r\n * representation, so its position information is stored without factoring in scroll, layer\r\n * scale or layer position.\r\n *\r\n * @class Tile\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The LayerData object in the Tilemap that this tile belongs to.\r\n * @param {integer} index - The unique index of this tile within the map.\r\n * @param {integer} x - The x coordinate of this tile in tile coordinates.\r\n * @param {integer} y - The y coordinate of this tile in tile coordinates.\r\n * @param {integer} width - Width of the tile in pixels.\r\n * @param {integer} height - Height of the tile in pixels.\r\n * @param {integer} baseWidth - The base width a tile in the map (in pixels). Tiled maps support\r\n * multiple tileset sizes within one map, but they are still placed at intervals of the base\r\n * tile width.\r\n * @param {integer} baseHeight - The base height of the tile in pixels (in pixels). Tiled maps\r\n * support multiple tileset sizes within one map, but they are still placed at intervals of the\r\n * base tile height.\r\n */\r\nvar Tile = new Class({\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.Flip,\r\n        Components.Visible\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Tile (layer, index, x, y, width, height, baseWidth, baseHeight)\r\n    {\r\n        /**\r\n         * The LayerData in the Tilemap data that this tile belongs to.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#layer\r\n         * @type {Phaser.Tilemaps.LayerData}\r\n         * @since 3.0.0\r\n         */\r\n        this.layer = layer;\r\n\r\n        /**\r\n         * The index of this tile within the map data corresponding to the tileset, or -1 if this\r\n         * represents a blank tile.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#index\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.index = index;\r\n\r\n        /**\r\n         * The x map coordinate of this tile in tile units.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#x\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.x = x;\r\n\r\n        /**\r\n         * The y map coordinate of this tile in tile units.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#y\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.y = y;\r\n\r\n        /**\r\n         * The width of the tile in pixels.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#width\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = width;\r\n\r\n        /**\r\n         * The height of the tile in pixels.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#height\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = height;\r\n\r\n        /**\r\n         * The map's base width of a tile in pixels. Tiled maps support multiple tileset sizes\r\n         * within one map, but they are still placed at intervals of the base tile size.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#baseWidth\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.baseWidth = (baseWidth !== undefined) ? baseWidth : width;\r\n\r\n        /**\r\n         * The map's base height of a tile in pixels. Tiled maps support multiple tileset sizes\r\n         * within one map, but they are still placed at intervals of the base tile size.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#baseHeight\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.baseHeight = (baseHeight !== undefined) ? baseHeight : height;\r\n\r\n        /**\r\n         * The x coordinate of the top left of this tile in pixels. This is relative to the top left\r\n         * of the layer this tile is being rendered within. This property does NOT factor in camera\r\n         * scroll, layer scale or layer position.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#pixelX\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.pixelX = 0;\r\n\r\n        /**\r\n         * The y coordinate of the top left of this tile in pixels. This is relative to the top left\r\n         * of the layer this tile is being rendered within. This property does NOT factor in camera\r\n         * scroll, layer scale or layer position.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#pixelY\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.pixelY = 0;\r\n\r\n        this.updatePixelXY();\r\n\r\n        /**\r\n         * Tile specific properties. These usually come from Tiled.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#properties\r\n         * @type {any}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = {};\r\n\r\n        /**\r\n         * The rotation angle of this tile.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#rotation\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.rotation = 0;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the left side.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideLeft\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideLeft = false;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the right side.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideRight\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideRight = false;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the top side.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideUp\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideUp = false;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the bottom side.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideDown\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideDown = false;\r\n\r\n        /**\r\n         * Whether the tile's left edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceLeft\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceLeft = false;\r\n\r\n        /**\r\n         * Whether the tile's right edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceRight\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceRight = false;\r\n\r\n        /**\r\n         * Whether the tile's top edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceTop\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceTop = false;\r\n\r\n        /**\r\n         * Whether the tile's bottom edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceBottom\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceBottom = false;\r\n\r\n        /**\r\n         * Tile collision callback.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collisionCallback\r\n         * @type {function}\r\n         * @since 3.0.0\r\n         */\r\n        this.collisionCallback = null;\r\n\r\n        /**\r\n         * The context in which the collision callback will be called.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collisionCallbackContext\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.collisionCallbackContext = this;\r\n\r\n        /**\r\n         * The tint to apply to this tile. Note: tint is currently a single color value instead of\r\n         * the 4 corner tint component on other GameObjects.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#tint\r\n         * @type {number}\r\n         * @default\r\n         * @since 3.0.0\r\n         */\r\n        this.tint = 0xffffff;\r\n\r\n        /**\r\n         * An empty object where physics-engine specific information (e.g. bodies) may be stored.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#physics\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.physics = {};\r\n    },\r\n\r\n    /**\r\n     * Check if the given x and y world coordinates are within this Tile. This does not factor in\r\n     * camera scroll, layer scale or layer position.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#containsPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to test.\r\n     * @param {number} y - The y coordinate to test.\r\n     *\r\n     * @return {boolean} True if the coordinates are within this Tile, otherwise false.\r\n     */\r\n    containsPoint: function (x, y)\r\n    {\r\n        return !(x < this.pixelX || y < this.pixelY || x > this.right || y > this.bottom);\r\n    },\r\n\r\n    /**\r\n     * Copies the tile data & properties from the given tile to this tile. This copies everything\r\n     * except for position and interesting faces.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.Tile} tile - The tile to copy from.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */\r\n    copy: function (tile)\r\n    {\r\n        this.index = tile.index;\r\n        this.alpha = tile.alpha;\r\n        this.properties = tile.properties;\r\n        this.visible = tile.visible;\r\n        this.setFlip(tile.flipX, tile.flipY);\r\n        this.tint = tile.tint;\r\n        this.rotation = tile.rotation;\r\n        this.collideUp = tile.collideUp;\r\n        this.collideDown = tile.collideDown;\r\n        this.collideLeft = tile.collideLeft;\r\n        this.collideRight = tile.collideRight;\r\n        this.collisionCallback = tile.collisionCallback;\r\n        this.collisionCallbackContext = tile.collisionCallbackContext;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The collision group for this Tile, defined within the Tileset. This returns a reference to\r\n     * the collision group stored within the Tileset, so any modification of the returned object\r\n     * will impact all tiles that have the same index as this tile.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @return {?object} tileset\r\n     */\r\n    getCollisionGroup: function ()\r\n    {\r\n        return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null;\r\n    },\r\n\r\n    /**\r\n     * The tile data for this Tile, defined within the Tileset. This typically contains Tiled\r\n     * collision data, tile animations and terrain information. This returns a reference to the tile\r\n     * data stored within the Tileset, so any modification of the returned object will impact all\r\n     * tiles that have the same index as this tile.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getTileData\r\n     * @since 3.0.0\r\n     *\r\n     * @return {?object} tileset\r\n     */\r\n    getTileData: function ()\r\n    {\r\n        return this.tileset ? this.tileset.getTileData(this.index) : null;\r\n    },\r\n\r\n    /**\r\n     * Gets the world X position of the left side of the tile, factoring in the layers position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getLeft\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */\r\n    getLeft: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        return (tilemapLayer) ? tilemapLayer.tileToWorldX(this.x, camera) : this.x * this.baseWidth;\r\n    },\r\n\r\n    /**\r\n     * Gets the world X position of the right side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getRight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */\r\n    getRight: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        return (tilemapLayer) ? this.getLeft(camera) + this.width * tilemapLayer.scaleX : this.getLeft(camera) + this.width;\r\n    },\r\n\r\n    /**\r\n     * Gets the world Y position of the top side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getTop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */\r\n    getTop: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        // Tiled places tiles on a grid of baseWidth x baseHeight. The origin for a tile in grid\r\n        // units is the bottom left, so the y coordinate needs to be adjusted by the difference\r\n        // between the base size and this tile's size.\r\n        return tilemapLayer\r\n            ? tilemapLayer.tileToWorldY(this.y, camera) - (this.height - this.baseHeight) * tilemapLayer.scaleY\r\n            : this.y * this.baseHeight - (this.height - this.baseHeight);\r\n    },\r\n\r\n    /**\r\n     * Gets the world Y position of the bottom side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n\r\n     * @method Phaser.Tilemaps.Tile#getBottom\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */\r\n    getBottom: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n        return tilemapLayer\r\n            ? this.getTop(camera) + this.height * tilemapLayer.scaleY\r\n            : this.getTop(camera) + this.height;\r\n    },\r\n\r\n\r\n    /**\r\n     * Gets the world rectangle bounding box for the tile, factoring in the layers position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     * @param {object} [output] - [description]\r\n     *\r\n     * @return {(Phaser.Geom.Rectangle|object)}\r\n     */\r\n    getBounds: function (camera, output)\r\n    {\r\n        if (output === undefined) { output = new Rectangle(); }\r\n\r\n        output.x = this.getLeft();\r\n        output.y = this.getTop();\r\n        output.width = this.getRight() - output.x;\r\n        output.height = this.getBottom() - output.y;\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Gets the world X position of the center of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCenterX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */\r\n    getCenterX: function (camera)\r\n    {\r\n        return (this.getLeft(camera) + this.getRight(camera)) / 2;\r\n    },\r\n\r\n    /**\r\n     * Gets the world Y position of the center of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCenterY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number}\r\n     */\r\n    getCenterY: function (camera)\r\n    {\r\n        return (this.getTop(camera) + this.getBottom(camera)) / 2;\r\n    },\r\n\r\n    /**\r\n     * Clean up memory.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.collisionCallback = undefined;\r\n        this.collisionCallbackContext = undefined;\r\n        this.properties = undefined;\r\n    },\r\n\r\n    /**\r\n     * Check for intersection with this tile. This does not factor in camera scroll, layer scale or\r\n     * layer position.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#intersects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x axis in pixels.\r\n     * @param {number} y - The y axis in pixels.\r\n     * @param {number} right - The right point.\r\n     * @param {number} bottom - The bottom point.\r\n     *\r\n     * @return {boolean}\r\n     */\r\n    intersects: function (x, y, right, bottom)\r\n    {\r\n        return !(\r\n            right <= this.pixelX || bottom <= this.pixelY ||\r\n            x >= this.right || y >= this.bottom\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Checks if the tile is interesting.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#isInteresting\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} collides - If true, will consider the tile interesting if it collides on any side.\r\n     * @param {boolean} faces - If true, will consider the tile interesting if it has an interesting face.\r\n     *\r\n     * @return {boolean} True if the Tile is interesting, otherwise false.\r\n     */\r\n    isInteresting: function (collides, faces)\r\n    {\r\n        if (collides && faces) { return (this.canCollide || this.hasInterestingFace); }\r\n        else if (collides) { return this.collides; }\r\n        else if (faces) { return this.hasInterestingFace; }\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Reset collision status flags.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#resetCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate interesting faces for this tile and its neighbors.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */\r\n    resetCollision: function (recalculateFaces)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        this.collideLeft = false;\r\n        this.collideRight = false;\r\n        this.collideUp = false;\r\n        this.collideDown = false;\r\n\r\n        this.faceTop = false;\r\n        this.faceBottom = false;\r\n        this.faceLeft = false;\r\n        this.faceRight = false;\r\n\r\n        if (recalculateFaces)\r\n        {\r\n            var tilemapLayer = this.tilemapLayer;\r\n\r\n            if (tilemapLayer)\r\n            {\r\n                this.tilemapLayer.calculateFacesAt(this.x, this.y);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reset faces.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#resetFaces\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */\r\n    resetFaces: function ()\r\n    {\r\n        this.faceTop = false;\r\n        this.faceBottom = false;\r\n        this.faceLeft = false;\r\n        this.faceRight = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the collision flags for each side of this tile and updates the interesting faces list.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} left - Indicating collide with any object on the left.\r\n     * @param {boolean} [right] - Indicating collide with any object on the right.\r\n     * @param {boolean} [up] - Indicating collide with any object on the top.\r\n     * @param {boolean} [down] - Indicating collide with any object on the bottom.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate interesting faces\r\n     * for this tile and its neighbors.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */\r\n    setCollision: function (left, right, up, down, recalculateFaces)\r\n    {\r\n        if (right === undefined) { right = left; }\r\n        if (up === undefined) { up = left; }\r\n        if (down === undefined) { down = left; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        this.collideLeft = left;\r\n        this.collideRight = right;\r\n        this.collideUp = up;\r\n        this.collideDown = down;\r\n\r\n        this.faceLeft = left;\r\n        this.faceRight = right;\r\n        this.faceTop = up;\r\n        this.faceBottom = down;\r\n\r\n        if (recalculateFaces)\r\n        {\r\n            var tilemapLayer = this.tilemapLayer;\r\n\r\n            if (tilemapLayer)\r\n            {\r\n                this.tilemapLayer.calculateFacesAt(this.x, this.y);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set a callback to be called when this tile is hit by an object. The callback must true for\r\n     * collision processing to take place.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setCollisionCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - Callback function.\r\n     * @param {object} context - Callback will be called within this context.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */\r\n    setCollisionCallback: function (callback, context)\r\n    {\r\n        if (callback === null)\r\n        {\r\n            this.collisionCallback = undefined;\r\n            this.collisionCallbackContext = undefined;\r\n        }\r\n        else\r\n        {\r\n            this.collisionCallback = callback;\r\n            this.collisionCallbackContext = context;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the size of the tile and updates its pixelX and pixelY.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} tileWidth - The width of the tile in pixels.\r\n     * @param {integer} tileHeight - The height of the tile in pixels.\r\n     * @param {integer} baseWidth - The base width a tile in the map (in pixels).\r\n     * @param {integer} baseHeight - The base height of the tile in pixels (in pixels).\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */\r\n    setSize: function (tileWidth, tileHeight, baseWidth, baseHeight)\r\n    {\r\n        if (tileWidth !== undefined) { this.width = tileWidth; }\r\n        if (tileHeight !== undefined) { this.height = tileHeight; }\r\n        if (baseWidth !== undefined) { this.baseWidth = baseWidth; }\r\n        if (baseHeight !== undefined) { this.baseHeight = baseHeight; }\r\n\r\n        this.updatePixelXY();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Used internally. Updates the tile's world XY position based on the current tile size.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#updatePixelXY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} This Tile object.\r\n     */\r\n    updatePixelXY: function ()\r\n    {\r\n        // Tiled places tiles on a grid of baseWidth x baseHeight. The origin for a tile is the\r\n        // bottom left, while the Phaser renderer assumes the origin is the top left. The y\r\n        // coordinate needs to be adjusted by the difference.\r\n        this.pixelX = this.x * this.baseWidth;\r\n        this.pixelY = this.y * this.baseHeight;\r\n\r\n        // this.pixelY = this.y * this.baseHeight - (this.height - this.baseHeight);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * True if this tile can collide on any of its faces or has a collision callback set.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#canCollide\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    canCollide: {\r\n        get: function ()\r\n        {\r\n            return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * True if this tile can collide on any of its faces.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#collides\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    collides: {\r\n        get: function ()\r\n        {\r\n            return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * True if this tile has any interesting faces.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#hasInterestingFace\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    hasInterestingFace: {\r\n        get: function ()\r\n        {\r\n            return (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The tileset that contains this Tile. This is null if accessed from a LayerData instance\r\n     * before the tile is placed in a StaticTilemapLayer or DynamicTilemapLayer, or if the tile has\r\n     * an index that doesn't correspond to any of the map's tilesets.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tileset\r\n     * @type {?Phaser.Tilemaps.Tileset}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    tileset: {\r\n\r\n        get: function ()\r\n        {\r\n            var tilemapLayer = this.layer.tilemapLayer;\r\n\r\n            if (tilemapLayer)\r\n            {\r\n                var tileset = tilemapLayer.gidMap[this.index];\r\n\r\n                if (tileset)\r\n                {\r\n                    return tileset;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The tilemap layer that contains this Tile. This will only return null if accessed from a\r\n     * LayerData instance before the tile is placed within a StaticTilemapLayer or\r\n     * DynamicTilemapLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tilemapLayer\r\n     * @type {?Phaser.Tilemaps.StaticTilemapLayer|Phaser.Tilemaps.DynamicTilemapLayer}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    tilemapLayer: {\r\n        get: function ()\r\n        {\r\n            return this.layer.tilemapLayer;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The tilemap that contains this Tile. This will only return null if accessed from a LayerData\r\n     * instance before the tile is placed within a StaticTilemapLayer or DynamicTilemapLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tilemap\r\n     * @type {?Phaser.Tilemaps.Tilemap}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    tilemap: {\r\n        get: function ()\r\n        {\r\n            var tilemapLayer = this.tilemapLayer;\r\n            return tilemapLayer ? tilemapLayer.tilemap : null;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Tile;\r\n"]},"metadata":{},"sourceType":"script"}