{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Body = require('../lib/body/Body');\n\nvar MATH_CONST = require('../../../math/const');\n\nvar WrapAngle = require('../../../math/angle/Wrap');\n\nvar WrapAngleDegrees = require('../../../math/angle/WrapDegrees'); //  global bitmask flag for GameObject.renderMask (used by Scale)\n\n\nvar _FLAG = 4; // 0100\n//  Transform Component\n\n/**\r\n * Provides methods used for getting and setting the position, scale and rotation of a Game Object.\r\n *\r\n * @namespace Phaser.Physics.Matter.Components.Transform\r\n * @since 3.0.0\r\n */\n\nvar Transform = {\n  /**\r\n   * The x position of this Game Object.\r\n   *\r\n   * @name Phaser.Physics.Matter.Components.Transform#x\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  x: {\n    get: function () {\n      return this.body.position.x;\n    },\n    set: function (value) {\n      this._tempVec2.set(value, this.y);\n\n      Body.setPosition(this.body, this._tempVec2);\n    }\n  },\n\n  /**\r\n   * The y position of this Game Object.\r\n   *\r\n   * @name Phaser.Physics.Matter.Components.Transform#y\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  y: {\n    get: function () {\n      return this.body.position.y;\n    },\n    set: function (value) {\n      this._tempVec2.set(this.x, value);\n\n      Body.setPosition(this.body, this._tempVec2);\n    }\n  },\n\n  /**\r\n   * The horizontal scale of this Game Object.\r\n   *\r\n   * @name Phaser.Physics.Matter.Components.Transform#scaleX\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  scaleX: {\n    get: function () {\n      return this._scaleX;\n    },\n    set: function (value) {\n      var factorX = 1 / this._scaleX;\n      var factorY = 1 / this._scaleY;\n      this._scaleX = value;\n\n      if (this._scaleX === 0) {\n        this.renderFlags &= ~_FLAG;\n      } else {\n        this.renderFlags |= _FLAG;\n      } //  Reset Matter scale back to 1 (sigh)\n\n\n      Body.scale(this.body, factorX, factorY);\n      Body.scale(this.body, value, this._scaleY);\n    }\n  },\n\n  /**\r\n   * The vertical scale of this Game Object.\r\n   *\r\n   * @name Phaser.Physics.Matter.Components.Transform#scaleY\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  scaleY: {\n    get: function () {\n      return this._scaleY;\n    },\n    set: function (value) {\n      var factorX = 1 / this._scaleX;\n      var factorY = 1 / this._scaleY;\n      this._scaleY = value;\n\n      if (this._scaleY === 0) {\n        this.renderFlags &= ~_FLAG;\n      } else {\n        this.renderFlags |= _FLAG;\n      }\n\n      Body.scale(this.body, factorX, factorY);\n      Body.scale(this.body, this._scaleX, value);\n    }\n  },\n\n  /**\r\n   * Use `angle` to set or get rotation of the physics body associated to this GameObject.\r\n   * Unlike rotation, when using set the value can be in degrees, which will be converted to radians internally.\r\n   *\r\n   * @name Phaser.Physics.Matter.Components.Transform#angle\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  angle: {\n    get: function () {\n      return WrapAngleDegrees(this.body.angle * MATH_CONST.RAD_TO_DEG);\n    },\n    set: function (value) {\n      //  value is in degrees\n      this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;\n    }\n  },\n\n  /**\r\n   * Use `rotation` to set or get the rotation of the physics body associated with this GameObject.\r\n   * The value when set must be in radians.\r\n   *\r\n   * @name Phaser.Physics.Matter.Components.Transform#rotation\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  rotation: {\n    get: function () {\n      return this.body.angle;\n    },\n    set: function (value) {\n      //  value is in radians\n      this._rotation = WrapAngle(value);\n      Body.setAngle(this.body, this._rotation);\n    }\n  },\n\n  /**\r\n   * Sets the position of the physics body along x and y axes.\r\n   * Both the parameters to this function are optional and if not passed any they default to 0.\r\n   * Velocity, angle, force etc. are unchanged.\r\n   *\r\n   * @method Phaser.Physics.Matter.Components.Transform#setPosition\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [x=0] - The horizontal position of the body.\r\n   * @param {number} [y=x] - The vertical position of the body.\r\n   *\r\n   * @return {this} This Game Object.\r\n   */\n  setPosition: function (x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = x;\n    }\n\n    this._tempVec2.set(x, y);\n\n    Body.setPosition(this.body, this._tempVec2);\n    return this;\n  },\n\n  /**\r\n   * Immediately sets the angle of the Body.\r\n   * Angular velocity, position, force etc. are unchanged.\r\n   *\r\n   * @method Phaser.Physics.Matter.Components.Transform#setRotation\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [radians=0] - The angle of the body, in radians.\r\n   *\r\n   * @return {this} This Game Object.\r\n   */\n  setRotation: function (radians) {\n    if (radians === undefined) {\n      radians = 0;\n    }\n\n    this._rotation = WrapAngle(radians);\n    Body.setAngle(this.body, radians);\n    return this;\n  },\n\n  /**\r\n   * Setting fixed rotation sets the Body inertia to Infinity, which stops it\r\n   * from being able to rotate when forces are applied to it.\r\n   *\r\n   * @method Phaser.Physics.Matter.Components.Transform#setFixedRotation\r\n   * @since 3.0.0\r\n   *\r\n   * @return {this} This Game Object.\r\n   */\n  setFixedRotation: function () {\n    Body.setInertia(this.body, Infinity);\n    return this;\n  },\n\n  /**\r\n   * Immediately sets the angle of the Body.\r\n   * Angular velocity, position, force etc. are unchanged.\r\n   *\r\n   * @method Phaser.Physics.Matter.Components.Transform#setAngle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [degrees=0] - The angle to set, in degrees.\r\n   *\r\n   * @return {this} This Game Object.\r\n   */\n  setAngle: function (degrees) {\n    if (degrees === undefined) {\n      degrees = 0;\n    }\n\n    this.angle = degrees;\n    Body.setAngle(this.body, this.rotation);\n    return this;\n  },\n\n  /**\r\n   * Sets the scale of this Game Object.\r\n   *\r\n   * @method Phaser.Physics.Matter.Components.Transform#setScale\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [x=1] - The horizontal scale of this Game Object.\r\n   * @param {number} [y=x] - The vertical scale of this Game Object. If not set it will use the x value.\r\n   * @param {Phaser.Math.Vector2} [point] - The point (Vector2) from which scaling will occur.\r\n   *\r\n   * @return {this} This Game Object.\r\n   */\n  setScale: function (x, y, point) {\n    if (x === undefined) {\n      x = 1;\n    }\n\n    if (y === undefined) {\n      y = x;\n    }\n\n    var factorX = 1 / this._scaleX;\n    var factorY = 1 / this._scaleY;\n    this._scaleX = x;\n    this._scaleY = y;\n    Body.scale(this.body, factorX, factorY, point);\n    Body.scale(this.body, x, y, point);\n    return this;\n  }\n};\nmodule.exports = Transform;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/components/Transform.js"],"names":["Body","require","MATH_CONST","WrapAngle","WrapAngleDegrees","_FLAG","Transform","x","get","body","position","set","value","_tempVec2","y","setPosition","scaleX","_scaleX","factorX","factorY","_scaleY","renderFlags","scale","scaleY","angle","RAD_TO_DEG","rotation","DEG_TO_RAD","_rotation","setAngle","undefined","setRotation","radians","setFixedRotation","setInertia","Infinity","degrees","setScale","point","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Body = require('../lib/body/Body');\r\nvar MATH_CONST = require('../../../math/const');\r\nvar WrapAngle = require('../../../math/angle/Wrap');\r\nvar WrapAngleDegrees = require('../../../math/angle/WrapDegrees');\r\n\r\n//  global bitmask flag for GameObject.renderMask (used by Scale)\r\nvar _FLAG = 4; // 0100\r\n\r\n//  Transform Component\r\n\r\n/**\r\n * Provides methods used for getting and setting the position, scale and rotation of a Game Object.\r\n *\r\n * @namespace Phaser.Physics.Matter.Components.Transform\r\n * @since 3.0.0\r\n */\r\nvar Transform = {\r\n\r\n    /**\r\n     * The x position of this Game Object.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.body.position.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tempVec2.set(value, this.y);\r\n\r\n            Body.setPosition(this.body, this._tempVec2);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The y position of this Game Object.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.body.position.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tempVec2.set(this.x, value);\r\n\r\n            Body.setPosition(this.body, this._tempVec2);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The horizontal scale of this Game Object.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#scaleX\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    scaleX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleX;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var factorX = 1 / this._scaleX;\r\n            var factorY = 1 / this._scaleY;\r\n    \r\n            this._scaleX = value;\r\n\r\n            if (this._scaleX === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n\r\n            //  Reset Matter scale back to 1 (sigh)\r\n            Body.scale(this.body, factorX, factorY);\r\n\r\n            Body.scale(this.body, value, this._scaleY);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scale of this Game Object.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#scaleY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    scaleY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleY;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var factorX = 1 / this._scaleX;\r\n            var factorY = 1 / this._scaleY;\r\n\r\n            this._scaleY = value;\r\n\r\n            if (this._scaleY === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n\r\n            Body.scale(this.body, factorX, factorY);\r\n\r\n            Body.scale(this.body, this._scaleX, value);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Use `angle` to set or get rotation of the physics body associated to this GameObject.\r\n     * Unlike rotation, when using set the value can be in degrees, which will be converted to radians internally.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#angle\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    angle: {\r\n\r\n        get: function ()\r\n        {\r\n            return WrapAngleDegrees(this.body.angle * MATH_CONST.RAD_TO_DEG);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            //  value is in degrees\r\n            this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Use `rotation` to set or get the rotation of the physics body associated with this GameObject.\r\n     * The value when set must be in radians.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#rotation\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    rotation: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.body.angle;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            //  value is in radians\r\n            this._rotation = WrapAngle(value);\r\n\r\n            Body.setAngle(this.body, this._rotation);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the position of the physics body along x and y axes.\r\n     * Both the parameters to this function are optional and if not passed any they default to 0.\r\n     * Velocity, angle, force etc. are unchanged.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal position of the body.\r\n     * @param {number} [y=x] - The vertical position of the body.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setPosition: function (x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this._tempVec2.set(x, y);\r\n\r\n        Body.setPosition(this.body, this._tempVec2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Immediately sets the angle of the Body.\r\n     * Angular velocity, position, force etc. are unchanged.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [radians=0] - The angle of the body, in radians.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setRotation: function (radians)\r\n    {\r\n        if (radians === undefined) { radians = 0; }\r\n\r\n        this._rotation = WrapAngle(radians);\r\n\r\n        Body.setAngle(this.body, radians);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Setting fixed rotation sets the Body inertia to Infinity, which stops it\r\n     * from being able to rotate when forces are applied to it.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setFixedRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setFixedRotation: function ()\r\n    {\r\n        Body.setInertia(this.body, Infinity);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Immediately sets the angle of the Body.\r\n     * Angular velocity, position, force etc. are unchanged.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [degrees=0] - The angle to set, in degrees.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setAngle: function (degrees)\r\n    {\r\n        if (degrees === undefined) { degrees = 0; }\r\n\r\n        this.angle = degrees;\r\n\r\n        Body.setAngle(this.body, this.rotation);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scale of this Game Object.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=1] - The horizontal scale of this Game Object.\r\n     * @param {number} [y=x] - The vertical scale of this Game Object. If not set it will use the x value.\r\n     * @param {Phaser.Math.Vector2} [point] - The point (Vector2) from which scaling will occur.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setScale: function (x, y, point)\r\n    {\r\n        if (x === undefined) { x = 1; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        var factorX = 1 / this._scaleX;\r\n        var factorY = 1 / this._scaleY;\r\n\r\n        this._scaleX = x;\r\n        this._scaleY = y;\r\n\r\n        Body.scale(this.body, factorX, factorY, point);\r\n\r\n        Body.scale(this.body, x, y, point);\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Transform;\r\n"]},"metadata":{},"sourceType":"script"}