{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar GetFastValue = require('../../utils/object/GetFastValue');\n/**\r\n * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithin\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {integer} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {integer} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {integer} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {integer} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Types.Tilemaps.GetTilesWithinFilteringOptions} GetTilesWithinFilteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */\n\n\nvar GetTilesWithin = function (tileX, tileY, width, height, filteringOptions, layer) {\n  if (tileX === undefined) {\n    tileX = 0;\n  }\n\n  if (tileY === undefined) {\n    tileY = 0;\n  }\n\n  if (width === undefined) {\n    width = layer.width;\n  }\n\n  if (height === undefined) {\n    height = layer.height;\n  }\n\n  var isNotEmpty = GetFastValue(filteringOptions, 'isNotEmpty', false);\n  var isColliding = GetFastValue(filteringOptions, 'isColliding', false);\n  var hasInterestingFace = GetFastValue(filteringOptions, 'hasInterestingFace', false); // Clip x, y to top left of map, while shrinking width/height to match.\n\n  if (tileX < 0) {\n    width += tileX;\n    tileX = 0;\n  }\n\n  if (tileY < 0) {\n    height += tileY;\n    tileY = 0;\n  } // Clip width and height to bottom right of map.\n\n\n  if (tileX + width > layer.width) {\n    width = Math.max(layer.width - tileX, 0);\n  }\n\n  if (tileY + height > layer.height) {\n    height = Math.max(layer.height - tileY, 0);\n  }\n\n  var results = [];\n\n  for (var ty = tileY; ty < tileY + height; ty++) {\n    for (var tx = tileX; tx < tileX + width; tx++) {\n      var tile = layer.data[ty][tx];\n\n      if (tile !== null) {\n        if (isNotEmpty && tile.index === -1) {\n          continue;\n        }\n\n        if (isColliding && !tile.collides) {\n          continue;\n        }\n\n        if (hasInterestingFace && !tile.hasInterestingFace) {\n          continue;\n        }\n\n        results.push(tile);\n      }\n    }\n  }\n\n  return results;\n};\n\nmodule.exports = GetTilesWithin;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/tilemaps/components/GetTilesWithin.js"],"names":["GetFastValue","require","GetTilesWithin","tileX","tileY","width","height","filteringOptions","layer","undefined","isNotEmpty","isColliding","hasInterestingFace","Math","max","results","ty","tx","tile","data","index","collides","push","module","exports"],"mappings":"AAAA;;;;;AAMA,IAAIA,YAAY,GAAGC,OAAO,CAAC,iCAAD,CAA1B;AAEA;;;;;;;;;;;;;;;;;;AAgBA,IAAIC,cAAc,GAAG,UAAUC,KAAV,EAAiBC,KAAjB,EAAwBC,KAAxB,EAA+BC,MAA/B,EAAuCC,gBAAvC,EAAyDC,KAAzD,EACrB;AACI,MAAIL,KAAK,KAAKM,SAAd,EAAyB;AAAEN,IAAAA,KAAK,GAAG,CAAR;AAAY;;AACvC,MAAIC,KAAK,KAAKK,SAAd,EAAyB;AAAEL,IAAAA,KAAK,GAAG,CAAR;AAAY;;AACvC,MAAIC,KAAK,KAAKI,SAAd,EAAyB;AAAEJ,IAAAA,KAAK,GAAGG,KAAK,CAACH,KAAd;AAAsB;;AACjD,MAAIC,MAAM,KAAKG,SAAf,EAA0B;AAAEH,IAAAA,MAAM,GAAGE,KAAK,CAACF,MAAf;AAAwB;;AAEpD,MAAII,UAAU,GAAGV,YAAY,CAACO,gBAAD,EAAmB,YAAnB,EAAiC,KAAjC,CAA7B;AACA,MAAII,WAAW,GAAGX,YAAY,CAACO,gBAAD,EAAmB,aAAnB,EAAkC,KAAlC,CAA9B;AACA,MAAIK,kBAAkB,GAAGZ,YAAY,CAACO,gBAAD,EAAmB,oBAAnB,EAAyC,KAAzC,CAArC,CARJ,CAUI;;AACA,MAAIJ,KAAK,GAAG,CAAZ,EACA;AACIE,IAAAA,KAAK,IAAIF,KAAT;AACAA,IAAAA,KAAK,GAAG,CAAR;AACH;;AACD,MAAIC,KAAK,GAAG,CAAZ,EACA;AACIE,IAAAA,MAAM,IAAIF,KAAV;AACAA,IAAAA,KAAK,GAAG,CAAR;AACH,GApBL,CAsBI;;;AACA,MAAID,KAAK,GAAGE,KAAR,GAAgBG,KAAK,CAACH,KAA1B,EACA;AACIA,IAAAA,KAAK,GAAGQ,IAAI,CAACC,GAAL,CAASN,KAAK,CAACH,KAAN,GAAcF,KAAvB,EAA8B,CAA9B,CAAR;AACH;;AACD,MAAIC,KAAK,GAAGE,MAAR,GAAiBE,KAAK,CAACF,MAA3B,EACA;AACIA,IAAAA,MAAM,GAAGO,IAAI,CAACC,GAAL,CAASN,KAAK,CAACF,MAAN,GAAeF,KAAxB,EAA+B,CAA/B,CAAT;AACH;;AAED,MAAIW,OAAO,GAAG,EAAd;;AAEA,OAAK,IAAIC,EAAE,GAAGZ,KAAd,EAAqBY,EAAE,GAAGZ,KAAK,GAAGE,MAAlC,EAA0CU,EAAE,EAA5C,EACA;AACI,SAAK,IAAIC,EAAE,GAAGd,KAAd,EAAqBc,EAAE,GAAGd,KAAK,GAAGE,KAAlC,EAAyCY,EAAE,EAA3C,EACA;AACI,UAAIC,IAAI,GAAGV,KAAK,CAACW,IAAN,CAAWH,EAAX,EAAeC,EAAf,CAAX;;AACA,UAAIC,IAAI,KAAK,IAAb,EACA;AACI,YAAIR,UAAU,IAAIQ,IAAI,CAACE,KAAL,KAAe,CAAC,CAAlC,EAAqC;AAAE;AAAW;;AAClD,YAAIT,WAAW,IAAI,CAACO,IAAI,CAACG,QAAzB,EAAmC;AAAE;AAAW;;AAChD,YAAIT,kBAAkB,IAAI,CAACM,IAAI,CAACN,kBAAhC,EAAoD;AAAE;AAAW;;AACjEG,QAAAA,OAAO,CAACO,IAAR,CAAaJ,IAAb;AACH;AACJ;AACJ;;AAED,SAAOH,OAAP;AACH,CAnDD;;AAqDAQ,MAAM,CAACC,OAAP,GAAiBtB,cAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithin\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {integer} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {integer} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {integer} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {integer} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Types.Tilemaps.GetTilesWithinFilteringOptions} GetTilesWithinFilteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * \r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */\r\nvar GetTilesWithin = function (tileX, tileY, width, height, filteringOptions, layer)\r\n{\r\n    if (tileX === undefined) { tileX = 0; }\r\n    if (tileY === undefined) { tileY = 0; }\r\n    if (width === undefined) { width = layer.width; }\r\n    if (height === undefined) { height = layer.height; }\r\n\r\n    var isNotEmpty = GetFastValue(filteringOptions, 'isNotEmpty', false);\r\n    var isColliding = GetFastValue(filteringOptions, 'isColliding', false);\r\n    var hasInterestingFace = GetFastValue(filteringOptions, 'hasInterestingFace', false);\r\n\r\n    // Clip x, y to top left of map, while shrinking width/height to match.\r\n    if (tileX < 0)\r\n    {\r\n        width += tileX;\r\n        tileX = 0;\r\n    }\r\n    if (tileY < 0)\r\n    {\r\n        height += tileY;\r\n        tileY = 0;\r\n    }\r\n\r\n    // Clip width and height to bottom right of map.\r\n    if (tileX + width > layer.width)\r\n    {\r\n        width = Math.max(layer.width - tileX, 0);\r\n    }\r\n    if (tileY + height > layer.height)\r\n    {\r\n        height = Math.max(layer.height - tileY, 0);\r\n    }\r\n\r\n    var results = [];\r\n\r\n    for (var ty = tileY; ty < tileY + height; ty++)\r\n    {\r\n        for (var tx = tileX; tx < tileX + width; tx++)\r\n        {\r\n            var tile = layer.data[ty][tx];\r\n            if (tile !== null)\r\n            {\r\n                if (isNotEmpty && tile.index === -1) { continue; }\r\n                if (isColliding && !tile.collides) { continue; }\r\n                if (hasInterestingFace && !tile.hasInterestingFace) { continue; }\r\n                results.push(tile);\r\n            }\r\n        }\r\n    }\r\n\r\n    return results;\r\n};\r\n\r\nmodule.exports = GetTilesWithin;\r\n"]},"metadata":{},"sourceType":"script"}