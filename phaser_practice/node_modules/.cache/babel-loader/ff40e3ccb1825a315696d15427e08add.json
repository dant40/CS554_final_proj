{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Length = require('../line/Length');\n\nvar Line = require('../line/Line');\n\nvar Perimeter = require('./Perimeter');\n/**\r\n * Returns an array of Point objects containing the coordinates of the points around the perimeter of the Polygon,\r\n * based on the given quantity or stepRate values.\r\n *\r\n * @function Phaser.Geom.Polygon.GetPoints\r\n * @since 3.12.0\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - The Polygon to get the points from.\r\n * @param {integer} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.\r\n * @param {number} [stepRate] - Sets the quantity by getting the perimeter of the Polygon and dividing it by the stepRate.\r\n * @param {array} [output] - An array to insert the points in to. If not provided a new array will be created.\r\n *\r\n * @return {Phaser.Geom.Point[]} An array of Point objects pertaining to the points around the perimeter of the Polygon.\r\n */\n\n\nvar GetPoints = function (polygon, quantity, stepRate, out) {\n  if (out === undefined) {\n    out = [];\n  }\n\n  var points = polygon.points;\n  var perimeter = Perimeter(polygon); //  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\n\n  if (!quantity) {\n    quantity = perimeter / stepRate;\n  }\n\n  for (var i = 0; i < quantity; i++) {\n    var position = perimeter * (i / quantity);\n    var accumulatedPerimeter = 0;\n\n    for (var j = 0; j < points.length; j++) {\n      var pointA = points[j];\n      var pointB = points[(j + 1) % points.length];\n      var line = new Line(pointA.x, pointA.y, pointB.x, pointB.y);\n      var length = Length(line);\n\n      if (position < accumulatedPerimeter || position > accumulatedPerimeter + length) {\n        accumulatedPerimeter += length;\n        continue;\n      }\n\n      var point = line.getPoint((position - accumulatedPerimeter) / length);\n      out.push(point);\n      break;\n    }\n  }\n\n  return out;\n};\n\nmodule.exports = GetPoints;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/geom/polygon/GetPoints.js"],"names":["Length","require","Line","Perimeter","GetPoints","polygon","quantity","stepRate","out","undefined","points","perimeter","i","position","accumulatedPerimeter","j","length","pointA","pointB","line","x","y","point","getPoint","push","module","exports"],"mappings":"AAAA;;;;;AAMA,IAAIA,MAAM,GAAGC,OAAO,CAAC,gBAAD,CAApB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,cAAD,CAAlB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,aAAD,CAAvB;AAEA;;;;;;;;;;;;;;;;AAcA,IAAIG,SAAS,GAAG,UAAUC,OAAV,EAAmBC,QAAnB,EAA6BC,QAA7B,EAAuCC,GAAvC,EAChB;AACI,MAAIA,GAAG,KAAKC,SAAZ,EAAuB;AAAED,IAAAA,GAAG,GAAG,EAAN;AAAW;;AAEpC,MAAIE,MAAM,GAAGL,OAAO,CAACK,MAArB;AACA,MAAIC,SAAS,GAAGR,SAAS,CAACE,OAAD,CAAzB,CAJJ,CAMI;;AACA,MAAI,CAACC,QAAL,EACA;AACIA,IAAAA,QAAQ,GAAGK,SAAS,GAAGJ,QAAvB;AACH;;AAED,OAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,QAApB,EAA8BM,CAAC,EAA/B,EACA;AACI,QAAIC,QAAQ,GAAGF,SAAS,IAAIC,CAAC,GAAGN,QAAR,CAAxB;AACA,QAAIQ,oBAAoB,GAAG,CAA3B;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,MAAM,CAACM,MAA3B,EAAmCD,CAAC,EAApC,EACA;AACI,UAAIE,MAAM,GAAGP,MAAM,CAACK,CAAD,CAAnB;AACA,UAAIG,MAAM,GAAGR,MAAM,CAAC,CAACK,CAAC,GAAG,CAAL,IAAUL,MAAM,CAACM,MAAlB,CAAnB;AACA,UAAIG,IAAI,GAAG,IAAIjB,IAAJ,CACPe,MAAM,CAACG,CADA,EAEPH,MAAM,CAACI,CAFA,EAGPH,MAAM,CAACE,CAHA,EAIPF,MAAM,CAACG,CAJA,CAAX;AAMA,UAAIL,MAAM,GAAGhB,MAAM,CAACmB,IAAD,CAAnB;;AAEA,UAAIN,QAAQ,GAAGC,oBAAX,IAAmCD,QAAQ,GAAGC,oBAAoB,GAAGE,MAAzE,EACA;AACIF,QAAAA,oBAAoB,IAAIE,MAAxB;AACA;AACH;;AAED,UAAIM,KAAK,GAAGH,IAAI,CAACI,QAAL,CAAc,CAACV,QAAQ,GAAGC,oBAAZ,IAAoCE,MAAlD,CAAZ;AACAR,MAAAA,GAAG,CAACgB,IAAJ,CAASF,KAAT;AAEA;AACH;AACJ;;AAED,SAAOd,GAAP;AACH,CA5CD;;AA8CAiB,MAAM,CAACC,OAAP,GAAiBtB,SAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Length = require('../line/Length');\r\nvar Line = require('../line/Line');\r\nvar Perimeter = require('./Perimeter');\r\n\r\n/**\r\n * Returns an array of Point objects containing the coordinates of the points around the perimeter of the Polygon,\r\n * based on the given quantity or stepRate values.\r\n *\r\n * @function Phaser.Geom.Polygon.GetPoints\r\n * @since 3.12.0\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - The Polygon to get the points from.\r\n * @param {integer} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.\r\n * @param {number} [stepRate] - Sets the quantity by getting the perimeter of the Polygon and dividing it by the stepRate.\r\n * @param {array} [output] - An array to insert the points in to. If not provided a new array will be created.\r\n *\r\n * @return {Phaser.Geom.Point[]} An array of Point objects pertaining to the points around the perimeter of the Polygon.\r\n */\r\nvar GetPoints = function (polygon, quantity, stepRate, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    var points = polygon.points;\r\n    var perimeter = Perimeter(polygon);\r\n\r\n    //  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\r\n    if (!quantity)\r\n    {\r\n        quantity = perimeter / stepRate;\r\n    }\r\n\r\n    for (var i = 0; i < quantity; i++)\r\n    {\r\n        var position = perimeter * (i / quantity);\r\n        var accumulatedPerimeter = 0;\r\n\r\n        for (var j = 0; j < points.length; j++)\r\n        {\r\n            var pointA = points[j];\r\n            var pointB = points[(j + 1) % points.length];\r\n            var line = new Line(\r\n                pointA.x,\r\n                pointA.y,\r\n                pointB.x,\r\n                pointB.y\r\n            );\r\n            var length = Length(line);\r\n\r\n            if (position < accumulatedPerimeter || position > accumulatedPerimeter + length)\r\n            {\r\n                accumulatedPerimeter += length;\r\n                continue;\r\n            }\r\n\r\n            var point = line.getPoint((position - accumulatedPerimeter) / length);\r\n            out.push(point);\r\n\r\n            break;\r\n        }\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetPoints;\r\n"]},"metadata":{},"sourceType":"script"}