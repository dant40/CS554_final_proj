{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.BitmapText#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.BitmapText} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\n\n\nvar BitmapTextCanvasRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix) {\n  var text = src._text;\n  var textLength = text.length;\n  var ctx = renderer.currentContext;\n\n  if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix)) {\n    return;\n  }\n\n  var textureFrame = src.frame;\n  var chars = src.fontData.chars;\n  var lineHeight = src.fontData.lineHeight;\n  var letterSpacing = src._letterSpacing;\n  var xAdvance = 0;\n  var yAdvance = 0;\n  var charCode = 0;\n  var glyph = null;\n  var glyphX = 0;\n  var glyphY = 0;\n  var glyphW = 0;\n  var glyphH = 0;\n  var x = 0;\n  var y = 0;\n  var lastGlyph = null;\n  var lastCharCode = 0;\n  var image = src.frame.source.image;\n  var textureX = textureFrame.cutX;\n  var textureY = textureFrame.cutY;\n  var scale = src._fontSize / src.fontData.size;\n  var align = src._align;\n  var currentLine = 0;\n  var lineOffsetX = 0; //  Update the bounds - skipped internally if not dirty\n\n  var bounds = src.getTextBounds(false); //  In case the method above changed it (word wrapping)\n\n  if (src.maxWidth > 0) {\n    text = bounds.wrappedText;\n    textLength = text.length;\n  }\n\n  var lineData = src._bounds.lines;\n\n  if (align === 1) {\n    lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;\n  } else if (align === 2) {\n    lineOffsetX = lineData.longest - lineData.lengths[0];\n  }\n\n  ctx.translate(-src.displayOriginX, -src.displayOriginY);\n  var roundPixels = camera.roundPixels;\n\n  for (var i = 0; i < textLength; i++) {\n    charCode = text.charCodeAt(i);\n\n    if (charCode === 10) {\n      currentLine++;\n\n      if (align === 1) {\n        lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;\n      } else if (align === 2) {\n        lineOffsetX = lineData.longest - lineData.lengths[currentLine];\n      }\n\n      xAdvance = 0;\n      yAdvance += lineHeight;\n      lastGlyph = null;\n      continue;\n    }\n\n    glyph = chars[charCode];\n\n    if (!glyph) {\n      continue;\n    }\n\n    glyphX = textureX + glyph.x;\n    glyphY = textureY + glyph.y;\n    glyphW = glyph.width;\n    glyphH = glyph.height;\n    x = glyph.xOffset + xAdvance;\n    y = glyph.yOffset + yAdvance;\n\n    if (lastGlyph !== null) {\n      var kerningOffset = glyph.kerning[lastCharCode];\n      x += kerningOffset !== undefined ? kerningOffset : 0;\n    }\n\n    x *= scale;\n    y *= scale;\n    x += lineOffsetX;\n    xAdvance += glyph.xAdvance + letterSpacing;\n    lastGlyph = glyph;\n    lastCharCode = charCode; //  Nothing to render or a space? Then skip to the next glyph\n\n    if (glyphW === 0 || glyphH === 0 || charCode === 32) {\n      continue;\n    }\n\n    if (roundPixels) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.scale(scale, scale);\n    ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);\n    ctx.restore();\n  }\n\n  ctx.restore();\n};\n\nmodule.exports = BitmapTextCanvasRenderer;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextCanvasRenderer.js"],"names":["SetTransform","require","BitmapTextCanvasRenderer","renderer","src","interpolationPercentage","camera","parentMatrix","text","_text","textLength","length","ctx","currentContext","textureFrame","frame","chars","fontData","lineHeight","letterSpacing","_letterSpacing","xAdvance","yAdvance","charCode","glyph","glyphX","glyphY","glyphW","glyphH","x","y","lastGlyph","lastCharCode","image","source","textureX","cutX","textureY","cutY","scale","_fontSize","size","align","_align","currentLine","lineOffsetX","bounds","getTextBounds","maxWidth","wrappedText","lineData","_bounds","lines","longest","lengths","translate","displayOriginX","displayOriginY","roundPixels","i","charCodeAt","width","height","xOffset","yOffset","kerningOffset","kerning","undefined","Math","round","save","drawImage","restore","module","exports"],"mappings":"AAAA;;;;;AAMA,IAAIA,YAAY,GAAGC,OAAO,CAAC,6CAAD,CAA1B;AAEA;;;;;;;;;;;;;;;;;AAeA,IAAIC,wBAAwB,GAAG,UAAUC,QAAV,EAAoBC,GAApB,EAAyBC,uBAAzB,EAAkDC,MAAlD,EAA0DC,YAA1D,EAC/B;AACI,MAAIC,IAAI,GAAGJ,GAAG,CAACK,KAAf;AACA,MAAIC,UAAU,GAAGF,IAAI,CAACG,MAAtB;AAEA,MAAIC,GAAG,GAAGT,QAAQ,CAACU,cAAnB;;AAEA,MAAIH,UAAU,KAAK,CAAf,IAAoB,CAACV,YAAY,CAACG,QAAD,EAAWS,GAAX,EAAgBR,GAAhB,EAAqBE,MAArB,EAA6BC,YAA7B,CAArC,EACA;AACI;AACH;;AAED,MAAIO,YAAY,GAAGV,GAAG,CAACW,KAAvB;AAEA,MAAIC,KAAK,GAAGZ,GAAG,CAACa,QAAJ,CAAaD,KAAzB;AACA,MAAIE,UAAU,GAAGd,GAAG,CAACa,QAAJ,CAAaC,UAA9B;AACA,MAAIC,aAAa,GAAGf,GAAG,CAACgB,cAAxB;AAEA,MAAIC,QAAQ,GAAG,CAAf;AACA,MAAIC,QAAQ,GAAG,CAAf;AAEA,MAAIC,QAAQ,GAAG,CAAf;AAEA,MAAIC,KAAK,GAAG,IAAZ;AACA,MAAIC,MAAM,GAAG,CAAb;AACA,MAAIC,MAAM,GAAG,CAAb;AACA,MAAIC,MAAM,GAAG,CAAb;AACA,MAAIC,MAAM,GAAG,CAAb;AAEA,MAAIC,CAAC,GAAG,CAAR;AACA,MAAIC,CAAC,GAAG,CAAR;AAEA,MAAIC,SAAS,GAAG,IAAhB;AACA,MAAIC,YAAY,GAAG,CAAnB;AAEA,MAAIC,KAAK,GAAG7B,GAAG,CAACW,KAAJ,CAAUmB,MAAV,CAAiBD,KAA7B;AAEA,MAAIE,QAAQ,GAAGrB,YAAY,CAACsB,IAA5B;AACA,MAAIC,QAAQ,GAAGvB,YAAY,CAACwB,IAA5B;AAEA,MAAIC,KAAK,GAAInC,GAAG,CAACoC,SAAJ,GAAgBpC,GAAG,CAACa,QAAJ,CAAawB,IAA1C;AAEA,MAAIC,KAAK,GAAGtC,GAAG,CAACuC,MAAhB;AACA,MAAIC,WAAW,GAAG,CAAlB;AACA,MAAIC,WAAW,GAAG,CAAlB,CA3CJ,CA6CI;;AACA,MAAIC,MAAM,GAAG1C,GAAG,CAAC2C,aAAJ,CAAkB,KAAlB,CAAb,CA9CJ,CAgDI;;AACA,MAAI3C,GAAG,CAAC4C,QAAJ,GAAe,CAAnB,EACA;AACIxC,IAAAA,IAAI,GAAGsC,MAAM,CAACG,WAAd;AACAvC,IAAAA,UAAU,GAAGF,IAAI,CAACG,MAAlB;AACH;;AAED,MAAIuC,QAAQ,GAAG9C,GAAG,CAAC+C,OAAJ,CAAYC,KAA3B;;AAEA,MAAIV,KAAK,KAAK,CAAd,EACA;AACIG,IAAAA,WAAW,GAAG,CAACK,QAAQ,CAACG,OAAT,GAAmBH,QAAQ,CAACI,OAAT,CAAiB,CAAjB,CAApB,IAA2C,CAAzD;AACH,GAHD,MAIK,IAAIZ,KAAK,KAAK,CAAd,EACL;AACIG,IAAAA,WAAW,GAAIK,QAAQ,CAACG,OAAT,GAAmBH,QAAQ,CAACI,OAAT,CAAiB,CAAjB,CAAlC;AACH;;AAED1C,EAAAA,GAAG,CAAC2C,SAAJ,CAAc,CAACnD,GAAG,CAACoD,cAAnB,EAAmC,CAACpD,GAAG,CAACqD,cAAxC;AAEA,MAAIC,WAAW,GAAGpD,MAAM,CAACoD,WAAzB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjD,UAApB,EAAgCiD,CAAC,EAAjC,EACA;AACIpC,IAAAA,QAAQ,GAAGf,IAAI,CAACoD,UAAL,CAAgBD,CAAhB,CAAX;;AAEA,QAAIpC,QAAQ,KAAK,EAAjB,EACA;AACIqB,MAAAA,WAAW;;AAEX,UAAIF,KAAK,KAAK,CAAd,EACA;AACIG,QAAAA,WAAW,GAAG,CAACK,QAAQ,CAACG,OAAT,GAAmBH,QAAQ,CAACI,OAAT,CAAiBV,WAAjB,CAApB,IAAqD,CAAnE;AACH,OAHD,MAIK,IAAIF,KAAK,KAAK,CAAd,EACL;AACIG,QAAAA,WAAW,GAAIK,QAAQ,CAACG,OAAT,GAAmBH,QAAQ,CAACI,OAAT,CAAiBV,WAAjB,CAAlC;AACH;;AAEDvB,MAAAA,QAAQ,GAAG,CAAX;AACAC,MAAAA,QAAQ,IAAIJ,UAAZ;AACAa,MAAAA,SAAS,GAAG,IAAZ;AAEA;AACH;;AAEDP,IAAAA,KAAK,GAAGR,KAAK,CAACO,QAAD,CAAb;;AAEA,QAAI,CAACC,KAAL,EACA;AACI;AACH;;AAEDC,IAAAA,MAAM,GAAGU,QAAQ,GAAGX,KAAK,CAACK,CAA1B;AACAH,IAAAA,MAAM,GAAGW,QAAQ,GAAGb,KAAK,CAACM,CAA1B;AAEAH,IAAAA,MAAM,GAAGH,KAAK,CAACqC,KAAf;AACAjC,IAAAA,MAAM,GAAGJ,KAAK,CAACsC,MAAf;AAEAjC,IAAAA,CAAC,GAAGL,KAAK,CAACuC,OAAN,GAAgB1C,QAApB;AACAS,IAAAA,CAAC,GAAGN,KAAK,CAACwC,OAAN,GAAgB1C,QAApB;;AAEA,QAAIS,SAAS,KAAK,IAAlB,EACA;AACI,UAAIkC,aAAa,GAAGzC,KAAK,CAAC0C,OAAN,CAAclC,YAAd,CAApB;AACAH,MAAAA,CAAC,IAAKoC,aAAa,KAAKE,SAAnB,GAAgCF,aAAhC,GAAgD,CAArD;AACH;;AAEDpC,IAAAA,CAAC,IAAIU,KAAL;AACAT,IAAAA,CAAC,IAAIS,KAAL;AAEAV,IAAAA,CAAC,IAAIgB,WAAL;AAEAxB,IAAAA,QAAQ,IAAIG,KAAK,CAACH,QAAN,GAAiBF,aAA7B;AACAY,IAAAA,SAAS,GAAGP,KAAZ;AACAQ,IAAAA,YAAY,GAAGT,QAAf,CApDJ,CAsDI;;AACA,QAAII,MAAM,KAAK,CAAX,IAAgBC,MAAM,KAAK,CAA3B,IAAgCL,QAAQ,KAAK,EAAjD,EACA;AACI;AACH;;AAED,QAAImC,WAAJ,EACA;AACI7B,MAAAA,CAAC,GAAGuC,IAAI,CAACC,KAAL,CAAWxC,CAAX,CAAJ;AACAC,MAAAA,CAAC,GAAGsC,IAAI,CAACC,KAAL,CAAWvC,CAAX,CAAJ;AACH;;AAEDlB,IAAAA,GAAG,CAAC0D,IAAJ;AAEA1D,IAAAA,GAAG,CAAC2C,SAAJ,CAAc1B,CAAd,EAAiBC,CAAjB;AAEAlB,IAAAA,GAAG,CAAC2B,KAAJ,CAAUA,KAAV,EAAiBA,KAAjB;AAEA3B,IAAAA,GAAG,CAAC2D,SAAJ,CAActC,KAAd,EAAqBR,MAArB,EAA6BC,MAA7B,EAAqCC,MAArC,EAA6CC,MAA7C,EAAqD,CAArD,EAAwD,CAAxD,EAA2DD,MAA3D,EAAmEC,MAAnE;AAEAhB,IAAAA,GAAG,CAAC4D,OAAJ;AACH;;AAED5D,EAAAA,GAAG,CAAC4D,OAAJ;AACH,CAtJD;;AAwJAC,MAAM,CAACC,OAAP,GAAiBxE,wBAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.BitmapText#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.BitmapText} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar BitmapTextCanvasRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix)\r\n{\r\n    var text = src._text;\r\n    var textLength = text.length;\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        return;\r\n    }\r\n    \r\n    var textureFrame = src.frame;\r\n\r\n    var chars = src.fontData.chars;\r\n    var lineHeight = src.fontData.lineHeight;\r\n    var letterSpacing = src._letterSpacing;\r\n\r\n    var xAdvance = 0;\r\n    var yAdvance = 0;\r\n\r\n    var charCode = 0;\r\n\r\n    var glyph = null;\r\n    var glyphX = 0;\r\n    var glyphY = 0;\r\n    var glyphW = 0;\r\n    var glyphH = 0;\r\n\r\n    var x = 0;\r\n    var y = 0;\r\n\r\n    var lastGlyph = null;\r\n    var lastCharCode = 0;\r\n\r\n    var image = src.frame.source.image;\r\n\r\n    var textureX = textureFrame.cutX;\r\n    var textureY = textureFrame.cutY;\r\n\r\n    var scale = (src._fontSize / src.fontData.size);\r\n\r\n    var align = src._align;\r\n    var currentLine = 0;\r\n    var lineOffsetX = 0;\r\n\r\n    //  Update the bounds - skipped internally if not dirty\r\n    var bounds = src.getTextBounds(false);\r\n\r\n    //  In case the method above changed it (word wrapping)\r\n    if (src.maxWidth > 0)\r\n    {\r\n        text = bounds.wrappedText;\r\n        textLength = text.length;\r\n    }\r\n\r\n    var lineData = src._bounds.lines;\r\n\r\n    if (align === 1)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;\r\n    }\r\n    else if (align === 2)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]);\r\n    }\r\n\r\n    ctx.translate(-src.displayOriginX, -src.displayOriginY);\r\n\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    for (var i = 0; i < textLength; i++)\r\n    {\r\n        charCode = text.charCodeAt(i);\r\n\r\n        if (charCode === 10)\r\n        {\r\n            currentLine++;\r\n\r\n            if (align === 1)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;\r\n            }\r\n            else if (align === 2)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]);\r\n            }\r\n\r\n            xAdvance = 0;\r\n            yAdvance += lineHeight;\r\n            lastGlyph = null;\r\n\r\n            continue;\r\n        }\r\n\r\n        glyph = chars[charCode];\r\n\r\n        if (!glyph)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        glyphX = textureX + glyph.x;\r\n        glyphY = textureY + glyph.y;\r\n\r\n        glyphW = glyph.width;\r\n        glyphH = glyph.height;\r\n\r\n        x = glyph.xOffset + xAdvance;\r\n        y = glyph.yOffset + yAdvance;\r\n\r\n        if (lastGlyph !== null)\r\n        {\r\n            var kerningOffset = glyph.kerning[lastCharCode];\r\n            x += (kerningOffset !== undefined) ? kerningOffset : 0;\r\n        }\r\n\r\n        x *= scale;\r\n        y *= scale;\r\n\r\n        x += lineOffsetX;\r\n\r\n        xAdvance += glyph.xAdvance + letterSpacing;\r\n        lastGlyph = glyph;\r\n        lastCharCode = charCode;\r\n\r\n        //  Nothing to render or a space? Then skip to the next glyph\r\n        if (glyphW === 0 || glyphH === 0 || charCode === 32)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (roundPixels)\r\n        {\r\n            x = Math.round(x);\r\n            y = Math.round(y);\r\n        }\r\n\r\n        ctx.save();\r\n\r\n        ctx.translate(x, y);\r\n\r\n        ctx.scale(scale, scale);\r\n\r\n        ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    ctx.restore();\r\n};\r\n\r\nmodule.exports = BitmapTextCanvasRenderer;\r\n"]},"metadata":{},"sourceType":"script"}