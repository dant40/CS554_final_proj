{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar CONST = require('./const');\n\nvar Class = require('../utils/Class');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar GameEvents = require('../core/events');\n\nvar GetInnerHeight = require('../dom/GetInnerHeight');\n\nvar GetTarget = require('../dom/GetTarget');\n\nvar GetScreenOrientation = require('../dom/GetScreenOrientation');\n\nvar NOOP = require('../utils/NOOP');\n\nvar Rectangle = require('../geom/rectangle/Rectangle');\n\nvar Size = require('../structs/Size');\n\nvar SnapFloor = require('../math/snap/SnapFloor');\n\nvar Vector2 = require('../math/Vector2');\n/**\r\n * @classdesc\r\n * The Scale Manager handles the scaling, resizing and alignment of the game canvas.\r\n * \r\n * The way scaling is handled is by setting the game canvas to a fixed size, which is defined in the\r\n * game configuration. You also define the parent container in the game config. If no parent is given,\r\n * it will default to using the document body. The Scale Manager will then look at the available space\r\n * within the _parent_ and scale the canvas accordingly. Scaling is handled by setting the canvas CSS\r\n * width and height properties, leaving the width and height of the canvas element itself untouched.\r\n * Scaling is therefore achieved by keeping the core canvas the same size and 'stretching'\r\n * it via its CSS properties. This gives the same result and speed as using the `transform-scale` CSS\r\n * property, without the need for browser prefix handling.\r\n * \r\n * The calculations for the scale are heavily influenced by the bounding parent size, which is the computed\r\n * dimensions of the canvas's parent. The CSS rules of the parent element play an important role in the\r\n * operation of the Scale Manager. For example, if the parent has no defined width or height, then actions\r\n * like auto-centering will fail to achieve the required result. The Scale Manager works in tandem with the\r\n * CSS you set-up on the page hosting your game, rather than taking control of it.\r\n * \r\n * #### Parent and Display canvas containment guidelines:\r\n *\r\n * - Style the Parent element (of the game canvas) to control the Parent size and thus the games size and layout.\r\n *\r\n * - The Parent element's CSS styles should _effectively_ apply maximum (and minimum) bounding behavior.\r\n *\r\n * - The Parent element should _not_ apply a padding as this is not accounted for.\r\n *   If a padding is required apply it to the Parent's parent or apply a margin to the Parent.\r\n *   If you need to add a border, margin or any other CSS around your game container, then use a parent element and\r\n *   apply the CSS to this instead, otherwise you'll be constantly resizing the shape of the game container.\r\n *\r\n * - The Display canvas layout CSS styles (i.e. margins, size) should not be altered / specified as\r\n *   they may be updated by the Scale Manager.\r\n *\r\n * #### Scale Modes\r\n * \r\n * The way the scaling is handled is determined by the `scaleMode` property. The default is `NONE`,\r\n * which prevents Phaser from scaling or touching the canvas, or its parent, at all. In this mode, you are\r\n * responsible for all scaling. The other scaling modes afford you automatic scaling.\r\n * \r\n * If you wish to scale your game so that it always fits into the available space within the parent, you\r\n * should use the scale mode `FIT`. Look at the documentation for other scale modes to see what options are\r\n * available. Here is a basic config showing how to set this scale mode:\r\n * \r\n * ```javascript\r\n * scale: {\r\n *     parent: 'yourgamediv',\r\n *     mode: Phaser.Scale.FIT,\r\n *     width: 800,\r\n *     height: 600\r\n * }\r\n * ```\r\n * \r\n * Place the `scale` config object within your game config.\r\n * \r\n * If you wish for the canvas to be resized directly, so that the canvas itself fills the available space\r\n * (i.e. it isn't scaled, it's resized) then use the `RESIZE` scale mode. This will give you a 1:1 mapping\r\n * of canvas pixels to game size. In this mode CSS isn't used to scale the canvas, it's literally adjusted\r\n * to fill all available space within the parent. You should be extremely careful about the size of the\r\n * canvas you're creating when doing this, as the larger the area, the more work the GPU has to do and it's\r\n * very easy to hit fill-rate limits quickly.\r\n * \r\n * For complex, custom-scaling requirements, you should probably consider using the `RESIZE` scale mode,\r\n * with your own limitations in place re: canvas dimensions and managing the scaling with the game scenes\r\n * yourself. For the vast majority of games, however, the `FIT` mode is likely to be the most used.\r\n * \r\n * Please appreciate that the Scale Manager cannot perform miracles. All it does is scale your game canvas\r\n * as best it can, based on what it can infer from its surrounding area. There are all kinds of environments\r\n * where it's up to you to guide and help the canvas position itself, especially when built into rendering\r\n * frameworks like React and Vue. If your page requires meta tags to prevent user scaling gestures, or such\r\n * like, then it's up to you to ensure they are present in the html.\r\n * \r\n * #### Centering\r\n * \r\n * You can also have the game canvas automatically centered. Again, this relies heavily on the parent being\r\n * properly configured and styled, as the centering offsets are based entirely on the available space\r\n * within the parent element. Centering is disabled by default, or can be applied horizontally, vertically,\r\n * or both. Here's an example:\r\n * \r\n * ```javascript\r\n * scale: {\r\n *     parent: 'yourgamediv',\r\n *     autoCenter: Phaser.Scale.CENTER_BOTH,\r\n *     width: 800,\r\n *     height: 600\r\n * }\r\n * ```\r\n * \r\n * #### Fullscreen API\r\n * \r\n * If the browser supports it, you can send your game into fullscreen mode. In this mode, the game will fill\r\n * the entire display, removing all browser UI and anything else present on the screen. It will remain in this\r\n * mode until your game either disables it, or until the user tabs out or presses ESCape if on desktop. It's a\r\n * great way to achieve a desktop-game like experience from the browser, but it does require a modern browser\r\n * to handle it. Some mobile browsers also support this.\r\n *\r\n * @class ScaleManager\r\n * @memberof Phaser.Scale\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.16.0\r\n *\r\n * @param {Phaser.Game} game - A reference to the Phaser.Game instance.\r\n */\n\n\nvar ScaleManager = new Class({\n  Extends: EventEmitter,\n  initialize: function ScaleManager(game) {\n    EventEmitter.call(this);\n    /**\r\n     * A reference to the Phaser.Game instance.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#game\r\n     * @type {Phaser.Game}\r\n     * @readonly\r\n     * @since 3.15.0\r\n     */\n\n    this.game = game;\n    /**\r\n     * A reference to the HTML Canvas Element that Phaser uses to render the game.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#canvas\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.16.0\r\n     */\n\n    this.canvas;\n    /**\r\n     * The DOM bounds of the canvas element.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#canvasBounds\r\n     * @type {Phaser.Geom.Rectangle}\r\n     * @since 3.16.0\r\n     */\n\n    this.canvasBounds = new Rectangle();\n    /**\r\n     * The parent object of the Canvas. Often a div, or the browser window, or nothing in non-browser environments.\r\n     * \r\n     * This is set in the Game Config as the `parent` property. If undefined (or just not present), it will default\r\n     * to use the document body. If specifically set to `null` Phaser will ignore all parent operations.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#parent\r\n     * @type {?any}\r\n     * @since 3.16.0\r\n     */\n\n    this.parent = null;\n    /**\r\n     * Is the parent element the browser window?\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#parentIsWindow\r\n     * @type {boolean}\r\n     * @since 3.16.0\r\n     */\n\n    this.parentIsWindow = false;\n    /**\r\n     * The Parent Size component.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#parentSize\r\n     * @type {Phaser.Structs.Size}\r\n     * @since 3.16.0\r\n     */\n\n    this.parentSize = new Size();\n    /**\r\n     * The Game Size component.\r\n     * \r\n     * The un-modified game size, as requested in the game config (the raw width / height),\r\n     * as used for world bounds, cameras, etc\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#gameSize\r\n     * @type {Phaser.Structs.Size}\r\n     * @since 3.16.0\r\n     */\n\n    this.gameSize = new Size();\n    /**\r\n     * The Base Size component.\r\n     * \r\n     * The modified game size, which is the gameSize * resolution, used to set the canvas width and height\r\n     * (but not the CSS style)\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#baseSize\r\n     * @type {Phaser.Structs.Size}\r\n     * @since 3.16.0\r\n     */\n\n    this.baseSize = new Size();\n    /**\r\n     * The Display Size component.\r\n     * \r\n     * The size used for the canvas style, factoring in the scale mode, parent and other values.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#displaySize\r\n     * @type {Phaser.Structs.Size}\r\n     * @since 3.16.0\r\n     */\n\n    this.displaySize = new Size();\n    /**\r\n     * The game scale mode.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#scaleMode\r\n     * @type {Phaser.Scale.ScaleModeType}\r\n     * @since 3.16.0\r\n     */\n\n    this.scaleMode = CONST.SCALE_MODE.NONE;\n    /**\r\n     * The canvas resolution.\r\n     * \r\n     * This is hard-coded to a value of 1 in the 3.16 release of Phaser and will be enabled at a later date.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#resolution\r\n     * @type {number}\r\n     * @since 3.16.0\r\n     */\n\n    this.resolution = 1;\n    /**\r\n     * The game zoom factor.\r\n     * \r\n     * This value allows you to multiply your games base size by the given zoom factor.\r\n     * This is then used when calculating the display size, even in `NONE` situations.\r\n     * If you don't want Phaser to touch the canvas style at all, this value should be 1.\r\n     * \r\n     * Can also be set to `MAX_ZOOM` in which case the zoom value will be derived based\r\n     * on the game size and available space within the parent.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#zoom\r\n     * @type {number}\r\n     * @since 3.16.0\r\n     */\n\n    this.zoom = 1;\n    /**\r\n     * Internal flag set when the game zoom factor is modified.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#_resetZoom\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.19.0\r\n     */\n\n    this._resetZoom = false;\n    /**\r\n     * The scale factor between the baseSize and the canvasBounds.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#displayScale\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.16.0\r\n     */\n\n    this.displayScale = new Vector2(1, 1);\n    /**\r\n     * If set, the canvas sizes will be automatically passed through Math.floor.\r\n     * This results in rounded pixel display values, which is important for performance on legacy\r\n     * and low powered devices, but at the cost of not achieving a 'perfect' fit in some browser windows.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#autoRound\r\n     * @type {boolean}\r\n     * @since 3.16.0\r\n     */\n\n    this.autoRound = false;\n    /**\r\n     * Automatically center the canvas within the parent? The different centering modes are:\r\n     * \r\n     * 1. No centering.\r\n     * 2. Center both horizontally and vertically.\r\n     * 3. Center horizontally.\r\n     * 4. Center vertically.\r\n     * \r\n     * Please be aware that in order to center the game canvas, you must have specified a parent\r\n     * that has a size set, or the canvas parent is the document.body.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#autoCenter\r\n     * @type {Phaser.Scale.CenterType}\r\n     * @since 3.16.0\r\n     */\n\n    this.autoCenter = CONST.CENTER.NO_CENTER;\n    /**\r\n     * The current device orientation.\r\n     * \r\n     * Orientation events are dispatched via the Device Orientation API, typically only on mobile browsers.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#orientation\r\n     * @type {Phaser.Scale.OrientationType}\r\n     * @since 3.16.0\r\n     */\n\n    this.orientation = CONST.ORIENTATION.LANDSCAPE;\n    /**\r\n     * A reference to the Device.Fullscreen object.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#fullscreen\r\n     * @type {Phaser.Device.Fullscreen}\r\n     * @since 3.16.0\r\n     */\n\n    this.fullscreen;\n    /**\r\n     * The DOM Element which is sent into fullscreen mode.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#fullscreenTarget\r\n     * @type {?any}\r\n     * @since 3.16.0\r\n     */\n\n    this.fullscreenTarget = null;\n    /**\r\n     * Did Phaser create the fullscreen target div, or was it provided in the game config?\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#_createdFullscreenTarget\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this._createdFullscreenTarget = false;\n    /**\r\n     * The dirty state of the Scale Manager.\r\n     * Set if there is a change between the parent size and the current size.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#dirty\r\n     * @type {boolean}\r\n     * @since 3.16.0\r\n     */\n\n    this.dirty = false;\n    /**\r\n     * How many milliseconds should elapse before checking if the browser size has changed?\r\n     * \r\n     * Most modern browsers dispatch a 'resize' event, which the Scale Manager will listen for.\r\n     * However, older browsers fail to do this, or do it consistently, so we fall back to a\r\n     * more traditional 'size check' based on a time interval. You can control how often it is\r\n     * checked here.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#resizeInterval\r\n     * @type {integer}\r\n     * @since 3.16.0\r\n     */\n\n    this.resizeInterval = 500;\n    /**\r\n     * Internal size interval tracker.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#_lastCheck\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this._lastCheck = 0;\n    /**\r\n     * Internal flag to check orientation state.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#_checkOrientation\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this._checkOrientation = false;\n    /**\r\n     * Internal object containing our defined event listeners.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#listeners\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this.listeners = {\n      orientationChange: NOOP,\n      windowResize: NOOP,\n      fullScreenChange: NOOP,\n      fullScreenError: NOOP\n    };\n  },\n\n  /**\r\n   * Called _before_ the canvas object is created and added to the DOM.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#preBoot\r\n   * @protected\r\n   * @listens Phaser.Core.Events#BOOT\r\n   * @since 3.16.0\r\n   */\n  preBoot: function () {\n    //  Parse the config to get the scaling values we need\n    this.parseConfig(this.game.config);\n    this.game.events.once('boot', this.boot, this);\n  },\n\n  /**\r\n   * The Boot handler is called by Phaser.Game when it first starts up.\r\n   * The renderer is available by now and the canvas has been added to the DOM.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#boot\r\n   * @protected\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   */\n  boot: function () {\n    var game = this.game;\n    this.canvas = game.canvas;\n    this.fullscreen = game.device.fullscreen;\n\n    if (this.scaleMode !== CONST.SCALE_MODE.RESIZE) {\n      this.displaySize.setAspectMode(this.scaleMode);\n    }\n\n    if (this.scaleMode === CONST.SCALE_MODE.NONE) {\n      this.resize(this.width, this.height);\n    } else {\n      this.getParentBounds(); //  Only set the parent bounds if the parent has an actual size\n\n      if (this.parentSize.width > 0 && this.parentSize.height > 0) {\n        this.displaySize.setParent(this.parentSize);\n      }\n\n      this.refresh();\n    }\n\n    game.events.on(GameEvents.PRE_STEP, this.step, this);\n    game.events.once(GameEvents.DESTROY, this.destroy, this);\n    this.startListeners();\n  },\n\n  /**\r\n   * Parses the game configuration to set-up the scale defaults.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#parseConfig\r\n   * @protected\r\n   * @since 3.16.0\r\n   * \r\n   * @param {Phaser.Types.Core.GameConfig} config - The Game configuration object.\r\n   */\n  parseConfig: function (config) {\n    //  Get the parent element, if any\n    this.getParent(config); //  Get the size of the parent element\n    //  This can often set a height of zero (especially for un-styled divs)\n\n    this.getParentBounds();\n    var width = config.width;\n    var height = config.height;\n    var scaleMode = config.scaleMode;\n    var resolution = config.resolution;\n    var zoom = config.zoom;\n    var autoRound = config.autoRound; //  If width = '100%', or similar value\n\n    if (typeof width === 'string') {\n      //  If we have a parent with a height, we'll work it out from that\n      var parentWidth = this.parentSize.width;\n\n      if (parentWidth === 0) {\n        parentWidth = window.innerWidth;\n      }\n\n      var parentScaleX = parseInt(width, 10) / 100;\n      width = Math.floor(parentWidth * parentScaleX);\n    } //  If height = '100%', or similar value\n\n\n    if (typeof height === 'string') {\n      //  If we have a parent with a height, we'll work it out from that\n      var parentHeight = this.parentSize.height;\n\n      if (parentHeight === 0) {\n        parentHeight = window.innerHeight;\n      }\n\n      var parentScaleY = parseInt(height, 10) / 100;\n      height = Math.floor(parentHeight * parentScaleY);\n    } //  This is fixed at 1 on purpose.\n    //  Changing it will break all user input.\n    //  Wait for another release to solve this issue.\n\n\n    this.resolution = 1;\n    this.scaleMode = scaleMode;\n    this.autoRound = autoRound;\n    this.autoCenter = config.autoCenter;\n    this.resizeInterval = config.resizeInterval;\n\n    if (autoRound) {\n      width = Math.floor(width);\n      height = Math.floor(height);\n    } //  The un-modified game size, as requested in the game config (the raw width / height) as used for world bounds, etc\n\n\n    this.gameSize.setSize(width, height);\n\n    if (zoom === CONST.ZOOM.MAX_ZOOM) {\n      zoom = this.getMaxZoom();\n    }\n\n    this.zoom = zoom;\n\n    if (zoom !== 1) {\n      this._resetZoom = true;\n    } //  The modified game size, which is the w/h * resolution\n\n\n    this.baseSize.setSize(width * resolution, height * resolution);\n\n    if (autoRound) {\n      this.baseSize.width = Math.floor(this.baseSize.width);\n      this.baseSize.height = Math.floor(this.baseSize.height);\n    }\n\n    if (config.minWidth > 0) {\n      this.displaySize.setMin(config.minWidth * zoom, config.minHeight * zoom);\n    }\n\n    if (config.maxWidth > 0) {\n      this.displaySize.setMax(config.maxWidth * zoom, config.maxHeight * zoom);\n    } //  The size used for the canvas style, factoring in the scale mode and parent and zoom value\n    //  We just use the w/h here as this is what sets the aspect ratio (which doesn't then change)\n\n\n    this.displaySize.setSize(width, height);\n    this.orientation = GetScreenOrientation(width, height);\n  },\n\n  /**\r\n   * Determines the parent element of the game canvas, if any, based on the game configuration.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#getParent\r\n   * @since 3.16.0\r\n   * \r\n   * @param {Phaser.Types.Core.GameConfig} config - The Game configuration object.\r\n   */\n  getParent: function (config) {\n    var parent = config.parent;\n\n    if (parent === null) {\n      //  User is responsible for managing the parent\n      return;\n    }\n\n    this.parent = GetTarget(parent);\n    this.parentIsWindow = this.parent === document.body;\n\n    if (config.expandParent && config.scaleMode !== CONST.SCALE_MODE.NONE) {\n      var DOMRect = this.parent.getBoundingClientRect();\n\n      if (this.parentIsWindow || DOMRect.height === 0) {\n        document.documentElement.style.height = '100%';\n        document.body.style.height = '100%';\n        DOMRect = this.parent.getBoundingClientRect(); //  The parent STILL has no height, clearly no CSS\n        //  has been set on it even though we fixed the body :(\n\n        if (!this.parentIsWindow && DOMRect.height === 0) {\n          this.parent.style.overflow = 'hidden';\n          this.parent.style.width = '100%';\n          this.parent.style.height = '100%';\n        }\n      }\n    } //  And now get the fullscreenTarget\n\n\n    if (config.fullscreenTarget && !this.fullscreenTarget) {\n      this.fullscreenTarget = GetTarget(config.fullscreenTarget);\n    }\n  },\n\n  /**\r\n   * Calculates the size of the parent bounds and updates the `parentSize` component, if the canvas has a dom parent.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#getParentBounds\r\n   * @since 3.16.0\r\n   * \r\n   * @return {boolean} `true` if the parent bounds have changed size, otherwise `false`.\r\n   */\n  getParentBounds: function () {\n    if (!this.parent) {\n      return false;\n    }\n\n    var parentSize = this.parentSize; // Ref. http://msdn.microsoft.com/en-us/library/hh781509(v=vs.85).aspx for getBoundingClientRect\n\n    var DOMRect = this.parent.getBoundingClientRect();\n\n    if (this.parentIsWindow && this.game.device.os.iOS) {\n      DOMRect.height = GetInnerHeight(true);\n    }\n\n    var resolution = this.resolution;\n    var newWidth = DOMRect.width * resolution;\n    var newHeight = DOMRect.height * resolution;\n\n    if (parentSize.width !== newWidth || parentSize.height !== newHeight) {\n      parentSize.setSize(newWidth, newHeight);\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  /**\r\n   * Attempts to lock the orientation of the web browser using the Screen Orientation API.\r\n   * \r\n   * This API is only available on modern mobile browsers.\r\n   * See https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation for details.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#lockOrientation\r\n   * @since 3.16.0\r\n   * \r\n   * @param {string} orientation - The orientation you'd like to lock the browser in. Should be an API string such as 'landscape', 'landscape-primary', 'portrait', etc.\r\n   * \r\n   * @return {boolean} `true` if the orientation was successfully locked, otherwise `false`.\r\n   */\n  lockOrientation: function (orientation) {\n    var lock = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;\n\n    if (lock) {\n      return lock(orientation);\n    }\n\n    return false;\n  },\n\n  /**\r\n   * This method will set the size of the Parent Size component, which is used in scaling\r\n   * and centering calculations. You only need to call this method if you have explicitly\r\n   * disabled the use of a parent in your game config, but still wish to take advantage of\r\n   * other Scale Manager features.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#setParentSize\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   * \r\n   * @param {number} width - The new width of the parent.\r\n   * @param {number} height - The new height of the parent.\r\n   * \r\n   * @return {this} The Scale Manager instance.\r\n   */\n  setParentSize: function (width, height) {\n    this.parentSize.setSize(width, height);\n    return this.refresh();\n  },\n\n  /**\r\n   * This method will set a new size for your game.\r\n   * \r\n   * It should only be used if you're looking to change the base size of your game and are using\r\n   * one of the Scale Manager scaling modes, i.e. `FIT`. If you're using `NONE` and wish to\r\n   * change the game and canvas size directly, then please use the `resize` method instead.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#setGameSize\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   * \r\n   * @param {number} width - The new width of the game.\r\n   * @param {number} height - The new height of the game.\r\n   * \r\n   * @return {this} The Scale Manager instance.\r\n   */\n  setGameSize: function (width, height) {\n    var autoRound = this.autoRound;\n    var resolution = this.resolution;\n\n    if (autoRound) {\n      width = Math.floor(width);\n      height = Math.floor(height);\n    }\n\n    var previousWidth = this.width;\n    var previousHeight = this.height; //  The un-modified game size, as requested in the game config (the raw width / height) as used for world bounds, etc\n\n    this.gameSize.resize(width, height); //  The modified game size, which is the w/h * resolution\n\n    this.baseSize.resize(width * resolution, height * resolution);\n\n    if (autoRound) {\n      this.baseSize.width = Math.floor(this.baseSize.width);\n      this.baseSize.height = Math.floor(this.baseSize.height);\n    } //  The size used for the canvas style, factoring in the scale mode and parent and zoom value\n    //  We just use the w/h here as this is what sets the aspect ratio (which doesn't then change)\n\n\n    this.displaySize.setSize(width, height);\n    this.canvas.width = this.baseSize.width;\n    this.canvas.height = this.baseSize.height;\n    return this.refresh(previousWidth, previousHeight);\n  },\n\n  /**\r\n   * Call this to modify the size of the Phaser canvas element directly.\r\n   * You should only use this if you are using the `NONE` scale mode,\r\n   * it will update all internal components completely.\r\n   * \r\n   * If all you want to do is change the size of the parent, see the `setParentSize` method.\r\n   * \r\n   * If all you want is to change the base size of the game, but still have the Scale Manager\r\n   * manage all the scaling (i.e. you're **not** using `NONE`), then see the `setGameSize` method.\r\n   * \r\n   * This method will set the `gameSize`, `baseSize` and `displaySize` components to the given\r\n   * dimensions. It will then resize the canvas width and height to the values given, by\r\n   * directly setting the properties. Finally, if you have set the Scale Manager zoom value\r\n   * to anything other than 1 (the default), it will set the canvas CSS width and height to\r\n   * be the given size multiplied by the zoom factor (the canvas pixel size remains untouched).\r\n   * \r\n   * If you have enabled `autoCenter`, it is then passed to the `updateCenter` method and\r\n   * the margins are set, allowing the canvas to be centered based on its parent element\r\n   * alone. Finally, the `displayScale` is adjusted and the RESIZE event dispatched.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#resize\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   * \r\n   * @param {number} width - The new width of the game.\r\n   * @param {number} height - The new height of the game.\r\n   * \r\n   * @return {this} The Scale Manager instance.\r\n   */\n  resize: function (width, height) {\n    var zoom = this.zoom;\n    var resolution = this.resolution;\n    var autoRound = this.autoRound;\n\n    if (autoRound) {\n      width = Math.floor(width);\n      height = Math.floor(height);\n    }\n\n    var previousWidth = this.width;\n    var previousHeight = this.height; //  The un-modified game size, as requested in the game config (the raw width / height) as used for world bounds, etc\n\n    this.gameSize.resize(width, height); //  The modified game size, which is the w/h * resolution\n\n    this.baseSize.resize(width * resolution, height * resolution);\n\n    if (autoRound) {\n      this.baseSize.width = Math.floor(this.baseSize.width);\n      this.baseSize.height = Math.floor(this.baseSize.height);\n    } //  The size used for the canvas style, factoring in the scale mode and parent and zoom value\n    //  We just use the w/h here as this is what sets the aspect ratio (which doesn't then change)\n\n\n    this.displaySize.setSize(width * zoom * resolution, height * zoom * resolution);\n    this.canvas.width = this.baseSize.width;\n    this.canvas.height = this.baseSize.height;\n    var style = this.canvas.style;\n    var styleWidth = width * zoom;\n    var styleHeight = height * zoom;\n\n    if (autoRound) {\n      styleWidth = Math.floor(styleWidth);\n      styleHeight = Math.floor(styleHeight);\n    }\n\n    if (styleWidth !== width || styleHeight !== height) {\n      style.width = styleWidth + 'px';\n      style.height = styleHeight + 'px';\n    }\n\n    return this.refresh(previousWidth, previousHeight);\n  },\n\n  /**\r\n   * Sets the zoom value of the Scale Manager.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#setZoom\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   * \r\n   * @param {integer} value - The new zoom value of the game.\r\n   * \r\n   * @return {this} The Scale Manager instance.\r\n   */\n  setZoom: function (value) {\n    this.zoom = value;\n    this._resetZoom = true;\n    return this.refresh();\n  },\n\n  /**\r\n   * Sets the zoom to be the maximum possible based on the _current_ parent size.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#setMaxZoom\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   * \r\n   * @return {this} The Scale Manager instance.\r\n   */\n  setMaxZoom: function () {\n    this.zoom = this.getMaxZoom();\n    this._resetZoom = true;\n    return this.refresh();\n  },\n\n  /**\r\n   * Refreshes the internal scale values, bounds sizes and orientation checks.\r\n   * \r\n   * Once finished, dispatches the resize event.\r\n   * \r\n   * This is called automatically by the Scale Manager when the browser window size changes,\r\n   * as long as it is using a Scale Mode other than 'NONE'.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#refresh\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   * \r\n   * @param {number} [previousWidth] - The previous width of the game. Only set if the gameSize has changed.\r\n   * @param {number} [previousHeight] - The previous height of the game. Only set if the gameSize has changed.\r\n   * \r\n   * @return {this} The Scale Manager instance.\r\n   */\n  refresh: function (previousWidth, previousHeight) {\n    if (previousWidth === undefined) {\n      previousWidth = this.width;\n    }\n\n    if (previousHeight === undefined) {\n      previousHeight = this.height;\n    }\n\n    this.updateScale();\n    this.updateBounds();\n    this.updateOrientation();\n    this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height);\n    var domContainer = this.game.domContainer;\n\n    if (domContainer) {\n      this.baseSize.setCSS(domContainer);\n      var canvasStyle = this.canvas.style;\n      var domStyle = domContainer.style;\n      domStyle.transform = 'scale(' + this.displaySize.width / this.baseSize.width + ',' + this.displaySize.height / this.baseSize.height + ')';\n      domStyle.marginLeft = canvasStyle.marginLeft;\n      domStyle.marginTop = canvasStyle.marginTop;\n    }\n\n    this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, this.resolution, previousWidth, previousHeight);\n    return this;\n  },\n\n  /**\r\n   * Internal method that checks the current screen orientation, only if the internal check flag is set.\r\n   * \r\n   * If the orientation has changed it updates the orientation property and then dispatches the orientation change event.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#updateOrientation\r\n   * @fires Phaser.Scale.Events#ORIENTATION_CHANGE\r\n   * @since 3.16.0\r\n   */\n  updateOrientation: function () {\n    if (this._checkOrientation) {\n      this._checkOrientation = false;\n      var newOrientation = GetScreenOrientation(this.width, this.height);\n\n      if (newOrientation !== this.orientation) {\n        this.orientation = newOrientation;\n        this.emit(Events.ORIENTATION_CHANGE, newOrientation);\n      }\n    }\n  },\n\n  /**\r\n   * Internal method that manages updating the size components based on the scale mode.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#updateScale\r\n   * @since 3.16.0\r\n   */\n  updateScale: function () {\n    var style = this.canvas.style;\n    var width = this.gameSize.width;\n    var height = this.gameSize.height;\n    var styleWidth;\n    var styleHeight;\n    var zoom = this.zoom;\n    var autoRound = this.autoRound;\n    var resolution = 1;\n\n    if (this.scaleMode === CONST.SCALE_MODE.NONE) {\n      //  No scale\n      this.displaySize.setSize(width * zoom * resolution, height * zoom * resolution);\n      styleWidth = this.displaySize.width / resolution;\n      styleHeight = this.displaySize.height / resolution;\n\n      if (autoRound) {\n        styleWidth = Math.floor(styleWidth);\n        styleHeight = Math.floor(styleHeight);\n      }\n\n      if (this._resetZoom) {\n        style.width = styleWidth + 'px';\n        style.height = styleHeight + 'px';\n        this._resetZoom = false;\n      }\n    } else if (this.scaleMode === CONST.SCALE_MODE.RESIZE) {\n      //  Resize to match parent\n      //  This will constrain using min/max\n      this.displaySize.setSize(this.parentSize.width, this.parentSize.height);\n      this.gameSize.setSize(this.displaySize.width, this.displaySize.height);\n      this.baseSize.setSize(this.displaySize.width * resolution, this.displaySize.height * resolution);\n      styleWidth = this.displaySize.width / resolution;\n      styleHeight = this.displaySize.height / resolution;\n\n      if (autoRound) {\n        styleWidth = Math.floor(styleWidth);\n        styleHeight = Math.floor(styleHeight);\n      }\n\n      this.canvas.width = styleWidth;\n      this.canvas.height = styleHeight;\n    } else {\n      //  All other scale modes\n      this.displaySize.setSize(this.parentSize.width, this.parentSize.height);\n      styleWidth = this.displaySize.width / resolution;\n      styleHeight = this.displaySize.height / resolution;\n\n      if (autoRound) {\n        styleWidth = Math.floor(styleWidth);\n        styleHeight = Math.floor(styleHeight);\n      }\n\n      style.width = styleWidth + 'px';\n      style.height = styleHeight + 'px';\n    } //  Update the parentSize in case the canvas / style change modified it\n\n\n    this.getParentBounds(); //  Finally, update the centering\n\n    this.updateCenter();\n  },\n\n  /**\r\n   * Calculates and returns the largest possible zoom factor, based on the current\r\n   * parent and game sizes. If the parent has no dimensions (i.e. an unstyled div),\r\n   * or is smaller than the un-zoomed game, then this will return a value of 1 (no zoom)\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#getMaxZoom\r\n   * @since 3.16.0\r\n   * \r\n   * @return {integer} The maximum possible zoom factor. At a minimum this value is always at least 1.\r\n   */\n  getMaxZoom: function () {\n    var zoomH = SnapFloor(this.parentSize.width, this.gameSize.width, 0, true);\n    var zoomV = SnapFloor(this.parentSize.height, this.gameSize.height, 0, true);\n    return Math.max(Math.min(zoomH, zoomV), 1);\n  },\n\n  /**\r\n   * Calculates and updates the canvas CSS style in order to center it within the\r\n   * bounds of its parent. If you have explicitly set parent to be `null` in your\r\n   * game config then this method will likely give incorrect results unless you have called the\r\n   * `setParentSize` method first.\r\n   * \r\n   * It works by modifying the canvas CSS `marginLeft` and `marginTop` properties.\r\n   * \r\n   * If they have already been set by your own style sheet, or code, this will overwrite them.\r\n   * \r\n   * To prevent the Scale Manager from centering the canvas, either do not set the\r\n   * `autoCenter` property in your game config, or make sure it is set to `NO_CENTER`.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#updateCenter\r\n   * @since 3.16.0\r\n   */\n  updateCenter: function () {\n    var autoCenter = this.autoCenter;\n\n    if (autoCenter === CONST.CENTER.NO_CENTER) {\n      return;\n    }\n\n    var canvas = this.canvas;\n    var style = canvas.style;\n    var bounds = canvas.getBoundingClientRect(); // var width = parseInt(canvas.style.width, 10) || canvas.width;\n    // var height = parseInt(canvas.style.height, 10) || canvas.height;\n\n    var width = bounds.width;\n    var height = bounds.height;\n    var offsetX = Math.floor((this.parentSize.width - width) / 2);\n    var offsetY = Math.floor((this.parentSize.height - height) / 2);\n\n    if (autoCenter === CONST.CENTER.CENTER_HORIZONTALLY) {\n      offsetY = 0;\n    } else if (autoCenter === CONST.CENTER.CENTER_VERTICALLY) {\n      offsetX = 0;\n    }\n\n    style.marginLeft = offsetX + 'px';\n    style.marginTop = offsetY + 'px';\n  },\n\n  /**\r\n   * Updates the `canvasBounds` rectangle to match the bounding client rectangle of the\r\n   * canvas element being used to track input events.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#updateBounds\r\n   * @since 3.16.0\r\n   */\n  updateBounds: function () {\n    var bounds = this.canvasBounds;\n    var clientRect = this.canvas.getBoundingClientRect();\n    bounds.x = clientRect.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0);\n    bounds.y = clientRect.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0);\n    bounds.width = clientRect.width;\n    bounds.height = clientRect.height;\n  },\n\n  /**\r\n   * Transforms the pageX value into the scaled coordinate space of the Scale Manager.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#transformX\r\n   * @since 3.16.0\r\n   *\r\n   * @param {number} pageX - The DOM pageX value.\r\n   *\r\n   * @return {number} The translated value.\r\n   */\n  transformX: function (pageX) {\n    return (pageX - this.canvasBounds.left) * this.displayScale.x;\n  },\n\n  /**\r\n   * Transforms the pageY value into the scaled coordinate space of the Scale Manager.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#transformY\r\n   * @since 3.16.0\r\n   *\r\n   * @param {number} pageY - The DOM pageY value.\r\n   *\r\n   * @return {number} The translated value.\r\n   */\n  transformY: function (pageY) {\n    return (pageY - this.canvasBounds.top) * this.displayScale.y;\n  },\n\n  /**\r\n   * Sends a request to the browser to ask it to go in to full screen mode, using the {@link https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API Fullscreen API}.\r\n   * \r\n   * If the browser does not support this, a `FULLSCREEN_UNSUPPORTED` event will be emitted.\r\n   * \r\n   * This method _must_ be called from a user-input gesture, such as `pointerup`. You cannot launch\r\n   * games fullscreen without this, as most browsers block it. Games within an iframe will also be blocked\r\n   * from fullscreen unless the iframe has the `allowfullscreen` attribute.\r\n   * \r\n   * On touch devices, such as Android and iOS Safari, you should always use `pointerup` and NOT `pointerdown`,\r\n   * otherwise the request will fail unless the document in which your game is embedded has already received\r\n   * some form of touch input, which you cannot guarantee. Activating fullscreen via `pointerup` circumvents\r\n   * this issue.\r\n   * \r\n   * Performing an action that navigates to another page, or opens another tab, will automatically cancel\r\n   * fullscreen mode, as will the user pressing the ESC key. To cancel fullscreen mode directly from your game,\r\n   * i.e. by clicking an icon, call the `stopFullscreen` method.\r\n   * \r\n   * A browser can only send one DOM element into fullscreen. You can control which element this is by\r\n   * setting the `fullscreenTarget` property in your game config, or changing the property in the Scale Manager.\r\n   * Note that the game canvas _must_ be a child of the target. If you do not give a target, Phaser will\r\n   * automatically create a blank `<div>` element and move the canvas into it, before going fullscreen.\r\n   * When it leaves fullscreen, the div will be removed.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#startFullscreen\r\n   * @fires Phaser.Scale.Events#ENTER_FULLSCREEN\r\n   * @fires Phaser.Scale.Events#FULLSCREEN_FAILED\r\n   * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   * \r\n   * @param {object} [fullscreenOptions] - The FullscreenOptions dictionary is used to provide configuration options when entering full screen.\r\n   */\n  startFullscreen: function (fullscreenOptions) {\n    if (fullscreenOptions === undefined) {\n      fullscreenOptions = {\n        navigationUI: 'hide'\n      };\n    }\n\n    var fullscreen = this.fullscreen;\n\n    if (!fullscreen.available) {\n      this.emit(Events.FULLSCREEN_UNSUPPORTED);\n      return;\n    }\n\n    if (!fullscreen.active) {\n      var fsTarget = this.getFullscreenTarget();\n      var fsPromise;\n\n      if (fullscreen.keyboard) {\n        fsPromise = fsTarget[fullscreen.request](Element.ALLOW_KEYBOARD_INPUT);\n      } else {\n        fsPromise = fsTarget[fullscreen.request](fullscreenOptions);\n      }\n\n      if (fsPromise) {\n        fsPromise.then(this.fullscreenSuccessHandler.bind(this)).catch(this.fullscreenErrorHandler.bind(this));\n      } else if (fullscreen.active) {\n        this.fullscreenSuccessHandler();\n      } else {\n        this.fullscreenErrorHandler();\n      }\n    }\n  },\n\n  /**\r\n   * The browser has successfully entered fullscreen mode.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#fullscreenSuccessHandler\r\n   * @private\r\n   * @fires Phaser.Scale.Events#ENTER_FULLSCREEN\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.17.0\r\n   */\n  fullscreenSuccessHandler: function () {\n    this.getParentBounds();\n    this.refresh();\n    this.emit(Events.ENTER_FULLSCREEN);\n  },\n\n  /**\r\n   * The browser failed to enter fullscreen mode.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#fullscreenErrorHandler\r\n   * @private\r\n   * @fires Phaser.Scale.Events#FULLSCREEN_FAILED\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.17.0\r\n   * \r\n   * @param {any} error - The DOM error event.\r\n   */\n  fullscreenErrorHandler: function (error) {\n    this.removeFullscreenTarget();\n    this.emit(Events.FULLSCREEN_FAILED, error);\n  },\n\n  /**\r\n   * An internal method that gets the target element that is used when entering fullscreen mode.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#getFullscreenTarget\r\n   * @since 3.16.0\r\n   * \r\n   * @return {object} The fullscreen target element.\r\n   */\n  getFullscreenTarget: function () {\n    if (!this.fullscreenTarget) {\n      var fsTarget = document.createElement('div');\n      fsTarget.style.margin = '0';\n      fsTarget.style.padding = '0';\n      fsTarget.style.width = '100%';\n      fsTarget.style.height = '100%';\n      this.fullscreenTarget = fsTarget;\n      this._createdFullscreenTarget = true;\n    }\n\n    if (this._createdFullscreenTarget) {\n      var canvasParent = this.canvas.parentNode;\n      canvasParent.insertBefore(this.fullscreenTarget, this.canvas);\n      this.fullscreenTarget.appendChild(this.canvas);\n    }\n\n    return this.fullscreenTarget;\n  },\n\n  /**\r\n   * Removes the fullscreen target that was added to the DOM.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#removeFullscreenTarget\r\n   * @since 3.17.0\r\n   */\n  removeFullscreenTarget: function () {\n    if (this._createdFullscreenTarget) {\n      var fsTarget = this.fullscreenTarget;\n\n      if (fsTarget && fsTarget.parentNode) {\n        var parent = fsTarget.parentNode;\n        parent.insertBefore(this.canvas, fsTarget);\n        parent.removeChild(fsTarget);\n      }\n    }\n  },\n\n  /**\r\n   * Calling this method will cancel fullscreen mode, if the browser has entered it.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#stopFullscreen\r\n   * @fires Phaser.Scale.Events#LEAVE_FULLSCREEN\r\n   * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n   * @since 3.16.0\r\n   */\n  stopFullscreen: function () {\n    var fullscreen = this.fullscreen;\n\n    if (!fullscreen.available) {\n      this.emit(Events.FULLSCREEN_UNSUPPORTED);\n      return false;\n    }\n\n    if (fullscreen.active) {\n      document[fullscreen.cancel]();\n    }\n\n    this.removeFullscreenTarget(); //  Get the parent size again as it will have changed\n\n    this.getParentBounds();\n    this.emit(Events.LEAVE_FULLSCREEN);\n    this.refresh();\n  },\n\n  /**\r\n   * Toggles the fullscreen mode. If already in fullscreen, calling this will cancel it.\r\n   * If not in fullscreen, this will request the browser to enter fullscreen mode.\r\n   * \r\n   * If the browser does not support this, a `FULLSCREEN_UNSUPPORTED` event will be emitted.\r\n   * \r\n   * This method _must_ be called from a user-input gesture, such as `pointerdown`. You cannot launch\r\n   * games fullscreen without this, as most browsers block it. Games within an iframe will also be blocked\r\n   * from fullscreen unless the iframe has the `allowfullscreen` attribute.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#toggleFullscreen\r\n   * @fires Phaser.Scale.Events#ENTER_FULLSCREEN\r\n   * @fires Phaser.Scale.Events#LEAVE_FULLSCREEN\r\n   * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n   * @fires Phaser.Scale.Events#RESIZE\r\n   * @since 3.16.0\r\n   * \r\n   * @param {object} [fullscreenOptions] - The FullscreenOptions dictionary is used to provide configuration options when entering full screen.\r\n   */\n  toggleFullscreen: function (fullscreenOptions) {\n    if (this.fullscreen.active) {\n      this.stopFullscreen();\n    } else {\n      this.startFullscreen(fullscreenOptions);\n    }\n  },\n\n  /**\r\n   * An internal method that starts the different DOM event listeners running.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#startListeners\r\n   * @since 3.16.0\r\n   */\n  startListeners: function () {\n    var _this = this;\n\n    var listeners = this.listeners;\n\n    listeners.orientationChange = function () {\n      _this._checkOrientation = true;\n      _this.dirty = true;\n    };\n\n    listeners.windowResize = function () {\n      _this.dirty = true;\n    }; //  Only dispatched on mobile devices\n\n\n    window.addEventListener('orientationchange', listeners.orientationChange, false);\n    window.addEventListener('resize', listeners.windowResize, false);\n\n    if (this.fullscreen.available) {\n      listeners.fullScreenChange = function (event) {\n        return _this.onFullScreenChange(event);\n      };\n\n      listeners.fullScreenError = function (event) {\n        return _this.onFullScreenError(event);\n      };\n\n      var vendors = ['webkit', 'moz', ''];\n      vendors.forEach(function (prefix) {\n        document.addEventListener(prefix + 'fullscreenchange', listeners.fullScreenChange, false);\n        document.addEventListener(prefix + 'fullscreenerror', listeners.fullScreenError, false);\n      }); //  MS Specific\n\n      document.addEventListener('MSFullscreenChange', listeners.fullScreenChange, false);\n      document.addEventListener('MSFullscreenError', listeners.fullScreenError, false);\n    }\n  },\n\n  /**\r\n   * Triggered when a fullscreenchange event is dispatched by the DOM.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#onFullScreenChange\r\n   * @since 3.16.0\r\n   */\n  onFullScreenChange: function () {\n    //  They pressed ESC while in fullscreen mode\n    if (!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement)) {\n      this.stopFullscreen();\n    }\n  },\n\n  /**\r\n   * Triggered when a fullscreenerror event is dispatched by the DOM.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#onFullScreenError\r\n   * @since 3.16.0\r\n   */\n  onFullScreenError: function () {\n    this.removeFullscreenTarget();\n  },\n\n  /**\r\n   * Internal method, called automatically by the game step.\r\n   * Monitors the elapsed time and resize interval to see if a parent bounds check needs to take place.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#step\r\n   * @since 3.16.0\r\n   *\r\n   * @param {number} time - The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().\r\n   * @param {number} delta - The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.\r\n   */\n  step: function (time, delta) {\n    if (!this.parent) {\n      return;\n    }\n\n    this._lastCheck += delta;\n\n    if (this.dirty || this._lastCheck > this.resizeInterval) {\n      //  Returns true if the parent bounds have changed size\n      if (this.getParentBounds()) {\n        this.refresh();\n      }\n\n      this.dirty = false;\n      this._lastCheck = 0;\n    }\n  },\n\n  /**\r\n   * Stops all DOM event listeners.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#stopListeners\r\n   * @since 3.16.0\r\n   */\n  stopListeners: function () {\n    var listeners = this.listeners;\n    window.removeEventListener('orientationchange', listeners.orientationChange, false);\n    window.removeEventListener('resize', listeners.windowResize, false);\n    var vendors = ['webkit', 'moz', ''];\n    vendors.forEach(function (prefix) {\n      document.removeEventListener(prefix + 'fullscreenchange', listeners.fullScreenChange, false);\n      document.removeEventListener(prefix + 'fullscreenerror', listeners.fullScreenError, false);\n    }); //  MS Specific\n\n    document.removeEventListener('MSFullscreenChange', listeners.fullScreenChange, false);\n    document.removeEventListener('MSFullscreenError', listeners.fullScreenError, false);\n  },\n\n  /**\r\n   * Destroys this Scale Manager, releasing all references to external resources.\r\n   * Once destroyed, the Scale Manager cannot be used again.\r\n   *\r\n   * @method Phaser.Scale.ScaleManager#destroy\r\n   * @since 3.16.0\r\n   */\n  destroy: function () {\n    this.removeAllListeners();\n    this.stopListeners();\n    this.game = null;\n    this.canvas = null;\n    this.canvasBounds = null;\n    this.parent = null;\n    this.fullscreenTarget = null;\n    this.parentSize.destroy();\n    this.gameSize.destroy();\n    this.baseSize.destroy();\n    this.displaySize.destroy();\n  },\n\n  /**\r\n   * Is the browser currently in fullscreen mode or not?\r\n   *\r\n   * @name Phaser.Scale.ScaleManager#isFullscreen\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.16.0\r\n   */\n  isFullscreen: {\n    get: function () {\n      return this.fullscreen.active;\n    }\n  },\n\n  /**\r\n   * The game width.\r\n   * \r\n   * This is typically the size given in the game configuration.\r\n   *\r\n   * @name Phaser.Scale.ScaleManager#width\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.16.0\r\n   */\n  width: {\n    get: function () {\n      return this.gameSize.width;\n    }\n  },\n\n  /**\r\n   * The game height.\r\n   * \r\n   * This is typically the size given in the game configuration.\r\n   *\r\n   * @name Phaser.Scale.ScaleManager#height\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.16.0\r\n   */\n  height: {\n    get: function () {\n      return this.gameSize.height;\n    }\n  },\n\n  /**\r\n   * Is the device in a portrait orientation as reported by the Orientation API?\r\n   * This value is usually only available on mobile devices.\r\n   *\r\n   * @name Phaser.Scale.ScaleManager#isPortrait\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.16.0\r\n   */\n  isPortrait: {\n    get: function () {\n      return this.orientation === CONST.ORIENTATION.PORTRAIT;\n    }\n  },\n\n  /**\r\n   * Is the device in a landscape orientation as reported by the Orientation API?\r\n   * This value is usually only available on mobile devices.\r\n   *\r\n   * @name Phaser.Scale.ScaleManager#isLandscape\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.16.0\r\n   */\n  isLandscape: {\n    get: function () {\n      return this.orientation === CONST.ORIENTATION.LANDSCAPE;\n    }\n  },\n\n  /**\r\n   * Are the game dimensions portrait? (i.e. taller than they are wide)\r\n   * \r\n   * This is different to the device itself being in a portrait orientation.\r\n   *\r\n   * @name Phaser.Scale.ScaleManager#isGamePortrait\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.16.0\r\n   */\n  isGamePortrait: {\n    get: function () {\n      return this.height > this.width;\n    }\n  },\n\n  /**\r\n   * Are the game dimensions landscape? (i.e. wider than they are tall)\r\n   * \r\n   * This is different to the device itself being in a landscape orientation.\r\n   *\r\n   * @name Phaser.Scale.ScaleManager#isGameLandscape\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.16.0\r\n   */\n  isGameLandscape: {\n    get: function () {\n      return this.width > this.height;\n    }\n  }\n});\nmodule.exports = ScaleManager;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/scale/ScaleManager.js"],"names":["CONST","require","Class","EventEmitter","Events","GameEvents","GetInnerHeight","GetTarget","GetScreenOrientation","NOOP","Rectangle","Size","SnapFloor","Vector2","ScaleManager","Extends","initialize","game","call","canvas","canvasBounds","parent","parentIsWindow","parentSize","gameSize","baseSize","displaySize","scaleMode","SCALE_MODE","NONE","resolution","zoom","_resetZoom","displayScale","autoRound","autoCenter","CENTER","NO_CENTER","orientation","ORIENTATION","LANDSCAPE","fullscreen","fullscreenTarget","_createdFullscreenTarget","dirty","resizeInterval","_lastCheck","_checkOrientation","listeners","orientationChange","windowResize","fullScreenChange","fullScreenError","preBoot","parseConfig","config","events","once","boot","device","RESIZE","setAspectMode","resize","width","height","getParentBounds","setParent","refresh","on","PRE_STEP","step","DESTROY","destroy","startListeners","getParent","parentWidth","window","innerWidth","parentScaleX","parseInt","Math","floor","parentHeight","innerHeight","parentScaleY","setSize","ZOOM","MAX_ZOOM","getMaxZoom","minWidth","setMin","minHeight","maxWidth","setMax","maxHeight","document","body","expandParent","DOMRect","getBoundingClientRect","documentElement","style","overflow","os","iOS","newWidth","newHeight","lockOrientation","lock","screen","mozLockOrientation","msLockOrientation","setParentSize","setGameSize","previousWidth","previousHeight","styleWidth","styleHeight","setZoom","value","setMaxZoom","undefined","updateScale","updateBounds","updateOrientation","set","domContainer","setCSS","canvasStyle","domStyle","transform","marginLeft","marginTop","emit","newOrientation","ORIENTATION_CHANGE","updateCenter","zoomH","zoomV","max","min","bounds","offsetX","offsetY","CENTER_HORIZONTALLY","CENTER_VERTICALLY","clientRect","x","left","pageXOffset","clientLeft","y","top","pageYOffset","clientTop","transformX","pageX","transformY","pageY","startFullscreen","fullscreenOptions","navigationUI","available","FULLSCREEN_UNSUPPORTED","active","fsTarget","getFullscreenTarget","fsPromise","keyboard","request","Element","ALLOW_KEYBOARD_INPUT","then","fullscreenSuccessHandler","bind","catch","fullscreenErrorHandler","ENTER_FULLSCREEN","error","removeFullscreenTarget","FULLSCREEN_FAILED","createElement","margin","padding","canvasParent","parentNode","insertBefore","appendChild","removeChild","stopFullscreen","cancel","LEAVE_FULLSCREEN","toggleFullscreen","_this","addEventListener","event","onFullScreenChange","onFullScreenError","vendors","forEach","prefix","fullscreenElement","webkitFullscreenElement","msFullscreenElement","mozFullScreenElement","time","delta","stopListeners","removeEventListener","removeAllListeners","isFullscreen","get","isPortrait","PORTRAIT","isLandscape","isGamePortrait","isGameLandscape","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\nvar Class = require('../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar GameEvents = require('../core/events');\r\nvar GetInnerHeight = require('../dom/GetInnerHeight');\r\nvar GetTarget = require('../dom/GetTarget');\r\nvar GetScreenOrientation = require('../dom/GetScreenOrientation');\r\nvar NOOP = require('../utils/NOOP');\r\nvar Rectangle = require('../geom/rectangle/Rectangle');\r\nvar Size = require('../structs/Size');\r\nvar SnapFloor = require('../math/snap/SnapFloor');\r\nvar Vector2 = require('../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * The Scale Manager handles the scaling, resizing and alignment of the game canvas.\r\n * \r\n * The way scaling is handled is by setting the game canvas to a fixed size, which is defined in the\r\n * game configuration. You also define the parent container in the game config. If no parent is given,\r\n * it will default to using the document body. The Scale Manager will then look at the available space\r\n * within the _parent_ and scale the canvas accordingly. Scaling is handled by setting the canvas CSS\r\n * width and height properties, leaving the width and height of the canvas element itself untouched.\r\n * Scaling is therefore achieved by keeping the core canvas the same size and 'stretching'\r\n * it via its CSS properties. This gives the same result and speed as using the `transform-scale` CSS\r\n * property, without the need for browser prefix handling.\r\n * \r\n * The calculations for the scale are heavily influenced by the bounding parent size, which is the computed\r\n * dimensions of the canvas's parent. The CSS rules of the parent element play an important role in the\r\n * operation of the Scale Manager. For example, if the parent has no defined width or height, then actions\r\n * like auto-centering will fail to achieve the required result. The Scale Manager works in tandem with the\r\n * CSS you set-up on the page hosting your game, rather than taking control of it.\r\n * \r\n * #### Parent and Display canvas containment guidelines:\r\n *\r\n * - Style the Parent element (of the game canvas) to control the Parent size and thus the games size and layout.\r\n *\r\n * - The Parent element's CSS styles should _effectively_ apply maximum (and minimum) bounding behavior.\r\n *\r\n * - The Parent element should _not_ apply a padding as this is not accounted for.\r\n *   If a padding is required apply it to the Parent's parent or apply a margin to the Parent.\r\n *   If you need to add a border, margin or any other CSS around your game container, then use a parent element and\r\n *   apply the CSS to this instead, otherwise you'll be constantly resizing the shape of the game container.\r\n *\r\n * - The Display canvas layout CSS styles (i.e. margins, size) should not be altered / specified as\r\n *   they may be updated by the Scale Manager.\r\n *\r\n * #### Scale Modes\r\n * \r\n * The way the scaling is handled is determined by the `scaleMode` property. The default is `NONE`,\r\n * which prevents Phaser from scaling or touching the canvas, or its parent, at all. In this mode, you are\r\n * responsible for all scaling. The other scaling modes afford you automatic scaling.\r\n * \r\n * If you wish to scale your game so that it always fits into the available space within the parent, you\r\n * should use the scale mode `FIT`. Look at the documentation for other scale modes to see what options are\r\n * available. Here is a basic config showing how to set this scale mode:\r\n * \r\n * ```javascript\r\n * scale: {\r\n *     parent: 'yourgamediv',\r\n *     mode: Phaser.Scale.FIT,\r\n *     width: 800,\r\n *     height: 600\r\n * }\r\n * ```\r\n * \r\n * Place the `scale` config object within your game config.\r\n * \r\n * If you wish for the canvas to be resized directly, so that the canvas itself fills the available space\r\n * (i.e. it isn't scaled, it's resized) then use the `RESIZE` scale mode. This will give you a 1:1 mapping\r\n * of canvas pixels to game size. In this mode CSS isn't used to scale the canvas, it's literally adjusted\r\n * to fill all available space within the parent. You should be extremely careful about the size of the\r\n * canvas you're creating when doing this, as the larger the area, the more work the GPU has to do and it's\r\n * very easy to hit fill-rate limits quickly.\r\n * \r\n * For complex, custom-scaling requirements, you should probably consider using the `RESIZE` scale mode,\r\n * with your own limitations in place re: canvas dimensions and managing the scaling with the game scenes\r\n * yourself. For the vast majority of games, however, the `FIT` mode is likely to be the most used.\r\n * \r\n * Please appreciate that the Scale Manager cannot perform miracles. All it does is scale your game canvas\r\n * as best it can, based on what it can infer from its surrounding area. There are all kinds of environments\r\n * where it's up to you to guide and help the canvas position itself, especially when built into rendering\r\n * frameworks like React and Vue. If your page requires meta tags to prevent user scaling gestures, or such\r\n * like, then it's up to you to ensure they are present in the html.\r\n * \r\n * #### Centering\r\n * \r\n * You can also have the game canvas automatically centered. Again, this relies heavily on the parent being\r\n * properly configured and styled, as the centering offsets are based entirely on the available space\r\n * within the parent element. Centering is disabled by default, or can be applied horizontally, vertically,\r\n * or both. Here's an example:\r\n * \r\n * ```javascript\r\n * scale: {\r\n *     parent: 'yourgamediv',\r\n *     autoCenter: Phaser.Scale.CENTER_BOTH,\r\n *     width: 800,\r\n *     height: 600\r\n * }\r\n * ```\r\n * \r\n * #### Fullscreen API\r\n * \r\n * If the browser supports it, you can send your game into fullscreen mode. In this mode, the game will fill\r\n * the entire display, removing all browser UI and anything else present on the screen. It will remain in this\r\n * mode until your game either disables it, or until the user tabs out or presses ESCape if on desktop. It's a\r\n * great way to achieve a desktop-game like experience from the browser, but it does require a modern browser\r\n * to handle it. Some mobile browsers also support this.\r\n *\r\n * @class ScaleManager\r\n * @memberof Phaser.Scale\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.16.0\r\n *\r\n * @param {Phaser.Game} game - A reference to the Phaser.Game instance.\r\n */\r\nvar ScaleManager = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function ScaleManager (game)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Phaser.Game instance.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#game\r\n         * @type {Phaser.Game}\r\n         * @readonly\r\n         * @since 3.15.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * A reference to the HTML Canvas Element that Phaser uses to render the game.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.16.0\r\n         */\r\n        this.canvas;\r\n\r\n        /**\r\n         * The DOM bounds of the canvas element.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#canvasBounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @since 3.16.0\r\n         */\r\n        this.canvasBounds = new Rectangle();\r\n\r\n        /**\r\n         * The parent object of the Canvas. Often a div, or the browser window, or nothing in non-browser environments.\r\n         * \r\n         * This is set in the Game Config as the `parent` property. If undefined (or just not present), it will default\r\n         * to use the document body. If specifically set to `null` Phaser will ignore all parent operations.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#parent\r\n         * @type {?any}\r\n         * @since 3.16.0\r\n         */\r\n        this.parent = null;\r\n\r\n        /**\r\n         * Is the parent element the browser window?\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#parentIsWindow\r\n         * @type {boolean}\r\n         * @since 3.16.0\r\n         */\r\n        this.parentIsWindow = false;\r\n\r\n        /**\r\n         * The Parent Size component.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#parentSize\r\n         * @type {Phaser.Structs.Size}\r\n         * @since 3.16.0\r\n         */\r\n        this.parentSize = new Size();\r\n\r\n        /**\r\n         * The Game Size component.\r\n         * \r\n         * The un-modified game size, as requested in the game config (the raw width / height),\r\n         * as used for world bounds, cameras, etc\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#gameSize\r\n         * @type {Phaser.Structs.Size}\r\n         * @since 3.16.0\r\n         */\r\n        this.gameSize = new Size();\r\n\r\n        /**\r\n         * The Base Size component.\r\n         * \r\n         * The modified game size, which is the gameSize * resolution, used to set the canvas width and height\r\n         * (but not the CSS style)\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#baseSize\r\n         * @type {Phaser.Structs.Size}\r\n         * @since 3.16.0\r\n         */\r\n        this.baseSize = new Size();\r\n\r\n        /**\r\n         * The Display Size component.\r\n         * \r\n         * The size used for the canvas style, factoring in the scale mode, parent and other values.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#displaySize\r\n         * @type {Phaser.Structs.Size}\r\n         * @since 3.16.0\r\n         */\r\n        this.displaySize = new Size();\r\n\r\n        /**\r\n         * The game scale mode.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#scaleMode\r\n         * @type {Phaser.Scale.ScaleModeType}\r\n         * @since 3.16.0\r\n         */\r\n        this.scaleMode = CONST.SCALE_MODE.NONE;\r\n\r\n        /**\r\n         * The canvas resolution.\r\n         * \r\n         * This is hard-coded to a value of 1 in the 3.16 release of Phaser and will be enabled at a later date.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#resolution\r\n         * @type {number}\r\n         * @since 3.16.0\r\n         */\r\n        this.resolution = 1;\r\n\r\n        /**\r\n         * The game zoom factor.\r\n         * \r\n         * This value allows you to multiply your games base size by the given zoom factor.\r\n         * This is then used when calculating the display size, even in `NONE` situations.\r\n         * If you don't want Phaser to touch the canvas style at all, this value should be 1.\r\n         * \r\n         * Can also be set to `MAX_ZOOM` in which case the zoom value will be derived based\r\n         * on the game size and available space within the parent.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#zoom\r\n         * @type {number}\r\n         * @since 3.16.0\r\n         */\r\n        this.zoom = 1;\r\n\r\n        /**\r\n         * Internal flag set when the game zoom factor is modified.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#_resetZoom\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.19.0\r\n         */\r\n        this._resetZoom = false;\r\n\r\n        /**\r\n         * The scale factor between the baseSize and the canvasBounds.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#displayScale\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.16.0\r\n         */\r\n        this.displayScale = new Vector2(1, 1);\r\n\r\n        /**\r\n         * If set, the canvas sizes will be automatically passed through Math.floor.\r\n         * This results in rounded pixel display values, which is important for performance on legacy\r\n         * and low powered devices, but at the cost of not achieving a 'perfect' fit in some browser windows.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#autoRound\r\n         * @type {boolean}\r\n         * @since 3.16.0\r\n         */\r\n        this.autoRound = false;\r\n\r\n        /**\r\n         * Automatically center the canvas within the parent? The different centering modes are:\r\n         * \r\n         * 1. No centering.\r\n         * 2. Center both horizontally and vertically.\r\n         * 3. Center horizontally.\r\n         * 4. Center vertically.\r\n         * \r\n         * Please be aware that in order to center the game canvas, you must have specified a parent\r\n         * that has a size set, or the canvas parent is the document.body.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#autoCenter\r\n         * @type {Phaser.Scale.CenterType}\r\n         * @since 3.16.0\r\n         */\r\n        this.autoCenter = CONST.CENTER.NO_CENTER;\r\n\r\n        /**\r\n         * The current device orientation.\r\n         * \r\n         * Orientation events are dispatched via the Device Orientation API, typically only on mobile browsers.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#orientation\r\n         * @type {Phaser.Scale.OrientationType}\r\n         * @since 3.16.0\r\n         */\r\n        this.orientation = CONST.ORIENTATION.LANDSCAPE;\r\n\r\n        /**\r\n         * A reference to the Device.Fullscreen object.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#fullscreen\r\n         * @type {Phaser.Device.Fullscreen}\r\n         * @since 3.16.0\r\n         */\r\n        this.fullscreen;\r\n\r\n        /**\r\n         * The DOM Element which is sent into fullscreen mode.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#fullscreenTarget\r\n         * @type {?any}\r\n         * @since 3.16.0\r\n         */\r\n        this.fullscreenTarget = null;\r\n\r\n        /**\r\n         * Did Phaser create the fullscreen target div, or was it provided in the game config?\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#_createdFullscreenTarget\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._createdFullscreenTarget = false;\r\n\r\n        /**\r\n         * The dirty state of the Scale Manager.\r\n         * Set if there is a change between the parent size and the current size.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#dirty\r\n         * @type {boolean}\r\n         * @since 3.16.0\r\n         */\r\n        this.dirty = false;\r\n\r\n        /**\r\n         * How many milliseconds should elapse before checking if the browser size has changed?\r\n         * \r\n         * Most modern browsers dispatch a 'resize' event, which the Scale Manager will listen for.\r\n         * However, older browsers fail to do this, or do it consistently, so we fall back to a\r\n         * more traditional 'size check' based on a time interval. You can control how often it is\r\n         * checked here.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#resizeInterval\r\n         * @type {integer}\r\n         * @since 3.16.0\r\n         */\r\n        this.resizeInterval = 500;\r\n\r\n        /**\r\n         * Internal size interval tracker.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#_lastCheck\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._lastCheck = 0;\r\n\r\n        /**\r\n         * Internal flag to check orientation state.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#_checkOrientation\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._checkOrientation = false;\r\n\r\n        /**\r\n         * Internal object containing our defined event listeners.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#listeners\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this.listeners = {\r\n\r\n            orientationChange: NOOP,\r\n            windowResize: NOOP,\r\n            fullScreenChange: NOOP,\r\n            fullScreenError: NOOP\r\n\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Called _before_ the canvas object is created and added to the DOM.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#preBoot\r\n     * @protected\r\n     * @listens Phaser.Core.Events#BOOT\r\n     * @since 3.16.0\r\n     */\r\n    preBoot: function ()\r\n    {\r\n        //  Parse the config to get the scaling values we need\r\n        this.parseConfig(this.game.config);\r\n\r\n        this.game.events.once('boot', this.boot, this);\r\n    },\r\n\r\n    /**\r\n     * The Boot handler is called by Phaser.Game when it first starts up.\r\n     * The renderer is available by now and the canvas has been added to the DOM.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#boot\r\n     * @protected\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        var game = this.game;\r\n\r\n        this.canvas = game.canvas;\r\n\r\n        this.fullscreen = game.device.fullscreen;\r\n\r\n        if (this.scaleMode !== CONST.SCALE_MODE.RESIZE)\r\n        {\r\n            this.displaySize.setAspectMode(this.scaleMode);\r\n        }\r\n\r\n        if (this.scaleMode === CONST.SCALE_MODE.NONE)\r\n        {\r\n            this.resize(this.width, this.height);\r\n        }\r\n        else\r\n        {\r\n            this.getParentBounds();\r\n\r\n            //  Only set the parent bounds if the parent has an actual size\r\n            if (this.parentSize.width > 0 && this.parentSize.height > 0)\r\n            {\r\n                this.displaySize.setParent(this.parentSize);\r\n            }\r\n\r\n            this.refresh();\r\n        }\r\n\r\n        game.events.on(GameEvents.PRE_STEP, this.step, this);\r\n        game.events.once(GameEvents.DESTROY, this.destroy, this);\r\n\r\n        this.startListeners();\r\n    },\r\n\r\n    /**\r\n     * Parses the game configuration to set-up the scale defaults.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#parseConfig\r\n     * @protected\r\n     * @since 3.16.0\r\n     * \r\n     * @param {Phaser.Types.Core.GameConfig} config - The Game configuration object.\r\n     */\r\n    parseConfig: function (config)\r\n    {\r\n        //  Get the parent element, if any\r\n        this.getParent(config);\r\n        \r\n        //  Get the size of the parent element\r\n        //  This can often set a height of zero (especially for un-styled divs)\r\n        this.getParentBounds();\r\n\r\n        var width = config.width;\r\n        var height = config.height;\r\n        var scaleMode = config.scaleMode;\r\n        var resolution = config.resolution;\r\n        var zoom = config.zoom;\r\n        var autoRound = config.autoRound;\r\n\r\n        //  If width = '100%', or similar value\r\n        if (typeof width === 'string')\r\n        {\r\n            //  If we have a parent with a height, we'll work it out from that\r\n            var parentWidth = this.parentSize.width;\r\n\r\n            if (parentWidth === 0)\r\n            {\r\n                parentWidth = window.innerWidth;\r\n            }\r\n\r\n            var parentScaleX = parseInt(width, 10) / 100;\r\n\r\n            width = Math.floor(parentWidth * parentScaleX);\r\n        }\r\n\r\n        //  If height = '100%', or similar value\r\n        if (typeof height === 'string')\r\n        {\r\n            //  If we have a parent with a height, we'll work it out from that\r\n            var parentHeight = this.parentSize.height;\r\n\r\n            if (parentHeight === 0)\r\n            {\r\n                parentHeight = window.innerHeight;\r\n            }\r\n\r\n            var parentScaleY = parseInt(height, 10) / 100;\r\n\r\n            height = Math.floor(parentHeight * parentScaleY);\r\n        }\r\n\r\n        //  This is fixed at 1 on purpose.\r\n        //  Changing it will break all user input.\r\n        //  Wait for another release to solve this issue.\r\n        this.resolution = 1;\r\n\r\n        this.scaleMode = scaleMode;\r\n\r\n        this.autoRound = autoRound;\r\n\r\n        this.autoCenter = config.autoCenter;\r\n\r\n        this.resizeInterval = config.resizeInterval;\r\n\r\n        if (autoRound)\r\n        {\r\n            width = Math.floor(width);\r\n            height = Math.floor(height);\r\n        }\r\n\r\n        //  The un-modified game size, as requested in the game config (the raw width / height) as used for world bounds, etc\r\n        this.gameSize.setSize(width, height);\r\n\r\n        if (zoom === CONST.ZOOM.MAX_ZOOM)\r\n        {\r\n            zoom = this.getMaxZoom();\r\n        }\r\n\r\n        this.zoom = zoom;\r\n\r\n        if (zoom !== 1)\r\n        {\r\n            this._resetZoom = true;\r\n        }\r\n\r\n        //  The modified game size, which is the w/h * resolution\r\n        this.baseSize.setSize(width * resolution, height * resolution);\r\n\r\n        if (autoRound)\r\n        {\r\n            this.baseSize.width = Math.floor(this.baseSize.width);\r\n            this.baseSize.height = Math.floor(this.baseSize.height);\r\n        }\r\n\r\n        if (config.minWidth > 0)\r\n        {\r\n            this.displaySize.setMin(config.minWidth * zoom, config.minHeight * zoom);\r\n        }\r\n\r\n        if (config.maxWidth > 0)\r\n        {\r\n            this.displaySize.setMax(config.maxWidth * zoom, config.maxHeight * zoom);\r\n        }\r\n\r\n        //  The size used for the canvas style, factoring in the scale mode and parent and zoom value\r\n        //  We just use the w/h here as this is what sets the aspect ratio (which doesn't then change)\r\n        this.displaySize.setSize(width, height);\r\n\r\n        this.orientation = GetScreenOrientation(width, height);\r\n    },\r\n\r\n    /**\r\n     * Determines the parent element of the game canvas, if any, based on the game configuration.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#getParent\r\n     * @since 3.16.0\r\n     * \r\n     * @param {Phaser.Types.Core.GameConfig} config - The Game configuration object.\r\n     */\r\n    getParent: function (config)\r\n    {\r\n        var parent = config.parent;\r\n\r\n        if (parent === null)\r\n        {\r\n            //  User is responsible for managing the parent\r\n            return;\r\n        }\r\n\r\n        this.parent = GetTarget(parent);\r\n        this.parentIsWindow = (this.parent === document.body);\r\n\r\n        if (config.expandParent && config.scaleMode !== CONST.SCALE_MODE.NONE)\r\n        {\r\n            var DOMRect = this.parent.getBoundingClientRect();\r\n\r\n            if (this.parentIsWindow || DOMRect.height === 0)\r\n            {\r\n                document.documentElement.style.height = '100%';\r\n                document.body.style.height = '100%';\r\n\r\n                DOMRect = this.parent.getBoundingClientRect();\r\n\r\n                //  The parent STILL has no height, clearly no CSS\r\n                //  has been set on it even though we fixed the body :(\r\n                if (!this.parentIsWindow && DOMRect.height === 0)\r\n                {\r\n                    this.parent.style.overflow = 'hidden';\r\n                    this.parent.style.width = '100%';\r\n                    this.parent.style.height = '100%';\r\n                }\r\n            }\r\n        }\r\n\r\n        //  And now get the fullscreenTarget\r\n        if (config.fullscreenTarget && !this.fullscreenTarget)\r\n        {\r\n            this.fullscreenTarget = GetTarget(config.fullscreenTarget);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Calculates the size of the parent bounds and updates the `parentSize` component, if the canvas has a dom parent.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#getParentBounds\r\n     * @since 3.16.0\r\n     * \r\n     * @return {boolean} `true` if the parent bounds have changed size, otherwise `false`.\r\n     */\r\n    getParentBounds: function ()\r\n    {\r\n        if (!this.parent)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var parentSize = this.parentSize;\r\n\r\n        // Ref. http://msdn.microsoft.com/en-us/library/hh781509(v=vs.85).aspx for getBoundingClientRect\r\n\r\n        var DOMRect = this.parent.getBoundingClientRect();\r\n\r\n        if (this.parentIsWindow && this.game.device.os.iOS)\r\n        {\r\n            DOMRect.height = GetInnerHeight(true);\r\n        }\r\n\r\n        var resolution = this.resolution;\r\n        var newWidth = DOMRect.width * resolution;\r\n        var newHeight = DOMRect.height * resolution;\r\n\r\n        if (parentSize.width !== newWidth || parentSize.height !== newHeight)\r\n        {\r\n            parentSize.setSize(newWidth, newHeight);\r\n\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Attempts to lock the orientation of the web browser using the Screen Orientation API.\r\n     * \r\n     * This API is only available on modern mobile browsers.\r\n     * See https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation for details.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#lockOrientation\r\n     * @since 3.16.0\r\n     * \r\n     * @param {string} orientation - The orientation you'd like to lock the browser in. Should be an API string such as 'landscape', 'landscape-primary', 'portrait', etc.\r\n     * \r\n     * @return {boolean} `true` if the orientation was successfully locked, otherwise `false`.\r\n     */\r\n    lockOrientation: function (orientation)\r\n    {\r\n        var lock = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;\r\n\r\n        if (lock)\r\n        {\r\n            return lock(orientation);\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * This method will set the size of the Parent Size component, which is used in scaling\r\n     * and centering calculations. You only need to call this method if you have explicitly\r\n     * disabled the use of a parent in your game config, but still wish to take advantage of\r\n     * other Scale Manager features.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#setParentSize\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     * \r\n     * @param {number} width - The new width of the parent.\r\n     * @param {number} height - The new height of the parent.\r\n     * \r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    setParentSize: function (width, height)\r\n    {\r\n        this.parentSize.setSize(width, height);\r\n\r\n        return this.refresh();\r\n    },\r\n\r\n    /**\r\n     * This method will set a new size for your game.\r\n     * \r\n     * It should only be used if you're looking to change the base size of your game and are using\r\n     * one of the Scale Manager scaling modes, i.e. `FIT`. If you're using `NONE` and wish to\r\n     * change the game and canvas size directly, then please use the `resize` method instead.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#setGameSize\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     * \r\n     * @param {number} width - The new width of the game.\r\n     * @param {number} height - The new height of the game.\r\n     * \r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    setGameSize: function (width, height)\r\n    {\r\n        var autoRound = this.autoRound;\r\n        var resolution = this.resolution;\r\n\r\n        if (autoRound)\r\n        {\r\n            width = Math.floor(width);\r\n            height = Math.floor(height);\r\n        }\r\n\r\n        var previousWidth = this.width;\r\n        var previousHeight = this.height;\r\n\r\n        //  The un-modified game size, as requested in the game config (the raw width / height) as used for world bounds, etc\r\n        this.gameSize.resize(width, height);\r\n\r\n        //  The modified game size, which is the w/h * resolution\r\n        this.baseSize.resize(width * resolution, height * resolution);\r\n\r\n        if (autoRound)\r\n        {\r\n            this.baseSize.width = Math.floor(this.baseSize.width);\r\n            this.baseSize.height = Math.floor(this.baseSize.height);\r\n        }\r\n\r\n        //  The size used for the canvas style, factoring in the scale mode and parent and zoom value\r\n        //  We just use the w/h here as this is what sets the aspect ratio (which doesn't then change)\r\n        this.displaySize.setSize(width, height);\r\n\r\n        this.canvas.width = this.baseSize.width;\r\n        this.canvas.height = this.baseSize.height;\r\n\r\n        return this.refresh(previousWidth, previousHeight);\r\n    },\r\n\r\n    /**\r\n     * Call this to modify the size of the Phaser canvas element directly.\r\n     * You should only use this if you are using the `NONE` scale mode,\r\n     * it will update all internal components completely.\r\n     * \r\n     * If all you want to do is change the size of the parent, see the `setParentSize` method.\r\n     * \r\n     * If all you want is to change the base size of the game, but still have the Scale Manager\r\n     * manage all the scaling (i.e. you're **not** using `NONE`), then see the `setGameSize` method.\r\n     * \r\n     * This method will set the `gameSize`, `baseSize` and `displaySize` components to the given\r\n     * dimensions. It will then resize the canvas width and height to the values given, by\r\n     * directly setting the properties. Finally, if you have set the Scale Manager zoom value\r\n     * to anything other than 1 (the default), it will set the canvas CSS width and height to\r\n     * be the given size multiplied by the zoom factor (the canvas pixel size remains untouched).\r\n     * \r\n     * If you have enabled `autoCenter`, it is then passed to the `updateCenter` method and\r\n     * the margins are set, allowing the canvas to be centered based on its parent element\r\n     * alone. Finally, the `displayScale` is adjusted and the RESIZE event dispatched.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#resize\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     * \r\n     * @param {number} width - The new width of the game.\r\n     * @param {number} height - The new height of the game.\r\n     * \r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    resize: function (width, height)\r\n    {\r\n        var zoom = this.zoom;\r\n        var resolution = this.resolution;\r\n        var autoRound = this.autoRound;\r\n\r\n        if (autoRound)\r\n        {\r\n            width = Math.floor(width);\r\n            height = Math.floor(height);\r\n        }\r\n\r\n        var previousWidth = this.width;\r\n        var previousHeight = this.height;\r\n\r\n        //  The un-modified game size, as requested in the game config (the raw width / height) as used for world bounds, etc\r\n        this.gameSize.resize(width, height);\r\n\r\n        //  The modified game size, which is the w/h * resolution\r\n        this.baseSize.resize(width * resolution, height * resolution);\r\n\r\n        if (autoRound)\r\n        {\r\n            this.baseSize.width = Math.floor(this.baseSize.width);\r\n            this.baseSize.height = Math.floor(this.baseSize.height);\r\n        }\r\n\r\n        //  The size used for the canvas style, factoring in the scale mode and parent and zoom value\r\n        //  We just use the w/h here as this is what sets the aspect ratio (which doesn't then change)\r\n        this.displaySize.setSize((width * zoom) * resolution, (height * zoom) * resolution);\r\n\r\n        this.canvas.width = this.baseSize.width;\r\n        this.canvas.height = this.baseSize.height;\r\n\r\n        var style = this.canvas.style;\r\n\r\n        var styleWidth = width * zoom;\r\n        var styleHeight = height * zoom;\r\n\r\n        if (autoRound)\r\n        {\r\n            styleWidth = Math.floor(styleWidth);\r\n            styleHeight = Math.floor(styleHeight);\r\n        }\r\n\r\n        if (styleWidth !== width || styleHeight !== height)\r\n        {\r\n            style.width = styleWidth + 'px';\r\n            style.height = styleHeight + 'px';\r\n        }\r\n\r\n        return this.refresh(previousWidth, previousHeight);\r\n    },\r\n\r\n    /**\r\n     * Sets the zoom value of the Scale Manager.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#setZoom\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     * \r\n     * @param {integer} value - The new zoom value of the game.\r\n     * \r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    setZoom: function (value)\r\n    {\r\n        this.zoom = value;\r\n        this._resetZoom = true;\r\n\r\n        return this.refresh();\r\n    },\r\n\r\n    /**\r\n     * Sets the zoom to be the maximum possible based on the _current_ parent size.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#setMaxZoom\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     * \r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    setMaxZoom: function ()\r\n    {\r\n        this.zoom = this.getMaxZoom();\r\n        this._resetZoom = true;\r\n\r\n        return this.refresh();\r\n    },\r\n\r\n    /**\r\n     * Refreshes the internal scale values, bounds sizes and orientation checks.\r\n     * \r\n     * Once finished, dispatches the resize event.\r\n     * \r\n     * This is called automatically by the Scale Manager when the browser window size changes,\r\n     * as long as it is using a Scale Mode other than 'NONE'.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#refresh\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     * \r\n     * @param {number} [previousWidth] - The previous width of the game. Only set if the gameSize has changed.\r\n     * @param {number} [previousHeight] - The previous height of the game. Only set if the gameSize has changed.\r\n     * \r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    refresh: function (previousWidth, previousHeight)\r\n    {\r\n        if (previousWidth === undefined) { previousWidth = this.width; }\r\n        if (previousHeight === undefined) { previousHeight = this.height; }\r\n\r\n        this.updateScale();\r\n        this.updateBounds();\r\n        this.updateOrientation();\r\n\r\n        this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height);\r\n\r\n        var domContainer = this.game.domContainer;\r\n\r\n        if (domContainer)\r\n        {\r\n            this.baseSize.setCSS(domContainer);\r\n\r\n            var canvasStyle = this.canvas.style;\r\n            var domStyle = domContainer.style;\r\n\r\n            domStyle.transform = 'scale(' + this.displaySize.width / this.baseSize.width + ',' + this.displaySize.height / this.baseSize.height + ')';\r\n\r\n            domStyle.marginLeft = canvasStyle.marginLeft;\r\n            domStyle.marginTop = canvasStyle.marginTop;\r\n        }\r\n\r\n        this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, this.resolution, previousWidth, previousHeight);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method that checks the current screen orientation, only if the internal check flag is set.\r\n     * \r\n     * If the orientation has changed it updates the orientation property and then dispatches the orientation change event.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#updateOrientation\r\n     * @fires Phaser.Scale.Events#ORIENTATION_CHANGE\r\n     * @since 3.16.0\r\n     */\r\n    updateOrientation: function ()\r\n    {\r\n        if (this._checkOrientation)\r\n        {\r\n            this._checkOrientation = false;\r\n\r\n            var newOrientation = GetScreenOrientation(this.width, this.height);\r\n\r\n            if (newOrientation !== this.orientation)\r\n            {\r\n                this.orientation = newOrientation;\r\n    \r\n                this.emit(Events.ORIENTATION_CHANGE, newOrientation);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that manages updating the size components based on the scale mode.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#updateScale\r\n     * @since 3.16.0\r\n     */\r\n    updateScale: function ()\r\n    {\r\n        var style = this.canvas.style;\r\n\r\n        var width = this.gameSize.width;\r\n        var height = this.gameSize.height;\r\n\r\n        var styleWidth;\r\n        var styleHeight;\r\n\r\n        var zoom = this.zoom;\r\n        var autoRound = this.autoRound;\r\n        var resolution = 1;\r\n\r\n        if (this.scaleMode === CONST.SCALE_MODE.NONE)\r\n        {\r\n            //  No scale\r\n            this.displaySize.setSize((width * zoom) * resolution, (height * zoom) * resolution);\r\n\r\n            styleWidth = this.displaySize.width / resolution;\r\n            styleHeight = this.displaySize.height / resolution;\r\n\r\n            if (autoRound)\r\n            {\r\n                styleWidth = Math.floor(styleWidth);\r\n                styleHeight = Math.floor(styleHeight);\r\n            }\r\n\r\n            if (this._resetZoom)\r\n            {\r\n                style.width = styleWidth + 'px';\r\n                style.height = styleHeight + 'px';\r\n\r\n                this._resetZoom = false;\r\n            }\r\n        }\r\n        else if (this.scaleMode === CONST.SCALE_MODE.RESIZE)\r\n        {\r\n            //  Resize to match parent\r\n\r\n            //  This will constrain using min/max\r\n            this.displaySize.setSize(this.parentSize.width, this.parentSize.height);\r\n\r\n            this.gameSize.setSize(this.displaySize.width, this.displaySize.height);\r\n\r\n            this.baseSize.setSize(this.displaySize.width * resolution, this.displaySize.height * resolution);\r\n\r\n            styleWidth = this.displaySize.width / resolution;\r\n            styleHeight = this.displaySize.height / resolution;\r\n\r\n            if (autoRound)\r\n            {\r\n                styleWidth = Math.floor(styleWidth);\r\n                styleHeight = Math.floor(styleHeight);\r\n            }\r\n\r\n            this.canvas.width = styleWidth;\r\n            this.canvas.height = styleHeight;\r\n        }\r\n        else\r\n        {\r\n            //  All other scale modes\r\n            this.displaySize.setSize(this.parentSize.width, this.parentSize.height);\r\n\r\n            styleWidth = this.displaySize.width / resolution;\r\n            styleHeight = this.displaySize.height / resolution;\r\n\r\n            if (autoRound)\r\n            {\r\n                styleWidth = Math.floor(styleWidth);\r\n                styleHeight = Math.floor(styleHeight);\r\n            }\r\n\r\n            style.width = styleWidth + 'px';\r\n            style.height = styleHeight + 'px';\r\n        }\r\n\r\n        //  Update the parentSize in case the canvas / style change modified it\r\n        this.getParentBounds();\r\n\r\n        //  Finally, update the centering\r\n        this.updateCenter();\r\n    },\r\n\r\n    /**\r\n     * Calculates and returns the largest possible zoom factor, based on the current\r\n     * parent and game sizes. If the parent has no dimensions (i.e. an unstyled div),\r\n     * or is smaller than the un-zoomed game, then this will return a value of 1 (no zoom)\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#getMaxZoom\r\n     * @since 3.16.0\r\n     * \r\n     * @return {integer} The maximum possible zoom factor. At a minimum this value is always at least 1.\r\n     */\r\n    getMaxZoom: function ()\r\n    {\r\n        var zoomH = SnapFloor(this.parentSize.width, this.gameSize.width, 0, true);\r\n        var zoomV = SnapFloor(this.parentSize.height, this.gameSize.height, 0, true);\r\n    \r\n        return Math.max(Math.min(zoomH, zoomV), 1);\r\n    },\r\n\r\n    /**\r\n     * Calculates and updates the canvas CSS style in order to center it within the\r\n     * bounds of its parent. If you have explicitly set parent to be `null` in your\r\n     * game config then this method will likely give incorrect results unless you have called the\r\n     * `setParentSize` method first.\r\n     * \r\n     * It works by modifying the canvas CSS `marginLeft` and `marginTop` properties.\r\n     * \r\n     * If they have already been set by your own style sheet, or code, this will overwrite them.\r\n     * \r\n     * To prevent the Scale Manager from centering the canvas, either do not set the\r\n     * `autoCenter` property in your game config, or make sure it is set to `NO_CENTER`.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#updateCenter\r\n     * @since 3.16.0\r\n     */\r\n    updateCenter: function ()\r\n    {\r\n        var autoCenter = this.autoCenter;\r\n\r\n        if (autoCenter === CONST.CENTER.NO_CENTER)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var canvas = this.canvas;\r\n\r\n        var style = canvas.style;\r\n\r\n        var bounds = canvas.getBoundingClientRect();\r\n\r\n        // var width = parseInt(canvas.style.width, 10) || canvas.width;\r\n        // var height = parseInt(canvas.style.height, 10) || canvas.height;\r\n\r\n        var width = bounds.width;\r\n        var height = bounds.height;\r\n\r\n        var offsetX = Math.floor((this.parentSize.width - width) / 2);\r\n        var offsetY = Math.floor((this.parentSize.height - height) / 2);\r\n\r\n        if (autoCenter === CONST.CENTER.CENTER_HORIZONTALLY)\r\n        {\r\n            offsetY = 0;\r\n        }\r\n        else if (autoCenter === CONST.CENTER.CENTER_VERTICALLY)\r\n        {\r\n            offsetX = 0;\r\n        }\r\n\r\n        style.marginLeft = offsetX + 'px';\r\n        style.marginTop = offsetY + 'px';\r\n    },\r\n\r\n    /**\r\n     * Updates the `canvasBounds` rectangle to match the bounding client rectangle of the\r\n     * canvas element being used to track input events.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#updateBounds\r\n     * @since 3.16.0\r\n     */\r\n    updateBounds: function ()\r\n    {\r\n        var bounds = this.canvasBounds;\r\n        var clientRect = this.canvas.getBoundingClientRect();\r\n\r\n        bounds.x = clientRect.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0);\r\n        bounds.y = clientRect.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0);\r\n        bounds.width = clientRect.width;\r\n        bounds.height = clientRect.height;\r\n    },\r\n\r\n    /**\r\n     * Transforms the pageX value into the scaled coordinate space of the Scale Manager.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#transformX\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} pageX - The DOM pageX value.\r\n     *\r\n     * @return {number} The translated value.\r\n     */\r\n    transformX: function (pageX)\r\n    {\r\n        return (pageX - this.canvasBounds.left) * this.displayScale.x;\r\n    },\r\n\r\n    /**\r\n     * Transforms the pageY value into the scaled coordinate space of the Scale Manager.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#transformY\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} pageY - The DOM pageY value.\r\n     *\r\n     * @return {number} The translated value.\r\n     */\r\n    transformY: function (pageY)\r\n    {\r\n        return (pageY - this.canvasBounds.top) * this.displayScale.y;\r\n    },\r\n\r\n    /**\r\n     * Sends a request to the browser to ask it to go in to full screen mode, using the {@link https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API Fullscreen API}.\r\n     * \r\n     * If the browser does not support this, a `FULLSCREEN_UNSUPPORTED` event will be emitted.\r\n     * \r\n     * This method _must_ be called from a user-input gesture, such as `pointerup`. You cannot launch\r\n     * games fullscreen without this, as most browsers block it. Games within an iframe will also be blocked\r\n     * from fullscreen unless the iframe has the `allowfullscreen` attribute.\r\n     * \r\n     * On touch devices, such as Android and iOS Safari, you should always use `pointerup` and NOT `pointerdown`,\r\n     * otherwise the request will fail unless the document in which your game is embedded has already received\r\n     * some form of touch input, which you cannot guarantee. Activating fullscreen via `pointerup` circumvents\r\n     * this issue.\r\n     * \r\n     * Performing an action that navigates to another page, or opens another tab, will automatically cancel\r\n     * fullscreen mode, as will the user pressing the ESC key. To cancel fullscreen mode directly from your game,\r\n     * i.e. by clicking an icon, call the `stopFullscreen` method.\r\n     * \r\n     * A browser can only send one DOM element into fullscreen. You can control which element this is by\r\n     * setting the `fullscreenTarget` property in your game config, or changing the property in the Scale Manager.\r\n     * Note that the game canvas _must_ be a child of the target. If you do not give a target, Phaser will\r\n     * automatically create a blank `<div>` element and move the canvas into it, before going fullscreen.\r\n     * When it leaves fullscreen, the div will be removed.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#startFullscreen\r\n     * @fires Phaser.Scale.Events#ENTER_FULLSCREEN\r\n     * @fires Phaser.Scale.Events#FULLSCREEN_FAILED\r\n     * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     * \r\n     * @param {object} [fullscreenOptions] - The FullscreenOptions dictionary is used to provide configuration options when entering full screen.\r\n     */\r\n    startFullscreen: function (fullscreenOptions)\r\n    {\r\n        if (fullscreenOptions === undefined) { fullscreenOptions = { navigationUI: 'hide' }; }\r\n\r\n        var fullscreen = this.fullscreen;\r\n\r\n        if (!fullscreen.available)\r\n        {\r\n            this.emit(Events.FULLSCREEN_UNSUPPORTED);\r\n\r\n            return;\r\n        }\r\n\r\n        if (!fullscreen.active)\r\n        {\r\n            var fsTarget = this.getFullscreenTarget();\r\n\r\n            var fsPromise;\r\n            \r\n            if (fullscreen.keyboard)\r\n            {\r\n                fsPromise = fsTarget[fullscreen.request](Element.ALLOW_KEYBOARD_INPUT);\r\n            }\r\n            else\r\n            {\r\n                fsPromise = fsTarget[fullscreen.request](fullscreenOptions);\r\n            }\r\n\r\n            if (fsPromise)\r\n            {\r\n                fsPromise.then(this.fullscreenSuccessHandler.bind(this)).catch(this.fullscreenErrorHandler.bind(this));\r\n            }\r\n            else if (fullscreen.active)\r\n            {\r\n                this.fullscreenSuccessHandler();\r\n            }\r\n            else\r\n            {\r\n                this.fullscreenErrorHandler();\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The browser has successfully entered fullscreen mode.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#fullscreenSuccessHandler\r\n     * @private\r\n     * @fires Phaser.Scale.Events#ENTER_FULLSCREEN\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.17.0\r\n     */\r\n    fullscreenSuccessHandler: function ()\r\n    {\r\n        this.getParentBounds();\r\n\r\n        this.refresh();\r\n\r\n        this.emit(Events.ENTER_FULLSCREEN);\r\n    },\r\n\r\n    /**\r\n     * The browser failed to enter fullscreen mode.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#fullscreenErrorHandler\r\n     * @private\r\n     * @fires Phaser.Scale.Events#FULLSCREEN_FAILED\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.17.0\r\n     * \r\n     * @param {any} error - The DOM error event.\r\n     */\r\n    fullscreenErrorHandler: function (error)\r\n    {\r\n        this.removeFullscreenTarget();\r\n\r\n        this.emit(Events.FULLSCREEN_FAILED, error);\r\n    },\r\n\r\n    /**\r\n     * An internal method that gets the target element that is used when entering fullscreen mode.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#getFullscreenTarget\r\n     * @since 3.16.0\r\n     * \r\n     * @return {object} The fullscreen target element.\r\n     */\r\n    getFullscreenTarget: function ()\r\n    {\r\n        if (!this.fullscreenTarget)\r\n        {\r\n            var fsTarget = document.createElement('div');\r\n\r\n            fsTarget.style.margin = '0';\r\n            fsTarget.style.padding = '0';\r\n            fsTarget.style.width = '100%';\r\n            fsTarget.style.height = '100%';\r\n\r\n            this.fullscreenTarget = fsTarget;\r\n\r\n            this._createdFullscreenTarget = true;\r\n        }\r\n\r\n        if (this._createdFullscreenTarget)\r\n        {\r\n            var canvasParent = this.canvas.parentNode;\r\n\r\n            canvasParent.insertBefore(this.fullscreenTarget, this.canvas);\r\n\r\n            this.fullscreenTarget.appendChild(this.canvas);\r\n        }\r\n\r\n        return this.fullscreenTarget;\r\n    },\r\n\r\n    /**\r\n     * Removes the fullscreen target that was added to the DOM.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#removeFullscreenTarget\r\n     * @since 3.17.0\r\n     */\r\n    removeFullscreenTarget: function ()\r\n    {\r\n        if (this._createdFullscreenTarget)\r\n        {\r\n            var fsTarget = this.fullscreenTarget;\r\n\r\n            if (fsTarget && fsTarget.parentNode)\r\n            {\r\n                var parent = fsTarget.parentNode;\r\n\r\n                parent.insertBefore(this.canvas, fsTarget);\r\n\r\n                parent.removeChild(fsTarget);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Calling this method will cancel fullscreen mode, if the browser has entered it.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#stopFullscreen\r\n     * @fires Phaser.Scale.Events#LEAVE_FULLSCREEN\r\n     * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n     * @since 3.16.0\r\n     */\r\n    stopFullscreen: function ()\r\n    {\r\n        var fullscreen = this.fullscreen;\r\n\r\n        if (!fullscreen.available)\r\n        {\r\n            this.emit(Events.FULLSCREEN_UNSUPPORTED);\r\n\r\n            return false;\r\n        }\r\n\r\n        if (fullscreen.active)\r\n        {\r\n            document[fullscreen.cancel]();\r\n        }\r\n\r\n        this.removeFullscreenTarget();\r\n\r\n        //  Get the parent size again as it will have changed\r\n        this.getParentBounds();\r\n\r\n        this.emit(Events.LEAVE_FULLSCREEN);\r\n\r\n        this.refresh();\r\n    },\r\n\r\n    /**\r\n     * Toggles the fullscreen mode. If already in fullscreen, calling this will cancel it.\r\n     * If not in fullscreen, this will request the browser to enter fullscreen mode.\r\n     * \r\n     * If the browser does not support this, a `FULLSCREEN_UNSUPPORTED` event will be emitted.\r\n     * \r\n     * This method _must_ be called from a user-input gesture, such as `pointerdown`. You cannot launch\r\n     * games fullscreen without this, as most browsers block it. Games within an iframe will also be blocked\r\n     * from fullscreen unless the iframe has the `allowfullscreen` attribute.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#toggleFullscreen\r\n     * @fires Phaser.Scale.Events#ENTER_FULLSCREEN\r\n     * @fires Phaser.Scale.Events#LEAVE_FULLSCREEN\r\n     * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     * \r\n     * @param {object} [fullscreenOptions] - The FullscreenOptions dictionary is used to provide configuration options when entering full screen.\r\n     */\r\n    toggleFullscreen: function (fullscreenOptions)\r\n    {\r\n        if (this.fullscreen.active)\r\n        {\r\n            this.stopFullscreen();\r\n        }\r\n        else\r\n        {\r\n            this.startFullscreen(fullscreenOptions);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * An internal method that starts the different DOM event listeners running.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#startListeners\r\n     * @since 3.16.0\r\n     */\r\n    startListeners: function ()\r\n    {\r\n        var _this = this;\r\n        var listeners = this.listeners;\r\n\r\n        listeners.orientationChange = function ()\r\n        {\r\n            _this._checkOrientation = true;\r\n            _this.dirty = true;\r\n        };\r\n\r\n        listeners.windowResize = function ()\r\n        {\r\n            _this.dirty = true;\r\n        };\r\n\r\n        //  Only dispatched on mobile devices\r\n        window.addEventListener('orientationchange', listeners.orientationChange, false);\r\n\r\n        window.addEventListener('resize', listeners.windowResize, false);\r\n\r\n        if (this.fullscreen.available)\r\n        {\r\n            listeners.fullScreenChange = function (event)\r\n            {\r\n                return _this.onFullScreenChange(event);\r\n            };\r\n\r\n            listeners.fullScreenError = function (event)\r\n            {\r\n                return _this.onFullScreenError(event);\r\n            };\r\n\r\n            var vendors = [ 'webkit', 'moz', '' ];\r\n\r\n            vendors.forEach(function (prefix)\r\n            {\r\n                document.addEventListener(prefix + 'fullscreenchange', listeners.fullScreenChange, false);\r\n                document.addEventListener(prefix + 'fullscreenerror', listeners.fullScreenError, false);\r\n            });\r\n\r\n            //  MS Specific\r\n            document.addEventListener('MSFullscreenChange', listeners.fullScreenChange, false);\r\n            document.addEventListener('MSFullscreenError', listeners.fullScreenError, false);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Triggered when a fullscreenchange event is dispatched by the DOM.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#onFullScreenChange\r\n     * @since 3.16.0\r\n     */\r\n    onFullScreenChange: function ()\r\n    {\r\n        //  They pressed ESC while in fullscreen mode\r\n        if (!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement))\r\n        {\r\n            this.stopFullscreen();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Triggered when a fullscreenerror event is dispatched by the DOM.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#onFullScreenError\r\n     * @since 3.16.0\r\n     */\r\n    onFullScreenError: function ()\r\n    {\r\n        this.removeFullscreenTarget();\r\n    },\r\n\r\n    /**\r\n     * Internal method, called automatically by the game step.\r\n     * Monitors the elapsed time and resize interval to see if a parent bounds check needs to take place.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#step\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} time - The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().\r\n     * @param {number} delta - The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.\r\n     */\r\n    step: function (time, delta)\r\n    {\r\n        if (!this.parent)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this._lastCheck += delta;\r\n\r\n        if (this.dirty || this._lastCheck > this.resizeInterval)\r\n        {\r\n            //  Returns true if the parent bounds have changed size\r\n            if (this.getParentBounds())\r\n            {\r\n                this.refresh();\r\n            }\r\n\r\n            this.dirty = false;\r\n            this._lastCheck = 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Stops all DOM event listeners.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#stopListeners\r\n     * @since 3.16.0\r\n     */\r\n    stopListeners: function ()\r\n    {\r\n        var listeners = this.listeners;\r\n\r\n        window.removeEventListener('orientationchange', listeners.orientationChange, false);\r\n        window.removeEventListener('resize', listeners.windowResize, false);\r\n\r\n        var vendors = [ 'webkit', 'moz', '' ];\r\n\r\n        vendors.forEach(function (prefix)\r\n        {\r\n            document.removeEventListener(prefix + 'fullscreenchange', listeners.fullScreenChange, false);\r\n            document.removeEventListener(prefix + 'fullscreenerror', listeners.fullScreenError, false);\r\n        });\r\n\r\n        //  MS Specific\r\n        document.removeEventListener('MSFullscreenChange', listeners.fullScreenChange, false);\r\n        document.removeEventListener('MSFullscreenError', listeners.fullScreenError, false);\r\n    },\r\n\r\n    /**\r\n     * Destroys this Scale Manager, releasing all references to external resources.\r\n     * Once destroyed, the Scale Manager cannot be used again.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#destroy\r\n     * @since 3.16.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAllListeners();\r\n\r\n        this.stopListeners();\r\n\r\n        this.game = null;\r\n        this.canvas = null;\r\n        this.canvasBounds = null;\r\n        this.parent = null;\r\n        this.fullscreenTarget = null;\r\n\r\n        this.parentSize.destroy();\r\n        this.gameSize.destroy();\r\n        this.baseSize.destroy();\r\n        this.displaySize.destroy();\r\n    },\r\n\r\n    /**\r\n     * Is the browser currently in fullscreen mode or not?\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#isFullscreen\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isFullscreen: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.fullscreen.active;\r\n        }\r\n    \r\n    },\r\n\r\n    /**\r\n     * The game width.\r\n     * \r\n     * This is typically the size given in the game configuration.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#width\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    width: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.gameSize.width;\r\n        }\r\n    \r\n    },\r\n\r\n    /**\r\n     * The game height.\r\n     * \r\n     * This is typically the size given in the game configuration.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#height\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    height: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.gameSize.height;\r\n        }\r\n    \r\n    },\r\n\r\n    /**\r\n     * Is the device in a portrait orientation as reported by the Orientation API?\r\n     * This value is usually only available on mobile devices.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#isPortrait\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isPortrait: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.orientation === CONST.ORIENTATION.PORTRAIT);\r\n        }\r\n    \r\n    },\r\n\r\n    /**\r\n     * Is the device in a landscape orientation as reported by the Orientation API?\r\n     * This value is usually only available on mobile devices.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#isLandscape\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isLandscape: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.orientation === CONST.ORIENTATION.LANDSCAPE);\r\n        }\r\n    \r\n    },\r\n\r\n    /**\r\n     * Are the game dimensions portrait? (i.e. taller than they are wide)\r\n     * \r\n     * This is different to the device itself being in a portrait orientation.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#isGamePortrait\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isGamePortrait: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.height > this.width);\r\n        }\r\n    \r\n    },\r\n\r\n    /**\r\n     * Are the game dimensions landscape? (i.e. wider than they are tall)\r\n     * \r\n     * This is different to the device itself being in a landscape orientation.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#isGameLandscape\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isGameLandscape: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.width > this.height);\r\n        }\r\n    \r\n    }\r\n\r\n});\r\n\r\nmodule.exports = ScaleManager;\r\n"]},"metadata":{},"sourceType":"script"}