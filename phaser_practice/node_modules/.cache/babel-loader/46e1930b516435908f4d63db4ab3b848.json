{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\n\n/**\r\n * Takes a reference to the Canvas Renderer, a Canvas Rendering Context, a Game Object, a Camera and a parent matrix\r\n * and then performs the following steps:\r\n * \r\n * 1. Checks the alpha of the source combined with the Camera alpha. If 0 or less it aborts.\r\n * 2. Takes the Camera and Game Object matrix and multiplies them, combined with the parent matrix if given.\r\n * 3. Sets the blend mode of the context to be that used by the Game Object.\r\n * 4. Sets the alpha value of the context to be that used by the Game Object combined with the Camera.\r\n * 5. Saves the context state.\r\n * 6. Sets the final matrix values into the context via setTransform.\r\n * 7. If Renderer.antialias, or the frame.source.scaleMode is set, then imageSmoothingEnabled is set.\r\n * \r\n * This function is only meant to be used internally. Most of the Canvas Renderer classes use it.\r\n *\r\n * @function Phaser.Renderer.Canvas.SetTransform\r\n * @since 3.12.0\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {CanvasRenderingContext2D} ctx - The canvas context to set the transform on.\r\n * @param {Phaser.GameObjects.GameObject} src - The Game Object being rendered. Can be any type that extends the base class.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} [parentMatrix] - A parent transform matrix to apply to the Game Object before rendering.\r\n * \r\n * @return {boolean} `true` if the Game Object context was set, otherwise `false`.\r\n */\nvar SetTransform = function (renderer, ctx, src, camera, parentMatrix) {\n  var alpha = camera.alpha * src.alpha;\n\n  if (alpha <= 0) {\n    //  Nothing to see, so don't waste time calculating stuff\n    return false;\n  }\n\n  var camMatrix = renderer._tempMatrix1.copyFromArray(camera.matrix.matrix);\n\n  var gameObjectMatrix = renderer._tempMatrix2.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\n\n  var calcMatrix = renderer._tempMatrix3;\n\n  if (parentMatrix) {\n    //  Multiply the camera by the parent matrix\n    camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY); //  Undo the camera scroll\n\n    gameObjectMatrix.e = src.x;\n    gameObjectMatrix.f = src.y; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n    camMatrix.multiply(gameObjectMatrix, calcMatrix);\n  } else {\n    gameObjectMatrix.e -= camera.scrollX * src.scrollFactorX;\n    gameObjectMatrix.f -= camera.scrollY * src.scrollFactorY; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n    camMatrix.multiply(gameObjectMatrix, calcMatrix);\n  } //  Blend Mode\n\n\n  ctx.globalCompositeOperation = renderer.blendModes[src.blendMode]; //  Alpha\n\n  ctx.globalAlpha = alpha;\n  ctx.save();\n  calcMatrix.setToContext(ctx);\n  ctx.imageSmoothingEnabled = !(!renderer.antialias || src.frame && src.frame.source.scaleMode);\n  return true;\n};\n\nmodule.exports = SetTransform;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/renderer/canvas/utils/SetTransform.js"],"names":["SetTransform","renderer","ctx","src","camera","parentMatrix","alpha","camMatrix","_tempMatrix1","copyFromArray","matrix","gameObjectMatrix","_tempMatrix2","applyITRS","x","y","rotation","scaleX","scaleY","calcMatrix","_tempMatrix3","multiplyWithOffset","scrollX","scrollFactorX","scrollY","scrollFactorY","e","f","multiply","globalCompositeOperation","blendModes","blendMode","globalAlpha","save","setToContext","imageSmoothingEnabled","antialias","frame","source","scaleMode","module","exports"],"mappings":"AAAA;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,IAAIA,YAAY,GAAG,UAAUC,QAAV,EAAoBC,GAApB,EAAyBC,GAAzB,EAA8BC,MAA9B,EAAsCC,YAAtC,EACnB;AACI,MAAIC,KAAK,GAAGF,MAAM,CAACE,KAAP,GAAeH,GAAG,CAACG,KAA/B;;AAEA,MAAIA,KAAK,IAAI,CAAb,EACA;AACI;AACA,WAAO,KAAP;AACH;;AAED,MAAIC,SAAS,GAAGN,QAAQ,CAACO,YAAT,CAAsBC,aAAtB,CAAoCL,MAAM,CAACM,MAAP,CAAcA,MAAlD,CAAhB;;AACA,MAAIC,gBAAgB,GAAGV,QAAQ,CAACW,YAAT,CAAsBC,SAAtB,CAAgCV,GAAG,CAACW,CAApC,EAAuCX,GAAG,CAACY,CAA3C,EAA8CZ,GAAG,CAACa,QAAlD,EAA4Db,GAAG,CAACc,MAAhE,EAAwEd,GAAG,CAACe,MAA5E,CAAvB;;AACA,MAAIC,UAAU,GAAGlB,QAAQ,CAACmB,YAA1B;;AAEA,MAAIf,YAAJ,EACA;AACI;AACAE,IAAAA,SAAS,CAACc,kBAAV,CAA6BhB,YAA7B,EAA2C,CAACD,MAAM,CAACkB,OAAR,GAAkBnB,GAAG,CAACoB,aAAjE,EAAgF,CAACnB,MAAM,CAACoB,OAAR,GAAkBrB,GAAG,CAACsB,aAAtG,EAFJ,CAII;;AACAd,IAAAA,gBAAgB,CAACe,CAAjB,GAAqBvB,GAAG,CAACW,CAAzB;AACAH,IAAAA,gBAAgB,CAACgB,CAAjB,GAAqBxB,GAAG,CAACY,CAAzB,CANJ,CAQI;;AACAR,IAAAA,SAAS,CAACqB,QAAV,CAAmBjB,gBAAnB,EAAqCQ,UAArC;AACH,GAXD,MAaA;AACIR,IAAAA,gBAAgB,CAACe,CAAjB,IAAsBtB,MAAM,CAACkB,OAAP,GAAiBnB,GAAG,CAACoB,aAA3C;AACAZ,IAAAA,gBAAgB,CAACgB,CAAjB,IAAsBvB,MAAM,CAACoB,OAAP,GAAiBrB,GAAG,CAACsB,aAA3C,CAFJ,CAII;;AACAlB,IAAAA,SAAS,CAACqB,QAAV,CAAmBjB,gBAAnB,EAAqCQ,UAArC;AACH,GAhCL,CAkCI;;;AACAjB,EAAAA,GAAG,CAAC2B,wBAAJ,GAA+B5B,QAAQ,CAAC6B,UAAT,CAAoB3B,GAAG,CAAC4B,SAAxB,CAA/B,CAnCJ,CAqCI;;AACA7B,EAAAA,GAAG,CAAC8B,WAAJ,GAAkB1B,KAAlB;AAEAJ,EAAAA,GAAG,CAAC+B,IAAJ;AAEAd,EAAAA,UAAU,CAACe,YAAX,CAAwBhC,GAAxB;AAEAA,EAAAA,GAAG,CAACiC,qBAAJ,GAA4B,EAAE,CAAClC,QAAQ,CAACmC,SAAV,IAAwBjC,GAAG,CAACkC,KAAJ,IAAalC,GAAG,CAACkC,KAAJ,CAAUC,MAAV,CAAiBC,SAAxD,CAA5B;AAEA,SAAO,IAAP;AACH,CAhDD;;AAkDAC,MAAM,CAACC,OAAP,GAAiBzC,YAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Takes a reference to the Canvas Renderer, a Canvas Rendering Context, a Game Object, a Camera and a parent matrix\r\n * and then performs the following steps:\r\n * \r\n * 1. Checks the alpha of the source combined with the Camera alpha. If 0 or less it aborts.\r\n * 2. Takes the Camera and Game Object matrix and multiplies them, combined with the parent matrix if given.\r\n * 3. Sets the blend mode of the context to be that used by the Game Object.\r\n * 4. Sets the alpha value of the context to be that used by the Game Object combined with the Camera.\r\n * 5. Saves the context state.\r\n * 6. Sets the final matrix values into the context via setTransform.\r\n * 7. If Renderer.antialias, or the frame.source.scaleMode is set, then imageSmoothingEnabled is set.\r\n * \r\n * This function is only meant to be used internally. Most of the Canvas Renderer classes use it.\r\n *\r\n * @function Phaser.Renderer.Canvas.SetTransform\r\n * @since 3.12.0\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {CanvasRenderingContext2D} ctx - The canvas context to set the transform on.\r\n * @param {Phaser.GameObjects.GameObject} src - The Game Object being rendered. Can be any type that extends the base class.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} [parentMatrix] - A parent transform matrix to apply to the Game Object before rendering.\r\n * \r\n * @return {boolean} `true` if the Game Object context was set, otherwise `false`.\r\n */\r\nvar SetTransform = function (renderer, ctx, src, camera, parentMatrix)\r\n{\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (alpha <= 0)\r\n    {\r\n        //  Nothing to see, so don't waste time calculating stuff\r\n        return false;\r\n    }\r\n\r\n    var camMatrix = renderer._tempMatrix1.copyFromArray(camera.matrix.matrix);\r\n    var gameObjectMatrix = renderer._tempMatrix2.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\r\n    var calcMatrix = renderer._tempMatrix3;\r\n\r\n    if (parentMatrix)\r\n    {\r\n        //  Multiply the camera by the parent matrix\r\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n\r\n        //  Undo the camera scroll\r\n        gameObjectMatrix.e = src.x;\r\n        gameObjectMatrix.f = src.y;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(gameObjectMatrix, calcMatrix);\r\n    }\r\n    else\r\n    {\r\n        gameObjectMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n        gameObjectMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(gameObjectMatrix, calcMatrix);\r\n    }\r\n\r\n    //  Blend Mode\r\n    ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];\r\n\r\n    //  Alpha\r\n    ctx.globalAlpha = alpha;\r\n\r\n    ctx.save();\r\n\r\n    calcMatrix.setToContext(ctx);\r\n\r\n    ctx.imageSmoothingEnabled = !(!renderer.antialias || (src.frame && src.frame.source.scaleMode));\r\n\r\n    return true;\r\n};\r\n\r\nmodule.exports = SetTransform;\r\n"]},"metadata":{},"sourceType":"script"}