{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Utils = require('../../renderer/webgl/Utils');\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Mesh#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Mesh} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\n\n\nvar MeshWebGLRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix) {\n  var pipeline = this.pipeline;\n  renderer.setPipeline(pipeline, src);\n  var camMatrix = pipeline._tempMatrix1;\n  var spriteMatrix = pipeline._tempMatrix2;\n  var calcMatrix = pipeline._tempMatrix3;\n  spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\n  camMatrix.copyFrom(camera.matrix);\n\n  if (parentMatrix) {\n    //  Multiply the camera by the parent matrix\n    camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY); //  Undo the camera scroll\n\n    spriteMatrix.e = src.x;\n    spriteMatrix.f = src.y; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n    camMatrix.multiply(spriteMatrix, calcMatrix);\n  } else {\n    spriteMatrix.e -= camera.scrollX * src.scrollFactorX;\n    spriteMatrix.f -= camera.scrollY * src.scrollFactorY; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n    camMatrix.multiply(spriteMatrix, calcMatrix);\n  }\n\n  var frame = src.frame;\n  var texture = frame.glTexture;\n  var vertices = src.vertices;\n  var uvs = src.uv;\n  var colors = src.colors;\n  var alphas = src.alphas;\n  var meshVerticesLength = vertices.length;\n  var vertexCount = Math.floor(meshVerticesLength * 0.5);\n\n  if (pipeline.vertexCount + vertexCount > pipeline.vertexCapacity) {\n    pipeline.flush();\n  }\n\n  pipeline.setTexture2D(texture, 0);\n  var vertexViewF32 = pipeline.vertexViewF32;\n  var vertexViewU32 = pipeline.vertexViewU32;\n  var vertexOffset = pipeline.vertexCount * pipeline.vertexComponentCount - 1;\n  var colorIndex = 0;\n  var tintEffect = src.tintFill;\n\n  for (var i = 0; i < meshVerticesLength; i += 2) {\n    var x = vertices[i + 0];\n    var y = vertices[i + 1];\n    var tx = x * calcMatrix.a + y * calcMatrix.c + calcMatrix.e;\n    var ty = x * calcMatrix.b + y * calcMatrix.d + calcMatrix.f;\n\n    if (camera.roundPixels) {\n      tx = Math.round(tx);\n      ty = Math.round(ty);\n    }\n\n    vertexViewF32[++vertexOffset] = tx;\n    vertexViewF32[++vertexOffset] = ty;\n    vertexViewF32[++vertexOffset] = uvs[i + 0];\n    vertexViewF32[++vertexOffset] = uvs[i + 1];\n    vertexViewF32[++vertexOffset] = tintEffect;\n    vertexViewU32[++vertexOffset] = Utils.getTintAppendFloatAlpha(colors[colorIndex], camera.alpha * alphas[colorIndex]);\n    colorIndex++;\n  }\n\n  pipeline.vertexCount += vertexCount;\n};\n\nmodule.exports = MeshWebGLRenderer;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/mesh/MeshWebGLRenderer.js"],"names":["Utils","require","MeshWebGLRenderer","renderer","src","interpolationPercentage","camera","parentMatrix","pipeline","setPipeline","camMatrix","_tempMatrix1","spriteMatrix","_tempMatrix2","calcMatrix","_tempMatrix3","applyITRS","x","y","rotation","scaleX","scaleY","copyFrom","matrix","multiplyWithOffset","scrollX","scrollFactorX","scrollY","scrollFactorY","e","f","multiply","frame","texture","glTexture","vertices","uvs","uv","colors","alphas","meshVerticesLength","length","vertexCount","Math","floor","vertexCapacity","flush","setTexture2D","vertexViewF32","vertexViewU32","vertexOffset","vertexComponentCount","colorIndex","tintEffect","tintFill","i","tx","a","c","ty","b","d","roundPixels","round","getTintAppendFloatAlpha","alpha","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Mesh#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Mesh} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar MeshWebGLRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix)\r\n{\r\n    var pipeline = this.pipeline;\r\n\r\n    renderer.setPipeline(pipeline, src);\r\n\r\n    var camMatrix = pipeline._tempMatrix1;\r\n    var spriteMatrix = pipeline._tempMatrix2;\r\n    var calcMatrix = pipeline._tempMatrix3;\r\n\r\n    spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\r\n\r\n    camMatrix.copyFrom(camera.matrix);\r\n\r\n    if (parentMatrix)\r\n    {\r\n        //  Multiply the camera by the parent matrix\r\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n\r\n        //  Undo the camera scroll\r\n        spriteMatrix.e = src.x;\r\n        spriteMatrix.f = src.y;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(spriteMatrix, calcMatrix);\r\n    }\r\n    else\r\n    {\r\n        spriteMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n        spriteMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(spriteMatrix, calcMatrix);\r\n    }\r\n\r\n    var frame = src.frame;\r\n    var texture = frame.glTexture;\r\n\r\n    var vertices = src.vertices;\r\n    var uvs = src.uv;\r\n    var colors = src.colors;\r\n    var alphas = src.alphas;\r\n\r\n    var meshVerticesLength = vertices.length;\r\n    var vertexCount = Math.floor(meshVerticesLength * 0.5);\r\n\r\n    if (pipeline.vertexCount + vertexCount > pipeline.vertexCapacity)\r\n    {\r\n        pipeline.flush();\r\n    }\r\n\r\n    pipeline.setTexture2D(texture, 0);\r\n\r\n    var vertexViewF32 = pipeline.vertexViewF32;\r\n    var vertexViewU32 = pipeline.vertexViewU32;\r\n\r\n    var vertexOffset = (pipeline.vertexCount * pipeline.vertexComponentCount) - 1;\r\n\r\n    var colorIndex = 0;\r\n    var tintEffect = src.tintFill;\r\n\r\n    for (var i = 0; i < meshVerticesLength; i += 2)\r\n    {\r\n        var x = vertices[i + 0];\r\n        var y = vertices[i + 1];\r\n\r\n        var tx = x * calcMatrix.a + y * calcMatrix.c + calcMatrix.e;\r\n        var ty = x * calcMatrix.b + y * calcMatrix.d + calcMatrix.f;\r\n\r\n        if (camera.roundPixels)\r\n        {\r\n            tx = Math.round(tx);\r\n            ty = Math.round(ty);\r\n        }\r\n\r\n        vertexViewF32[++vertexOffset] = tx;\r\n        vertexViewF32[++vertexOffset] = ty;\r\n        vertexViewF32[++vertexOffset] = uvs[i + 0];\r\n        vertexViewF32[++vertexOffset] = uvs[i + 1];\r\n        vertexViewF32[++vertexOffset] = tintEffect;\r\n        vertexViewU32[++vertexOffset] = Utils.getTintAppendFloatAlpha(colors[colorIndex], camera.alpha * alphas[colorIndex]);\r\n\r\n        colorIndex++;\r\n    }\r\n\r\n    pipeline.vertexCount += vertexCount;\r\n};\r\n\r\nmodule.exports = MeshWebGLRenderer;\r\n"]},"metadata":{},"sourceType":"script"}