{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Perimeter = require('./Perimeter');\n\nvar Point = require('../point/Point');\n/**\r\n *  Return an array of points from the perimeter of the rectangle\r\n *  each spaced out based on the quantity or step required\r\n *\r\n * @function Phaser.Geom.Rectangle.MarchingAnts\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point[]} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {number} step - [description]\r\n * @param {integer} quantity - [description]\r\n * @param {(array|Phaser.Geom.Point[])} [out] - [description]\r\n *\r\n * @return {(array|Phaser.Geom.Point[])} [description]\r\n */\n\n\nvar MarchingAnts = function (rect, step, quantity, out) {\n  if (out === undefined) {\n    out = [];\n  }\n\n  if (!step && !quantity) {\n    //  Bail out\n    return out;\n  } //  If step is a falsey value (false, null, 0, undefined, etc) then we calculate\n  //  it based on the quantity instead, otherwise we always use the step value\n\n\n  if (!step) {\n    step = Perimeter(rect) / quantity;\n  } else {\n    quantity = Math.round(Perimeter(rect) / step);\n  }\n\n  var x = rect.x;\n  var y = rect.y;\n  var face = 0; //  Loop across each face of the rectangle\n\n  for (var i = 0; i < quantity; i++) {\n    out.push(new Point(x, y));\n\n    switch (face) {\n      //  Top face\n      case 0:\n        x += step;\n\n        if (x >= rect.right) {\n          face = 1;\n          y += x - rect.right;\n          x = rect.right;\n        }\n\n        break;\n      //  Right face\n\n      case 1:\n        y += step;\n\n        if (y >= rect.bottom) {\n          face = 2;\n          x -= y - rect.bottom;\n          y = rect.bottom;\n        }\n\n        break;\n      //  Bottom face\n\n      case 2:\n        x -= step;\n\n        if (x <= rect.left) {\n          face = 3;\n          y -= rect.left - x;\n          x = rect.left;\n        }\n\n        break;\n      //  Left face\n\n      case 3:\n        y -= step;\n\n        if (y <= rect.top) {\n          face = 0;\n          y = rect.top;\n        }\n\n        break;\n    }\n  }\n\n  return out;\n};\n\nmodule.exports = MarchingAnts;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/geom/rectangle/MarchingAnts.js"],"names":["Perimeter","require","Point","MarchingAnts","rect","step","quantity","out","undefined","Math","round","x","y","face","i","push","right","bottom","left","top","module","exports"],"mappings":"AAAA;;;;;AAMA,IAAIA,SAAS,GAAGC,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,gBAAD,CAAnB;AAGA;;;;;;;;;;;;;;;;;;AAgBA,IAAIE,YAAY,GAAG,UAAUC,IAAV,EAAgBC,IAAhB,EAAsBC,QAAtB,EAAgCC,GAAhC,EACnB;AACI,MAAIA,GAAG,KAAKC,SAAZ,EAAuB;AAAED,IAAAA,GAAG,GAAG,EAAN;AAAW;;AAEpC,MAAI,CAACF,IAAD,IAAS,CAACC,QAAd,EACA;AACI;AACA,WAAOC,GAAP;AACH,GAPL,CASI;AACA;;;AACA,MAAI,CAACF,IAAL,EACA;AACIA,IAAAA,IAAI,GAAGL,SAAS,CAACI,IAAD,CAAT,GAAkBE,QAAzB;AACH,GAHD,MAKA;AACIA,IAAAA,QAAQ,GAAGG,IAAI,CAACC,KAAL,CAAWV,SAAS,CAACI,IAAD,CAAT,GAAkBC,IAA7B,CAAX;AACH;;AAED,MAAIM,CAAC,GAAGP,IAAI,CAACO,CAAb;AACA,MAAIC,CAAC,GAAGR,IAAI,CAACQ,CAAb;AACA,MAAIC,IAAI,GAAG,CAAX,CAtBJ,CAwBI;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,QAApB,EAA8BQ,CAAC,EAA/B,EACA;AACIP,IAAAA,GAAG,CAACQ,IAAJ,CAAS,IAAIb,KAAJ,CAAUS,CAAV,EAAaC,CAAb,CAAT;;AAEA,YAAQC,IAAR;AAGI;AACA,WAAK,CAAL;AACIF,QAAAA,CAAC,IAAIN,IAAL;;AAEA,YAAIM,CAAC,IAAIP,IAAI,CAACY,KAAd,EACA;AACIH,UAAAA,IAAI,GAAG,CAAP;AACAD,UAAAA,CAAC,IAAKD,CAAC,GAAGP,IAAI,CAACY,KAAf;AACAL,UAAAA,CAAC,GAAGP,IAAI,CAACY,KAAT;AACH;;AACD;AAEJ;;AACA,WAAK,CAAL;AACIJ,QAAAA,CAAC,IAAIP,IAAL;;AAEA,YAAIO,CAAC,IAAIR,IAAI,CAACa,MAAd,EACA;AACIJ,UAAAA,IAAI,GAAG,CAAP;AACAF,UAAAA,CAAC,IAAKC,CAAC,GAAGR,IAAI,CAACa,MAAf;AACAL,UAAAA,CAAC,GAAGR,IAAI,CAACa,MAAT;AACH;;AACD;AAEJ;;AACA,WAAK,CAAL;AACIN,QAAAA,CAAC,IAAIN,IAAL;;AAEA,YAAIM,CAAC,IAAIP,IAAI,CAACc,IAAd,EACA;AACIL,UAAAA,IAAI,GAAG,CAAP;AACAD,UAAAA,CAAC,IAAKR,IAAI,CAACc,IAAL,GAAYP,CAAlB;AACAA,UAAAA,CAAC,GAAGP,IAAI,CAACc,IAAT;AACH;;AACD;AAEJ;;AACA,WAAK,CAAL;AACIN,QAAAA,CAAC,IAAIP,IAAL;;AAEA,YAAIO,CAAC,IAAIR,IAAI,CAACe,GAAd,EACA;AACIN,UAAAA,IAAI,GAAG,CAAP;AACAD,UAAAA,CAAC,GAAGR,IAAI,CAACe,GAAT;AACH;;AACD;AAhDR;AAkDH;;AAED,SAAOZ,GAAP;AACH,CApFD;;AAsFAa,MAAM,CAACC,OAAP,GAAiBlB,YAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Perimeter = require('./Perimeter');\r\nvar Point = require('../point/Point');\r\n\r\n\r\n/**\r\n *  Return an array of points from the perimeter of the rectangle\r\n *  each spaced out based on the quantity or step required\r\n *\r\n * @function Phaser.Geom.Rectangle.MarchingAnts\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point[]} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - [description]\r\n * @param {number} step - [description]\r\n * @param {integer} quantity - [description]\r\n * @param {(array|Phaser.Geom.Point[])} [out] - [description]\r\n *\r\n * @return {(array|Phaser.Geom.Point[])} [description]\r\n */\r\nvar MarchingAnts = function (rect, step, quantity, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    if (!step && !quantity)\r\n    {\r\n        //  Bail out\r\n        return out;\r\n    }\r\n\r\n    //  If step is a falsey value (false, null, 0, undefined, etc) then we calculate\r\n    //  it based on the quantity instead, otherwise we always use the step value\r\n    if (!step)\r\n    {\r\n        step = Perimeter(rect) / quantity;\r\n    }\r\n    else\r\n    {\r\n        quantity = Math.round(Perimeter(rect) / step);\r\n    }\r\n\r\n    var x = rect.x;\r\n    var y = rect.y;\r\n    var face = 0;\r\n\r\n    //  Loop across each face of the rectangle\r\n\r\n    for (var i = 0; i < quantity; i++)\r\n    {\r\n        out.push(new Point(x, y));\r\n\r\n        switch (face)\r\n        {\r\n\r\n            //  Top face\r\n            case 0:\r\n                x += step;\r\n\r\n                if (x >= rect.right)\r\n                {\r\n                    face = 1;\r\n                    y += (x - rect.right);\r\n                    x = rect.right;\r\n                }\r\n                break;\r\n\r\n            //  Right face\r\n            case 1:\r\n                y += step;\r\n\r\n                if (y >= rect.bottom)\r\n                {\r\n                    face = 2;\r\n                    x -= (y - rect.bottom);\r\n                    y = rect.bottom;\r\n                }\r\n                break;\r\n\r\n            //  Bottom face\r\n            case 2:\r\n                x -= step;\r\n\r\n                if (x <= rect.left)\r\n                {\r\n                    face = 3;\r\n                    y -= (rect.left - x);\r\n                    x = rect.left;\r\n                }\r\n                break;\r\n\r\n            //  Left face\r\n            case 3:\r\n                y -= step;\r\n\r\n                if (y <= rect.top)\r\n                {\r\n                    face = 0;\r\n                    y = rect.top;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = MarchingAnts;\r\n"]},"metadata":{},"sourceType":"script"}