{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar AddToDOM = require('../../../dom/AddToDOM');\n\nvar CanvasPool = require('../../../display/canvas/CanvasPool');\n\nvar Class = require('../../../utils/Class');\n\nvar Components = require('../../components');\n\nvar GameEvents = require('../../../core/events');\n\nvar GameObject = require('../../GameObject');\n\nvar GetTextSize = require('../GetTextSize');\n\nvar GetValue = require('../../../utils/object/GetValue');\n\nvar RemoveFromDOM = require('../../../dom/RemoveFromDOM');\n\nvar TextRender = require('./TextRender');\n\nvar TextStyle = require('../TextStyle');\n/**\r\n * @classdesc\r\n * A Text Game Object.\r\n * \r\n * Text objects work by creating their own internal hidden Canvas and then renders text to it using\r\n * the standard Canvas `fillText` API. It then creates a texture from this canvas which is rendered\r\n * to your game during the render pass.\r\n * \r\n * Because it uses the Canvas API you can take advantage of all the features this offers, such as\r\n * applying gradient fills to the text, or strokes, shadows and more. You can also use custom fonts\r\n * loaded externally, such as Google or TypeKit Web fonts.\r\n * \r\n * **Important:** If the font you wish to use has a space or digit in its name, such as\r\n * 'Press Start 2P' or 'Roboto Condensed', then you _must_ put the font name in quotes, either\r\n * when creating the Text object, or when setting the font via `setFont` or `setFontFamily`. I.e.:\r\n * \r\n * ```javascript\r\n * this.add.text(0, 0, 'Hello World', { fontFamily: '\"Roboto Condensed\"' });\r\n * ```\r\n * \r\n * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all\r\n * quoted properly, too:\r\n * \r\n * ```javascript\r\n * this.add.text(0, 0, 'Hello World', { fontFamily: 'Verdana, \"Times New Roman\", Tahoma, serif' });\r\n * ```\r\n *\r\n * You can only display fonts that are currently loaded and available to the browser: therefore fonts must\r\n * be pre-loaded. Phaser does not do ths for you, so you will require the use of a 3rd party font loader,\r\n * or have the fonts ready available in the CSS on the page in which your Phaser game resides.\r\n *\r\n * See {@link http://www.jordanm.co.uk/tinytype this compatibility table} for the available default fonts\r\n * across mobile browsers.\r\n * \r\n * A note on performance: Every time the contents of a Text object changes, i.e. changing the text being\r\n * displayed, or the style of the text, it needs to remake the Text canvas, and if on WebGL, re-upload the\r\n * new texture to the GPU. This can be an expensive operation if used often, or with large quantities of\r\n * Text objects in your game. If you run into performance issues you would be better off using Bitmap Text\r\n * instead, as it benefits from batching and avoids expensive Canvas API calls.\r\n *\r\n * @class Text\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Crop\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|string[])} text - The text this Text object will display.\r\n * @param {Phaser.Types.GameObjects.Text.TextStyle} style - The text style configuration object.\r\n */\n\n\nvar Text = new Class({\n  Extends: GameObject,\n  Mixins: [Components.Alpha, Components.BlendMode, Components.ComputedSize, Components.Crop, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Tint, Components.Transform, Components.Visible, TextRender],\n  initialize: function Text(scene, x, y, text, style) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    GameObject.call(this, scene, 'Text');\n    /**\r\n     * The renderer in use by this Text object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#renderer\r\n     * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n     * @since 3.12.0\r\n     */\n\n    this.renderer = scene.sys.game.renderer;\n    this.setPosition(x, y);\n    this.setOrigin(0, 0);\n    this.initPipeline();\n    /**\r\n     * The canvas element that the text is rendered to.\r\n     *\r\n     * @name Phaser.GameObjects.Text#canvas\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.0.0\r\n     */\n\n    this.canvas = CanvasPool.create(this);\n    /**\r\n     * The context of the canvas element that the text is rendered to.\r\n     *\r\n     * @name Phaser.GameObjects.Text#context\r\n     * @type {CanvasRenderingContext2D}\r\n     * @since 3.0.0\r\n     */\n\n    this.context = this.canvas.getContext('2d');\n    /**\r\n     * The Text Style object.\r\n     *\r\n     * Manages the style of this Text object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#style\r\n     * @type {Phaser.GameObjects.TextStyle}\r\n     * @since 3.0.0\r\n     */\n\n    this.style = new TextStyle(this, style);\n    /**\r\n     * Whether to automatically round line positions.\r\n     *\r\n     * @name Phaser.GameObjects.Text#autoRound\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.autoRound = true;\n    /**\r\n     * The Regular Expression that is used to split the text up into lines, in\r\n     * multi-line text. By default this is `/(?:\\r\\n|\\r|\\n)/`.\r\n     * You can change this RegExp to be anything else that you may need.\r\n     *\r\n     * @name Phaser.GameObjects.Text#splitRegExp\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.splitRegExp = /(?:\\r\\n|\\r|\\n)/;\n    /**\r\n     * The text to display.\r\n     *\r\n     * @name Phaser.GameObjects.Text#_text\r\n     * @type {string}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._text = undefined;\n    /**\r\n     * Specify a padding value which is added to the line width and height when calculating the Text size.\r\n     * Allows you to add extra spacing if the browser is unable to accurately determine the true font dimensions.\r\n     *\r\n     * @name Phaser.GameObjects.Text#padding\r\n     * @type {{left:number,right:number,top:number,bottom:number}}\r\n     * @since 3.0.0\r\n     */\n\n    this.padding = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    /**\r\n     * The width of this Text object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#width\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\n\n    this.width = 1;\n    /**\r\n     * The height of this Text object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#height\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\n\n    this.height = 1;\n    /**\r\n     * The line spacing value.\r\n     * This value is added to the font height to calculate the overall line height.\r\n     * Only has an effect if this Text object contains multiple lines of text.\r\n     * \r\n     * If you update this property directly, instead of using the `setLineSpacing` method, then\r\n     * be sure to call `updateText` after, or you won't see the change reflected in the Text object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#lineSpacing\r\n     * @type {number}\r\n     * @since 3.13.0\r\n     */\n\n    this.lineSpacing = 0;\n    /**\r\n     * Whether the text or its settings have changed and need updating.\r\n     *\r\n     * @name Phaser.GameObjects.Text#dirty\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.dirty = false; //  If resolution wasn't set, then we get it from the game config\n\n    if (this.style.resolution === 0) {\n      this.style.resolution = scene.sys.game.config.resolution;\n    }\n    /**\r\n     * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n     *\r\n     * @name Phaser.GameObjects.Text#_crop\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n\n    this._crop = this.resetCropObject(); //  Create a Texture for this Text object\n\n    this.texture = scene.sys.textures.addCanvas(null, this.canvas, true); //  Get the frame\n\n    this.frame = this.texture.get(); //  Set the resolution\n\n    this.frame.source.resolution = this.style.resolution;\n\n    if (this.renderer && this.renderer.gl) {\n      //  Clear the default 1x1 glTexture, as we override it later\n      this.renderer.deleteTexture(this.frame.source.glTexture);\n      this.frame.source.glTexture = null;\n    }\n\n    this.initRTL();\n    this.setText(text);\n\n    if (style && style.padding) {\n      this.setPadding(style.padding);\n    }\n\n    if (style && style.lineSpacing) {\n      this.setLineSpacing(style.lineSpacing);\n    }\n\n    scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function () {\n      this.dirty = true;\n    }, this);\n  },\n\n  /**\r\n   * Initialize right to left text.\r\n   *\r\n   * @method Phaser.GameObjects.Text#initRTL\r\n   * @since 3.0.0\r\n   */\n  initRTL: function () {\n    if (!this.style.rtl) {\n      return;\n    } //  Here is where the crazy starts.\n    //\n    //  Due to browser implementation issues, you cannot fillText BiDi text to a canvas\n    //  that is not part of the DOM. It just completely ignores the direction property.\n\n\n    this.canvas.dir = 'rtl'; //  Experimental atm, but one day ...\n\n    this.context.direction = 'rtl'; //  Add it to the DOM, but hidden within the parent canvas.\n\n    this.canvas.style.display = 'none';\n    AddToDOM(this.canvas, this.scene.sys.canvas); //  And finally we set the x origin\n\n    this.originX = 1;\n  },\n\n  /**\r\n   * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n   * bounds.\r\n   *\r\n   * @method Phaser.GameObjects.Text#runWordWrap\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} text - The text to perform word wrap detection against.\r\n   *\r\n   * @return {string} The text after wrapping has been applied.\r\n   */\n  runWordWrap: function (text) {\n    var style = this.style;\n\n    if (style.wordWrapCallback) {\n      var wrappedLines = style.wordWrapCallback.call(style.wordWrapCallbackScope, text, this);\n\n      if (Array.isArray(wrappedLines)) {\n        wrappedLines = wrappedLines.join('\\n');\n      }\n\n      return wrappedLines;\n    } else if (style.wordWrapWidth) {\n      if (style.wordWrapUseAdvanced) {\n        return this.advancedWordWrap(text, this.context, this.style.wordWrapWidth);\n      } else {\n        return this.basicWordWrap(text, this.context, this.style.wordWrapWidth);\n      }\n    } else {\n      return text;\n    }\n  },\n\n  /**\r\n   * Advanced wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n   * bounds. Consecutive spaces will be collapsed and replaced with a single space. Lines will be\r\n   * trimmed of white space before processing. Throws an error if wordWrapWidth is less than a\r\n   * single character.\r\n   *\r\n   * @method Phaser.GameObjects.Text#advancedWordWrap\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} text - The text to perform word wrap detection against.\r\n   * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.\r\n   * @param {number} wordWrapWidth - The word wrap width.\r\n   *\r\n   * @return {string} The wrapped text.\r\n   */\n  advancedWordWrap: function (text, context, wordWrapWidth) {\n    var output = ''; // Condense consecutive spaces and split into lines\n\n    var lines = text.replace(/ +/gi, ' ').split(this.splitRegExp);\n    var linesCount = lines.length;\n\n    for (var i = 0; i < linesCount; i++) {\n      var line = lines[i];\n      var out = ''; // Trim whitespace\n\n      line = line.replace(/^ *|\\s*$/gi, ''); // If entire line is less than wordWrapWidth append the entire line and exit early\n\n      var lineWidth = context.measureText(line).width;\n\n      if (lineWidth < wordWrapWidth) {\n        output += line + '\\n';\n        continue;\n      } // Otherwise, calculate new lines\n\n\n      var currentLineWidth = wordWrapWidth; // Split into words\n\n      var words = line.split(' ');\n\n      for (var j = 0; j < words.length; j++) {\n        var word = words[j];\n        var wordWithSpace = word + ' ';\n        var wordWidth = context.measureText(wordWithSpace).width;\n\n        if (wordWidth > currentLineWidth) {\n          // Break word\n          if (j === 0) {\n            // Shave off letters from word until it's small enough\n            var newWord = wordWithSpace;\n\n            while (newWord.length) {\n              newWord = newWord.slice(0, -1);\n              wordWidth = context.measureText(newWord).width;\n\n              if (wordWidth <= currentLineWidth) {\n                break;\n              }\n            } // If wordWrapWidth is too small for even a single letter, shame user\n            // failure with a fatal error\n\n\n            if (!newWord.length) {\n              throw new Error('This text\\'s wordWrapWidth setting is less than a single character!');\n            } // Replace current word in array with remainder\n\n\n            var secondPart = word.substr(newWord.length);\n            words[j] = secondPart; // Append first piece to output\n\n            out += newWord;\n          } // If existing word length is 0, don't include it\n\n\n          var offset = words[j].length ? j : j + 1; // Collapse rest of sentence and remove any trailing white space\n\n          var remainder = words.slice(offset).join(' ').replace(/[ \\n]*$/gi, ''); // Prepend remainder to next line\n\n          lines[i + 1] = remainder + ' ' + (lines[i + 1] || '');\n          linesCount = lines.length;\n          break; // Processing on this line\n          // Append word with space to output\n        } else {\n          out += wordWithSpace;\n          currentLineWidth -= wordWidth;\n        }\n      } // Append processed line to output\n\n\n      output += out.replace(/[ \\n]*$/gi, '') + '\\n';\n    } // Trim the end of the string\n\n\n    output = output.replace(/[\\s|\\n]*$/gi, '');\n    return output;\n  },\n\n  /**\r\n   * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n   * bounds. Spaces are not collapsed and whitespace is not trimmed.\r\n   *\r\n   * @method Phaser.GameObjects.Text#basicWordWrap\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} text - The text to perform word wrap detection against.\r\n   * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.\r\n   * @param {number} wordWrapWidth - The word wrap width.\r\n   *\r\n   * @return {string} The wrapped text.\r\n   */\n  basicWordWrap: function (text, context, wordWrapWidth) {\n    var result = '';\n    var lines = text.split(this.splitRegExp);\n    var lastLineIndex = lines.length - 1;\n    var whiteSpaceWidth = context.measureText(' ').width;\n\n    for (var i = 0; i <= lastLineIndex; i++) {\n      var spaceLeft = wordWrapWidth;\n      var words = lines[i].split(' ');\n      var lastWordIndex = words.length - 1;\n\n      for (var j = 0; j <= lastWordIndex; j++) {\n        var word = words[j];\n        var wordWidth = context.measureText(word).width;\n        var wordWidthWithSpace = wordWidth + whiteSpaceWidth;\n\n        if (wordWidthWithSpace > spaceLeft) {\n          // Skip printing the newline if it's the first word of the line that is greater\n          // than the word wrap width.\n          if (j > 0) {\n            result += '\\n';\n            spaceLeft = wordWrapWidth;\n          }\n        }\n\n        result += word;\n\n        if (j < lastWordIndex) {\n          result += ' ';\n          spaceLeft -= wordWidthWithSpace;\n        } else {\n          spaceLeft -= wordWidth;\n        }\n      }\n\n      if (i < lastLineIndex) {\n        result += '\\n';\n      }\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Runs the given text through this Text objects word wrapping and returns the results as an\r\n   * array, where each element of the array corresponds to a wrapped line of text.\r\n   *\r\n   * @method Phaser.GameObjects.Text#getWrappedText\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} text - The text for which the wrapping will be calculated. If unspecified, the Text objects current text will be used.\r\n   *\r\n   * @return {string[]} An array of strings with the pieces of wrapped text.\r\n   */\n  getWrappedText: function (text) {\n    if (text === undefined) {\n      text = this._text;\n    }\n\n    this.style.syncFont(this.canvas, this.context);\n    var wrappedLines = this.runWordWrap(text);\n    return wrappedLines.split(this.splitRegExp);\n  },\n\n  /**\r\n   * Set the text to display.\r\n   *\r\n   * An array of strings will be joined with `\\n` line breaks.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setText\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|string[])} value - The string, or array of strings, to be set as the content of this Text object.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setText: function (value) {\n    if (!value && value !== 0) {\n      value = '';\n    }\n\n    if (Array.isArray(value)) {\n      value = value.join('\\n');\n    }\n\n    if (value !== this._text) {\n      this._text = value.toString();\n      this.updateText();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Set the text style.\r\n   *\r\n   * @example\r\n   * text.setStyle({\r\n   *     fontSize: '64px',\r\n   *     fontFamily: 'Arial',\r\n   *     color: '#ffffff',\r\n   *     align: 'center',\r\n   *     backgroundColor: '#ff00ff'\r\n   * });\r\n   *\r\n   * @method Phaser.GameObjects.Text#setStyle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} style - The style settings to set.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setStyle: function (style) {\n    return this.style.setStyle(style);\n  },\n\n  /**\r\n   * Set the font.\r\n   *\r\n   * If a string is given, the font family is set.\r\n   *\r\n   * If an object is given, the `fontFamily`, `fontSize` and `fontStyle`\r\n   * properties of that object are set.\r\n   * \r\n   * **Important:** If the font you wish to use has a space or digit in its name, such as\r\n   * 'Press Start 2P' or 'Roboto Condensed', then you _must_ put the font name in quotes:\r\n   * \r\n   * ```javascript\r\n   * Text.setFont('\"Roboto Condensed\"');\r\n   * ```\r\n   * \r\n   * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all\r\n   * quoted properly, too:\r\n   * \r\n   * ```javascript\r\n   * Text.setFont('Verdana, \"Times New Roman\", Tahoma, serif');\r\n   * ```\r\n   *\r\n   * @method Phaser.GameObjects.Text#setFont\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} font - The font family or font settings to set.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setFont: function (font) {\n    return this.style.setFont(font);\n  },\n\n  /**\r\n   * Set the font family.\r\n   * \r\n   * **Important:** If the font you wish to use has a space or digit in its name, such as\r\n   * 'Press Start 2P' or 'Roboto Condensed', then you _must_ put the font name in quotes:\r\n   * \r\n   * ```javascript\r\n   * Text.setFont('\"Roboto Condensed\"');\r\n   * ```\r\n   * \r\n   * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all\r\n   * quoted properly, too:\r\n   * \r\n   * ```javascript\r\n   * Text.setFont('Verdana, \"Times New Roman\", Tahoma, serif');\r\n   * ```\r\n   *\r\n   * @method Phaser.GameObjects.Text#setFontFamily\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} family - The font family.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setFontFamily: function (family) {\n    return this.style.setFontFamily(family);\n  },\n\n  /**\r\n   * Set the font size.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setFontSize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} size - The font size.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setFontSize: function (size) {\n    return this.style.setFontSize(size);\n  },\n\n  /**\r\n   * Set the font style.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setFontStyle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} style - The font style.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setFontStyle: function (style) {\n    return this.style.setFontStyle(style);\n  },\n\n  /**\r\n   * Set a fixed width and height for the text.\r\n   *\r\n   * Pass in `0` for either of these parameters to disable fixed width or height respectively.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setFixedSize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} width - The fixed width to set. `0` disables fixed width.\r\n   * @param {number} height - The fixed height to set. `0` disables fixed height.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setFixedSize: function (width, height) {\n    return this.style.setFixedSize(width, height);\n  },\n\n  /**\r\n   * Set the background color.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setBackgroundColor\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} color - The background color.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setBackgroundColor: function (color) {\n    return this.style.setBackgroundColor(color);\n  },\n\n  /**\r\n   * Set the fill style to be used by the Text object.\r\n   *\r\n   * This can be any valid CanvasRenderingContext2D fillStyle value, such as\r\n   * a color (in hex, rgb, rgba, hsl or named values), a gradient or a pattern.\r\n   *\r\n   * See the [MDN fillStyle docs](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle) for more details.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setFill\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|any)} color - The text fill style. Can be any valid CanvasRenderingContext `fillStyle` value.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setFill: function (fillStyle) {\n    return this.style.setFill(fillStyle);\n  },\n\n  /**\r\n   * Set the text fill color.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setColor\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} color - The text fill color.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setColor: function (color) {\n    return this.style.setColor(color);\n  },\n\n  /**\r\n   * Set the stroke settings.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setStroke\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} color - The stroke color.\r\n   * @param {number} thickness - The stroke thickness.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setStroke: function (color, thickness) {\n    return this.style.setStroke(color, thickness);\n  },\n\n  /**\r\n   * Set the shadow settings.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setShadow\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [x=0] - The horizontal shadow offset.\r\n   * @param {number} [y=0] - The vertical shadow offset.\r\n   * @param {string} [color='#000'] - The shadow color.\r\n   * @param {number} [blur=0] - The shadow blur radius.\r\n   * @param {boolean} [shadowStroke=false] - Whether to stroke the shadow.\r\n   * @param {boolean} [shadowFill=true] - Whether to fill the shadow.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setShadow: function (x, y, color, blur, shadowStroke, shadowFill) {\n    return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);\n  },\n\n  /**\r\n   * Set the shadow offset.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setShadowOffset\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal shadow offset.\r\n   * @param {number} y - The vertical shadow offset.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setShadowOffset: function (x, y) {\n    return this.style.setShadowOffset(x, y);\n  },\n\n  /**\r\n   * Set the shadow color.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setShadowColor\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} color - The shadow color.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setShadowColor: function (color) {\n    return this.style.setShadowColor(color);\n  },\n\n  /**\r\n   * Set the shadow blur radius.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setShadowBlur\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} blur - The shadow blur radius.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setShadowBlur: function (blur) {\n    return this.style.setShadowBlur(blur);\n  },\n\n  /**\r\n   * Enable or disable shadow stroke.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setShadowStroke\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} enabled - Whether shadow stroke is enabled or not.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setShadowStroke: function (enabled) {\n    return this.style.setShadowStroke(enabled);\n  },\n\n  /**\r\n   * Enable or disable shadow fill.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setShadowFill\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} enabled - Whether shadow fill is enabled or not.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setShadowFill: function (enabled) {\n    return this.style.setShadowFill(enabled);\n  },\n\n  /**\r\n   * Set the width (in pixels) to use for wrapping lines. Pass in null to remove wrapping by width.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setWordWrapWidth\r\n   * @since 3.0.0\r\n   *\r\n   * @param {?number} width - The maximum width of a line in pixels. Set to null to remove wrapping.\r\n   * @param {boolean} [useAdvancedWrap=false] - Whether or not to use the advanced wrapping\r\n   * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,\r\n   * spaces and whitespace are left as is.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setWordWrapWidth: function (width, useAdvancedWrap) {\n    return this.style.setWordWrapWidth(width, useAdvancedWrap);\n  },\n\n  /**\r\n   * Set a custom callback for wrapping lines. Pass in null to remove wrapping by callback.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setWordWrapCallback\r\n   * @since 3.0.0\r\n   *\r\n   * @param {TextStyleWordWrapCallback} callback - A custom function that will be responsible for wrapping the\r\n   * text. It will receive two arguments: text (the string to wrap), textObject (this Text\r\n   * instance). It should return the wrapped lines either as an array of lines or as a string with\r\n   * newline characters in place to indicate where breaks should happen.\r\n   * @param {object} [scope=null] - The scope that will be applied when the callback is invoked.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setWordWrapCallback: function (callback, scope) {\n    return this.style.setWordWrapCallback(callback, scope);\n  },\n\n  /**\r\n   * Set the alignment of the text in this Text object.\r\n   * \r\n   * The argument can be one of: `left`, `right`, `center` or `justify`.\r\n   * \r\n   * Alignment only works if the Text object has more than one line of text.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setAlign\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [align='left'] - The text alignment for multi-line text.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setAlign: function (align) {\n    return this.style.setAlign(align);\n  },\n\n  /**\r\n   * Set the resolution used by this Text object.\r\n   *\r\n   * By default it will be set to match the resolution set in the Game Config,\r\n   * but you can override it via this method, or by specifying it in the Text style configuration object.\r\n   * \r\n   * It allows for much clearer text on High DPI devices, at the cost of memory because it uses larger\r\n   * internal Canvas textures for the Text.\r\n   * \r\n   * Therefore, please use with caution, as the more high res Text you have, the more memory it uses.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setResolution\r\n   * @since 3.12.0\r\n   *\r\n   * @param {number} value - The resolution for this Text object to use.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setResolution: function (value) {\n    return this.style.setResolution(value);\n  },\n\n  /**\r\n   * Sets the line spacing value.\r\n   *\r\n   * This value is _added_ to the height of the font when calculating the overall line height.\r\n   * This only has an effect if this Text object consists of multiple lines of text.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setLineSpacing\r\n   * @since 3.13.0\r\n   *\r\n   * @param {number} value - The amount to add to the font height to achieve the overall line height.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setLineSpacing: function (value) {\n    this.lineSpacing = value;\n    return this.updateText();\n  },\n\n  /**\r\n   * Set the text padding.\r\n   *\r\n   * 'left' can be an object.\r\n   *\r\n   * If only 'left' and 'top' are given they are treated as 'x' and 'y'.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setPadding\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(number|Phaser.Types.GameObjects.Text.TextPadding)} left - The left padding value, or a padding config object.\r\n   * @param {number} top - The top padding value.\r\n   * @param {number} right - The right padding value.\r\n   * @param {number} bottom - The bottom padding value.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setPadding: function (left, top, right, bottom) {\n    if (typeof left === 'object') {\n      var config = left; //  If they specify x and/or y this applies to all\n\n      var x = GetValue(config, 'x', null);\n\n      if (x !== null) {\n        left = x;\n        right = x;\n      } else {\n        left = GetValue(config, 'left', 0);\n        right = GetValue(config, 'right', left);\n      }\n\n      var y = GetValue(config, 'y', null);\n\n      if (y !== null) {\n        top = y;\n        bottom = y;\n      } else {\n        top = GetValue(config, 'top', 0);\n        bottom = GetValue(config, 'bottom', top);\n      }\n    } else {\n      if (left === undefined) {\n        left = 0;\n      }\n\n      if (top === undefined) {\n        top = left;\n      }\n\n      if (right === undefined) {\n        right = left;\n      }\n\n      if (bottom === undefined) {\n        bottom = top;\n      }\n    }\n\n    this.padding.left = left;\n    this.padding.top = top;\n    this.padding.right = right;\n    this.padding.bottom = bottom;\n    return this.updateText();\n  },\n\n  /**\r\n   * Set the maximum number of lines to draw.\r\n   *\r\n   * @method Phaser.GameObjects.Text#setMaxLines\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} [max=0] - The maximum number of lines to draw.\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  setMaxLines: function (max) {\n    return this.style.setMaxLines(max);\n  },\n\n  /**\r\n   * Update the displayed text.\r\n   *\r\n   * @method Phaser.GameObjects.Text#updateText\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.GameObjects.Text} This Text object.\r\n   */\n  updateText: function () {\n    var canvas = this.canvas;\n    var context = this.context;\n    var style = this.style;\n    var resolution = style.resolution;\n    var size = style.metrics;\n    style.syncFont(canvas, context);\n    var outputText = this._text;\n\n    if (style.wordWrapWidth || style.wordWrapCallback) {\n      outputText = this.runWordWrap(this._text);\n    } //  Split text into lines\n\n\n    var lines = outputText.split(this.splitRegExp);\n    var textSize = GetTextSize(this, size, lines);\n    var padding = this.padding;\n    var textWidth;\n\n    if (style.fixedWidth === 0) {\n      this.width = textSize.width + padding.left + padding.right;\n      textWidth = textSize.width;\n    } else {\n      this.width = style.fixedWidth;\n      textWidth = this.width - padding.left - padding.right;\n\n      if (textWidth < textSize.width) {\n        textWidth = textSize.width;\n      }\n    }\n\n    if (style.fixedHeight === 0) {\n      this.height = textSize.height + padding.top + padding.bottom;\n    } else {\n      this.height = style.fixedHeight;\n    }\n\n    var w = this.width;\n    var h = this.height;\n    this.updateDisplayOrigin();\n    w *= resolution;\n    h *= resolution;\n    w = Math.max(w, 1);\n    h = Math.max(h, 1);\n\n    if (canvas.width !== w || canvas.height !== h) {\n      canvas.width = w;\n      canvas.height = h;\n      this.frame.setSize(w, h); //  Because resizing the canvas resets the context\n\n      style.syncFont(canvas, context);\n    } else {\n      context.clearRect(0, 0, w, h);\n    }\n\n    context.save();\n    context.scale(resolution, resolution);\n\n    if (style.backgroundColor) {\n      context.fillStyle = style.backgroundColor;\n      context.fillRect(0, 0, w, h);\n    }\n\n    style.syncStyle(canvas, context);\n    context.textBaseline = 'alphabetic'; //  Apply padding\n\n    context.translate(padding.left, padding.top);\n    var linePositionX;\n    var linePositionY; //  Draw text line by line\n\n    for (var i = 0; i < textSize.lines; i++) {\n      linePositionX = style.strokeThickness / 2;\n      linePositionY = style.strokeThickness / 2 + i * textSize.lineHeight + size.ascent;\n\n      if (i > 0) {\n        linePositionY += textSize.lineSpacing * i;\n      }\n\n      if (style.rtl) {\n        linePositionX = w - linePositionX;\n      } else if (style.align === 'right') {\n        linePositionX += textWidth - textSize.lineWidths[i];\n      } else if (style.align === 'center') {\n        linePositionX += (textWidth - textSize.lineWidths[i]) / 2;\n      } else if (style.align === 'justify') {\n        //  To justify text line its width must be no less than 85% of defined width\n        var minimumLengthToApplyJustification = 0.85;\n\n        if (textSize.lineWidths[i] / textSize.width >= minimumLengthToApplyJustification) {\n          var extraSpace = textSize.width - textSize.lineWidths[i];\n          var spaceSize = context.measureText(' ').width;\n          var trimmedLine = lines[i].trim();\n          var array = trimmedLine.split(' ');\n          extraSpace += (lines[i].length - trimmedLine.length) * spaceSize;\n          var extraSpaceCharacters = Math.floor(extraSpace / spaceSize);\n          var idx = 0;\n\n          while (extraSpaceCharacters > 0) {\n            array[idx] += ' ';\n            idx = (idx + 1) % (array.length - 1 || 1);\n            --extraSpaceCharacters;\n          }\n\n          lines[i] = array.join(' ');\n        }\n      }\n\n      if (this.autoRound) {\n        linePositionX = Math.round(linePositionX);\n        linePositionY = Math.round(linePositionY);\n      }\n\n      if (style.strokeThickness) {\n        this.style.syncShadow(context, style.shadowStroke);\n        context.strokeText(lines[i], linePositionX, linePositionY);\n      }\n\n      if (style.color) {\n        this.style.syncShadow(context, style.shadowFill);\n        context.fillText(lines[i], linePositionX, linePositionY);\n      }\n    }\n\n    context.restore();\n\n    if (this.renderer.gl) {\n      this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);\n      this.frame.glTexture = this.frame.source.glTexture;\n    }\n\n    this.dirty = true;\n    var input = this.input;\n\n    if (input && !input.customHitArea) {\n      input.hitArea.width = this.width;\n      input.hitArea.height = this.height;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Get the current text metrics.\r\n   *\r\n   * @method Phaser.GameObjects.Text#getTextMetrics\r\n   * @since 3.0.0\r\n   *\r\n   * @return {object} The text metrics.\r\n   */\n  getTextMetrics: function () {\n    return this.style.getTextMetrics();\n  },\n\n  /**\r\n   * The text string being rendered by this Text Game Object.\r\n   *\r\n   * @name Phaser.GameObjects.Text#text\r\n   * @type {string}\r\n   * @since 3.0.0\r\n   */\n  text: {\n    get: function () {\n      return this._text;\n    },\n    set: function (value) {\n      this.setText(value);\n    }\n  },\n\n  /**\r\n   * Build a JSON representation of the Text object.\r\n   *\r\n   * @method Phaser.GameObjects.Text#toJSON\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Text object.\r\n   */\n  toJSON: function () {\n    var out = Components.ToJSON(this); //  Extra Text data is added here\n\n    var data = {\n      autoRound: this.autoRound,\n      text: this._text,\n      style: this.style.toJSON(),\n      padding: {\n        left: this.padding.left,\n        right: this.padding.right,\n        top: this.padding.top,\n        bottom: this.padding.bottom\n      }\n    };\n    out.data = data;\n    return out;\n  },\n\n  /**\r\n   * Internal destroy handler, called as part of the destroy process.\r\n   *\r\n   * @method Phaser.GameObjects.Text#preDestroy\r\n   * @protected\r\n   * @since 3.0.0\r\n   */\n  preDestroy: function () {\n    if (this.style.rtl) {\n      RemoveFromDOM(this.canvas);\n    }\n\n    CanvasPool.remove(this.canvas);\n    this.texture.destroy();\n  }\n  /**\r\n   * The horizontal origin of this Game Object.\r\n   * The origin maps the relationship between the size and position of the Game Object.\r\n   * The default value is 0.5, meaning all Game Objects are positioned based on their center.\r\n   * Setting the value to 0 means the position now relates to the left of the Game Object.\r\n   *\r\n   * @name Phaser.GameObjects.Text#originX\r\n   * @type {number}\r\n   * @default 0\r\n   * @since 3.0.0\r\n   */\n\n  /**\r\n   * The vertical origin of this Game Object.\r\n   * The origin maps the relationship between the size and position of the Game Object.\r\n   * The default value is 0.5, meaning all Game Objects are positioned based on their center.\r\n   * Setting the value to 0 means the position now relates to the top of the Game Object.\r\n   *\r\n   * @name Phaser.GameObjects.Text#originY\r\n   * @type {number}\r\n   * @default 0\r\n   * @since 3.0.0\r\n   */\n\n});\nmodule.exports = Text;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/text/static/Text.js"],"names":["AddToDOM","require","CanvasPool","Class","Components","GameEvents","GameObject","GetTextSize","GetValue","RemoveFromDOM","TextRender","TextStyle","Text","Extends","Mixins","Alpha","BlendMode","ComputedSize","Crop","Depth","Flip","GetBounds","Mask","Origin","Pipeline","ScrollFactor","Tint","Transform","Visible","initialize","scene","x","y","text","style","undefined","call","renderer","sys","game","setPosition","setOrigin","initPipeline","canvas","create","context","getContext","autoRound","splitRegExp","_text","padding","left","right","top","bottom","width","height","lineSpacing","dirty","resolution","config","_crop","resetCropObject","texture","textures","addCanvas","frame","get","source","gl","deleteTexture","glTexture","initRTL","setText","setPadding","setLineSpacing","events","on","CONTEXT_RESTORED","rtl","dir","direction","display","originX","runWordWrap","wordWrapCallback","wrappedLines","wordWrapCallbackScope","Array","isArray","join","wordWrapWidth","wordWrapUseAdvanced","advancedWordWrap","basicWordWrap","output","lines","replace","split","linesCount","length","i","line","out","lineWidth","measureText","currentLineWidth","words","j","word","wordWithSpace","wordWidth","newWord","slice","Error","secondPart","substr","offset","remainder","result","lastLineIndex","whiteSpaceWidth","spaceLeft","lastWordIndex","wordWidthWithSpace","getWrappedText","syncFont","value","toString","updateText","setStyle","setFont","font","setFontFamily","family","setFontSize","size","setFontStyle","setFixedSize","setBackgroundColor","color","setFill","fillStyle","setColor","setStroke","thickness","setShadow","blur","shadowStroke","shadowFill","setShadowOffset","setShadowColor","setShadowBlur","setShadowStroke","enabled","setShadowFill","setWordWrapWidth","useAdvancedWrap","setWordWrapCallback","callback","scope","setAlign","align","setResolution","setMaxLines","max","metrics","outputText","textSize","textWidth","fixedWidth","fixedHeight","w","h","updateDisplayOrigin","Math","setSize","clearRect","save","scale","backgroundColor","fillRect","syncStyle","textBaseline","translate","linePositionX","linePositionY","strokeThickness","lineHeight","ascent","lineWidths","minimumLengthToApplyJustification","extraSpace","spaceSize","trimmedLine","trim","array","extraSpaceCharacters","floor","idx","round","syncShadow","strokeText","fillText","restore","canvasToTexture","input","customHitArea","hitArea","getTextMetrics","set","toJSON","ToJSON","data","preDestroy","remove","destroy","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AddToDOM = require('../../../dom/AddToDOM');\r\nvar CanvasPool = require('../../../display/canvas/CanvasPool');\r\nvar Class = require('../../../utils/Class');\r\nvar Components = require('../../components');\r\nvar GameEvents = require('../../../core/events');\r\nvar GameObject = require('../../GameObject');\r\nvar GetTextSize = require('../GetTextSize');\r\nvar GetValue = require('../../../utils/object/GetValue');\r\nvar RemoveFromDOM = require('../../../dom/RemoveFromDOM');\r\nvar TextRender = require('./TextRender');\r\nvar TextStyle = require('../TextStyle');\r\n\r\n/**\r\n * @classdesc\r\n * A Text Game Object.\r\n * \r\n * Text objects work by creating their own internal hidden Canvas and then renders text to it using\r\n * the standard Canvas `fillText` API. It then creates a texture from this canvas which is rendered\r\n * to your game during the render pass.\r\n * \r\n * Because it uses the Canvas API you can take advantage of all the features this offers, such as\r\n * applying gradient fills to the text, or strokes, shadows and more. You can also use custom fonts\r\n * loaded externally, such as Google or TypeKit Web fonts.\r\n * \r\n * **Important:** If the font you wish to use has a space or digit in its name, such as\r\n * 'Press Start 2P' or 'Roboto Condensed', then you _must_ put the font name in quotes, either\r\n * when creating the Text object, or when setting the font via `setFont` or `setFontFamily`. I.e.:\r\n * \r\n * ```javascript\r\n * this.add.text(0, 0, 'Hello World', { fontFamily: '\"Roboto Condensed\"' });\r\n * ```\r\n * \r\n * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all\r\n * quoted properly, too:\r\n * \r\n * ```javascript\r\n * this.add.text(0, 0, 'Hello World', { fontFamily: 'Verdana, \"Times New Roman\", Tahoma, serif' });\r\n * ```\r\n *\r\n * You can only display fonts that are currently loaded and available to the browser: therefore fonts must\r\n * be pre-loaded. Phaser does not do ths for you, so you will require the use of a 3rd party font loader,\r\n * or have the fonts ready available in the CSS on the page in which your Phaser game resides.\r\n *\r\n * See {@link http://www.jordanm.co.uk/tinytype this compatibility table} for the available default fonts\r\n * across mobile browsers.\r\n * \r\n * A note on performance: Every time the contents of a Text object changes, i.e. changing the text being\r\n * displayed, or the style of the text, it needs to remake the Text canvas, and if on WebGL, re-upload the\r\n * new texture to the GPU. This can be an expensive operation if used often, or with large quantities of\r\n * Text objects in your game. If you run into performance issues you would be better off using Bitmap Text\r\n * instead, as it benefits from batching and avoids expensive Canvas API calls.\r\n *\r\n * @class Text\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Crop\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|string[])} text - The text this Text object will display.\r\n * @param {Phaser.Types.GameObjects.Text.TextStyle} style - The text style configuration object.\r\n */\r\nvar Text = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.ComputedSize,\r\n        Components.Crop,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        TextRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Text (scene, x, y, text, style)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        GameObject.call(this, scene, 'Text');\r\n\r\n        /**\r\n         * The renderer in use by this Text object.\r\n         *\r\n         * @name Phaser.GameObjects.Text#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.12.0\r\n         */\r\n        this.renderer = scene.sys.game.renderer;\r\n\r\n        this.setPosition(x, y);\r\n        this.setOrigin(0, 0);\r\n        this.initPipeline();\r\n\r\n        /**\r\n         * The canvas element that the text is rendered to.\r\n         *\r\n         * @name Phaser.GameObjects.Text#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */\r\n        this.canvas = CanvasPool.create(this);\r\n\r\n        /**\r\n         * The context of the canvas element that the text is rendered to.\r\n         *\r\n         * @name Phaser.GameObjects.Text#context\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */\r\n        this.context = this.canvas.getContext('2d');\r\n\r\n        /**\r\n         * The Text Style object.\r\n         *\r\n         * Manages the style of this Text object.\r\n         *\r\n         * @name Phaser.GameObjects.Text#style\r\n         * @type {Phaser.GameObjects.TextStyle}\r\n         * @since 3.0.0\r\n         */\r\n        this.style = new TextStyle(this, style);\r\n\r\n        /**\r\n         * Whether to automatically round line positions.\r\n         *\r\n         * @name Phaser.GameObjects.Text#autoRound\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.autoRound = true;\r\n\r\n        /**\r\n         * The Regular Expression that is used to split the text up into lines, in\r\n         * multi-line text. By default this is `/(?:\\r\\n|\\r|\\n)/`.\r\n         * You can change this RegExp to be anything else that you may need.\r\n         *\r\n         * @name Phaser.GameObjects.Text#splitRegExp\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.splitRegExp = /(?:\\r\\n|\\r|\\n)/;\r\n\r\n        /**\r\n         * The text to display.\r\n         *\r\n         * @name Phaser.GameObjects.Text#_text\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._text = undefined;\r\n\r\n        /**\r\n         * Specify a padding value which is added to the line width and height when calculating the Text size.\r\n         * Allows you to add extra spacing if the browser is unable to accurately determine the true font dimensions.\r\n         *\r\n         * @name Phaser.GameObjects.Text#padding\r\n         * @type {{left:number,right:number,top:number,bottom:number}}\r\n         * @since 3.0.0\r\n         */\r\n        this.padding = { left: 0, right: 0, top: 0, bottom: 0 };\r\n\r\n        /**\r\n         * The width of this Text object.\r\n         *\r\n         * @name Phaser.GameObjects.Text#width\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.width = 1;\r\n\r\n        /**\r\n         * The height of this Text object.\r\n         *\r\n         * @name Phaser.GameObjects.Text#height\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.height = 1;\r\n\r\n        /**\r\n         * The line spacing value.\r\n         * This value is added to the font height to calculate the overall line height.\r\n         * Only has an effect if this Text object contains multiple lines of text.\r\n         * \r\n         * If you update this property directly, instead of using the `setLineSpacing` method, then\r\n         * be sure to call `updateText` after, or you won't see the change reflected in the Text object.\r\n         *\r\n         * @name Phaser.GameObjects.Text#lineSpacing\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.lineSpacing = 0;\r\n\r\n        /**\r\n         * Whether the text or its settings have changed and need updating.\r\n         *\r\n         * @name Phaser.GameObjects.Text#dirty\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.dirty = false;\r\n\r\n        //  If resolution wasn't set, then we get it from the game config\r\n        if (this.style.resolution === 0)\r\n        {\r\n            this.style.resolution = scene.sys.game.config.resolution;\r\n        }\r\n\r\n        /**\r\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n         *\r\n         * @name Phaser.GameObjects.Text#_crop\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._crop = this.resetCropObject();\r\n\r\n        //  Create a Texture for this Text object\r\n        this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);\r\n\r\n        //  Get the frame\r\n        this.frame = this.texture.get();\r\n\r\n        //  Set the resolution\r\n        this.frame.source.resolution = this.style.resolution;\r\n\r\n        if (this.renderer && this.renderer.gl)\r\n        {\r\n            //  Clear the default 1x1 glTexture, as we override it later\r\n            this.renderer.deleteTexture(this.frame.source.glTexture);\r\n\r\n            this.frame.source.glTexture = null;\r\n        }\r\n\r\n        this.initRTL();\r\n\r\n        this.setText(text);\r\n\r\n        if (style && style.padding)\r\n        {\r\n            this.setPadding(style.padding);\r\n        }\r\n\r\n        if (style && style.lineSpacing)\r\n        {\r\n            this.setLineSpacing(style.lineSpacing);\r\n        }\r\n\r\n        scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function ()\r\n        {\r\n            this.dirty = true;\r\n        }, this);\r\n    },\r\n\r\n    /**\r\n     * Initialize right to left text.\r\n     *\r\n     * @method Phaser.GameObjects.Text#initRTL\r\n     * @since 3.0.0\r\n     */\r\n    initRTL: function ()\r\n    {\r\n        if (!this.style.rtl)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  Here is where the crazy starts.\r\n        //\r\n        //  Due to browser implementation issues, you cannot fillText BiDi text to a canvas\r\n        //  that is not part of the DOM. It just completely ignores the direction property.\r\n\r\n        this.canvas.dir = 'rtl';\r\n\r\n        //  Experimental atm, but one day ...\r\n        this.context.direction = 'rtl';\r\n\r\n        //  Add it to the DOM, but hidden within the parent canvas.\r\n        this.canvas.style.display = 'none';\r\n\r\n        AddToDOM(this.canvas, this.scene.sys.canvas);\r\n\r\n        //  And finally we set the x origin\r\n        this.originX = 1;\r\n    },\r\n\r\n    /**\r\n     * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n     * bounds.\r\n     *\r\n     * @method Phaser.GameObjects.Text#runWordWrap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} text - The text to perform word wrap detection against.\r\n     *\r\n     * @return {string} The text after wrapping has been applied.\r\n     */\r\n    runWordWrap: function (text)\r\n    {\r\n        var style = this.style;\r\n\r\n        if (style.wordWrapCallback)\r\n        {\r\n            var wrappedLines = style.wordWrapCallback.call(style.wordWrapCallbackScope, text, this);\r\n\r\n            if (Array.isArray(wrappedLines))\r\n            {\r\n                wrappedLines = wrappedLines.join('\\n');\r\n            }\r\n\r\n            return wrappedLines;\r\n        }\r\n        else if (style.wordWrapWidth)\r\n        {\r\n            if (style.wordWrapUseAdvanced)\r\n            {\r\n                return this.advancedWordWrap(text, this.context, this.style.wordWrapWidth);\r\n            }\r\n            else\r\n            {\r\n                return this.basicWordWrap(text, this.context, this.style.wordWrapWidth);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            return text;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Advanced wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n     * bounds. Consecutive spaces will be collapsed and replaced with a single space. Lines will be\r\n     * trimmed of white space before processing. Throws an error if wordWrapWidth is less than a\r\n     * single character.\r\n     *\r\n     * @method Phaser.GameObjects.Text#advancedWordWrap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} text - The text to perform word wrap detection against.\r\n     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.\r\n     * @param {number} wordWrapWidth - The word wrap width.\r\n     *\r\n     * @return {string} The wrapped text.\r\n     */\r\n    advancedWordWrap: function (text, context, wordWrapWidth)\r\n    {\r\n        var output = '';\r\n\r\n        // Condense consecutive spaces and split into lines\r\n        var lines = text\r\n            .replace(/ +/gi, ' ')\r\n            .split(this.splitRegExp);\r\n\r\n        var linesCount = lines.length;\r\n\r\n        for (var i = 0; i < linesCount; i++)\r\n        {\r\n            var line = lines[i];\r\n            var out = '';\r\n\r\n            // Trim whitespace\r\n            line = line.replace(/^ *|\\s*$/gi, '');\r\n\r\n            // If entire line is less than wordWrapWidth append the entire line and exit early\r\n            var lineWidth = context.measureText(line).width;\r\n\r\n            if (lineWidth < wordWrapWidth)\r\n            {\r\n                output += line + '\\n';\r\n                continue;\r\n            }\r\n\r\n            // Otherwise, calculate new lines\r\n            var currentLineWidth = wordWrapWidth;\r\n\r\n            // Split into words\r\n            var words = line.split(' ');\r\n\r\n            for (var j = 0; j < words.length; j++)\r\n            {\r\n                var word = words[j];\r\n                var wordWithSpace = word + ' ';\r\n                var wordWidth = context.measureText(wordWithSpace).width;\r\n\r\n                if (wordWidth > currentLineWidth)\r\n                {\r\n                    // Break word\r\n                    if (j === 0)\r\n                    {\r\n                        // Shave off letters from word until it's small enough\r\n                        var newWord = wordWithSpace;\r\n\r\n                        while (newWord.length)\r\n                        {\r\n                            newWord = newWord.slice(0, -1);\r\n                            wordWidth = context.measureText(newWord).width;\r\n\r\n                            if (wordWidth <= currentLineWidth)\r\n                            {\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        // If wordWrapWidth is too small for even a single letter, shame user\r\n                        // failure with a fatal error\r\n                        if (!newWord.length)\r\n                        {\r\n                            throw new Error('This text\\'s wordWrapWidth setting is less than a single character!');\r\n                        }\r\n\r\n                        // Replace current word in array with remainder\r\n                        var secondPart = word.substr(newWord.length);\r\n\r\n                        words[j] = secondPart;\r\n\r\n                        // Append first piece to output\r\n                        out += newWord;\r\n                    }\r\n\r\n                    // If existing word length is 0, don't include it\r\n                    var offset = (words[j].length) ? j : j + 1;\r\n\r\n                    // Collapse rest of sentence and remove any trailing white space\r\n                    var remainder = words.slice(offset).join(' ')\r\n                        .replace(/[ \\n]*$/gi, '');\r\n\r\n                    // Prepend remainder to next line\r\n                    lines[i + 1] = remainder + ' ' + (lines[i + 1] || '');\r\n                    linesCount = lines.length;\r\n\r\n                    break; // Processing on this line\r\n\r\n                    // Append word with space to output\r\n                }\r\n                else\r\n                {\r\n                    out += wordWithSpace;\r\n                    currentLineWidth -= wordWidth;\r\n                }\r\n            }\r\n\r\n            // Append processed line to output\r\n            output += out.replace(/[ \\n]*$/gi, '') + '\\n';\r\n        }\r\n\r\n        // Trim the end of the string\r\n        output = output.replace(/[\\s|\\n]*$/gi, '');\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n     * bounds. Spaces are not collapsed and whitespace is not trimmed.\r\n     *\r\n     * @method Phaser.GameObjects.Text#basicWordWrap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} text - The text to perform word wrap detection against.\r\n     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.\r\n     * @param {number} wordWrapWidth - The word wrap width.\r\n     *\r\n     * @return {string} The wrapped text.\r\n     */\r\n    basicWordWrap: function (text, context, wordWrapWidth)\r\n    {\r\n        var result = '';\r\n        var lines = text.split(this.splitRegExp);\r\n        var lastLineIndex = lines.length - 1;\r\n        var whiteSpaceWidth = context.measureText(' ').width;\r\n\r\n        for (var i = 0; i <= lastLineIndex; i++)\r\n        {\r\n            var spaceLeft = wordWrapWidth;\r\n            var words = lines[i].split(' ');\r\n            var lastWordIndex = words.length - 1;\r\n\r\n            for (var j = 0; j <= lastWordIndex; j++)\r\n            {\r\n                var word = words[j];\r\n                var wordWidth = context.measureText(word).width;\r\n                var wordWidthWithSpace = wordWidth + whiteSpaceWidth;\r\n\r\n                if (wordWidthWithSpace > spaceLeft)\r\n                {\r\n                    // Skip printing the newline if it's the first word of the line that is greater\r\n                    // than the word wrap width.\r\n                    if (j > 0)\r\n                    {\r\n                        result += '\\n';\r\n                        spaceLeft = wordWrapWidth;\r\n                    }\r\n                }\r\n\r\n                result += word;\r\n\r\n                if (j < lastWordIndex)\r\n                {\r\n                    result += ' ';\r\n                    spaceLeft -= wordWidthWithSpace;\r\n                }\r\n                else\r\n                {\r\n                    spaceLeft -= wordWidth;\r\n                }\r\n            }\r\n\r\n            if (i < lastLineIndex)\r\n            {\r\n                result += '\\n';\r\n            }\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    /**\r\n     * Runs the given text through this Text objects word wrapping and returns the results as an\r\n     * array, where each element of the array corresponds to a wrapped line of text.\r\n     *\r\n     * @method Phaser.GameObjects.Text#getWrappedText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} text - The text for which the wrapping will be calculated. If unspecified, the Text objects current text will be used.\r\n     *\r\n     * @return {string[]} An array of strings with the pieces of wrapped text.\r\n     */\r\n    getWrappedText: function (text)\r\n    {\r\n        if (text === undefined) { text = this._text; }\r\n\r\n        this.style.syncFont(this.canvas, this.context);\r\n\r\n        var wrappedLines = this.runWordWrap(text);\r\n\r\n        return wrappedLines.split(this.splitRegExp);\r\n    },\r\n\r\n    /**\r\n     * Set the text to display.\r\n     *\r\n     * An array of strings will be joined with `\\n` line breaks.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} value - The string, or array of strings, to be set as the content of this Text object.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setText: function (value)\r\n    {\r\n        if (!value && value !== 0)\r\n        {\r\n            value = '';\r\n        }\r\n\r\n        if (Array.isArray(value))\r\n        {\r\n            value = value.join('\\n');\r\n        }\r\n\r\n        if (value !== this._text)\r\n        {\r\n            this._text = value.toString();\r\n\r\n            this.updateText();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the text style.\r\n     *\r\n     * @example\r\n     * text.setStyle({\r\n     *     fontSize: '64px',\r\n     *     fontFamily: 'Arial',\r\n     *     color: '#ffffff',\r\n     *     align: 'center',\r\n     *     backgroundColor: '#ff00ff'\r\n     * });\r\n     *\r\n     * @method Phaser.GameObjects.Text#setStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} style - The style settings to set.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setStyle: function (style)\r\n    {\r\n        return this.style.setStyle(style);\r\n    },\r\n\r\n    /**\r\n     * Set the font.\r\n     *\r\n     * If a string is given, the font family is set.\r\n     *\r\n     * If an object is given, the `fontFamily`, `fontSize` and `fontStyle`\r\n     * properties of that object are set.\r\n     * \r\n     * **Important:** If the font you wish to use has a space or digit in its name, such as\r\n     * 'Press Start 2P' or 'Roboto Condensed', then you _must_ put the font name in quotes:\r\n     * \r\n     * ```javascript\r\n     * Text.setFont('\"Roboto Condensed\"');\r\n     * ```\r\n     * \r\n     * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all\r\n     * quoted properly, too:\r\n     * \r\n     * ```javascript\r\n     * Text.setFont('Verdana, \"Times New Roman\", Tahoma, serif');\r\n     * ```\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFont\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} font - The font family or font settings to set.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setFont: function (font)\r\n    {\r\n        return this.style.setFont(font);\r\n    },\r\n\r\n    /**\r\n     * Set the font family.\r\n     * \r\n     * **Important:** If the font you wish to use has a space or digit in its name, such as\r\n     * 'Press Start 2P' or 'Roboto Condensed', then you _must_ put the font name in quotes:\r\n     * \r\n     * ```javascript\r\n     * Text.setFont('\"Roboto Condensed\"');\r\n     * ```\r\n     * \r\n     * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all\r\n     * quoted properly, too:\r\n     * \r\n     * ```javascript\r\n     * Text.setFont('Verdana, \"Times New Roman\", Tahoma, serif');\r\n     * ```\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFontFamily\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} family - The font family.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setFontFamily: function (family)\r\n    {\r\n        return this.style.setFontFamily(family);\r\n    },\r\n\r\n    /**\r\n     * Set the font size.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFontSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} size - The font size.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setFontSize: function (size)\r\n    {\r\n        return this.style.setFontSize(size);\r\n    },\r\n\r\n    /**\r\n     * Set the font style.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFontStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} style - The font style.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setFontStyle: function (style)\r\n    {\r\n        return this.style.setFontStyle(style);\r\n    },\r\n\r\n    /**\r\n     * Set a fixed width and height for the text.\r\n     *\r\n     * Pass in `0` for either of these parameters to disable fixed width or height respectively.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFixedSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The fixed width to set. `0` disables fixed width.\r\n     * @param {number} height - The fixed height to set. `0` disables fixed height.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setFixedSize: function (width, height)\r\n    {\r\n        return this.style.setFixedSize(width, height);\r\n    },\r\n\r\n    /**\r\n     * Set the background color.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setBackgroundColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - The background color.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setBackgroundColor: function (color)\r\n    {\r\n        return this.style.setBackgroundColor(color);\r\n    },\r\n\r\n    /**\r\n     * Set the fill style to be used by the Text object.\r\n     *\r\n     * This can be any valid CanvasRenderingContext2D fillStyle value, such as\r\n     * a color (in hex, rgb, rgba, hsl or named values), a gradient or a pattern.\r\n     *\r\n     * See the [MDN fillStyle docs](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle) for more details.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|any)} color - The text fill style. Can be any valid CanvasRenderingContext `fillStyle` value.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setFill: function (fillStyle)\r\n    {\r\n        return this.style.setFill(fillStyle);\r\n    },\r\n\r\n    /**\r\n     * Set the text fill color.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - The text fill color.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setColor: function (color)\r\n    {\r\n        return this.style.setColor(color);\r\n    },\r\n\r\n    /**\r\n     * Set the stroke settings.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setStroke\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - The stroke color.\r\n     * @param {number} thickness - The stroke thickness.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setStroke: function (color, thickness)\r\n    {\r\n        return this.style.setStroke(color, thickness);\r\n    },\r\n\r\n    /**\r\n     * Set the shadow settings.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal shadow offset.\r\n     * @param {number} [y=0] - The vertical shadow offset.\r\n     * @param {string} [color='#000'] - The shadow color.\r\n     * @param {number} [blur=0] - The shadow blur radius.\r\n     * @param {boolean} [shadowStroke=false] - Whether to stroke the shadow.\r\n     * @param {boolean} [shadowFill=true] - Whether to fill the shadow.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setShadow: function (x, y, color, blur, shadowStroke, shadowFill)\r\n    {\r\n        return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);\r\n    },\r\n\r\n    /**\r\n     * Set the shadow offset.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowOffset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal shadow offset.\r\n     * @param {number} y - The vertical shadow offset.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setShadowOffset: function (x, y)\r\n    {\r\n        return this.style.setShadowOffset(x, y);\r\n    },\r\n\r\n    /**\r\n     * Set the shadow color.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - The shadow color.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setShadowColor: function (color)\r\n    {\r\n        return this.style.setShadowColor(color);\r\n    },\r\n\r\n    /**\r\n     * Set the shadow blur radius.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowBlur\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} blur - The shadow blur radius.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setShadowBlur: function (blur)\r\n    {\r\n        return this.style.setShadowBlur(blur);\r\n    },\r\n\r\n    /**\r\n     * Enable or disable shadow stroke.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowStroke\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} enabled - Whether shadow stroke is enabled or not.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setShadowStroke: function (enabled)\r\n    {\r\n        return this.style.setShadowStroke(enabled);\r\n    },\r\n\r\n    /**\r\n     * Enable or disable shadow fill.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowFill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} enabled - Whether shadow fill is enabled or not.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setShadowFill: function (enabled)\r\n    {\r\n        return this.style.setShadowFill(enabled);\r\n    },\r\n\r\n    /**\r\n     * Set the width (in pixels) to use for wrapping lines. Pass in null to remove wrapping by width.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setWordWrapWidth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {?number} width - The maximum width of a line in pixels. Set to null to remove wrapping.\r\n     * @param {boolean} [useAdvancedWrap=false] - Whether or not to use the advanced wrapping\r\n     * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,\r\n     * spaces and whitespace are left as is.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setWordWrapWidth: function (width, useAdvancedWrap)\r\n    {\r\n        return this.style.setWordWrapWidth(width, useAdvancedWrap);\r\n    },\r\n\r\n    /**\r\n     * Set a custom callback for wrapping lines. Pass in null to remove wrapping by callback.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setWordWrapCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {TextStyleWordWrapCallback} callback - A custom function that will be responsible for wrapping the\r\n     * text. It will receive two arguments: text (the string to wrap), textObject (this Text\r\n     * instance). It should return the wrapped lines either as an array of lines or as a string with\r\n     * newline characters in place to indicate where breaks should happen.\r\n     * @param {object} [scope=null] - The scope that will be applied when the callback is invoked.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setWordWrapCallback: function (callback, scope)\r\n    {\r\n        return this.style.setWordWrapCallback(callback, scope);\r\n    },\r\n\r\n    /**\r\n     * Set the alignment of the text in this Text object.\r\n     * \r\n     * The argument can be one of: `left`, `right`, `center` or `justify`.\r\n     * \r\n     * Alignment only works if the Text object has more than one line of text.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setAlign\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [align='left'] - The text alignment for multi-line text.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setAlign: function (align)\r\n    {\r\n        return this.style.setAlign(align);\r\n    },\r\n\r\n    /**\r\n     * Set the resolution used by this Text object.\r\n     *\r\n     * By default it will be set to match the resolution set in the Game Config,\r\n     * but you can override it via this method, or by specifying it in the Text style configuration object.\r\n     * \r\n     * It allows for much clearer text on High DPI devices, at the cost of memory because it uses larger\r\n     * internal Canvas textures for the Text.\r\n     * \r\n     * Therefore, please use with caution, as the more high res Text you have, the more memory it uses.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setResolution\r\n     * @since 3.12.0\r\n     *\r\n     * @param {number} value - The resolution for this Text object to use.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setResolution: function (value)\r\n    {\r\n        return this.style.setResolution(value);\r\n    },\r\n\r\n    /**\r\n     * Sets the line spacing value.\r\n     *\r\n     * This value is _added_ to the height of the font when calculating the overall line height.\r\n     * This only has an effect if this Text object consists of multiple lines of text.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setLineSpacing\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} value - The amount to add to the font height to achieve the overall line height.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setLineSpacing: function (value)\r\n    {\r\n        this.lineSpacing = value;\r\n\r\n        return this.updateText();\r\n    },\r\n\r\n    /**\r\n     * Set the text padding.\r\n     *\r\n     * 'left' can be an object.\r\n     *\r\n     * If only 'left' and 'top' are given they are treated as 'x' and 'y'.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setPadding\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Types.GameObjects.Text.TextPadding)} left - The left padding value, or a padding config object.\r\n     * @param {number} top - The top padding value.\r\n     * @param {number} right - The right padding value.\r\n     * @param {number} bottom - The bottom padding value.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setPadding: function (left, top, right, bottom)\r\n    {\r\n        if (typeof left === 'object')\r\n        {\r\n            var config = left;\r\n\r\n            //  If they specify x and/or y this applies to all\r\n            var x = GetValue(config, 'x', null);\r\n\r\n            if (x !== null)\r\n            {\r\n                left = x;\r\n                right = x;\r\n            }\r\n            else\r\n            {\r\n                left = GetValue(config, 'left', 0);\r\n                right = GetValue(config, 'right', left);\r\n            }\r\n\r\n            var y = GetValue(config, 'y', null);\r\n\r\n            if (y !== null)\r\n            {\r\n                top = y;\r\n                bottom = y;\r\n            }\r\n            else\r\n            {\r\n                top = GetValue(config, 'top', 0);\r\n                bottom = GetValue(config, 'bottom', top);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if (left === undefined) { left = 0; }\r\n            if (top === undefined) { top = left; }\r\n            if (right === undefined) { right = left; }\r\n            if (bottom === undefined) { bottom = top; }\r\n        }\r\n\r\n        this.padding.left = left;\r\n        this.padding.top = top;\r\n        this.padding.right = right;\r\n        this.padding.bottom = bottom;\r\n\r\n        return this.updateText();\r\n    },\r\n\r\n    /**\r\n     * Set the maximum number of lines to draw.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setMaxLines\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [max=0] - The maximum number of lines to draw.\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    setMaxLines: function (max)\r\n    {\r\n        return this.style.setMaxLines(max);\r\n    },\r\n\r\n    /**\r\n     * Update the displayed text.\r\n     *\r\n     * @method Phaser.GameObjects.Text#updateText\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Text} This Text object.\r\n     */\r\n    updateText: function ()\r\n    {\r\n        var canvas = this.canvas;\r\n        var context = this.context;\r\n        var style = this.style;\r\n        var resolution = style.resolution;\r\n        var size = style.metrics;\r\n\r\n        style.syncFont(canvas, context);\r\n\r\n        var outputText = this._text;\r\n\r\n        if (style.wordWrapWidth || style.wordWrapCallback)\r\n        {\r\n            outputText = this.runWordWrap(this._text);\r\n        }\r\n\r\n        //  Split text into lines\r\n        var lines = outputText.split(this.splitRegExp);\r\n\r\n        var textSize = GetTextSize(this, size, lines);\r\n\r\n        var padding = this.padding;\r\n\r\n        var textWidth;\r\n\r\n        if (style.fixedWidth === 0)\r\n        {\r\n            this.width = textSize.width + padding.left + padding.right;\r\n\r\n            textWidth = textSize.width;\r\n        }\r\n        else\r\n        {\r\n            this.width = style.fixedWidth;\r\n\r\n            textWidth = this.width - padding.left - padding.right;\r\n\r\n            if (textWidth < textSize.width)\r\n            {\r\n                textWidth = textSize.width;\r\n            }\r\n        }\r\n\r\n        if (style.fixedHeight === 0)\r\n        {\r\n            this.height = textSize.height + padding.top + padding.bottom;\r\n        }\r\n        else\r\n        {\r\n            this.height = style.fixedHeight;\r\n        }\r\n\r\n        var w = this.width;\r\n        var h = this.height;\r\n\r\n        this.updateDisplayOrigin();\r\n\r\n        w *= resolution;\r\n        h *= resolution;\r\n\r\n        w = Math.max(w, 1);\r\n        h = Math.max(h, 1);\r\n\r\n        if (canvas.width !== w || canvas.height !== h)\r\n        {\r\n            canvas.width = w;\r\n            canvas.height = h;\r\n\r\n            this.frame.setSize(w, h);\r\n\r\n            //  Because resizing the canvas resets the context\r\n            style.syncFont(canvas, context);\r\n        }\r\n        else\r\n        {\r\n            context.clearRect(0, 0, w, h);\r\n        }\r\n\r\n        context.save();\r\n\r\n        context.scale(resolution, resolution);\r\n\r\n        if (style.backgroundColor)\r\n        {\r\n            context.fillStyle = style.backgroundColor;\r\n            context.fillRect(0, 0, w, h);\r\n        }\r\n\r\n        style.syncStyle(canvas, context);\r\n\r\n        context.textBaseline = 'alphabetic';\r\n\r\n        //  Apply padding\r\n        context.translate(padding.left, padding.top);\r\n\r\n        var linePositionX;\r\n        var linePositionY;\r\n\r\n        //  Draw text line by line\r\n        for (var i = 0; i < textSize.lines; i++)\r\n        {\r\n            linePositionX = style.strokeThickness / 2;\r\n            linePositionY = (style.strokeThickness / 2 + i * textSize.lineHeight) + size.ascent;\r\n\r\n            if (i > 0)\r\n            {\r\n                linePositionY += (textSize.lineSpacing * i);\r\n            }\r\n\r\n            if (style.rtl)\r\n            {\r\n                linePositionX = w - linePositionX;\r\n            }\r\n            else if (style.align === 'right')\r\n            {\r\n                linePositionX += textWidth - textSize.lineWidths[i];\r\n            }\r\n            else if (style.align === 'center')\r\n            {\r\n                linePositionX += (textWidth - textSize.lineWidths[i]) / 2;\r\n            }\r\n            else if (style.align === 'justify')\r\n            {\r\n                //  To justify text line its width must be no less than 85% of defined width\r\n                var minimumLengthToApplyJustification = 0.85;\r\n\r\n                if (textSize.lineWidths[i] / textSize.width >= minimumLengthToApplyJustification)\r\n                {\r\n                    var extraSpace = textSize.width - textSize.lineWidths[i];\r\n                    var spaceSize = context.measureText(' ').width;\r\n                    var trimmedLine = lines[i].trim();\r\n                    var array = trimmedLine.split(' ');\r\n            \r\n                    extraSpace += (lines[i].length - trimmedLine.length) * spaceSize;\r\n            \r\n                    var extraSpaceCharacters = Math.floor(extraSpace / spaceSize);\r\n                    var idx = 0;\r\n\r\n                    while (extraSpaceCharacters > 0)\r\n                    {\r\n                        array[idx] += ' ';\r\n                        idx = (idx + 1) % (array.length - 1 || 1);\r\n                        --extraSpaceCharacters;\r\n                    }\r\n            \r\n                    lines[i] = array.join(' ');\r\n                }\r\n            }\r\n\r\n            if (this.autoRound)\r\n            {\r\n                linePositionX = Math.round(linePositionX);\r\n                linePositionY = Math.round(linePositionY);\r\n            }\r\n\r\n            if (style.strokeThickness)\r\n            {\r\n                this.style.syncShadow(context, style.shadowStroke);\r\n\r\n                context.strokeText(lines[i], linePositionX, linePositionY);\r\n            }\r\n\r\n            if (style.color)\r\n            {\r\n                this.style.syncShadow(context, style.shadowFill);\r\n\r\n                context.fillText(lines[i], linePositionX, linePositionY);\r\n            }\r\n        }\r\n\r\n        context.restore();\r\n\r\n        if (this.renderer.gl)\r\n        {\r\n            this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);\r\n\r\n            this.frame.glTexture = this.frame.source.glTexture;\r\n        }\r\n\r\n        this.dirty = true;\r\n\r\n        var input = this.input;\r\n\r\n        if (input && !input.customHitArea)\r\n        {\r\n            input.hitArea.width = this.width;\r\n            input.hitArea.height = this.height;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Get the current text metrics.\r\n     *\r\n     * @method Phaser.GameObjects.Text#getTextMetrics\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} The text metrics.\r\n     */\r\n    getTextMetrics: function ()\r\n    {\r\n        return this.style.getTextMetrics();\r\n    },\r\n\r\n    /**\r\n     * The text string being rendered by this Text Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#text\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\r\n    text: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._text;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.setText(value);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Build a JSON representation of the Text object.\r\n     *\r\n     * @method Phaser.GameObjects.Text#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Text object.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        var out = Components.ToJSON(this);\r\n\r\n        //  Extra Text data is added here\r\n\r\n        var data = {\r\n            autoRound: this.autoRound,\r\n            text: this._text,\r\n            style: this.style.toJSON(),\r\n            padding: {\r\n                left: this.padding.left,\r\n                right: this.padding.right,\r\n                top: this.padding.top,\r\n                bottom: this.padding.bottom\r\n            }\r\n        };\r\n\r\n        out.data = data;\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.Text#preDestroy\r\n     * @protected\r\n     * @since 3.0.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        if (this.style.rtl)\r\n        {\r\n            RemoveFromDOM(this.canvas);\r\n        }\r\n\r\n        CanvasPool.remove(this.canvas);\r\n\r\n        this.texture.destroy();\r\n    }\r\n\r\n    /**\r\n     * The horizontal origin of this Game Object.\r\n     * The origin maps the relationship between the size and position of the Game Object.\r\n     * The default value is 0.5, meaning all Game Objects are positioned based on their center.\r\n     * Setting the value to 0 means the position now relates to the left of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#originX\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n\r\n    /**\r\n     * The vertical origin of this Game Object.\r\n     * The origin maps the relationship between the size and position of the Game Object.\r\n     * The default value is 0.5, meaning all Game Objects are positioned based on their center.\r\n     * Setting the value to 0 means the position now relates to the top of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#originY\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n\r\n});\r\n\r\nmodule.exports = Text;\r\n"]},"metadata":{},"sourceType":"script"}