{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar CONST = require('./const');\n/**\r\n * Calculates and returns the horizontal overlap between two arcade physics bodies and sets their properties\r\n * accordingly, including: `touching.left`, `touching.right`, `touching.none` and `overlapX'.\r\n *\r\n * @function Phaser.Physics.Arcade.GetOverlapX\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to separate.\r\n * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to separate.\r\n * @param {boolean} overlapOnly - Is this an overlap only check, or part of separation?\r\n * @param {number} bias - A value added to the delta values during collision checks. Increase it to prevent sprite tunneling(sprites passing through another instead of colliding).\r\n *\r\n * @return {number} The amount of overlap.\r\n */\n\n\nvar GetOverlapX = function (body1, body2, overlapOnly, bias) {\n  var overlap = 0;\n  var maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + bias;\n\n  if (body1._dx === 0 && body2._dx === 0) {\n    //  They overlap but neither of them are moving\n    body1.embedded = true;\n    body2.embedded = true;\n  } else if (body1._dx > body2._dx) {\n    //  Body1 is moving right and / or Body2 is moving left\n    overlap = body1.right - body2.x;\n\n    if (overlap > maxOverlap && !overlapOnly || body1.checkCollision.right === false || body2.checkCollision.left === false) {\n      overlap = 0;\n    } else {\n      body1.touching.none = false;\n      body1.touching.right = true;\n      body2.touching.none = false;\n      body2.touching.left = true;\n\n      if (body2.physicsType === CONST.STATIC_BODY) {\n        body1.blocked.none = false;\n        body1.blocked.right = true;\n      }\n\n      if (body1.physicsType === CONST.STATIC_BODY) {\n        body2.blocked.none = false;\n        body2.blocked.left = true;\n      }\n    }\n  } else if (body1._dx < body2._dx) {\n    //  Body1 is moving left and/or Body2 is moving right\n    overlap = body1.x - body2.width - body2.x;\n\n    if (-overlap > maxOverlap && !overlapOnly || body1.checkCollision.left === false || body2.checkCollision.right === false) {\n      overlap = 0;\n    } else {\n      body1.touching.none = false;\n      body1.touching.left = true;\n      body2.touching.none = false;\n      body2.touching.right = true;\n\n      if (body2.physicsType === CONST.STATIC_BODY) {\n        body1.blocked.none = false;\n        body1.blocked.left = true;\n      }\n\n      if (body1.physicsType === CONST.STATIC_BODY) {\n        body2.blocked.none = false;\n        body2.blocked.right = true;\n      }\n    }\n  } //  Resets the overlapX to zero if there is no overlap, or to the actual pixel value if there is\n\n\n  body1.overlapX = overlap;\n  body2.overlapX = overlap;\n  return overlap;\n};\n\nmodule.exports = GetOverlapX;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/arcade/GetOverlapX.js"],"names":["CONST","require","GetOverlapX","body1","body2","overlapOnly","bias","overlap","maxOverlap","deltaAbsX","_dx","embedded","right","x","checkCollision","left","touching","none","physicsType","STATIC_BODY","blocked","width","overlapX","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * Calculates and returns the horizontal overlap between two arcade physics bodies and sets their properties\r\n * accordingly, including: `touching.left`, `touching.right`, `touching.none` and `overlapX'.\r\n *\r\n * @function Phaser.Physics.Arcade.GetOverlapX\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to separate.\r\n * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to separate.\r\n * @param {boolean} overlapOnly - Is this an overlap only check, or part of separation?\r\n * @param {number} bias - A value added to the delta values during collision checks. Increase it to prevent sprite tunneling(sprites passing through another instead of colliding).\r\n *\r\n * @return {number} The amount of overlap.\r\n */\r\nvar GetOverlapX = function (body1, body2, overlapOnly, bias)\r\n{\r\n    var overlap = 0;\r\n    var maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + bias;\r\n\r\n    if (body1._dx === 0 && body2._dx === 0)\r\n    {\r\n        //  They overlap but neither of them are moving\r\n        body1.embedded = true;\r\n        body2.embedded = true;\r\n    }\r\n    else if (body1._dx > body2._dx)\r\n    {\r\n        //  Body1 is moving right and / or Body2 is moving left\r\n        overlap = body1.right - body2.x;\r\n\r\n        if ((overlap > maxOverlap && !overlapOnly) || body1.checkCollision.right === false || body2.checkCollision.left === false)\r\n        {\r\n            overlap = 0;\r\n        }\r\n        else\r\n        {\r\n            body1.touching.none = false;\r\n            body1.touching.right = true;\r\n\r\n            body2.touching.none = false;\r\n            body2.touching.left = true;\r\n\r\n            if (body2.physicsType === CONST.STATIC_BODY)\r\n            {\r\n                body1.blocked.none = false;\r\n                body1.blocked.right = true;\r\n            }\r\n\r\n            if (body1.physicsType === CONST.STATIC_BODY)\r\n            {\r\n                body2.blocked.none = false;\r\n                body2.blocked.left = true;\r\n            }\r\n        }\r\n    }\r\n    else if (body1._dx < body2._dx)\r\n    {\r\n        //  Body1 is moving left and/or Body2 is moving right\r\n        overlap = body1.x - body2.width - body2.x;\r\n\r\n        if ((-overlap > maxOverlap && !overlapOnly) || body1.checkCollision.left === false || body2.checkCollision.right === false)\r\n        {\r\n            overlap = 0;\r\n        }\r\n        else\r\n        {\r\n            body1.touching.none = false;\r\n            body1.touching.left = true;\r\n\r\n            body2.touching.none = false;\r\n            body2.touching.right = true;\r\n\r\n            if (body2.physicsType === CONST.STATIC_BODY)\r\n            {\r\n                body1.blocked.none = false;\r\n                body1.blocked.left = true;\r\n            }\r\n\r\n            if (body1.physicsType === CONST.STATIC_BODY)\r\n            {\r\n                body2.blocked.none = false;\r\n                body2.blocked.right = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    //  Resets the overlapX to zero if there is no overlap, or to the actual pixel value if there is\r\n    body1.overlapX = overlap;\r\n    body2.overlapX = overlap;\r\n\r\n    return overlap;\r\n};\r\n\r\nmodule.exports = GetOverlapX;\r\n"]},"metadata":{},"sourceType":"script"}