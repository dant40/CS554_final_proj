{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar CONST = require('./const');\n/**\r\n * Calculates and returns the vertical overlap between two arcade physics bodies and sets their properties\r\n * accordingly, including: `touching.up`, `touching.down`, `touching.none` and `overlapY'.\r\n *\r\n * @function Phaser.Physics.Arcade.GetOverlapY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to separate.\r\n * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to separate.\r\n * @param {boolean} overlapOnly - Is this an overlap only check, or part of separation?\r\n * @param {number} bias - A value added to the delta values during collision checks. Increase it to prevent sprite tunneling(sprites passing through another instead of colliding).\r\n *\r\n * @return {number} The amount of overlap.\r\n */\n\n\nvar GetOverlapY = function (body1, body2, overlapOnly, bias) {\n  var overlap = 0;\n  var maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + bias;\n\n  if (body1._dy === 0 && body2._dy === 0) {\n    //  They overlap but neither of them are moving\n    body1.embedded = true;\n    body2.embedded = true;\n  } else if (body1._dy > body2._dy) {\n    //  Body1 is moving down and/or Body2 is moving up\n    overlap = body1.bottom - body2.y;\n\n    if (overlap > maxOverlap && !overlapOnly || body1.checkCollision.down === false || body2.checkCollision.up === false) {\n      overlap = 0;\n    } else {\n      body1.touching.none = false;\n      body1.touching.down = true;\n      body2.touching.none = false;\n      body2.touching.up = true;\n\n      if (body2.physicsType === CONST.STATIC_BODY) {\n        body1.blocked.none = false;\n        body1.blocked.down = true;\n      }\n\n      if (body1.physicsType === CONST.STATIC_BODY) {\n        body2.blocked.none = false;\n        body2.blocked.up = true;\n      }\n    }\n  } else if (body1._dy < body2._dy) {\n    //  Body1 is moving up and/or Body2 is moving down\n    overlap = body1.y - body2.bottom;\n\n    if (-overlap > maxOverlap && !overlapOnly || body1.checkCollision.up === false || body2.checkCollision.down === false) {\n      overlap = 0;\n    } else {\n      body1.touching.none = false;\n      body1.touching.up = true;\n      body2.touching.none = false;\n      body2.touching.down = true;\n\n      if (body2.physicsType === CONST.STATIC_BODY) {\n        body1.blocked.none = false;\n        body1.blocked.up = true;\n      }\n\n      if (body1.physicsType === CONST.STATIC_BODY) {\n        body2.blocked.none = false;\n        body2.blocked.down = true;\n      }\n    }\n  } //  Resets the overlapY to zero if there is no overlap, or to the actual pixel value if there is\n\n\n  body1.overlapY = overlap;\n  body2.overlapY = overlap;\n  return overlap;\n};\n\nmodule.exports = GetOverlapY;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/arcade/GetOverlapY.js"],"names":["CONST","require","GetOverlapY","body1","body2","overlapOnly","bias","overlap","maxOverlap","deltaAbsY","_dy","embedded","bottom","y","checkCollision","down","up","touching","none","physicsType","STATIC_BODY","blocked","overlapY","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * Calculates and returns the vertical overlap between two arcade physics bodies and sets their properties\r\n * accordingly, including: `touching.up`, `touching.down`, `touching.none` and `overlapY'.\r\n *\r\n * @function Phaser.Physics.Arcade.GetOverlapY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to separate.\r\n * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to separate.\r\n * @param {boolean} overlapOnly - Is this an overlap only check, or part of separation?\r\n * @param {number} bias - A value added to the delta values during collision checks. Increase it to prevent sprite tunneling(sprites passing through another instead of colliding).\r\n *\r\n * @return {number} The amount of overlap.\r\n */\r\nvar GetOverlapY = function (body1, body2, overlapOnly, bias)\r\n{\r\n    var overlap = 0;\r\n    var maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + bias;\r\n\r\n    if (body1._dy === 0 && body2._dy === 0)\r\n    {\r\n        //  They overlap but neither of them are moving\r\n        body1.embedded = true;\r\n        body2.embedded = true;\r\n    }\r\n    else if (body1._dy > body2._dy)\r\n    {\r\n        //  Body1 is moving down and/or Body2 is moving up\r\n        overlap = body1.bottom - body2.y;\r\n\r\n        if ((overlap > maxOverlap && !overlapOnly) || body1.checkCollision.down === false || body2.checkCollision.up === false)\r\n        {\r\n            overlap = 0;\r\n        }\r\n        else\r\n        {\r\n            body1.touching.none = false;\r\n            body1.touching.down = true;\r\n\r\n            body2.touching.none = false;\r\n            body2.touching.up = true;\r\n\r\n            if (body2.physicsType === CONST.STATIC_BODY)\r\n            {\r\n                body1.blocked.none = false;\r\n                body1.blocked.down = true;\r\n            }\r\n\r\n            if (body1.physicsType === CONST.STATIC_BODY)\r\n            {\r\n                body2.blocked.none = false;\r\n                body2.blocked.up = true;\r\n            }\r\n        }\r\n    }\r\n    else if (body1._dy < body2._dy)\r\n    {\r\n        //  Body1 is moving up and/or Body2 is moving down\r\n        overlap = body1.y - body2.bottom;\r\n\r\n        if ((-overlap > maxOverlap && !overlapOnly) || body1.checkCollision.up === false || body2.checkCollision.down === false)\r\n        {\r\n            overlap = 0;\r\n        }\r\n        else\r\n        {\r\n            body1.touching.none = false;\r\n            body1.touching.up = true;\r\n\r\n            body2.touching.none = false;\r\n            body2.touching.down = true;\r\n\r\n            if (body2.physicsType === CONST.STATIC_BODY)\r\n            {\r\n                body1.blocked.none = false;\r\n                body1.blocked.up = true;\r\n            }\r\n\r\n            if (body1.physicsType === CONST.STATIC_BODY)\r\n            {\r\n                body2.blocked.none = false;\r\n                body2.blocked.down = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    //  Resets the overlapY to zero if there is no overlap, or to the actual pixel value if there is\r\n    body1.overlapY = overlap;\r\n    body2.overlapY = overlap;\r\n\r\n    return overlap;\r\n};\r\n\r\nmodule.exports = GetOverlapY;\r\n"]},"metadata":{},"sourceType":"script"}