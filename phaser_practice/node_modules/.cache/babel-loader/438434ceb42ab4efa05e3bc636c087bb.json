{"ast":null,"code":"/**\r\n * @author       Florian Vazelle\r\n * @author       Geoffrey Glaive\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Point = require('../point/Point');\n\nvar CircleToCircle = require('./CircleToCircle');\n/**\r\n * Checks if two Circles intersect and returns the intersection points as a Point object array.\r\n *\r\n * @function Phaser.Geom.Intersects.GetCircleToCircle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circleA - The first Circle to check for intersection.\r\n * @param {Phaser.Geom.Circle} circleB - The second Circle to check for intersection.\r\n * @param {array} [out] - An optional array in which to store the points of intersection.\r\n *\r\n * @return {array} An array with the points of intersection if objects intersect, otherwise an empty array.\r\n */\n\n\nvar GetCircleToCircle = function (circleA, circleB, out) {\n  if (out === undefined) {\n    out = [];\n  }\n\n  if (CircleToCircle(circleA, circleB)) {\n    var x0 = circleA.x;\n    var y0 = circleA.y;\n    var r0 = circleA.radius;\n    var x1 = circleB.x;\n    var y1 = circleB.y;\n    var r1 = circleB.radius;\n    var coefficientA, coefficientB, coefficientC, lambda, x;\n\n    if (y0 === y1) {\n      x = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0) / (2 * (x0 - x1));\n      coefficientA = 1;\n      coefficientB = -2 * y1;\n      coefficientC = x1 * x1 + x * x - 2 * x1 * x + y1 * y1 - r1 * r1;\n      lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;\n\n      if (lambda === 0) {\n        out.push(new Point(x, -coefficientB / (2 * coefficientA)));\n      } else if (lambda > 0) {\n        out.push(new Point(x, (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA)));\n        out.push(new Point(x, (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA)));\n      }\n    } else {\n      var v1 = (x0 - x1) / (y0 - y1);\n      var n = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0 - y1 * y1 + y0 * y0) / (2 * (y0 - y1));\n      coefficientA = v1 * v1 + 1;\n      coefficientB = 2 * y0 * v1 - 2 * n * v1 - 2 * x0;\n      coefficientC = x0 * x0 + y0 * y0 + n * n - r0 * r0 - 2 * y0 * n;\n      lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;\n\n      if (lambda === 0) {\n        x = -coefficientB / (2 * coefficientA);\n        out.push(new Point(x, n - x * v1));\n      } else if (lambda > 0) {\n        x = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);\n        out.push(new Point(x, n - x * v1));\n        x = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);\n        out.push(new Point(x, n - x * v1));\n      }\n    }\n  }\n\n  return out;\n};\n\nmodule.exports = GetCircleToCircle;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/geom/intersects/GetCircleToCircle.js"],"names":["Point","require","CircleToCircle","GetCircleToCircle","circleA","circleB","out","undefined","x0","x","y0","y","r0","radius","x1","y1","r1","coefficientA","coefficientB","coefficientC","lambda","push","Math","sqrt","v1","n","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Florian Vazelle\r\n * @author       Geoffrey Glaive\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\nvar CircleToCircle = require('./CircleToCircle');\r\n\r\n/**\r\n * Checks if two Circles intersect and returns the intersection points as a Point object array.\r\n *\r\n * @function Phaser.Geom.Intersects.GetCircleToCircle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circleA - The first Circle to check for intersection.\r\n * @param {Phaser.Geom.Circle} circleB - The second Circle to check for intersection.\r\n * @param {array} [out] - An optional array in which to store the points of intersection.\r\n *\r\n * @return {array} An array with the points of intersection if objects intersect, otherwise an empty array.\r\n */\r\nvar GetCircleToCircle = function (circleA, circleB, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    if (CircleToCircle(circleA, circleB))\r\n    {\r\n        var x0 = circleA.x;\r\n        var y0 = circleA.y;\r\n        var r0 = circleA.radius;\r\n\r\n        var x1 = circleB.x;\r\n        var y1 = circleB.y;\r\n        var r1 = circleB.radius;\r\n\r\n        var coefficientA, coefficientB, coefficientC, lambda, x;\r\n\r\n        if (y0 === y1)\r\n        {\r\n            x = ((r1 * r1) - (r0 * r0) - (x1 * x1) + (x0 * x0)) / (2 * (x0 - x1));\r\n\r\n            coefficientA = 1;\r\n            coefficientB = -2 * y1;\r\n            coefficientC = (x1 * x1) + (x * x) - (2 * x1 * x) + (y1 * y1) - (r1 * r1);\r\n\r\n            lambda = (coefficientB * coefficientB) - (4 * coefficientA * coefficientC);\r\n\r\n            if (lambda === 0)\r\n            {\r\n                out.push(new Point(x, (-coefficientB / (2 * coefficientA))));\r\n            }\r\n            else if (lambda > 0)\r\n            {\r\n                out.push(new Point(x, (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA)));\r\n                out.push(new Point(x, (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA)));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var v1 = (x0 - x1) / (y0 - y1);\r\n            var n = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0 - y1 * y1 + y0 * y0) / (2 * (y0 - y1));\r\n\r\n            coefficientA = (v1 * v1) + 1;\r\n            coefficientB = (2 * y0 * v1) - (2 * n * v1) - (2 * x0);\r\n            coefficientC = (x0 * x0) + (y0 * y0) + (n * n) - (r0 * r0) - (2 * y0 * n);\r\n\r\n            lambda = (coefficientB * coefficientB) - (4 * coefficientA * coefficientC);\r\n\r\n            if (lambda === 0)\r\n            {\r\n                x = (-coefficientB / (2 * coefficientA));\r\n                out.push(new Point(x, (n - (x * v1))));\r\n            }\r\n            else if (lambda > 0)\r\n            {\r\n                x = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);\r\n                out.push(new Point(x, (n - (x * v1))));\r\n                x = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);\r\n                out.push(new Point(x, (n - (x * v1))));\r\n            }\r\n        }\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetCircleToCircle;\r\n"]},"metadata":{},"sourceType":"script"}