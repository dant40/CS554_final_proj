{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar Clamp = require('../math/Clamp');\n\nvar Color = require('../display/color/Color');\n\nvar CONST = require('../const');\n\nvar IsSizePowerOfTwo = require('../math/pow2/IsSizePowerOfTwo');\n\nvar Texture = require('./Texture');\n/**\r\n * @classdesc\r\n * A Canvas Texture is a special kind of Texture that is backed by an HTML Canvas Element as its source.\r\n *\r\n * You can use the properties of this texture to draw to the canvas element directly, using all of the standard\r\n * canvas operations available in the browser. Any Game Object can be given this texture and will render with it.\r\n *\r\n * Note: When running under WebGL the Canvas Texture needs to re-generate its base WebGLTexture and reupload it to\r\n * the GPU every time you modify it, otherwise the changes you make to this texture will not be visible. To do this\r\n * you should call `CanvasTexture.refresh()` once you are finished with your changes to the canvas. Try and keep\r\n * this to a minimum, especially on large canvas sizes, or you may inadvertently thrash the GPU by constantly uploading\r\n * texture data to it. This restriction does not apply if using the Canvas Renderer.\r\n * \r\n * It starts with only one frame that covers the whole of the canvas. You can add further frames, that specify\r\n * sections of the canvas using the `add` method.\r\n * \r\n * Should you need to resize the canvas use the `setSize` method so that it accurately updates all of the underlying\r\n * texture data as well. Forgetting to do this (i.e. by changing the canvas size directly from your code) could cause\r\n * graphical errors.\r\n *\r\n * @class CanvasTexture\r\n * @extends Phaser.Textures.Texture\r\n * @memberof Phaser.Textures\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Textures.TextureManager} manager - A reference to the Texture Manager this Texture belongs to.\r\n * @param {string} key - The unique string-based key of this Texture.\r\n * @param {HTMLCanvasElement} source - The canvas element that is used as the base of this texture.\r\n * @param {integer} width - The width of the canvas.\r\n * @param {integer} height - The height of the canvas.\r\n */\n\n\nvar CanvasTexture = new Class({\n  Extends: Texture,\n  initialize: function CanvasTexture(manager, key, source, width, height) {\n    Texture.call(this, manager, key, source, width, height);\n    this.add('__BASE', 0, 0, 0, width, height);\n    /**\r\n     * A reference to the Texture Source of this Canvas.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#_source\r\n     * @type {Phaser.Textures.TextureSource}\r\n     * @private\r\n     * @since 3.7.0\r\n     */\n\n    this._source = this.frames['__BASE'].source;\n    /**\r\n     * The source Canvas Element.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#canvas\r\n     * @readonly\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.7.0\r\n     */\n\n    this.canvas = this._source.image;\n    /**\r\n     * The 2D Canvas Rendering Context.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#context\r\n     * @readonly\r\n     * @type {CanvasRenderingContext2D}\r\n     * @since 3.7.0\r\n     */\n\n    this.context = this.canvas.getContext('2d');\n    /**\r\n     * The width of the Canvas.\r\n     * This property is read-only, if you wish to change it use the `setSize` method.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#width\r\n     * @readonly\r\n     * @type {integer}\r\n     * @since 3.7.0\r\n     */\n\n    this.width = width;\n    /**\r\n     * The height of the Canvas.\r\n     * This property is read-only, if you wish to change it use the `setSize` method.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#height\r\n     * @readonly\r\n     * @type {integer}\r\n     * @since 3.7.0\r\n     */\n\n    this.height = height;\n    /**\r\n     * The context image data.\r\n     * Use the `update` method to populate this when the canvas changes.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#imageData\r\n     * @type {ImageData}\r\n     * @since 3.13.0\r\n     */\n\n    this.imageData = this.context.getImageData(0, 0, width, height);\n    /**\r\n     * A Uint8ClampedArray view into the `buffer`.\r\n     * Use the `update` method to populate this when the canvas changes.\r\n     * Note that this is unavailable in some browsers, such as Epic Browser, due to their security restrictions.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#data\r\n     * @type {Uint8ClampedArray}\r\n     * @since 3.13.0\r\n     */\n\n    this.data = null;\n\n    if (this.imageData) {\n      this.data = this.imageData.data;\n    }\n    /**\r\n     * An Uint32Array view into the `buffer`.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#pixels\r\n     * @type {Uint32Array}\r\n     * @since 3.13.0\r\n     */\n\n\n    this.pixels = null;\n    /**\r\n     * An ArrayBuffer the same size as the context ImageData.\r\n     *\r\n     * @name Phaser.Textures.CanvasTexture#buffer\r\n     * @type {ArrayBuffer}\r\n     * @since 3.13.0\r\n     */\n\n    this.buffer;\n\n    if (this.data) {\n      if (this.imageData.data.buffer) {\n        this.buffer = this.imageData.data.buffer;\n        this.pixels = new Uint32Array(this.buffer);\n      } else if (window.ArrayBuffer) {\n        this.buffer = new ArrayBuffer(this.imageData.data.length);\n        this.pixels = new Uint32Array(this.buffer);\n      } else {\n        this.pixels = this.imageData.data;\n      }\n    }\n  },\n\n  /**\r\n   * This re-creates the `imageData` from the current context.\r\n   * It then re-builds the ArrayBuffer, the `data` Uint8ClampedArray reference and the `pixels` Int32Array.\r\n   *\r\n   * Warning: This is a very expensive operation, so use it sparingly.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#update\r\n   * @since 3.13.0\r\n   *\r\n   * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n   */\n  update: function () {\n    this.imageData = this.context.getImageData(0, 0, this.width, this.height);\n    this.data = this.imageData.data;\n\n    if (this.imageData.data.buffer) {\n      this.buffer = this.imageData.data.buffer;\n      this.pixels = new Uint32Array(this.buffer);\n    } else if (window.ArrayBuffer) {\n      this.buffer = new ArrayBuffer(this.imageData.data.length);\n      this.pixels = new Uint32Array(this.buffer);\n    } else {\n      this.pixels = this.imageData.data;\n    }\n\n    if (this.manager.game.config.renderType === CONST.WEBGL) {\n      this.refresh();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Draws the given Image or Canvas element to this CanvasTexture, then updates the internal\r\n   * ImageData buffer and arrays.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#draw\r\n   * @since 3.13.0\r\n   * \r\n   * @param {integer} x - The x coordinate to draw the source at.\r\n   * @param {integer} y - The y coordinate to draw the source at.\r\n   * @param {(HTMLImageElement|HTMLCanvasElement)} source - The element to draw to this canvas.\r\n   * \r\n   * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n   */\n  draw: function (x, y, source) {\n    this.context.drawImage(source, x, y);\n    return this.update();\n  },\n\n  /**\r\n   * Draws the given texture frame to this CanvasTexture, then updates the internal\r\n   * ImageData buffer and arrays.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#drawFrame\r\n   * @since 3.16.0\r\n   * \r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {(string|integer)} [frame] - The string-based name, or integer based index, of the Frame to get from the Texture.\r\n   * @param {integer} [x=0] - The x coordinate to draw the source at.\r\n   * @param {integer} [y=0] - The y coordinate to draw the source at.\r\n   * \r\n   * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n   */\n  drawFrame: function (key, frame, x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    var textureFrame = this.manager.getFrame(key, frame);\n\n    if (textureFrame) {\n      var cd = textureFrame.canvasData;\n      var width = textureFrame.cutWidth;\n      var height = textureFrame.cutHeight;\n      var res = textureFrame.source.resolution;\n      this.context.drawImage(textureFrame.source.image, cd.x, cd.y, width, height, x, y, width / res, height / res);\n      return this.update();\n    } else {\n      return this;\n    }\n  },\n\n  /**\r\n   * Sets a pixel in the CanvasTexture to the given color and alpha values.\r\n   *\r\n   * This is an expensive operation to run in large quantities, so use sparingly.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#setPixel\r\n   * @since 3.16.0\r\n   * \r\n   * @param {integer} x - The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} y - The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} red - The red color value. A number between 0 and 255.\r\n   * @param {integer} green - The green color value. A number between 0 and 255.\r\n   * @param {integer} blue - The blue color value. A number between 0 and 255.\r\n   * @param {integer} [alpha=255] - The alpha value. A number between 0 and 255.\r\n   * \r\n   * @return {this} This CanvasTexture.\r\n   */\n  setPixel: function (x, y, red, green, blue, alpha) {\n    if (alpha === undefined) {\n      alpha = 255;\n    }\n\n    x = Math.abs(Math.floor(x));\n    y = Math.abs(Math.floor(y));\n    var index = this.getIndex(x, y);\n\n    if (index > -1) {\n      var imageData = this.context.getImageData(x, y, 1, 1);\n      imageData.data[0] = red;\n      imageData.data[1] = green;\n      imageData.data[2] = blue;\n      imageData.data[3] = alpha;\n      this.context.putImageData(imageData, x, y);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Puts the ImageData into the context of this CanvasTexture at the given coordinates.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#putData\r\n   * @since 3.16.0\r\n   * \r\n   * @param {ImageData} imageData - The ImageData to put at the given location.\r\n   * @param {integer} x - The x coordinate to put the imageData. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} y - The y coordinate to put the imageData. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} [dirtyX=0] - Horizontal position (x coordinate) of the top-left corner from which the image data will be extracted.\r\n   * @param {integer} [dirtyY=0] - Vertical position (x coordinate) of the top-left corner from which the image data will be extracted.\r\n   * @param {integer} [dirtyWidth] - Width of the rectangle to be painted. Defaults to the width of the image data.\r\n   * @param {integer} [dirtyHeight] - Height of the rectangle to be painted. Defaults to the height of the image data.\r\n   * \r\n   * @return {this} This CanvasTexture.\r\n   */\n  putData: function (imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {\n    if (dirtyX === undefined) {\n      dirtyX = 0;\n    }\n\n    if (dirtyY === undefined) {\n      dirtyY = 0;\n    }\n\n    if (dirtyWidth === undefined) {\n      dirtyWidth = imageData.width;\n    }\n\n    if (dirtyHeight === undefined) {\n      dirtyHeight = imageData.height;\n    }\n\n    this.context.putImageData(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\n    return this;\n  },\n\n  /**\r\n   * Gets an ImageData region from this CanvasTexture from the position and size specified.\r\n   * You can write this back using `CanvasTexture.putData`, or manipulate it.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#getData\r\n   * @since 3.16.0\r\n   * \r\n   * @param {integer} x - The x coordinate of the top-left of the area to get the ImageData from. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} y - The y coordinate of the top-left of the area to get the ImageData from. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} width - The width of the rectangle from which the ImageData will be extracted. Positive values are to the right, and negative to the left.\r\n   * @param {integer} height - The height of the rectangle from which the ImageData will be extracted. Positive values are down, and negative are up.\r\n   * \r\n   * @return {ImageData} The ImageData extracted from this CanvasTexture.\r\n   */\n  getData: function (x, y, width, height) {\n    x = Clamp(Math.floor(x), 0, this.width - 1);\n    y = Clamp(Math.floor(y), 0, this.height - 1);\n    width = Clamp(width, 1, this.width - x);\n    height = Clamp(height, 1, this.height - y);\n    var imageData = this.context.getImageData(x, y, width, height);\n    return imageData;\n  },\n\n  /**\r\n   * Get the color of a specific pixel from this texture and store it in a Color object.\r\n   * \r\n   * If you have drawn anything to this CanvasTexture since it was created you must call `CanvasTexture.update` to refresh the array buffer,\r\n   * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#getPixel\r\n   * @since 3.13.0\r\n   * \r\n   * @param {integer} x - The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} y - The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {Phaser.Display.Color} [out] - A Color object to store the pixel values in. If not provided a new Color object will be created.\r\n   * \r\n   * @return {Phaser.Display.Color} An object with the red, green, blue and alpha values set in the r, g, b and a properties.\r\n   */\n  getPixel: function (x, y, out) {\n    if (!out) {\n      out = new Color();\n    }\n\n    var index = this.getIndex(x, y);\n\n    if (index > -1) {\n      var data = this.data;\n      var r = data[index + 0];\n      var g = data[index + 1];\n      var b = data[index + 2];\n      var a = data[index + 3];\n      out.setTo(r, g, b, a);\n    }\n\n    return out;\n  },\n\n  /**\r\n   * Returns an array containing all of the pixels in the given region.\r\n   *\r\n   * If the requested region extends outside the bounds of this CanvasTexture,\r\n   * the region is truncated to fit.\r\n   * \r\n   * If you have drawn anything to this CanvasTexture since it was created you must call `CanvasTexture.update` to refresh the array buffer,\r\n   * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#getPixels\r\n   * @since 3.16.0\r\n   * \r\n   * @param {integer} [x=0] - The x coordinate of the top-left of the region. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} [y=0] - The y coordinate of the top-left of the region. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} [width] - The width of the region to get. Must be an integer. Defaults to the canvas width if not given.\r\n   * @param {integer} [height] - The height of the region to get. Must be an integer. If not given will be set to the `width`.\r\n   * \r\n   * @return {Phaser.Types.Textures.PixelConfig[]} An array of Pixel objects.\r\n   */\n  getPixels: function (x, y, width, height) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = this.width;\n    }\n\n    if (height === undefined) {\n      height = width;\n    }\n\n    x = Math.abs(Math.round(x));\n    y = Math.abs(Math.round(y));\n    var left = Clamp(x, 0, this.width);\n    var right = Clamp(x + width, 0, this.width);\n    var top = Clamp(y, 0, this.height);\n    var bottom = Clamp(y + height, 0, this.height);\n    var pixel = new Color();\n    var out = [];\n\n    for (var py = top; py < bottom; py++) {\n      var row = [];\n\n      for (var px = left; px < right; px++) {\n        pixel = this.getPixel(px, py, pixel);\n        row.push({\n          x: px,\n          y: py,\n          color: pixel.color,\n          alpha: pixel.alphaGL\n        });\n      }\n\n      out.push(row);\n    }\n\n    return out;\n  },\n\n  /**\r\n   * Returns the Image Data index for the given pixel in this CanvasTexture.\r\n   *\r\n   * The index can be used to read directly from the `this.data` array.\r\n   *\r\n   * The index points to the red value in the array. The subsequent 3 indexes\r\n   * point to green, blue and alpha respectively.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#getIndex\r\n   * @since 3.16.0\r\n   * \r\n   * @param {integer} x - The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * @param {integer} y - The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n   * \r\n   * @return {integer} \r\n   */\n  getIndex: function (x, y) {\n    x = Math.abs(Math.round(x));\n    y = Math.abs(Math.round(y));\n\n    if (x < this.width && y < this.height) {\n      return (x + y * this.width) * 4;\n    } else {\n      return -1;\n    }\n  },\n\n  /**\r\n   * This should be called manually if you are running under WebGL.\r\n   * It will refresh the WebGLTexture from the Canvas source. Only call this if you know that the\r\n   * canvas has changed, as there is a significant GPU texture allocation cost involved in doing so.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#refresh\r\n   * @since 3.7.0\r\n   *\r\n   * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n   */\n  refresh: function () {\n    this._source.update();\n\n    return this;\n  },\n\n  /**\r\n   * Gets the Canvas Element.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#getCanvas\r\n   * @since 3.7.0\r\n   *\r\n   * @return {HTMLCanvasElement} The Canvas DOM element this texture is using.\r\n   */\n  getCanvas: function () {\n    return this.canvas;\n  },\n\n  /**\r\n   * Gets the 2D Canvas Rendering Context.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#getContext\r\n   * @since 3.7.0\r\n   *\r\n   * @return {CanvasRenderingContext2D} The Canvas Rendering Context this texture is using.\r\n   */\n  getContext: function () {\n    return this.context;\n  },\n\n  /**\r\n   * Clears the given region of this Canvas Texture, resetting it back to transparent.\r\n   * If no region is given, the whole Canvas Texture is cleared.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#clear\r\n   * @since 3.7.0\r\n   * \r\n   * @param {integer} [x=0] - The x coordinate of the top-left of the region to clear.\r\n   * @param {integer} [y=0] - The y coordinate of the top-left of the region to clear.\r\n   * @param {integer} [width] - The width of the region.\r\n   * @param {integer} [height] - The height of the region.\r\n   *\r\n   * @return {Phaser.Textures.CanvasTexture} The Canvas Texture.\r\n   */\n  clear: function (x, y, width, height) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = this.width;\n    }\n\n    if (height === undefined) {\n      height = this.height;\n    }\n\n    this.context.clearRect(x, y, width, height);\n    return this.update();\n  },\n\n  /**\r\n   * Changes the size of this Canvas Texture.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#setSize\r\n   * @since 3.7.0\r\n   *\r\n   * @param {integer} width - The new width of the Canvas.\r\n   * @param {integer} [height] - The new height of the Canvas. If not given it will use the width as the height.\r\n   *\r\n   * @return {Phaser.Textures.CanvasTexture} The Canvas Texture.\r\n   */\n  setSize: function (width, height) {\n    if (height === undefined) {\n      height = width;\n    }\n\n    if (width !== this.width || height !== this.height) {\n      //  Update the Canvas\n      this.canvas.width = width;\n      this.canvas.height = height; //  Update the Texture Source\n\n      this._source.width = width;\n      this._source.height = height;\n      this._source.isPowerOf2 = IsSizePowerOfTwo(width, height); //  Update the Frame\n\n      this.frames['__BASE'].setSize(width, height, 0, 0);\n      this.refresh();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Destroys this Texture and releases references to its sources and frames.\r\n   *\r\n   * @method Phaser.Textures.CanvasTexture#destroy\r\n   * @since 3.16.0\r\n   */\n  destroy: function () {\n    Texture.prototype.destroy.call(this);\n    this._source = null;\n    this.canvas = null;\n    this.context = null;\n    this.imageData = null;\n    this.data = null;\n    this.pixels = null;\n    this.buffer = null;\n  }\n});\nmodule.exports = CanvasTexture;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/textures/CanvasTexture.js"],"names":["Class","require","Clamp","Color","CONST","IsSizePowerOfTwo","Texture","CanvasTexture","Extends","initialize","manager","key","source","width","height","call","add","_source","frames","canvas","image","context","getContext","imageData","getImageData","data","pixels","buffer","Uint32Array","window","ArrayBuffer","length","update","game","config","renderType","WEBGL","refresh","draw","x","y","drawImage","drawFrame","frame","undefined","textureFrame","getFrame","cd","canvasData","cutWidth","cutHeight","res","resolution","setPixel","red","green","blue","alpha","Math","abs","floor","index","getIndex","putImageData","putData","dirtyX","dirtyY","dirtyWidth","dirtyHeight","getData","getPixel","out","r","g","b","a","setTo","getPixels","round","left","right","top","bottom","pixel","py","row","px","push","color","alphaGL","getCanvas","clear","clearRect","setSize","isPowerOf2","destroy","prototype","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar Clamp = require('../math/Clamp');\r\nvar Color = require('../display/color/Color');\r\nvar CONST = require('../const');\r\nvar IsSizePowerOfTwo = require('../math/pow2/IsSizePowerOfTwo');\r\nvar Texture = require('./Texture');\r\n\r\n/**\r\n * @classdesc\r\n * A Canvas Texture is a special kind of Texture that is backed by an HTML Canvas Element as its source.\r\n *\r\n * You can use the properties of this texture to draw to the canvas element directly, using all of the standard\r\n * canvas operations available in the browser. Any Game Object can be given this texture and will render with it.\r\n *\r\n * Note: When running under WebGL the Canvas Texture needs to re-generate its base WebGLTexture and reupload it to\r\n * the GPU every time you modify it, otherwise the changes you make to this texture will not be visible. To do this\r\n * you should call `CanvasTexture.refresh()` once you are finished with your changes to the canvas. Try and keep\r\n * this to a minimum, especially on large canvas sizes, or you may inadvertently thrash the GPU by constantly uploading\r\n * texture data to it. This restriction does not apply if using the Canvas Renderer.\r\n * \r\n * It starts with only one frame that covers the whole of the canvas. You can add further frames, that specify\r\n * sections of the canvas using the `add` method.\r\n * \r\n * Should you need to resize the canvas use the `setSize` method so that it accurately updates all of the underlying\r\n * texture data as well. Forgetting to do this (i.e. by changing the canvas size directly from your code) could cause\r\n * graphical errors.\r\n *\r\n * @class CanvasTexture\r\n * @extends Phaser.Textures.Texture\r\n * @memberof Phaser.Textures\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Textures.TextureManager} manager - A reference to the Texture Manager this Texture belongs to.\r\n * @param {string} key - The unique string-based key of this Texture.\r\n * @param {HTMLCanvasElement} source - The canvas element that is used as the base of this texture.\r\n * @param {integer} width - The width of the canvas.\r\n * @param {integer} height - The height of the canvas.\r\n */\r\nvar CanvasTexture = new Class({\r\n\r\n    Extends: Texture,\r\n\r\n    initialize:\r\n\r\n    function CanvasTexture (manager, key, source, width, height)\r\n    {\r\n        Texture.call(this, manager, key, source, width, height);\r\n\r\n        this.add('__BASE', 0, 0, 0, width, height);\r\n\r\n        /**\r\n         * A reference to the Texture Source of this Canvas.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#_source\r\n         * @type {Phaser.Textures.TextureSource}\r\n         * @private\r\n         * @since 3.7.0\r\n         */\r\n        this._source = this.frames['__BASE'].source;\r\n\r\n        /**\r\n         * The source Canvas Element.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#canvas\r\n         * @readonly\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.7.0\r\n         */\r\n        this.canvas = this._source.image;\r\n\r\n        /**\r\n         * The 2D Canvas Rendering Context.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#context\r\n         * @readonly\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.7.0\r\n         */\r\n        this.context = this.canvas.getContext('2d');\r\n\r\n        /**\r\n         * The width of the Canvas.\r\n         * This property is read-only, if you wish to change it use the `setSize` method.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#width\r\n         * @readonly\r\n         * @type {integer}\r\n         * @since 3.7.0\r\n         */\r\n        this.width = width;\r\n\r\n        /**\r\n         * The height of the Canvas.\r\n         * This property is read-only, if you wish to change it use the `setSize` method.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#height\r\n         * @readonly\r\n         * @type {integer}\r\n         * @since 3.7.0\r\n         */\r\n        this.height = height;\r\n\r\n        /**\r\n         * The context image data.\r\n         * Use the `update` method to populate this when the canvas changes.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#imageData\r\n         * @type {ImageData}\r\n         * @since 3.13.0\r\n         */\r\n        this.imageData = this.context.getImageData(0, 0, width, height);\r\n\r\n        /**\r\n         * A Uint8ClampedArray view into the `buffer`.\r\n         * Use the `update` method to populate this when the canvas changes.\r\n         * Note that this is unavailable in some browsers, such as Epic Browser, due to their security restrictions.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#data\r\n         * @type {Uint8ClampedArray}\r\n         * @since 3.13.0\r\n         */\r\n        this.data = null;\r\n\r\n        if (this.imageData)\r\n        {\r\n            this.data = this.imageData.data;\r\n        }\r\n\r\n        /**\r\n         * An Uint32Array view into the `buffer`.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#pixels\r\n         * @type {Uint32Array}\r\n         * @since 3.13.0\r\n         */\r\n        this.pixels = null;\r\n\r\n        /**\r\n         * An ArrayBuffer the same size as the context ImageData.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#buffer\r\n         * @type {ArrayBuffer}\r\n         * @since 3.13.0\r\n         */\r\n        this.buffer;\r\n\r\n        if (this.data)\r\n        {\r\n            if (this.imageData.data.buffer)\r\n            {\r\n                this.buffer = this.imageData.data.buffer;\r\n                this.pixels = new Uint32Array(this.buffer);\r\n            }\r\n            else if (window.ArrayBuffer)\r\n            {\r\n                this.buffer = new ArrayBuffer(this.imageData.data.length);\r\n                this.pixels = new Uint32Array(this.buffer);\r\n            }\r\n            else\r\n            {\r\n                this.pixels = this.imageData.data;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * This re-creates the `imageData` from the current context.\r\n     * It then re-builds the ArrayBuffer, the `data` Uint8ClampedArray reference and the `pixels` Int32Array.\r\n     *\r\n     * Warning: This is a very expensive operation, so use it sparingly.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#update\r\n     * @since 3.13.0\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n     */\r\n    update: function ()\r\n    {\r\n        this.imageData = this.context.getImageData(0, 0, this.width, this.height);\r\n\r\n        this.data = this.imageData.data;\r\n\r\n        if (this.imageData.data.buffer)\r\n        {\r\n            this.buffer = this.imageData.data.buffer;\r\n            this.pixels = new Uint32Array(this.buffer);\r\n        }\r\n        else if (window.ArrayBuffer)\r\n        {\r\n            this.buffer = new ArrayBuffer(this.imageData.data.length);\r\n            this.pixels = new Uint32Array(this.buffer);\r\n        }\r\n        else\r\n        {\r\n            this.pixels = this.imageData.data;\r\n        }\r\n\r\n        if (this.manager.game.config.renderType === CONST.WEBGL)\r\n        {\r\n            this.refresh();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the given Image or Canvas element to this CanvasTexture, then updates the internal\r\n     * ImageData buffer and arrays.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#draw\r\n     * @since 3.13.0\r\n     * \r\n     * @param {integer} x - The x coordinate to draw the source at.\r\n     * @param {integer} y - The y coordinate to draw the source at.\r\n     * @param {(HTMLImageElement|HTMLCanvasElement)} source - The element to draw to this canvas.\r\n     * \r\n     * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n     */\r\n    draw: function (x, y, source)\r\n    {\r\n        this.context.drawImage(source, x, y);\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * Draws the given texture frame to this CanvasTexture, then updates the internal\r\n     * ImageData buffer and arrays.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#drawFrame\r\n     * @since 3.16.0\r\n     * \r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|integer)} [frame] - The string-based name, or integer based index, of the Frame to get from the Texture.\r\n     * @param {integer} [x=0] - The x coordinate to draw the source at.\r\n     * @param {integer} [y=0] - The y coordinate to draw the source at.\r\n     * \r\n     * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n     */\r\n    drawFrame: function (key, frame, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        var textureFrame = this.manager.getFrame(key, frame);\r\n\r\n        if (textureFrame)\r\n        {\r\n            var cd = textureFrame.canvasData;\r\n\r\n            var width = textureFrame.cutWidth;\r\n            var height = textureFrame.cutHeight;\r\n            var res = textureFrame.source.resolution;\r\n\r\n            this.context.drawImage(\r\n                textureFrame.source.image,\r\n                cd.x, cd.y,\r\n                width,\r\n                height,\r\n                x, y,\r\n                width / res,\r\n                height / res\r\n            );\r\n\r\n            return this.update();\r\n        }\r\n        else\r\n        {\r\n            return this;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets a pixel in the CanvasTexture to the given color and alpha values.\r\n     *\r\n     * This is an expensive operation to run in large quantities, so use sparingly.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#setPixel\r\n     * @since 3.16.0\r\n     * \r\n     * @param {integer} x - The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {integer} y - The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {integer} red - The red color value. A number between 0 and 255.\r\n     * @param {integer} green - The green color value. A number between 0 and 255.\r\n     * @param {integer} blue - The blue color value. A number between 0 and 255.\r\n     * @param {integer} [alpha=255] - The alpha value. A number between 0 and 255.\r\n     * \r\n     * @return {this} This CanvasTexture.\r\n     */\r\n    setPixel: function (x, y, red, green, blue, alpha)\r\n    {\r\n        if (alpha === undefined) { alpha = 255; }\r\n\r\n        x = Math.abs(Math.floor(x));\r\n        y = Math.abs(Math.floor(y));\r\n\r\n        var index = this.getIndex(x, y);\r\n\r\n        if (index > -1)\r\n        {\r\n            var imageData = this.context.getImageData(x, y, 1, 1);\r\n\r\n            imageData.data[0] = red;\r\n            imageData.data[1] = green;\r\n            imageData.data[2] = blue;\r\n            imageData.data[3] = alpha;\r\n\r\n            this.context.putImageData(imageData, x, y);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Puts the ImageData into the context of this CanvasTexture at the given coordinates.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#putData\r\n     * @since 3.16.0\r\n     * \r\n     * @param {ImageData} imageData - The ImageData to put at the given location.\r\n     * @param {integer} x - The x coordinate to put the imageData. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {integer} y - The y coordinate to put the imageData. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {integer} [dirtyX=0] - Horizontal position (x coordinate) of the top-left corner from which the image data will be extracted.\r\n     * @param {integer} [dirtyY=0] - Vertical position (x coordinate) of the top-left corner from which the image data will be extracted.\r\n     * @param {integer} [dirtyWidth] - Width of the rectangle to be painted. Defaults to the width of the image data.\r\n     * @param {integer} [dirtyHeight] - Height of the rectangle to be painted. Defaults to the height of the image data.\r\n     * \r\n     * @return {this} This CanvasTexture.\r\n     */\r\n    putData: function (imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight)\r\n    {\r\n        if (dirtyX === undefined) { dirtyX = 0; }\r\n        if (dirtyY === undefined) { dirtyY = 0; }\r\n        if (dirtyWidth === undefined) { dirtyWidth = imageData.width; }\r\n        if (dirtyHeight === undefined) { dirtyHeight = imageData.height; }\r\n\r\n        this.context.putImageData(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets an ImageData region from this CanvasTexture from the position and size specified.\r\n     * You can write this back using `CanvasTexture.putData`, or manipulate it.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#getData\r\n     * @since 3.16.0\r\n     * \r\n     * @param {integer} x - The x coordinate of the top-left of the area to get the ImageData from. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {integer} y - The y coordinate of the top-left of the area to get the ImageData from. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {integer} width - The width of the rectangle from which the ImageData will be extracted. Positive values are to the right, and negative to the left.\r\n     * @param {integer} height - The height of the rectangle from which the ImageData will be extracted. Positive values are down, and negative are up.\r\n     * \r\n     * @return {ImageData} The ImageData extracted from this CanvasTexture.\r\n     */\r\n    getData: function (x, y, width, height)\r\n    {\r\n        x = Clamp(Math.floor(x), 0, this.width - 1);\r\n        y = Clamp(Math.floor(y), 0, this.height - 1);\r\n        width = Clamp(width, 1, this.width - x);\r\n        height = Clamp(height, 1, this.height - y);\r\n\r\n        var imageData = this.context.getImageData(x, y, width, height);\r\n\r\n        return imageData;\r\n    },\r\n\r\n    /**\r\n     * Get the color of a specific pixel from this texture and store it in a Color object.\r\n     * \r\n     * If you have drawn anything to this CanvasTexture since it was created you must call `CanvasTexture.update` to refresh the array buffer,\r\n     * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#getPixel\r\n     * @since 3.13.0\r\n     * \r\n     * @param {integer} x - The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {integer} y - The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {Phaser.Display.Color} [out] - A Color object to store the pixel values in. If not provided a new Color object will be created.\r\n     * \r\n     * @return {Phaser.Display.Color} An object with the red, green, blue and alpha values set in the r, g, b and a properties.\r\n     */\r\n    getPixel: function (x, y, out)\r\n    {\r\n        if (!out)\r\n        {\r\n            out = new Color();\r\n        }\r\n\r\n        var index = this.getIndex(x, y);\r\n\r\n        if (index > -1)\r\n        {\r\n            var data = this.data;\r\n\r\n            var r = data[index + 0];\r\n            var g = data[index + 1];\r\n            var b = data[index + 2];\r\n            var a = data[index + 3];\r\n\r\n            out.setTo(r, g, b, a);\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing all of the pixels in the given region.\r\n     *\r\n     * If the requested region extends outside the bounds of this CanvasTexture,\r\n     * the region is truncated to fit.\r\n     * \r\n     * If you have drawn anything to this CanvasTexture since it was created you must call `CanvasTexture.update` to refresh the array buffer,\r\n     * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#getPixels\r\n     * @since 3.16.0\r\n     * \r\n     * @param {integer} [x=0] - The x coordinate of the top-left of the region. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {integer} [y=0] - The y coordinate of the top-left of the region. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {integer} [width] - The width of the region to get. Must be an integer. Defaults to the canvas width if not given.\r\n     * @param {integer} [height] - The height of the region to get. Must be an integer. If not given will be set to the `width`.\r\n     * \r\n     * @return {Phaser.Types.Textures.PixelConfig[]} An array of Pixel objects.\r\n     */\r\n    getPixels: function (x, y, width, height)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.width; }\r\n        if (height === undefined) { height = width; }\r\n\r\n        x = Math.abs(Math.round(x));\r\n        y = Math.abs(Math.round(y));\r\n\r\n        var left = Clamp(x, 0, this.width);\r\n        var right = Clamp(x + width, 0, this.width);\r\n        var top = Clamp(y, 0, this.height);\r\n        var bottom = Clamp(y + height, 0, this.height);\r\n\r\n        var pixel = new Color();\r\n\r\n        var out = [];\r\n\r\n        for (var py = top; py < bottom; py++)\r\n        {\r\n            var row = [];\r\n\r\n            for (var px = left; px < right; px++)\r\n            {\r\n                pixel = this.getPixel(px, py, pixel);\r\n\r\n                row.push({ x: px, y: py, color: pixel.color, alpha: pixel.alphaGL });\r\n            }\r\n\r\n            out.push(row);\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Returns the Image Data index for the given pixel in this CanvasTexture.\r\n     *\r\n     * The index can be used to read directly from the `this.data` array.\r\n     *\r\n     * The index points to the red value in the array. The subsequent 3 indexes\r\n     * point to green, blue and alpha respectively.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#getIndex\r\n     * @since 3.16.0\r\n     * \r\n     * @param {integer} x - The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {integer} y - The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * \r\n     * @return {integer} \r\n     */\r\n    getIndex: function (x, y)\r\n    {\r\n        x = Math.abs(Math.round(x));\r\n        y = Math.abs(Math.round(y));\r\n\r\n        if (x < this.width && y < this.height)\r\n        {\r\n            return (x + y * this.width) * 4;\r\n        }\r\n        else\r\n        {\r\n            return -1;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * This should be called manually if you are running under WebGL.\r\n     * It will refresh the WebGLTexture from the Canvas source. Only call this if you know that the\r\n     * canvas has changed, as there is a significant GPU texture allocation cost involved in doing so.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#refresh\r\n     * @since 3.7.0\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n     */\r\n    refresh: function ()\r\n    {\r\n        this._source.update();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the Canvas Element.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#getCanvas\r\n     * @since 3.7.0\r\n     *\r\n     * @return {HTMLCanvasElement} The Canvas DOM element this texture is using.\r\n     */\r\n    getCanvas: function ()\r\n    {\r\n        return this.canvas;\r\n    },\r\n\r\n    /**\r\n     * Gets the 2D Canvas Rendering Context.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#getContext\r\n     * @since 3.7.0\r\n     *\r\n     * @return {CanvasRenderingContext2D} The Canvas Rendering Context this texture is using.\r\n     */\r\n    getContext: function ()\r\n    {\r\n        return this.context;\r\n    },\r\n\r\n    /**\r\n     * Clears the given region of this Canvas Texture, resetting it back to transparent.\r\n     * If no region is given, the whole Canvas Texture is cleared.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#clear\r\n     * @since 3.7.0\r\n     * \r\n     * @param {integer} [x=0] - The x coordinate of the top-left of the region to clear.\r\n     * @param {integer} [y=0] - The y coordinate of the top-left of the region to clear.\r\n     * @param {integer} [width] - The width of the region.\r\n     * @param {integer} [height] - The height of the region.\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} The Canvas Texture.\r\n     */\r\n    clear: function (x, y, width, height)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.width; }\r\n        if (height === undefined) { height = this.height; }\r\n\r\n        this.context.clearRect(x, y, width, height);\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * Changes the size of this Canvas Texture.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#setSize\r\n     * @since 3.7.0\r\n     *\r\n     * @param {integer} width - The new width of the Canvas.\r\n     * @param {integer} [height] - The new height of the Canvas. If not given it will use the width as the height.\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} The Canvas Texture.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        if (height === undefined) { height = width; }\r\n\r\n        if (width !== this.width || height !== this.height)\r\n        {\r\n            //  Update the Canvas\r\n            this.canvas.width = width;\r\n            this.canvas.height = height;\r\n\r\n            //  Update the Texture Source\r\n            this._source.width = width;\r\n            this._source.height = height;\r\n            this._source.isPowerOf2 = IsSizePowerOfTwo(width, height);\r\n\r\n            //  Update the Frame\r\n            this.frames['__BASE'].setSize(width, height, 0, 0);\r\n\r\n            this.refresh();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Texture and releases references to its sources and frames.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#destroy\r\n     * @since 3.16.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        Texture.prototype.destroy.call(this);\r\n\r\n        this._source = null;\r\n        this.canvas = null;\r\n        this.context = null;\r\n        this.imageData = null;\r\n        this.data = null;\r\n        this.pixels = null;\r\n        this.buffer = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = CanvasTexture;\r\n"]},"metadata":{},"sourceType":"script"}