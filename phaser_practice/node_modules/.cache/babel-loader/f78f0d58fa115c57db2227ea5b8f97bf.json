{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar MATH_CONST = require('../../math/const');\n\nvar TransformMatrix = require('./TransformMatrix');\n\nvar WrapAngle = require('../../math/angle/Wrap');\n\nvar WrapAngleDegrees = require('../../math/angle/WrapDegrees'); //  global bitmask flag for GameObject.renderMask (used by Scale)\n\n\nvar _FLAG = 4; // 0100\n\n/**\r\n * Provides methods used for getting and setting the position, scale and rotation of a Game Object.\r\n *\r\n * @namespace Phaser.GameObjects.Components.Transform\r\n * @since 3.0.0\r\n */\n\nvar Transform = {\n  /**\r\n   * Private internal value. Holds the horizontal scale value.\r\n   *\r\n   * @name Phaser.GameObjects.Components.Transform#_scaleX\r\n   * @type {number}\r\n   * @private\r\n   * @default 1\r\n   * @since 3.0.0\r\n   */\n  _scaleX: 1,\n\n  /**\r\n   * Private internal value. Holds the vertical scale value.\r\n   *\r\n   * @name Phaser.GameObjects.Components.Transform#_scaleY\r\n   * @type {number}\r\n   * @private\r\n   * @default 1\r\n   * @since 3.0.0\r\n   */\n  _scaleY: 1,\n\n  /**\r\n   * Private internal value. Holds the rotation value in radians.\r\n   *\r\n   * @name Phaser.GameObjects.Components.Transform#_rotation\r\n   * @type {number}\r\n   * @private\r\n   * @default 0\r\n   * @since 3.0.0\r\n   */\n  _rotation: 0,\n\n  /**\r\n   * The x position of this Game Object.\r\n   *\r\n   * @name Phaser.GameObjects.Components.Transform#x\r\n   * @type {number}\r\n   * @default 0\r\n   * @since 3.0.0\r\n   */\n  x: 0,\n\n  /**\r\n   * The y position of this Game Object.\r\n   *\r\n   * @name Phaser.GameObjects.Components.Transform#y\r\n   * @type {number}\r\n   * @default 0\r\n   * @since 3.0.0\r\n   */\n  y: 0,\n\n  /**\r\n   * The z position of this Game Object.\r\n   *\r\n   * Note: The z position does not control the rendering order of 2D Game Objects. Use\r\n   * {@link Phaser.GameObjects.Components.Depth#depth} instead.\r\n   *\r\n   * @name Phaser.GameObjects.Components.Transform#z\r\n   * @type {number}\r\n   * @default 0\r\n   * @since 3.0.0\r\n   */\n  z: 0,\n\n  /**\r\n   * The w position of this Game Object.\r\n   *\r\n   * @name Phaser.GameObjects.Components.Transform#w\r\n   * @type {number}\r\n   * @default 0\r\n   * @since 3.0.0\r\n   */\n  w: 0,\n\n  /**\r\n   * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object\r\n   * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.\r\n   *\r\n   * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this\r\n   * isn't the case, use the `scaleX` or `scaleY` properties instead.\r\n   *\r\n   * @name Phaser.GameObjects.Components.Transform#scale\r\n   * @type {number}\r\n   * @default 1\r\n   * @since 3.18.0\r\n   */\n  scale: {\n    get: function () {\n      return (this._scaleX + this._scaleY) / 2;\n    },\n    set: function (value) {\n      this._scaleX = value;\n      this._scaleY = value;\n\n      if (value === 0) {\n        this.renderFlags &= ~_FLAG;\n      } else {\n        this.renderFlags |= _FLAG;\n      }\n    }\n  },\n\n  /**\r\n   * The horizontal scale of this Game Object.\r\n   *\r\n   * @name Phaser.GameObjects.Components.Transform#scaleX\r\n   * @type {number}\r\n   * @default 1\r\n   * @since 3.0.0\r\n   */\n  scaleX: {\n    get: function () {\n      return this._scaleX;\n    },\n    set: function (value) {\n      this._scaleX = value;\n\n      if (value === 0) {\n        this.renderFlags &= ~_FLAG;\n      } else {\n        this.renderFlags |= _FLAG;\n      }\n    }\n  },\n\n  /**\r\n   * The vertical scale of this Game Object.\r\n   *\r\n   * @name Phaser.GameObjects.Components.Transform#scaleY\r\n   * @type {number}\r\n   * @default 1\r\n   * @since 3.0.0\r\n   */\n  scaleY: {\n    get: function () {\n      return this._scaleY;\n    },\n    set: function (value) {\n      this._scaleY = value;\n\n      if (value === 0) {\n        this.renderFlags &= ~_FLAG;\n      } else {\n        this.renderFlags |= _FLAG;\n      }\n    }\n  },\n\n  /**\r\n   * The angle of this Game Object as expressed in degrees.\r\n   *\r\n   * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left\r\n   * and -90 is up.\r\n   *\r\n   * If you prefer to work in radians, see the `rotation` property instead.\r\n   *\r\n   * @name Phaser.GameObjects.Components.Transform#angle\r\n   * @type {integer}\r\n   * @default 0\r\n   * @since 3.0.0\r\n   */\n  angle: {\n    get: function () {\n      return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);\n    },\n    set: function (value) {\n      //  value is in degrees\n      this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;\n    }\n  },\n\n  /**\r\n   * The angle of this Game Object in radians.\r\n   *\r\n   * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left\r\n   * and -90 is up.\r\n   *\r\n   * If you prefer to work in degrees, see the `angle` property instead.\r\n   *\r\n   * @name Phaser.GameObjects.Components.Transform#rotation\r\n   * @type {number}\r\n   * @default 1\r\n   * @since 3.0.0\r\n   */\n  rotation: {\n    get: function () {\n      return this._rotation;\n    },\n    set: function (value) {\n      //  value is in radians\n      this._rotation = WrapAngle(value);\n    }\n  },\n\n  /**\r\n   * Sets the position of this Game Object.\r\n   *\r\n   * @method Phaser.GameObjects.Components.Transform#setPosition\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [x=0] - The x position of this Game Object.\r\n   * @param {number} [y=x] - The y position of this Game Object. If not set it will use the `x` value.\r\n   * @param {number} [z=0] - The z position of this Game Object.\r\n   * @param {number} [w=0] - The w position of this Game Object.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setPosition: function (x, y, z, w) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = x;\n    }\n\n    if (z === undefined) {\n      z = 0;\n    }\n\n    if (w === undefined) {\n      w = 0;\n    }\n\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  },\n\n  /**\r\n   * Sets the position of this Game Object to be a random position within the confines of\r\n   * the given area.\r\n   *\r\n   * If no area is specified a random position between 0 x 0 and the game width x height is used instead.\r\n   *\r\n   * The position does not factor in the size of this Game Object, meaning that only the origin is\r\n   * guaranteed to be within the area.\r\n   *\r\n   * @method Phaser.GameObjects.Components.Transform#setRandomPosition\r\n   * @since 3.8.0\r\n   *\r\n   * @param {number} [x=0] - The x position of the top-left of the random area.\r\n   * @param {number} [y=0] - The y position of the top-left of the random area.\r\n   * @param {number} [width] - The width of the random area.\r\n   * @param {number} [height] - The height of the random area.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setRandomPosition: function (x, y, width, height) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = this.scene.sys.scale.width;\n    }\n\n    if (height === undefined) {\n      height = this.scene.sys.scale.height;\n    }\n\n    this.x = x + Math.random() * width;\n    this.y = y + Math.random() * height;\n    return this;\n  },\n\n  /**\r\n   * Sets the rotation of this Game Object.\r\n   *\r\n   * @method Phaser.GameObjects.Components.Transform#setRotation\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [radians=0] - The rotation of this Game Object, in radians.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setRotation: function (radians) {\n    if (radians === undefined) {\n      radians = 0;\n    }\n\n    this.rotation = radians;\n    return this;\n  },\n\n  /**\r\n   * Sets the angle of this Game Object.\r\n   *\r\n   * @method Phaser.GameObjects.Components.Transform#setAngle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [degrees=0] - The rotation of this Game Object, in degrees.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setAngle: function (degrees) {\n    if (degrees === undefined) {\n      degrees = 0;\n    }\n\n    this.angle = degrees;\n    return this;\n  },\n\n  /**\r\n   * Sets the scale of this Game Object.\r\n   *\r\n   * @method Phaser.GameObjects.Components.Transform#setScale\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal scale of this Game Object.\r\n   * @param {number} [y=x] - The vertical scale of this Game Object. If not set it will use the `x` value.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setScale: function (x, y) {\n    if (x === undefined) {\n      x = 1;\n    }\n\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.scaleX = x;\n    this.scaleY = y;\n    return this;\n  },\n\n  /**\r\n   * Sets the x position of this Game Object.\r\n   *\r\n   * @method Phaser.GameObjects.Components.Transform#setX\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [value=0] - The x position of this Game Object.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setX: function (value) {\n    if (value === undefined) {\n      value = 0;\n    }\n\n    this.x = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the y position of this Game Object.\r\n   *\r\n   * @method Phaser.GameObjects.Components.Transform#setY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [value=0] - The y position of this Game Object.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setY: function (value) {\n    if (value === undefined) {\n      value = 0;\n    }\n\n    this.y = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the z position of this Game Object.\r\n   *\r\n   * Note: The z position does not control the rendering order of 2D Game Objects. Use\r\n   * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.\r\n   *\r\n   * @method Phaser.GameObjects.Components.Transform#setZ\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [value=0] - The z position of this Game Object.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setZ: function (value) {\n    if (value === undefined) {\n      value = 0;\n    }\n\n    this.z = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the w position of this Game Object.\r\n   *\r\n   * @method Phaser.GameObjects.Components.Transform#setW\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [value=0] - The w position of this Game Object.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setW: function (value) {\n    if (value === undefined) {\n      value = 0;\n    }\n\n    this.w = value;\n    return this;\n  },\n\n  /**\r\n   * Gets the local transform matrix for this Game Object.\r\n   *\r\n   * @method Phaser.GameObjects.Components.Transform#getLocalTransformMatrix\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.\r\n   *\r\n   * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.\r\n   */\n  getLocalTransformMatrix: function (tempMatrix) {\n    if (tempMatrix === undefined) {\n      tempMatrix = new TransformMatrix();\n    }\n\n    return tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);\n  },\n\n  /**\r\n   * Gets the world transform matrix for this Game Object, factoring in any parent Containers.\r\n   *\r\n   * @method Phaser.GameObjects.Components.Transform#getWorldTransformMatrix\r\n   * @since 3.4.0\r\n   *\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} [parentMatrix] - A temporary matrix to hold parent values during the calculations.\r\n   *\r\n   * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.\r\n   */\n  getWorldTransformMatrix: function (tempMatrix, parentMatrix) {\n    if (tempMatrix === undefined) {\n      tempMatrix = new TransformMatrix();\n    }\n\n    if (parentMatrix === undefined) {\n      parentMatrix = new TransformMatrix();\n    }\n\n    var parent = this.parentContainer;\n\n    if (!parent) {\n      return this.getLocalTransformMatrix(tempMatrix);\n    }\n\n    tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);\n\n    while (parent) {\n      parentMatrix.applyITRS(parent.x, parent.y, parent._rotation, parent._scaleX, parent._scaleY);\n      parentMatrix.multiply(tempMatrix, tempMatrix);\n      parent = parent.parentContainer;\n    }\n\n    return tempMatrix;\n  },\n\n  /**\r\n   * Gets the sum total rotation of all of this Game Objects parent Containers.\r\n   *\r\n   * The returned value is in radians and will be zero if this Game Object has no parent container.\r\n   *\r\n   * @method Phaser.GameObjects.Components.Transform#getParentRotation\r\n   * @since 3.18.0\r\n   *\r\n   * @return {number} The sum total rotation, in radians, of all parent containers of this Game Object.\r\n   */\n  getParentRotation: function () {\n    var rotation = 0;\n    var parent = this.parentContainer;\n\n    while (parent) {\n      rotation += parent.rotation;\n      parent = parent.parentContainer;\n    }\n\n    return rotation;\n  }\n};\nmodule.exports = Transform;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/components/Transform.js"],"names":["MATH_CONST","require","TransformMatrix","WrapAngle","WrapAngleDegrees","_FLAG","Transform","_scaleX","_scaleY","_rotation","x","y","z","w","scale","get","set","value","renderFlags","scaleX","scaleY","angle","RAD_TO_DEG","rotation","DEG_TO_RAD","setPosition","undefined","setRandomPosition","width","height","scene","sys","Math","random","setRotation","radians","setAngle","degrees","setScale","setX","setY","setZ","setW","getLocalTransformMatrix","tempMatrix","applyITRS","getWorldTransformMatrix","parentMatrix","parent","parentContainer","multiply","getParentRotation","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MATH_CONST = require('../../math/const');\r\nvar TransformMatrix = require('./TransformMatrix');\r\nvar WrapAngle = require('../../math/angle/Wrap');\r\nvar WrapAngleDegrees = require('../../math/angle/WrapDegrees');\r\n\r\n//  global bitmask flag for GameObject.renderMask (used by Scale)\r\nvar _FLAG = 4; // 0100\r\n\r\n/**\r\n * Provides methods used for getting and setting the position, scale and rotation of a Game Object.\r\n *\r\n * @namespace Phaser.GameObjects.Components.Transform\r\n * @since 3.0.0\r\n */\r\n\r\nvar Transform = {\r\n\r\n    /**\r\n     * Private internal value. Holds the horizontal scale value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#_scaleX\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _scaleX: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the vertical scale value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#_scaleY\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _scaleY: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the rotation value in radians.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#_rotation\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    _rotation: 0,\r\n\r\n    /**\r\n     * The x position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#x\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    x: 0,\r\n\r\n    /**\r\n     * The y position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#y\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    y: 0,\r\n\r\n    /**\r\n     * The z position of this Game Object.\r\n     *\r\n     * Note: The z position does not control the rendering order of 2D Game Objects. Use\r\n     * {@link Phaser.GameObjects.Components.Depth#depth} instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#z\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    z: 0,\r\n\r\n    /**\r\n     * The w position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#w\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    w: 0,\r\n\r\n    /**\r\n     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object\r\n     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.\r\n     *\r\n     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this\r\n     * isn't the case, use the `scaleX` or `scaleY` properties instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#scale\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.18.0\r\n     */\r\n    scale: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this._scaleX + this._scaleY) / 2;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleX = value;\r\n            this._scaleY = value;\r\n\r\n            if (value === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The horizontal scale of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#scaleX\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scaleX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleX;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleX = value;\r\n\r\n            if (value === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scale of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#scaleY\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scaleY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleY;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleY = value;\r\n\r\n            if (value === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The angle of this Game Object as expressed in degrees.\r\n     *\r\n     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left\r\n     * and -90 is up.\r\n     *\r\n     * If you prefer to work in radians, see the `rotation` property instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#angle\r\n     * @type {integer}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    angle: {\r\n\r\n        get: function ()\r\n        {\r\n            return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            //  value is in degrees\r\n            this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The angle of this Game Object in radians.\r\n     *\r\n     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left\r\n     * and -90 is up.\r\n     *\r\n     * If you prefer to work in degrees, see the `angle` property instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#rotation\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    rotation: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._rotation;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            //  value is in radians\r\n            this._rotation = WrapAngle(value);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The x position of this Game Object.\r\n     * @param {number} [y=x] - The y position of this Game Object. If not set it will use the `x` value.\r\n     * @param {number} [z=0] - The z position of this Game Object.\r\n     * @param {number} [w=0] - The w position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setPosition: function (x, y, z, w)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = x; }\r\n        if (z === undefined) { z = 0; }\r\n        if (w === undefined) { w = 0; }\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the position of this Game Object to be a random position within the confines of\r\n     * the given area.\r\n     *\r\n     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.\r\n     *\r\n     * The position does not factor in the size of this Game Object, meaning that only the origin is\r\n     * guaranteed to be within the area.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setRandomPosition\r\n     * @since 3.8.0\r\n     *\r\n     * @param {number} [x=0] - The x position of the top-left of the random area.\r\n     * @param {number} [y=0] - The y position of the top-left of the random area.\r\n     * @param {number} [width] - The width of the random area.\r\n     * @param {number} [height] - The height of the random area.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setRandomPosition: function (x, y, width, height)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.scene.sys.scale.width; }\r\n        if (height === undefined) { height = this.scene.sys.scale.height; }\r\n\r\n        this.x = x + (Math.random() * width);\r\n        this.y = y + (Math.random() * height);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the rotation of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [radians=0] - The rotation of this Game Object, in radians.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setRotation: function (radians)\r\n    {\r\n        if (radians === undefined) { radians = 0; }\r\n\r\n        this.rotation = radians;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the angle of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [degrees=0] - The rotation of this Game Object, in degrees.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setAngle: function (degrees)\r\n    {\r\n        if (degrees === undefined) { degrees = 0; }\r\n\r\n        this.angle = degrees;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scale of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scale of this Game Object.\r\n     * @param {number} [y=x] - The vertical scale of this Game Object. If not set it will use the `x` value.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setScale: function (x, y)\r\n    {\r\n        if (x === undefined) { x = 1; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.scaleX = x;\r\n        this.scaleY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the x position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The x position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setX: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the y position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The y position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setY: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the z position of this Game Object.\r\n     *\r\n     * Note: The z position does not control the rendering order of 2D Game Objects. Use\r\n     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setZ\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The z position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setZ: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.z = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the w position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setW\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The w position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setW: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.w = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the local transform matrix for this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getLocalTransformMatrix\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.\r\n     */\r\n    getLocalTransformMatrix: function (tempMatrix)\r\n    {\r\n        if (tempMatrix === undefined) { tempMatrix = new TransformMatrix(); }\r\n\r\n        return tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);\r\n    },\r\n\r\n    /**\r\n     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getWorldTransformMatrix\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentMatrix] - A temporary matrix to hold parent values during the calculations.\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.\r\n     */\r\n    getWorldTransformMatrix: function (tempMatrix, parentMatrix)\r\n    {\r\n        if (tempMatrix === undefined) { tempMatrix = new TransformMatrix(); }\r\n        if (parentMatrix === undefined) { parentMatrix = new TransformMatrix(); }\r\n\r\n        var parent = this.parentContainer;\r\n\r\n        if (!parent)\r\n        {\r\n            return this.getLocalTransformMatrix(tempMatrix);\r\n        }\r\n\r\n        tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);\r\n\r\n        while (parent)\r\n        {\r\n            parentMatrix.applyITRS(parent.x, parent.y, parent._rotation, parent._scaleX, parent._scaleY);\r\n\r\n            parentMatrix.multiply(tempMatrix, tempMatrix);\r\n\r\n            parent = parent.parentContainer;\r\n        }\r\n\r\n        return tempMatrix;\r\n    },\r\n\r\n    /**\r\n     * Gets the sum total rotation of all of this Game Objects parent Containers.\r\n     *\r\n     * The returned value is in radians and will be zero if this Game Object has no parent container.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getParentRotation\r\n     * @since 3.18.0\r\n     *\r\n     * @return {number} The sum total rotation, in radians, of all parent containers of this Game Object.\r\n     */\r\n    getParentRotation: function ()\r\n    {\r\n        var rotation = 0;\r\n\r\n        var parent = this.parentContainer;\r\n\r\n        while (parent)\r\n        {\r\n            rotation += parent.rotation;\r\n\r\n            parent = parent.parentContainer;\r\n        }\r\n\r\n        return rotation;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Transform;\r\n"]},"metadata":{},"sourceType":"script"}