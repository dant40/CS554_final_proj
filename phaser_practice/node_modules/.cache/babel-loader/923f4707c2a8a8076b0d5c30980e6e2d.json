{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\n\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Shader#renderWebGL\r\n * @since 3.17.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Shader} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\nvar ShaderWebGLRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix) {\n  if (!src.shader) {\n    return;\n  }\n\n  var pipeline = renderer.currentPipeline;\n  renderer.clearPipeline();\n\n  if (src.renderToTexture) {\n    src.load();\n    src.flush();\n  } else {\n    var camMatrix = src._tempMatrix1;\n    var shapeMatrix = src._tempMatrix2;\n    var calcMatrix = src._tempMatrix3;\n    shapeMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\n    camMatrix.copyFrom(camera.matrix);\n\n    if (parentMatrix) {\n      //  Multiply the camera by the parent matrix\n      camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY); //  Undo the camera scroll\n\n      shapeMatrix.e = src.x;\n      shapeMatrix.f = src.y;\n    } else {\n      shapeMatrix.e -= camera.scrollX * src.scrollFactorX;\n      shapeMatrix.f -= camera.scrollY * src.scrollFactorY;\n    }\n\n    camMatrix.multiply(shapeMatrix, calcMatrix); //  Renderer size changed?\n\n    if (renderer.width !== src._rendererWidth || renderer.height !== src._rendererHeight) {\n      src.projOrtho(0, renderer.width, renderer.height, 0);\n    }\n\n    src.load(calcMatrix.matrix);\n    src.flush();\n  }\n\n  renderer.rebindPipeline(pipeline);\n};\n\nmodule.exports = ShaderWebGLRenderer;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/shader/ShaderWebGLRenderer.js"],"names":["ShaderWebGLRenderer","renderer","src","interpolationPercentage","camera","parentMatrix","shader","pipeline","currentPipeline","clearPipeline","renderToTexture","load","flush","camMatrix","_tempMatrix1","shapeMatrix","_tempMatrix2","calcMatrix","_tempMatrix3","applyITRS","x","y","rotation","scaleX","scaleY","copyFrom","matrix","multiplyWithOffset","scrollX","scrollFactorX","scrollY","scrollFactorY","e","f","multiply","width","_rendererWidth","height","_rendererHeight","projOrtho","rebindPipeline","module","exports"],"mappings":"AAAA;;;;;;AAMA;;;;;;;;;;;;;;;AAeA,IAAIA,mBAAmB,GAAG,UAAUC,QAAV,EAAoBC,GAApB,EAAyBC,uBAAzB,EAAkDC,MAAlD,EAA0DC,YAA1D,EAC1B;AACI,MAAI,CAACH,GAAG,CAACI,MAAT,EACA;AACI;AACH;;AAED,MAAIC,QAAQ,GAAGN,QAAQ,CAACO,eAAxB;AAEAP,EAAAA,QAAQ,CAACQ,aAAT;;AAEA,MAAIP,GAAG,CAACQ,eAAR,EACA;AACIR,IAAAA,GAAG,CAACS,IAAJ;AACAT,IAAAA,GAAG,CAACU,KAAJ;AACH,GAJD,MAMA;AACI,QAAIC,SAAS,GAAGX,GAAG,CAACY,YAApB;AACA,QAAIC,WAAW,GAAGb,GAAG,CAACc,YAAtB;AACA,QAAIC,UAAU,GAAGf,GAAG,CAACgB,YAArB;AAEAH,IAAAA,WAAW,CAACI,SAAZ,CAAsBjB,GAAG,CAACkB,CAA1B,EAA6BlB,GAAG,CAACmB,CAAjC,EAAoCnB,GAAG,CAACoB,QAAxC,EAAkDpB,GAAG,CAACqB,MAAtD,EAA8DrB,GAAG,CAACsB,MAAlE;AAEAX,IAAAA,SAAS,CAACY,QAAV,CAAmBrB,MAAM,CAACsB,MAA1B;;AAEA,QAAIrB,YAAJ,EACA;AACI;AACAQ,MAAAA,SAAS,CAACc,kBAAV,CAA6BtB,YAA7B,EAA2C,CAACD,MAAM,CAACwB,OAAR,GAAkB1B,GAAG,CAAC2B,aAAjE,EAAgF,CAACzB,MAAM,CAAC0B,OAAR,GAAkB5B,GAAG,CAAC6B,aAAtG,EAFJ,CAII;;AACAhB,MAAAA,WAAW,CAACiB,CAAZ,GAAgB9B,GAAG,CAACkB,CAApB;AACAL,MAAAA,WAAW,CAACkB,CAAZ,GAAgB/B,GAAG,CAACmB,CAApB;AACH,KARD,MAUA;AACIN,MAAAA,WAAW,CAACiB,CAAZ,IAAiB5B,MAAM,CAACwB,OAAP,GAAiB1B,GAAG,CAAC2B,aAAtC;AACAd,MAAAA,WAAW,CAACkB,CAAZ,IAAiB7B,MAAM,CAAC0B,OAAP,GAAiB5B,GAAG,CAAC6B,aAAtC;AACH;;AAEDlB,IAAAA,SAAS,CAACqB,QAAV,CAAmBnB,WAAnB,EAAgCE,UAAhC,EAxBJ,CA0BI;;AACA,QAAIhB,QAAQ,CAACkC,KAAT,KAAmBjC,GAAG,CAACkC,cAAvB,IAAyCnC,QAAQ,CAACoC,MAAT,KAAoBnC,GAAG,CAACoC,eAArE,EACA;AACIpC,MAAAA,GAAG,CAACqC,SAAJ,CAAc,CAAd,EAAiBtC,QAAQ,CAACkC,KAA1B,EAAiClC,QAAQ,CAACoC,MAA1C,EAAkD,CAAlD;AACH;;AAEDnC,IAAAA,GAAG,CAACS,IAAJ,CAASM,UAAU,CAACS,MAApB;AACAxB,IAAAA,GAAG,CAACU,KAAJ;AACH;;AAEDX,EAAAA,QAAQ,CAACuC,cAAT,CAAwBjC,QAAxB;AACH,CAtDD;;AAwDAkC,MAAM,CAACC,OAAP,GAAiB1C,mBAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Shader#renderWebGL\r\n * @since 3.17.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Shader} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ShaderWebGLRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix)\r\n{\r\n    if (!src.shader)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var pipeline = renderer.currentPipeline;\r\n\r\n    renderer.clearPipeline();\r\n\r\n    if (src.renderToTexture)\r\n    {\r\n        src.load();\r\n        src.flush();\r\n    }\r\n    else\r\n    {\r\n        var camMatrix = src._tempMatrix1;\r\n        var shapeMatrix = src._tempMatrix2;\r\n        var calcMatrix = src._tempMatrix3;\r\n    \r\n        shapeMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\r\n    \r\n        camMatrix.copyFrom(camera.matrix);\r\n    \r\n        if (parentMatrix)\r\n        {\r\n            //  Multiply the camera by the parent matrix\r\n            camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n    \r\n            //  Undo the camera scroll\r\n            shapeMatrix.e = src.x;\r\n            shapeMatrix.f = src.y;\r\n        }\r\n        else\r\n        {\r\n            shapeMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n            shapeMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n        }\r\n    \r\n        camMatrix.multiply(shapeMatrix, calcMatrix);\r\n    \r\n        //  Renderer size changed?\r\n        if (renderer.width !== src._rendererWidth || renderer.height !== src._rendererHeight)\r\n        {\r\n            src.projOrtho(0, renderer.width, renderer.height, 0);\r\n        }\r\n    \r\n        src.load(calcMatrix.matrix);\r\n        src.flush();\r\n    }\r\n\r\n    renderer.rebindPipeline(pipeline);\r\n};\r\n\r\nmodule.exports = ShaderWebGLRenderer;\r\n"]},"metadata":{},"sourceType":"script"}