{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Igor Ognichenko <ognichenko.igor@gmail.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\n\n/**\r\n * @ignore\r\n */\nvar copy = function (out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n};\n/**\r\n * Takes a Polygon object and applies Chaikin's smoothing algorithm on its points.\r\n *\r\n * @function Phaser.Geom.Polygon.Smooth\r\n * @since 3.13.0\r\n *\r\n * @generic {Phaser.Geom.Polygon} O - [polygon,$return]\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - The polygon to be smoothed. The polygon will be modified in-place and returned.\r\n *\r\n * @return {Phaser.Geom.Polygon} The input polygon.\r\n */\n\n\nvar Smooth = function (polygon) {\n  var i;\n  var points = [];\n  var data = polygon.points;\n\n  for (i = 0; i < data.length; i++) {\n    points.push([data[i].x, data[i].y]);\n  }\n\n  var output = [];\n\n  if (points.length > 0) {\n    output.push(copy([0, 0], points[0]));\n  }\n\n  for (i = 0; i < points.length - 1; i++) {\n    var p0 = points[i];\n    var p1 = points[i + 1];\n    var p0x = p0[0];\n    var p0y = p0[1];\n    var p1x = p1[0];\n    var p1y = p1[1];\n    output.push([0.85 * p0x + 0.15 * p1x, 0.85 * p0y + 0.15 * p1y]);\n    output.push([0.15 * p0x + 0.85 * p1x, 0.15 * p0y + 0.85 * p1y]);\n  }\n\n  if (points.length > 1) {\n    output.push(copy([0, 0], points[points.length - 1]));\n  }\n\n  return polygon.setTo(output);\n};\n\nmodule.exports = Smooth;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/geom/polygon/Smooth.js"],"names":["copy","out","a","Smooth","polygon","i","points","data","length","push","x","y","output","p0","p1","p0x","p0y","p1x","p1y","setTo","module","exports"],"mappings":"AAAA;;;;;;;AAOA;;;AAGA,IAAIA,IAAI,GAAG,UAAUC,GAAV,EAAeC,CAAf,EACX;AACID,EAAAA,GAAG,CAAC,CAAD,CAAH,GAASC,CAAC,CAAC,CAAD,CAAV;AACAD,EAAAA,GAAG,CAAC,CAAD,CAAH,GAASC,CAAC,CAAC,CAAD,CAAV;AAEA,SAAOD,GAAP;AACH,CAND;AAQA;;;;;;;;;;;;;;AAYA,IAAIE,MAAM,GAAG,UAAUC,OAAV,EACb;AACI,MAAIC,CAAJ;AACA,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,IAAI,GAAGH,OAAO,CAACE,MAAnB;;AAEA,OAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGE,IAAI,CAACC,MAArB,EAA6BH,CAAC,EAA9B,EACA;AACIC,IAAAA,MAAM,CAACG,IAAP,CAAY,CAAEF,IAAI,CAACF,CAAD,CAAJ,CAAQK,CAAV,EAAaH,IAAI,CAACF,CAAD,CAAJ,CAAQM,CAArB,CAAZ;AACH;;AAED,MAAIC,MAAM,GAAG,EAAb;;AAEA,MAAIN,MAAM,CAACE,MAAP,GAAgB,CAApB,EACA;AACII,IAAAA,MAAM,CAACH,IAAP,CAAYT,IAAI,CAAC,CAAE,CAAF,EAAK,CAAL,CAAD,EAAWM,MAAM,CAAC,CAAD,CAAjB,CAAhB;AACH;;AAED,OAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,MAAM,CAACE,MAAP,GAAgB,CAAhC,EAAmCH,CAAC,EAApC,EACA;AACI,QAAIQ,EAAE,GAAGP,MAAM,CAACD,CAAD,CAAf;AACA,QAAIS,EAAE,GAAGR,MAAM,CAACD,CAAC,GAAG,CAAL,CAAf;AACA,QAAIU,GAAG,GAAGF,EAAE,CAAC,CAAD,CAAZ;AACA,QAAIG,GAAG,GAAGH,EAAE,CAAC,CAAD,CAAZ;AACA,QAAII,GAAG,GAAGH,EAAE,CAAC,CAAD,CAAZ;AACA,QAAII,GAAG,GAAGJ,EAAE,CAAC,CAAD,CAAZ;AAEAF,IAAAA,MAAM,CAACH,IAAP,CAAY,CAAE,OAAOM,GAAP,GAAa,OAAOE,GAAtB,EAA2B,OAAOD,GAAP,GAAa,OAAOE,GAA/C,CAAZ;AACAN,IAAAA,MAAM,CAACH,IAAP,CAAY,CAAE,OAAOM,GAAP,GAAa,OAAOE,GAAtB,EAA2B,OAAOD,GAAP,GAAa,OAAOE,GAA/C,CAAZ;AACH;;AAED,MAAIZ,MAAM,CAACE,MAAP,GAAgB,CAApB,EACA;AACII,IAAAA,MAAM,CAACH,IAAP,CAAYT,IAAI,CAAC,CAAE,CAAF,EAAK,CAAL,CAAD,EAAWM,MAAM,CAACA,MAAM,CAACE,MAAP,GAAgB,CAAjB,CAAjB,CAAhB;AACH;;AAED,SAAOJ,OAAO,CAACe,KAAR,CAAcP,MAAd,CAAP;AACH,CArCD;;AAuCAQ,MAAM,CAACC,OAAP,GAAiBlB,MAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Igor Ognichenko <ognichenko.igor@gmail.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @ignore\r\n */\r\nvar copy = function (out, a)\r\n{\r\n    out[0] = a[0];\r\n    out[1] = a[1];\r\n  \r\n    return out;\r\n};\r\n\r\n/**\r\n * Takes a Polygon object and applies Chaikin's smoothing algorithm on its points.\r\n *\r\n * @function Phaser.Geom.Polygon.Smooth\r\n * @since 3.13.0\r\n *\r\n * @generic {Phaser.Geom.Polygon} O - [polygon,$return]\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - The polygon to be smoothed. The polygon will be modified in-place and returned.\r\n *\r\n * @return {Phaser.Geom.Polygon} The input polygon.\r\n */\r\nvar Smooth = function (polygon)\r\n{\r\n    var i;\r\n    var points = [];\r\n    var data = polygon.points;\r\n\r\n    for (i = 0; i < data.length; i++)\r\n    {\r\n        points.push([ data[i].x, data[i].y ]);\r\n    }\r\n\r\n    var output = [];\r\n  \r\n    if (points.length > 0)\r\n    {\r\n        output.push(copy([ 0, 0 ], points[0]));\r\n    }\r\n  \r\n    for (i = 0; i < points.length - 1; i++)\r\n    {\r\n        var p0 = points[i];\r\n        var p1 = points[i + 1];\r\n        var p0x = p0[0];\r\n        var p0y = p0[1];\r\n        var p1x = p1[0];\r\n        var p1y = p1[1];\r\n\r\n        output.push([ 0.85 * p0x + 0.15 * p1x, 0.85 * p0y + 0.15 * p1y ]);\r\n        output.push([ 0.15 * p0x + 0.85 * p1x, 0.15 * p0y + 0.85 * p1y ]);\r\n    }\r\n  \r\n    if (points.length > 1)\r\n    {\r\n        output.push(copy([ 0, 0 ], points[points.length - 1]));\r\n    }\r\n  \r\n    return polygon.setTo(output);\r\n};\r\n\r\nmodule.exports = Smooth;\r\n"]},"metadata":{},"sourceType":"script"}