{"ast":null,"code":"/**\r\n* The `Matter.Query` module contains methods for performing collision queries.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Query\r\n*/\nvar Query = {};\nmodule.exports = Query;\n\nvar Vector = require('../geometry/Vector');\n\nvar SAT = require('./SAT');\n\nvar Bounds = require('../geometry/Bounds');\n\nvar Bodies = require('../factory/Bodies');\n\nvar Vertices = require('../geometry/Vertices');\n\n(function () {\n  /**\r\n   * Returns a list of collisions between `body` and `bodies`.\r\n   * @method collides\r\n   * @param {body} body\r\n   * @param {body[]} bodies\r\n   * @return {object[]} Collisions\r\n   */\n  Query.collides = function (body, bodies) {\n    var collisions = [];\n\n    for (var i = 0; i < bodies.length; i++) {\n      var bodyA = bodies[i]; //  Phaser addition - skip same body checks\n\n      if (body === bodyA) {\n        continue;\n      }\n\n      if (Bounds.overlaps(bodyA.bounds, body.bounds)) {\n        for (var j = bodyA.parts.length === 1 ? 0 : 1; j < bodyA.parts.length; j++) {\n          var part = bodyA.parts[j];\n\n          if (Bounds.overlaps(part.bounds, body.bounds)) {\n            var collision = SAT.collides(part, body);\n\n            if (collision.collided) {\n              collisions.push(collision);\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    return collisions;\n  };\n  /**\r\n   * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.\r\n   * @method ray\r\n   * @param {body[]} bodies\r\n   * @param {vector} startPoint\r\n   * @param {vector} endPoint\r\n   * @param {number} [rayWidth]\r\n   * @return {object[]} Collisions\r\n   */\n\n\n  Query.ray = function (bodies, startPoint, endPoint, rayWidth) {\n    rayWidth = rayWidth || 1e-100;\n    var rayAngle = Vector.angle(startPoint, endPoint),\n        rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)),\n        rayX = (endPoint.x + startPoint.x) * 0.5,\n        rayY = (endPoint.y + startPoint.y) * 0.5,\n        ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, {\n      angle: rayAngle\n    }),\n        collisions = Query.collides(ray, bodies);\n\n    for (var i = 0; i < collisions.length; i += 1) {\n      var collision = collisions[i];\n      collision.body = collision.bodyB = collision.bodyA;\n    }\n\n    return collisions;\n  };\n  /**\r\n   * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.\r\n   * @method region\r\n   * @param {body[]} bodies\r\n   * @param {bounds} bounds\r\n   * @param {bool} [outside=false]\r\n   * @return {body[]} The bodies matching the query\r\n   */\n\n\n  Query.region = function (bodies, bounds, outside) {\n    var result = [];\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i],\n          overlaps = Bounds.overlaps(body.bounds, bounds);\n      if (overlaps && !outside || !overlaps && outside) result.push(body);\n    }\n\n    return result;\n  };\n  /**\r\n   * Returns all bodies whose vertices contain the given point, from the given set of bodies.\r\n   * @method point\r\n   * @param {body[]} bodies\r\n   * @param {vector} point\r\n   * @return {body[]} The bodies matching the query\r\n   */\n\n\n  Query.point = function (bodies, point) {\n    var result = [];\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i];\n\n      if (Bounds.contains(body.bounds, point)) {\n        for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {\n          var part = body.parts[j];\n\n          if (Bounds.contains(part.bounds, point) && Vertices.contains(part.vertices, point)) {\n            result.push(body);\n            break;\n          }\n        }\n      }\n    }\n\n    return result;\n  };\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/lib/collision/Query.js"],"names":["Query","module","exports","Vector","require","SAT","Bounds","Bodies","Vertices","collides","body","bodies","collisions","i","length","bodyA","overlaps","bounds","j","parts","part","collision","collided","push","ray","startPoint","endPoint","rayWidth","rayAngle","angle","rayLength","magnitude","sub","rayX","x","rayY","y","rectangle","bodyB","region","outside","result","point","contains","vertices"],"mappings":"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","sourcesContent":["/**\r\n* The `Matter.Query` module contains methods for performing collision queries.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Query\r\n*/\r\n\r\nvar Query = {};\r\n\r\nmodule.exports = Query;\r\n\r\nvar Vector = require('../geometry/Vector');\r\nvar SAT = require('./SAT');\r\nvar Bounds = require('../geometry/Bounds');\r\nvar Bodies = require('../factory/Bodies');\r\nvar Vertices = require('../geometry/Vertices');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Returns a list of collisions between `body` and `bodies`.\r\n     * @method collides\r\n     * @param {body} body\r\n     * @param {body[]} bodies\r\n     * @return {object[]} Collisions\r\n     */\r\n    Query.collides = function(body, bodies) {\r\n        var collisions = [];\r\n\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var bodyA = bodies[i];\r\n\r\n            //  Phaser addition - skip same body checks\r\n            if (body === bodyA)\r\n            {\r\n                continue;\r\n            }\r\n            \r\n            if (Bounds.overlaps(bodyA.bounds, body.bounds)) {\r\n                for (var j = bodyA.parts.length === 1 ? 0 : 1; j < bodyA.parts.length; j++) {\r\n                    var part = bodyA.parts[j];\r\n\r\n                    if (Bounds.overlaps(part.bounds, body.bounds)) {\r\n                        var collision = SAT.collides(part, body);\r\n\r\n                        if (collision.collided) {\r\n                            collisions.push(collision);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return collisions;\r\n    };\r\n\r\n    /**\r\n     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.\r\n     * @method ray\r\n     * @param {body[]} bodies\r\n     * @param {vector} startPoint\r\n     * @param {vector} endPoint\r\n     * @param {number} [rayWidth]\r\n     * @return {object[]} Collisions\r\n     */\r\n    Query.ray = function(bodies, startPoint, endPoint, rayWidth) {\r\n        rayWidth = rayWidth || 1e-100;\r\n\r\n        var rayAngle = Vector.angle(startPoint, endPoint),\r\n            rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)),\r\n            rayX = (endPoint.x + startPoint.x) * 0.5,\r\n            rayY = (endPoint.y + startPoint.y) * 0.5,\r\n            ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, { angle: rayAngle }),\r\n            collisions = Query.collides(ray, bodies);\r\n\r\n        for (var i = 0; i < collisions.length; i += 1) {\r\n            var collision = collisions[i];\r\n            collision.body = collision.bodyB = collision.bodyA;            \r\n        }\r\n\r\n        return collisions;\r\n    };\r\n\r\n    /**\r\n     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.\r\n     * @method region\r\n     * @param {body[]} bodies\r\n     * @param {bounds} bounds\r\n     * @param {bool} [outside=false]\r\n     * @return {body[]} The bodies matching the query\r\n     */\r\n    Query.region = function(bodies, bounds, outside) {\r\n        var result = [];\r\n\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i],\r\n                overlaps = Bounds.overlaps(body.bounds, bounds);\r\n            if ((overlaps && !outside) || (!overlaps && outside))\r\n                result.push(body);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Returns all bodies whose vertices contain the given point, from the given set of bodies.\r\n     * @method point\r\n     * @param {body[]} bodies\r\n     * @param {vector} point\r\n     * @return {body[]} The bodies matching the query\r\n     */\r\n    Query.point = function(bodies, point) {\r\n        var result = [];\r\n\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n            \r\n            if (Bounds.contains(body.bounds, point)) {\r\n                for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {\r\n                    var part = body.parts[j];\r\n\r\n                    if (Bounds.contains(part.bounds, point)\r\n                        && Vertices.contains(part.vertices, point)) {\r\n                        result.push(body);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}