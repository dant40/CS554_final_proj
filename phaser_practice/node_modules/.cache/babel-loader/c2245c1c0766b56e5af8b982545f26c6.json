{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Vector2 = require('../math/Vector2');\n/**\r\n * Iterate through the items array changing the position of each element to be that of the element that came before\r\n * it in the array (or after it if direction = 1)\r\n * \r\n * The first items position is set to x/y.\r\n * \r\n * The final x/y coords are returned\r\n *\r\n * @function Phaser.Actions.ShiftPosition\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items]\r\n * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {number} x - The x coordinate to place the first item in the array at.\r\n * @param {number} y - The y coordinate to place the first item in the array at.\r\n * @param {integer} [direction=0] - The iteration direction. 0 = first to last and 1 = last to first.\r\n * @param {(Phaser.Math.Vector2|object)} [output] - An optional objec to store the final objects position in.\r\n *\r\n * @return {Phaser.Math.Vector2} The output vector.\r\n */\n\n\nvar ShiftPosition = function (items, x, y, direction, output) {\n  if (direction === undefined) {\n    direction = 0;\n  }\n\n  if (output === undefined) {\n    output = new Vector2();\n  }\n\n  var px;\n  var py;\n\n  if (items.length > 1) {\n    var i;\n    var cx;\n    var cy;\n    var cur;\n\n    if (direction === 0) {\n      //  Bottom to Top\n      var len = items.length - 1;\n      px = items[len].x;\n      py = items[len].y;\n\n      for (i = len - 1; i >= 0; i--) {\n        //  Current item\n        cur = items[i]; //  Get current item x/y, to be passed to the next item in the list\n\n        cx = cur.x;\n        cy = cur.y; //  Set current item to the previous items x/y\n\n        cur.x = px;\n        cur.y = py; //  Set current as previous\n\n        px = cx;\n        py = cy;\n      } //  Update the head item to the new x/y coordinates\n\n\n      items[len].x = x;\n      items[len].y = y;\n    } else {\n      //  Top to Bottom\n      px = items[0].x;\n      py = items[0].y;\n\n      for (i = 1; i < items.length; i++) {\n        //  Current item\n        cur = items[i]; //  Get current item x/y, to be passed to the next item in the list\n\n        cx = cur.x;\n        cy = cur.y; //  Set current item to the previous items x/y\n\n        cur.x = px;\n        cur.y = py; //  Set current as previous\n\n        px = cx;\n        py = cy;\n      } //  Update the head item to the new x/y coordinates\n\n\n      items[0].x = x;\n      items[0].y = y;\n    }\n  } else {\n    px = items[0].x;\n    py = items[0].y;\n    items[0].x = x;\n    items[0].y = y;\n  } //  Return the final set of coordinates as they're effectively lost from the shift and may be needed\n\n\n  output.x = px;\n  output.y = py;\n  return output;\n};\n\nmodule.exports = ShiftPosition;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/actions/ShiftPosition.js"],"names":["Vector2","require","ShiftPosition","items","x","y","direction","output","undefined","px","py","length","i","cx","cy","cur","len","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../math/Vector2');\r\n\r\n/**\r\n * Iterate through the items array changing the position of each element to be that of the element that came before\r\n * it in the array (or after it if direction = 1)\r\n * \r\n * The first items position is set to x/y.\r\n * \r\n * The final x/y coords are returned\r\n *\r\n * @function Phaser.Actions.ShiftPosition\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items]\r\n * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {number} x - The x coordinate to place the first item in the array at.\r\n * @param {number} y - The y coordinate to place the first item in the array at.\r\n * @param {integer} [direction=0] - The iteration direction. 0 = first to last and 1 = last to first.\r\n * @param {(Phaser.Math.Vector2|object)} [output] - An optional objec to store the final objects position in.\r\n *\r\n * @return {Phaser.Math.Vector2} The output vector.\r\n */\r\nvar ShiftPosition = function (items, x, y, direction, output)\r\n{\r\n    if (direction === undefined) { direction = 0; }\r\n    if (output === undefined) { output = new Vector2(); }\r\n\r\n    var px;\r\n    var py;\r\n\r\n    if (items.length > 1)\r\n    {\r\n        var i;\r\n        var cx;\r\n        var cy;\r\n        var cur;\r\n\r\n        if (direction === 0)\r\n        {\r\n            //  Bottom to Top\r\n\r\n            var len = items.length - 1;\r\n\r\n            px = items[len].x;\r\n            py = items[len].y;\r\n\r\n            for (i = len - 1; i >= 0; i--)\r\n            {\r\n                //  Current item\r\n                cur = items[i];\r\n\r\n                //  Get current item x/y, to be passed to the next item in the list\r\n                cx = cur.x;\r\n                cy = cur.y;\r\n\r\n                //  Set current item to the previous items x/y\r\n                cur.x = px;\r\n                cur.y = py;\r\n\r\n                //  Set current as previous\r\n                px = cx;\r\n                py = cy;\r\n            }\r\n\r\n            //  Update the head item to the new x/y coordinates\r\n            items[len].x = x;\r\n            items[len].y = y;\r\n        }\r\n        else\r\n        {\r\n            //  Top to Bottom\r\n\r\n            px = items[0].x;\r\n            py = items[0].y;\r\n\r\n            for (i = 1; i < items.length; i++)\r\n            {\r\n                //  Current item\r\n                cur = items[i];\r\n\r\n                //  Get current item x/y, to be passed to the next item in the list\r\n                cx = cur.x;\r\n                cy = cur.y;\r\n\r\n                //  Set current item to the previous items x/y\r\n                cur.x = px;\r\n                cur.y = py;\r\n\r\n                //  Set current as previous\r\n                px = cx;\r\n                py = cy;\r\n            }\r\n\r\n            //  Update the head item to the new x/y coordinates\r\n            items[0].x = x;\r\n            items[0].y = y;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        px = items[0].x;\r\n        py = items[0].y;\r\n\r\n        items[0].x = x;\r\n        items[0].y = y;\r\n    }\r\n\r\n    //  Return the final set of coordinates as they're effectively lost from the shift and may be needed\r\n\r\n    output.x = px;\r\n    output.y = py;\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = ShiftPosition;\r\n"]},"metadata":{},"sourceType":"script"}