{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\n\n/**\r\n * Contains methods for changing the collision filter of a Matter Body. Should be used as a mixin and not called directly.\r\n *\r\n * @namespace Phaser.Physics.Matter.Components.Collision\r\n * @since 3.0.0\r\n */\nvar Collision = {\n  /**\r\n   * Sets the collision category of this Game Object's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.\r\n   * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\r\n   * categories are included in their collision masks (see {@link #setCollidesWith}).\r\n   *\r\n   * @method Phaser.Physics.Matter.Components.Collision#setCollisionCategory\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - Unique category bitfield.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n   */\n  setCollisionCategory: function (value) {\n    this.body.collisionFilter.category = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the collision group of this Game Object's Matter Body. If this is zero or two Matter Bodies have different values,\r\n   * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\r\n   * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,\r\n   * they will never collide.\r\n   *\r\n   * @method Phaser.Physics.Matter.Components.Collision#setCollisionGroup\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - Unique group index.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n   */\n  setCollisionGroup: function (value) {\n    this.body.collisionFilter.group = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the collision mask for this Game Object's Matter Body. Two Matter Bodies with different collision groups will only\r\n   * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`\r\n   * and `(categoryB & maskA) !== 0` are both true.\r\n   *\r\n   * @method Phaser.Physics.Matter.Components.Collision#setCollidesWith\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n   */\n  setCollidesWith: function (categories) {\n    var flags = 0;\n\n    if (!Array.isArray(categories)) {\n      flags = categories;\n    } else {\n      for (var i = 0; i < categories.length; i++) {\n        flags |= categories[i];\n      }\n    }\n\n    this.body.collisionFilter.mask = flags;\n    return this;\n  },\n\n  /**\r\n   * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n   * \r\n   * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n   * to the callback.\r\n   *\r\n   * @method Phaser.Physics.Matter.Components.Collision#setOnCollide\r\n   * @since 3.22.0\r\n   *\r\n   * @param {function} callback - The callback to invoke when this body starts colliding with another.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n   */\n  setOnCollide: function (callback) {\n    this.body.onCollideCallback = callback;\n    return this;\n  },\n\n  /**\r\n   * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n   * \r\n   * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n   * to the callback.\r\n   *\r\n   * @method Phaser.Physics.Matter.Components.Collision#setOnCollideEnd\r\n   * @since 3.22.0\r\n   *\r\n   * @param {function} callback - The callback to invoke when this body stops colliding with another.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n   */\n  setOnCollideEnd: function (callback) {\n    this.body.onCollideEndCallback = callback;\n    return this;\n  },\n\n  /**\r\n   * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n   * \r\n   * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n   * to the callback.\r\n   *\r\n   * @method Phaser.Physics.Matter.Components.Collision#setOnCollideActive\r\n   * @since 3.22.0\r\n   *\r\n   * @param {function} callback - The callback to invoke for the duration of this body colliding with another.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n   */\n  setOnCollideActive: function (callback) {\n    this.body.onCollideActiveCallback = callback;\n    return this;\n  },\n\n  /**\r\n   * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n   * \r\n   * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n   * to the callback.\r\n   *\r\n   * @method Phaser.Physics.Matter.Components.Collision#setOnCollideWith\r\n   * @since 3.22.0\r\n   *\r\n   * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.\r\n   * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n   */\n  setOnCollideWith: function (body, callback) {\n    if (!Array.isArray(body)) {\n      body = [body];\n    }\n\n    for (var i = 0; i < body.length; i++) {\n      var src = body[i].hasOwnProperty('body') ? body[i].body : body[i];\n      this.body.setOnCollideWith(src, callback);\n    }\n\n    return this;\n  }\n};\nmodule.exports = Collision;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/components/Collision.js"],"names":["Collision","setCollisionCategory","value","body","collisionFilter","category","setCollisionGroup","group","setCollidesWith","categories","flags","Array","isArray","i","length","mask","setOnCollide","callback","onCollideCallback","setOnCollideEnd","onCollideEndCallback","setOnCollideActive","onCollideActiveCallback","setOnCollideWith","src","hasOwnProperty","module","exports"],"mappings":"AAAA;;;;;;AAMA;;;;;;AAMA,IAAIA,SAAS,GAAG;AAEZ;;;;;;;;;;;;AAYAC,EAAAA,oBAAoB,EAAE,UAAUC,KAAV,EACtB;AACI,SAAKC,IAAL,CAAUC,eAAV,CAA0BC,QAA1B,GAAqCH,KAArC;AAEA,WAAO,IAAP;AACH,GAnBW;;AAqBZ;;;;;;;;;;;;;AAaAI,EAAAA,iBAAiB,EAAE,UAAUJ,KAAV,EACnB;AACI,SAAKC,IAAL,CAAUC,eAAV,CAA0BG,KAA1B,GAAkCL,KAAlC;AAEA,WAAO,IAAP;AACH,GAvCW;;AAyCZ;;;;;;;;;;;;AAYAM,EAAAA,eAAe,EAAE,UAAUC,UAAV,EACjB;AACI,QAAIC,KAAK,GAAG,CAAZ;;AAEA,QAAI,CAACC,KAAK,CAACC,OAAN,CAAcH,UAAd,CAAL,EACA;AACIC,MAAAA,KAAK,GAAGD,UAAR;AACH,KAHD,MAKA;AACI,WAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,UAAU,CAACK,MAA/B,EAAuCD,CAAC,EAAxC,EACA;AACIH,QAAAA,KAAK,IAAID,UAAU,CAACI,CAAD,CAAnB;AACH;AACJ;;AAED,SAAKV,IAAL,CAAUC,eAAV,CAA0BW,IAA1B,GAAiCL,KAAjC;AAEA,WAAO,IAAP;AACH,GAxEW;;AA0EZ;;;;;;;;;;;;;AAaAM,EAAAA,YAAY,EAAE,UAAUC,QAAV,EACd;AACI,SAAKd,IAAL,CAAUe,iBAAV,GAA8BD,QAA9B;AAEA,WAAO,IAAP;AACH,GA5FW;;AA8FZ;;;;;;;;;;;;;AAaAE,EAAAA,eAAe,EAAE,UAAUF,QAAV,EACjB;AACI,SAAKd,IAAL,CAAUiB,oBAAV,GAAiCH,QAAjC;AAEA,WAAO,IAAP;AACH,GAhHW;;AAkHZ;;;;;;;;;;;;;AAaAI,EAAAA,kBAAkB,EAAE,UAAUJ,QAAV,EACpB;AACI,SAAKd,IAAL,CAAUmB,uBAAV,GAAoCL,QAApC;AAEA,WAAO,IAAP;AACH,GApIW;;AAsIZ;;;;;;;;;;;;;;AAcAM,EAAAA,gBAAgB,EAAE,UAAUpB,IAAV,EAAgBc,QAAhB,EAClB;AACI,QAAI,CAACN,KAAK,CAACC,OAAN,CAAcT,IAAd,CAAL,EACA;AACIA,MAAAA,IAAI,GAAG,CAAEA,IAAF,CAAP;AACH;;AAED,SAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,IAAI,CAACW,MAAzB,EAAiCD,CAAC,EAAlC,EACA;AACI,UAAIW,GAAG,GAAIrB,IAAI,CAACU,CAAD,CAAJ,CAAQY,cAAR,CAAuB,MAAvB,CAAD,GAAmCtB,IAAI,CAACU,CAAD,CAAJ,CAAQV,IAA3C,GAAkDA,IAAI,CAACU,CAAD,CAAhE;AAEA,WAAKV,IAAL,CAAUoB,gBAAV,CAA2BC,GAA3B,EAAgCP,QAAhC;AACH;;AAED,WAAO,IAAP;AACH;AAnKW,CAAhB;AAuKAS,MAAM,CAACC,OAAP,GAAiB3B,SAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Contains methods for changing the collision filter of a Matter Body. Should be used as a mixin and not called directly.\r\n *\r\n * @namespace Phaser.Physics.Matter.Components.Collision\r\n * @since 3.0.0\r\n */\r\nvar Collision = {\r\n\r\n    /**\r\n     * Sets the collision category of this Game Object's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.\r\n     * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\r\n     * categories are included in their collision masks (see {@link #setCollidesWith}).\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setCollisionCategory\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - Unique category bitfield.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setCollisionCategory: function (value)\r\n    {\r\n        this.body.collisionFilter.category = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the collision group of this Game Object's Matter Body. If this is zero or two Matter Bodies have different values,\r\n     * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\r\n     * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,\r\n     * they will never collide.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - Unique group index.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setCollisionGroup: function (value)\r\n    {\r\n        this.body.collisionFilter.group = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the collision mask for this Game Object's Matter Body. Two Matter Bodies with different collision groups will only\r\n     * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`\r\n     * and `(categoryB & maskA) !== 0` are both true.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setCollidesWith\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setCollidesWith: function (categories)\r\n    {\r\n        var flags = 0;\r\n\r\n        if (!Array.isArray(categories))\r\n        {\r\n            flags = categories;\r\n        }\r\n        else\r\n        {\r\n            for (var i = 0; i < categories.length; i++)\r\n            {\r\n                flags |= categories[i];\r\n            }\r\n        }\r\n\r\n        this.body.collisionFilter.mask = flags;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n     * \r\n     * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n     * to the callback.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setOnCollide\r\n     * @since 3.22.0\r\n     *\r\n     * @param {function} callback - The callback to invoke when this body starts colliding with another.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setOnCollide: function (callback)\r\n    {\r\n        this.body.onCollideCallback = callback;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n     * \r\n     * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n     * to the callback.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setOnCollideEnd\r\n     * @since 3.22.0\r\n     *\r\n     * @param {function} callback - The callback to invoke when this body stops colliding with another.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setOnCollideEnd: function (callback)\r\n    {\r\n        this.body.onCollideEndCallback = callback;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n     * \r\n     * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n     * to the callback.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setOnCollideActive\r\n     * @since 3.22.0\r\n     *\r\n     * @param {function} callback - The callback to invoke for the duration of this body colliding with another.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setOnCollideActive: function (callback)\r\n    {\r\n        this.body.onCollideActiveCallback = callback;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n     * \r\n     * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n     * to the callback.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setOnCollideWith\r\n     * @since 3.22.0\r\n     *\r\n     * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.\r\n     * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setOnCollideWith: function (body, callback)\r\n    {\r\n        if (!Array.isArray(body))\r\n        {\r\n            body = [ body ];\r\n        }\r\n\r\n        for (var i = 0; i < body.length; i++)\r\n        {\r\n            var src = (body[i].hasOwnProperty('body')) ? body[i].body : body[i];\r\n\r\n            this.body.setOnCollideWith(src, callback);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Collision;\r\n"]},"metadata":{},"sourceType":"script"}