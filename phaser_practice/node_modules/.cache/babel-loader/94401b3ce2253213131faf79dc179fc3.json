{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Clone = require('../../utils/object/Clone');\n/**\r\n * Parses a Texture Atlas JSON Hash and adds the Frames to the Texture.\r\n * JSON format expected to match that defined by Texture Packer, with the frames property containing an object of Frames.\r\n *\r\n * @function Phaser.Textures.Parsers.JSONHash\r\n * @memberof Phaser.Textures.Parsers\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {integer} sourceIndex - The index of the TextureSource.\r\n * @param {object} json - The JSON data.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */\n\n\nvar JSONHash = function (texture, sourceIndex, json) {\n  //  Malformed?\n  if (!json['frames']) {\n    console.warn('Invalid Texture Atlas JSON Hash given, missing \\'frames\\' Object');\n    return;\n  } //  Add in a __BASE entry (for the entire atlas)\n\n\n  var source = texture.source[sourceIndex];\n  texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height); //  By this stage frames is a fully parsed Object\n\n  var frames = json['frames'];\n  var newFrame;\n\n  for (var key in frames) {\n    var src = frames[key]; //  The frame values are the exact coordinates to cut the frame out of the atlas from\n\n    newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h); //  These are the original (non-trimmed) sprite values\n\n    if (src.trimmed) {\n      newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h);\n    }\n\n    if (src.rotated) {\n      newFrame.rotated = true;\n      newFrame.updateUVsInverted();\n    } //  Copy over any extra data\n\n\n    newFrame.customData = Clone(src);\n  } //  Copy over any additional data that was in the JSON to Texture.customData\n\n\n  for (var dataKey in json) {\n    if (dataKey === 'frames') {\n      continue;\n    }\n\n    if (Array.isArray(json[dataKey])) {\n      texture.customData[dataKey] = json[dataKey].slice(0);\n    } else {\n      texture.customData[dataKey] = json[dataKey];\n    }\n  }\n\n  return texture;\n};\n\nmodule.exports = JSONHash;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/textures/parsers/JSONHash.js"],"names":["Clone","require","JSONHash","texture","sourceIndex","json","console","warn","source","add","width","height","frames","newFrame","key","src","frame","x","y","w","h","trimmed","setTrim","sourceSize","spriteSourceSize","rotated","updateUVsInverted","customData","dataKey","Array","isArray","slice","module","exports"],"mappings":"AAAA;;;;;AAMA,IAAIA,KAAK,GAAGC,OAAO,CAAC,0BAAD,CAAnB;AAEA;;;;;;;;;;;;;;;;;AAeA,IAAIC,QAAQ,GAAG,UAAUC,OAAV,EAAmBC,WAAnB,EAAgCC,IAAhC,EACf;AACI;AACA,MAAI,CAACA,IAAI,CAAC,QAAD,CAAT,EACA;AACIC,IAAAA,OAAO,CAACC,IAAR,CAAa,kEAAb;AACA;AACH,GANL,CAQI;;;AACA,MAAIC,MAAM,GAAGL,OAAO,CAACK,MAAR,CAAeJ,WAAf,CAAb;AAEAD,EAAAA,OAAO,CAACM,GAAR,CAAY,QAAZ,EAAsBL,WAAtB,EAAmC,CAAnC,EAAsC,CAAtC,EAAyCI,MAAM,CAACE,KAAhD,EAAuDF,MAAM,CAACG,MAA9D,EAXJ,CAaI;;AACA,MAAIC,MAAM,GAAGP,IAAI,CAAC,QAAD,CAAjB;AACA,MAAIQ,QAAJ;;AAEA,OAAK,IAAIC,GAAT,IAAgBF,MAAhB,EACA;AACI,QAAIG,GAAG,GAAGH,MAAM,CAACE,GAAD,CAAhB,CADJ,CAGI;;AACAD,IAAAA,QAAQ,GAAGV,OAAO,CAACM,GAAR,CAAYK,GAAZ,EAAiBV,WAAjB,EAA8BW,GAAG,CAACC,KAAJ,CAAUC,CAAxC,EAA2CF,GAAG,CAACC,KAAJ,CAAUE,CAArD,EAAwDH,GAAG,CAACC,KAAJ,CAAUG,CAAlE,EAAqEJ,GAAG,CAACC,KAAJ,CAAUI,CAA/E,CAAX,CAJJ,CAMI;;AACA,QAAIL,GAAG,CAACM,OAAR,EACA;AACIR,MAAAA,QAAQ,CAACS,OAAT,CACIP,GAAG,CAACQ,UAAJ,CAAeJ,CADnB,EAEIJ,GAAG,CAACQ,UAAJ,CAAeH,CAFnB,EAGIL,GAAG,CAACS,gBAAJ,CAAqBP,CAHzB,EAIIF,GAAG,CAACS,gBAAJ,CAAqBN,CAJzB,EAKIH,GAAG,CAACS,gBAAJ,CAAqBL,CALzB,EAMIJ,GAAG,CAACS,gBAAJ,CAAqBJ,CANzB;AAQH;;AAED,QAAIL,GAAG,CAACU,OAAR,EACA;AACIZ,MAAAA,QAAQ,CAACY,OAAT,GAAmB,IAAnB;AACAZ,MAAAA,QAAQ,CAACa,iBAAT;AACH,KAvBL,CAyBI;;;AACAb,IAAAA,QAAQ,CAACc,UAAT,GAAsB3B,KAAK,CAACe,GAAD,CAA3B;AACH,GA7CL,CA+CI;;;AACA,OAAK,IAAIa,OAAT,IAAoBvB,IAApB,EACA;AACI,QAAIuB,OAAO,KAAK,QAAhB,EACA;AACI;AACH;;AAED,QAAIC,KAAK,CAACC,OAAN,CAAczB,IAAI,CAACuB,OAAD,CAAlB,CAAJ,EACA;AACIzB,MAAAA,OAAO,CAACwB,UAAR,CAAmBC,OAAnB,IAA8BvB,IAAI,CAACuB,OAAD,CAAJ,CAAcG,KAAd,CAAoB,CAApB,CAA9B;AACH,KAHD,MAKA;AACI5B,MAAAA,OAAO,CAACwB,UAAR,CAAmBC,OAAnB,IAA8BvB,IAAI,CAACuB,OAAD,CAAlC;AACH;AACJ;;AAED,SAAOzB,OAAP;AACH,CAnED;;AAqEA6B,MAAM,CAACC,OAAP,GAAiB/B,QAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clone = require('../../utils/object/Clone');\r\n\r\n/**\r\n * Parses a Texture Atlas JSON Hash and adds the Frames to the Texture.\r\n * JSON format expected to match that defined by Texture Packer, with the frames property containing an object of Frames.\r\n *\r\n * @function Phaser.Textures.Parsers.JSONHash\r\n * @memberof Phaser.Textures.Parsers\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {integer} sourceIndex - The index of the TextureSource.\r\n * @param {object} json - The JSON data.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */\r\nvar JSONHash = function (texture, sourceIndex, json)\r\n{\r\n    //  Malformed?\r\n    if (!json['frames'])\r\n    {\r\n        console.warn('Invalid Texture Atlas JSON Hash given, missing \\'frames\\' Object');\r\n        return;\r\n    }\r\n\r\n    //  Add in a __BASE entry (for the entire atlas)\r\n    var source = texture.source[sourceIndex];\r\n\r\n    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);\r\n\r\n    //  By this stage frames is a fully parsed Object\r\n    var frames = json['frames'];\r\n    var newFrame;\r\n\r\n    for (var key in frames)\r\n    {\r\n        var src = frames[key];\r\n\r\n        //  The frame values are the exact coordinates to cut the frame out of the atlas from\r\n        newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);\r\n\r\n        //  These are the original (non-trimmed) sprite values\r\n        if (src.trimmed)\r\n        {\r\n            newFrame.setTrim(\r\n                src.sourceSize.w,\r\n                src.sourceSize.h,\r\n                src.spriteSourceSize.x,\r\n                src.spriteSourceSize.y,\r\n                src.spriteSourceSize.w,\r\n                src.spriteSourceSize.h\r\n            );\r\n        }\r\n\r\n        if (src.rotated)\r\n        {\r\n            newFrame.rotated = true;\r\n            newFrame.updateUVsInverted();\r\n        }\r\n\r\n        //  Copy over any extra data\r\n        newFrame.customData = Clone(src);\r\n    }\r\n\r\n    //  Copy over any additional data that was in the JSON to Texture.customData\r\n    for (var dataKey in json)\r\n    {\r\n        if (dataKey === 'frames')\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (Array.isArray(json[dataKey]))\r\n        {\r\n            texture.customData[dataKey] = json[dataKey].slice(0);\r\n        }\r\n        else\r\n        {\r\n            texture.customData[dataKey] = json[dataKey];\r\n        }\r\n    }\r\n\r\n    return texture;\r\n};\r\n\r\nmodule.exports = JSONHash;\r\n"]},"metadata":{},"sourceType":"script"}