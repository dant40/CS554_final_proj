{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Utils = require('../../../renderer/webgl/Utils');\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.BitmapText#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.BitmapText} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\n\n\nvar BitmapTextWebGLRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix) {\n  var text = src._text;\n  var textLength = text.length;\n\n  if (textLength === 0) {\n    return;\n  }\n\n  var pipeline = this.pipeline;\n  renderer.setPipeline(pipeline, src);\n  var camMatrix = pipeline._tempMatrix1;\n  var spriteMatrix = pipeline._tempMatrix2;\n  var calcMatrix = pipeline._tempMatrix3;\n  spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\n  camMatrix.copyFrom(camera.matrix);\n\n  if (parentMatrix) {\n    //  Multiply the camera by the parent matrix\n    camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY); //  Undo the camera scroll\n\n    spriteMatrix.e = src.x;\n    spriteMatrix.f = src.y; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n    camMatrix.multiply(spriteMatrix, calcMatrix);\n  } else {\n    spriteMatrix.e -= camera.scrollX * src.scrollFactorX;\n    spriteMatrix.f -= camera.scrollY * src.scrollFactorY; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n    camMatrix.multiply(spriteMatrix, calcMatrix);\n  }\n\n  var frame = src.frame;\n  var texture = frame.glTexture;\n  var textureX = frame.cutX;\n  var textureY = frame.cutY;\n  var textureWidth = texture.width;\n  var textureHeight = texture.height;\n  var tintEffect = src._isTinted && src.tintFill;\n  var tintTL = Utils.getTintAppendFloatAlpha(src._tintTL, camera.alpha * src._alphaTL);\n  var tintTR = Utils.getTintAppendFloatAlpha(src._tintTR, camera.alpha * src._alphaTR);\n  var tintBL = Utils.getTintAppendFloatAlpha(src._tintBL, camera.alpha * src._alphaBL);\n  var tintBR = Utils.getTintAppendFloatAlpha(src._tintBR, camera.alpha * src._alphaBR);\n  pipeline.setTexture2D(texture, 0);\n  var xAdvance = 0;\n  var yAdvance = 0;\n  var charCode = 0;\n  var lastCharCode = 0;\n  var letterSpacing = src._letterSpacing;\n  var glyph;\n  var glyphX = 0;\n  var glyphY = 0;\n  var glyphW = 0;\n  var glyphH = 0;\n  var lastGlyph;\n  var fontData = src.fontData;\n  var chars = fontData.chars;\n  var lineHeight = fontData.lineHeight;\n  var scale = src._fontSize / fontData.size;\n  var align = src._align;\n  var currentLine = 0;\n  var lineOffsetX = 0; //  Update the bounds - skipped internally if not dirty\n\n  var bounds = src.getTextBounds(false); //  In case the method above changed it (word wrapping)\n\n  if (src.maxWidth > 0) {\n    text = bounds.wrappedText;\n    textLength = text.length;\n  }\n\n  var lineData = src._bounds.lines;\n\n  if (align === 1) {\n    lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;\n  } else if (align === 2) {\n    lineOffsetX = lineData.longest - lineData.lengths[0];\n  }\n\n  var roundPixels = camera.roundPixels;\n\n  for (var i = 0; i < textLength; i++) {\n    charCode = text.charCodeAt(i); //  Carriage-return\n\n    if (charCode === 10) {\n      currentLine++;\n\n      if (align === 1) {\n        lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;\n      } else if (align === 2) {\n        lineOffsetX = lineData.longest - lineData.lengths[currentLine];\n      }\n\n      xAdvance = 0;\n      yAdvance += lineHeight;\n      lastGlyph = null;\n      continue;\n    }\n\n    glyph = chars[charCode];\n\n    if (!glyph) {\n      continue;\n    }\n\n    glyphX = textureX + glyph.x;\n    glyphY = textureY + glyph.y;\n    glyphW = glyph.width;\n    glyphH = glyph.height;\n    var x = glyph.xOffset + xAdvance;\n    var y = glyph.yOffset + yAdvance;\n\n    if (lastGlyph !== null) {\n      var kerningOffset = glyph.kerning[lastCharCode];\n      x += kerningOffset !== undefined ? kerningOffset : 0;\n    }\n\n    xAdvance += glyph.xAdvance + letterSpacing;\n    lastGlyph = glyph;\n    lastCharCode = charCode; //  Nothing to render or a space? Then skip to the next glyph\n\n    if (glyphW === 0 || glyphH === 0 || charCode === 32) {\n      continue;\n    }\n\n    x *= scale;\n    y *= scale;\n    x -= src.displayOriginX;\n    y -= src.displayOriginY;\n    x += lineOffsetX;\n    var u0 = glyphX / textureWidth;\n    var v0 = glyphY / textureHeight;\n    var u1 = (glyphX + glyphW) / textureWidth;\n    var v1 = (glyphY + glyphH) / textureHeight;\n    var xw = x + glyphW * scale;\n    var yh = y + glyphH * scale;\n    var tx0 = calcMatrix.getX(x, y);\n    var ty0 = calcMatrix.getY(x, y);\n    var tx1 = calcMatrix.getX(x, yh);\n    var ty1 = calcMatrix.getY(x, yh);\n    var tx2 = calcMatrix.getX(xw, yh);\n    var ty2 = calcMatrix.getY(xw, yh);\n    var tx3 = calcMatrix.getX(xw, y);\n    var ty3 = calcMatrix.getY(xw, y);\n\n    if (roundPixels) {\n      tx0 = Math.round(tx0);\n      ty0 = Math.round(ty0);\n      tx1 = Math.round(tx1);\n      ty1 = Math.round(ty1);\n      tx2 = Math.round(tx2);\n      ty2 = Math.round(ty2);\n      tx3 = Math.round(tx3);\n      ty3 = Math.round(ty3);\n    }\n\n    pipeline.batchQuad(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, 0);\n  }\n};\n\nmodule.exports = BitmapTextWebGLRenderer;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextWebGLRenderer.js"],"names":["Utils","require","BitmapTextWebGLRenderer","renderer","src","interpolationPercentage","camera","parentMatrix","text","_text","textLength","length","pipeline","setPipeline","camMatrix","_tempMatrix1","spriteMatrix","_tempMatrix2","calcMatrix","_tempMatrix3","applyITRS","x","y","rotation","scaleX","scaleY","copyFrom","matrix","multiplyWithOffset","scrollX","scrollFactorX","scrollY","scrollFactorY","e","f","multiply","frame","texture","glTexture","textureX","cutX","textureY","cutY","textureWidth","width","textureHeight","height","tintEffect","_isTinted","tintFill","tintTL","getTintAppendFloatAlpha","_tintTL","alpha","_alphaTL","tintTR","_tintTR","_alphaTR","tintBL","_tintBL","_alphaBL","tintBR","_tintBR","_alphaBR","setTexture2D","xAdvance","yAdvance","charCode","lastCharCode","letterSpacing","_letterSpacing","glyph","glyphX","glyphY","glyphW","glyphH","lastGlyph","fontData","chars","lineHeight","scale","_fontSize","size","align","_align","currentLine","lineOffsetX","bounds","getTextBounds","maxWidth","wrappedText","lineData","_bounds","lines","longest","lengths","roundPixels","i","charCodeAt","xOffset","yOffset","kerningOffset","kerning","undefined","displayOriginX","displayOriginY","u0","v0","u1","v1","xw","yh","tx0","getX","ty0","getY","tx1","ty1","tx2","ty2","tx3","ty3","Math","round","batchQuad","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.BitmapText#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.BitmapText} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar BitmapTextWebGLRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix)\r\n{\r\n    var text = src._text;\r\n    var textLength = text.length;\r\n\r\n    if (textLength === 0)\r\n    {\r\n        return;\r\n    }\r\n \r\n    var pipeline = this.pipeline;\r\n\r\n    renderer.setPipeline(pipeline, src);\r\n\r\n    var camMatrix = pipeline._tempMatrix1;\r\n    var spriteMatrix = pipeline._tempMatrix2;\r\n    var calcMatrix = pipeline._tempMatrix3;\r\n\r\n    spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\r\n\r\n    camMatrix.copyFrom(camera.matrix);\r\n\r\n    if (parentMatrix)\r\n    {\r\n        //  Multiply the camera by the parent matrix\r\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n\r\n        //  Undo the camera scroll\r\n        spriteMatrix.e = src.x;\r\n        spriteMatrix.f = src.y;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(spriteMatrix, calcMatrix);\r\n    }\r\n    else\r\n    {\r\n        spriteMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n        spriteMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(spriteMatrix, calcMatrix);\r\n    }\r\n\r\n    var frame = src.frame;\r\n    var texture = frame.glTexture;\r\n    var textureX = frame.cutX;\r\n    var textureY = frame.cutY;\r\n    var textureWidth = texture.width;\r\n    var textureHeight = texture.height;\r\n\r\n    var tintEffect = (src._isTinted && src.tintFill);\r\n    var tintTL = Utils.getTintAppendFloatAlpha(src._tintTL, camera.alpha * src._alphaTL);\r\n    var tintTR = Utils.getTintAppendFloatAlpha(src._tintTR, camera.alpha * src._alphaTR);\r\n    var tintBL = Utils.getTintAppendFloatAlpha(src._tintBL, camera.alpha * src._alphaBL);\r\n    var tintBR = Utils.getTintAppendFloatAlpha(src._tintBR, camera.alpha * src._alphaBR);\r\n\r\n    pipeline.setTexture2D(texture, 0);\r\n\r\n    var xAdvance = 0;\r\n    var yAdvance = 0;\r\n    var charCode = 0;\r\n    var lastCharCode = 0;\r\n    var letterSpacing = src._letterSpacing;\r\n    var glyph;\r\n    var glyphX = 0;\r\n    var glyphY = 0;\r\n    var glyphW = 0;\r\n    var glyphH = 0;\r\n    var lastGlyph;\r\n\r\n    var fontData = src.fontData;\r\n    var chars = fontData.chars;\r\n    var lineHeight = fontData.lineHeight;\r\n    var scale = (src._fontSize / fontData.size);\r\n\r\n    var align = src._align;\r\n    var currentLine = 0;\r\n    var lineOffsetX = 0;\r\n\r\n    //  Update the bounds - skipped internally if not dirty\r\n    var bounds = src.getTextBounds(false);\r\n\r\n    //  In case the method above changed it (word wrapping)\r\n    if (src.maxWidth > 0)\r\n    {\r\n        text = bounds.wrappedText;\r\n        textLength = text.length;\r\n    }\r\n\r\n    var lineData = src._bounds.lines;\r\n\r\n    if (align === 1)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;\r\n    }\r\n    else if (align === 2)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]);\r\n    }\r\n\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    for (var i = 0; i < textLength; i++)\r\n    {\r\n        charCode = text.charCodeAt(i);\r\n\r\n        //  Carriage-return\r\n        if (charCode === 10)\r\n        {\r\n            currentLine++;\r\n\r\n            if (align === 1)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;\r\n            }\r\n            else if (align === 2)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]);\r\n            }\r\n        \r\n            xAdvance = 0;\r\n            yAdvance += lineHeight;\r\n            lastGlyph = null;\r\n        \r\n            continue;\r\n        }\r\n\r\n        glyph = chars[charCode];\r\n\r\n        if (!glyph)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        glyphX = textureX + glyph.x;\r\n        glyphY = textureY + glyph.y;\r\n\r\n        glyphW = glyph.width;\r\n        glyphH = glyph.height;\r\n\r\n        var x = glyph.xOffset + xAdvance;\r\n        var y = glyph.yOffset + yAdvance;\r\n\r\n        if (lastGlyph !== null)\r\n        {\r\n            var kerningOffset = glyph.kerning[lastCharCode];\r\n            x += (kerningOffset !== undefined) ? kerningOffset : 0;\r\n        }\r\n\r\n        xAdvance += glyph.xAdvance + letterSpacing;\r\n        lastGlyph = glyph;\r\n        lastCharCode = charCode;\r\n\r\n        //  Nothing to render or a space? Then skip to the next glyph\r\n        if (glyphW === 0 || glyphH === 0 || charCode === 32)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        x *= scale;\r\n        y *= scale;\r\n\r\n        x -= src.displayOriginX;\r\n        y -= src.displayOriginY;\r\n\r\n        x += lineOffsetX;\r\n\r\n        var u0 = glyphX / textureWidth;\r\n        var v0 = glyphY / textureHeight;\r\n        var u1 = (glyphX + glyphW) / textureWidth;\r\n        var v1 = (glyphY + glyphH) / textureHeight;\r\n\r\n        var xw = x + (glyphW * scale);\r\n        var yh = y + (glyphH * scale);\r\n\r\n        var tx0 = calcMatrix.getX(x, y);\r\n        var ty0 = calcMatrix.getY(x, y);\r\n\r\n        var tx1 = calcMatrix.getX(x, yh);\r\n        var ty1 = calcMatrix.getY(x, yh);\r\n\r\n        var tx2 = calcMatrix.getX(xw, yh);\r\n        var ty2 = calcMatrix.getY(xw, yh);\r\n\r\n        var tx3 = calcMatrix.getX(xw, y);\r\n        var ty3 = calcMatrix.getY(xw, y);\r\n\r\n        if (roundPixels)\r\n        {\r\n            tx0 = Math.round(tx0);\r\n            ty0 = Math.round(ty0);\r\n\r\n            tx1 = Math.round(tx1);\r\n            ty1 = Math.round(ty1);\r\n\r\n            tx2 = Math.round(tx2);\r\n            ty2 = Math.round(ty2);\r\n\r\n            tx3 = Math.round(tx3);\r\n            ty3 = Math.round(ty3);\r\n        }\r\n\r\n        pipeline.batchQuad(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, 0);\r\n    }\r\n};\r\n\r\nmodule.exports = BitmapTextWebGLRenderer;\r\n"]},"metadata":{},"sourceType":"script"}