{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar Components = require('../components');\n\nvar GameObject = require('../GameObject');\n\nvar GetFastValue = require('../../utils/object/GetFastValue');\n\nvar Extend = require('../../utils/object/Extend');\n\nvar SetValue = require('../../utils/object/SetValue');\n\nvar ShaderRender = require('./ShaderRender');\n\nvar TransformMatrix = require('../components/TransformMatrix');\n/**\r\n * @classdesc\r\n * A Shader Game Object.\r\n * \r\n * This Game Object allows you to easily add a quad with its own shader into the display list, and manipulate it\r\n * as you would any other Game Object, including scaling, rotating, positioning and adding to Containers. Shaders\r\n * can be masked with either Bitmap or Geometry masks and can also be used as a Bitmap Mask for a Camera or other\r\n * Game Object. They can also be made interactive and used for input events.\r\n * \r\n * It works by taking a reference to a `Phaser.Display.BaseShader` instance, as found in the Shader Cache. These can\r\n * be created dynamically at runtime, or loaded in via the GLSL File Loader:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.glsl('fire', 'shaders/fire.glsl.js');\r\n * }\r\n *  \r\n * function create ()\r\n * {\r\n *     this.add.shader('fire', 400, 300, 512, 512);\r\n * }\r\n * ```\r\n * \r\n * Please see the Phaser 3 Examples GitHub repo for examples of loading and creating shaders dynamically.\r\n * \r\n * Due to the way in which they work, you cannot directly change the alpha or blend mode of a Shader. This should\r\n * be handled via exposed uniforms in the shader code itself.\r\n * \r\n * By default a Shader will be created with a standard set of uniforms. These were added to match those\r\n * found on sites such as ShaderToy or GLSLSandbox, and provide common functionality a shader may need,\r\n * such as the timestamp, resolution or pointer position. You can replace them by specifying your own uniforms\r\n * in the Base Shader.\r\n * \r\n * These Shaders work by halting the current pipeline during rendering, creating a viewport matched to the\r\n * size of this Game Object and then renders a quad using the bound shader. At the end, the pipeline is restored.\r\n * \r\n * Because it blocks the pipeline it means it will interrupt any batching that is currently going on, so you should\r\n * use these Game Objects sparingly. If you need to have a fully batched custom shader, then please look at using\r\n * a custom pipeline instead. However, for background or special masking effects, they are extremely effective.\r\n * \r\n * @class Shader\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @webglOnly\r\n * @since 3.17.0\r\n *\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {(string|Phaser.Display.BaseShader)} key - The key of the shader to use from the shader cache, or a BaseShader instance.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=128] - The width of the Game Object.\r\n * @param {number} [height=128] - The height of the Game Object.\r\n * @param {string[]} [textures] - Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.\r\n * @param {any} [textureData] - Additional texture data if you want to create shader with none NPOT textures.\r\n */\n\n\nvar Shader = new Class({\n  Extends: GameObject,\n  Mixins: [Components.ComputedSize, Components.Depth, Components.GetBounds, Components.Mask, Components.Origin, Components.ScrollFactor, Components.Transform, Components.Visible, ShaderRender],\n  initialize: function Shader(scene, key, x, y, width, height, textures, textureData) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = 128;\n    }\n\n    if (height === undefined) {\n      height = 128;\n    }\n\n    GameObject.call(this, scene, 'Shader');\n    /**\r\n     * This Game Object cannot have a blend mode, so skip all checks.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#blendMode\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.17.0\r\n     */\n\n    this.blendMode = -1;\n    /**\r\n     * The underlying shader object being used.\r\n     * Empty by default and set during a call to the `setShader` method.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#shader\r\n     * @type {Phaser.Display.BaseShader}\r\n     * @since 3.17.0\r\n     */\n\n    this.shader;\n    var renderer = scene.sys.renderer;\n    /**\r\n     * A reference to the current renderer.\r\n     * Shaders only work with the WebGL Renderer.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#renderer\r\n     * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n     * @since 3.17.0\r\n     */\n\n    this.renderer = renderer;\n    /**\r\n     * The WebGL context belonging to the renderer.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#gl\r\n     * @type {WebGLRenderingContext}\r\n     * @since 3.17.0\r\n     */\n\n    this.gl = renderer.gl;\n    /**\r\n     * Raw byte buffer of vertices this Shader uses.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#vertexData\r\n     * @type {ArrayBuffer}\r\n     * @since 3.17.0\r\n     */\n\n    this.vertexData = new ArrayBuffer(6 * (Float32Array.BYTES_PER_ELEMENT * 2));\n    /**\r\n     * The WebGL vertex buffer object this shader uses.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#vertexBuffer\r\n     * @type {WebGLBuffer}\r\n     * @since 3.17.0\r\n     */\n\n    this.vertexBuffer = renderer.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW);\n    /**\r\n     * The WebGL shader program this shader uses.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#program\r\n     * @type {WebGLProgram}\r\n     * @since 3.17.0\r\n     */\n\n    this.program = null;\n    /**\r\n     * Uint8 view to the vertex raw buffer. Used for uploading vertex buffer resources to the GPU.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#bytes\r\n     * @type {Uint8Array}\r\n     * @since 3.17.0\r\n     */\n\n    this.bytes = new Uint8Array(this.vertexData);\n    /**\r\n     * Float32 view of the array buffer containing the shaders vertices.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#vertexViewF32\r\n     * @type {Float32Array}\r\n     * @since 3.17.0\r\n     */\n\n    this.vertexViewF32 = new Float32Array(this.vertexData);\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#_tempMatrix1\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.17.0\r\n     */\n\n    this._tempMatrix1 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#_tempMatrix2\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.17.0\r\n     */\n\n    this._tempMatrix2 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#_tempMatrix3\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.17.0\r\n     */\n\n    this._tempMatrix3 = new TransformMatrix();\n    /**\r\n     * The view matrix the shader uses during rendering.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#viewMatrix\r\n     * @type {Float32Array}\r\n     * @readonly\r\n     * @since 3.17.0\r\n     */\n\n    this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n    /**\r\n     * The projection matrix the shader uses during rendering.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#projectionMatrix\r\n     * @type {Float32Array}\r\n     * @readonly\r\n     * @since 3.17.0\r\n     */\n\n    this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n    /**\r\n     * The default uniform mappings. These can be added to (or replaced) by specifying your own uniforms when\r\n     * creating this shader game object. The uniforms are updated automatically during the render step.\r\n     * \r\n     * The defaults are:\r\n     * \r\n     * `resolution` (2f) - Set to the size of this shader.\r\n     * `time` (1f) - The elapsed game time, in seconds.\r\n     * `mouse` (2f) - If a pointer has been bound (with `setPointer`), this uniform contains its position each frame.\r\n     * `date` (4fv) - A vec4 containing the year, month, day and time in seconds.\r\n     * `sampleRate` (1f) - Sound sample rate. 44100 by default.\r\n     * `iChannel0...3` (sampler2D) - Input channels 0 to 3. `null` by default.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#uniforms\r\n     * @type {any}\r\n     * @since 3.17.0\r\n     */\n\n    this.uniforms = {};\n    /**\r\n     * The pointer bound to this shader, if any.\r\n     * Set via the chainable `setPointer` method, or by modifying this property directly.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#pointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @since 3.17.0\r\n     */\n\n    this.pointer = null;\n    /**\r\n     * The cached width of the renderer.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#_rendererWidth\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.17.0\r\n     */\n\n    this._rendererWidth = renderer.width;\n    /**\r\n     * The cached height of the renderer.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#_rendererHeight\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.17.0\r\n     */\n\n    this._rendererHeight = renderer.height;\n    /**\r\n     * Internal texture count tracker.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#_textureCount\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.17.0\r\n     */\n\n    this._textureCount = 0;\n    /**\r\n     * A reference to the GL Frame Buffer this Shader is drawing to.\r\n     * This property is only set if you have called `Shader.setRenderToTexture`.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#framebuffer\r\n     * @type {?WebGLFramebuffer}\r\n     * @since 3.19.0\r\n     */\n\n    this.framebuffer = null;\n    /**\r\n     * A reference to the WebGLTexture this Shader is rendering to.\r\n     * This property is only set if you have called `Shader.setRenderToTexture`.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#glTexture\r\n     * @type {?WebGLTexture}\r\n     * @since 3.19.0\r\n     */\n\n    this.glTexture = null;\n    /**\r\n     * A flag that indicates if this Shader has been set to render to a texture instead of the display list.\r\n     * \r\n     * This property is `true` if you have called `Shader.setRenderToTexture`, otherwise it's `false`.\r\n     * \r\n     * A Shader that is rendering to a texture _does not_ appear on the display list.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#renderToTexture\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.19.0\r\n     */\n\n    this.renderToTexture = false;\n    /**\r\n     * A reference to the Phaser.Textures.Texture that has been stored in the Texture Manager for this Shader.\r\n     * \r\n     * This property is only set if you have called `Shader.setRenderToTexture`, otherwise it is `null`.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#texture\r\n     * @type {Phaser.Textures.Texture}\r\n     * @since 3.19.0\r\n     */\n\n    this.texture = null;\n    this.setPosition(x, y);\n    this.setSize(width, height);\n    this.setOrigin(0.5, 0.5);\n    this.setShader(key, textures, textureData);\n  },\n\n  /**\r\n   * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n   * Also checks the Game Object against the given Cameras exclusion list.\r\n   *\r\n   * @method Phaser.GameObjects.Shader#willRender\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.\r\n   *\r\n   * @return {boolean} True if the Game Object should be rendered, otherwise false.\r\n   */\n  willRender: function (camera) {\n    if (this.renderToTexture) {\n      return true;\n    } else {\n      return !(GameObject.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);\n    }\n  },\n\n  /**\r\n   * Changes this Shader so instead of rendering to the display list it renders to a\r\n   * WebGL Framebuffer and WebGL Texture instead. This allows you to use the output\r\n   * of this shader as an input for another shader, by mapping a sampler2D uniform\r\n   * to it.\r\n   * \r\n   * After calling this method the `Shader.framebuffer` and `Shader.glTexture` properties\r\n   * are populated.\r\n   * \r\n   * Additionally, you can provide a key to this method. Doing so will create a Phaser Texture\r\n   * from this Shader and save it into the Texture Manager, allowing you to then use it for\r\n   * any texture-based Game Object, such as a Sprite or Image:\r\n   * \r\n   * ```javascript\r\n   * var shader = this.add.shader('myShader', x, y, width, height);\r\n   * \r\n   * shader.setRenderToTexture('doodle');\r\n   * \r\n   * this.add.image(400, 300, 'doodle');\r\n   * ```\r\n   * \r\n   * Note that it stores an active reference to this Shader. That means as this shader updates,\r\n   * so does the texture and any object using it to render with. Also, if you destroy this\r\n   * shader, be sure to clear any objects that may have been using it as a texture too.\r\n   * \r\n   * You can access the Phaser Texture that is created via the `Shader.texture` property.\r\n   * \r\n   * By default it will create a single base texture. You can add frames to the texture\r\n   * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n   * to use a specific frame from a Render Texture.\r\n   *\r\n   * @method Phaser.GameObjects.Shader#setRenderToTexture\r\n   * @since 3.19.0\r\n   *\r\n   * @param {string} [key] - The unique key to store the texture as within the global Texture Manager.\r\n   * @param {boolean} [flipY=false] - Does this texture need vertically flipping before rendering? This should usually be set to `true` if being fed from a buffer.\r\n   *\r\n   * @return {this} This Shader instance.\r\n   */\n  setRenderToTexture: function (key, flipY) {\n    if (flipY === undefined) {\n      flipY = false;\n    }\n\n    if (!this.renderToTexture) {\n      var width = this.width;\n      var height = this.height;\n      var renderer = this.renderer;\n      this.glTexture = renderer.createTextureFromSource(null, width, height, 0);\n      this.glTexture.flipY = flipY;\n      this.framebuffer = renderer.createFramebuffer(width, height, this.glTexture, false);\n      this._rendererWidth = width;\n      this._rendererHeight = height;\n      this.renderToTexture = true;\n      this.projOrtho(0, this.width, this.height, 0);\n\n      if (key) {\n        this.texture = this.scene.sys.textures.addGLTexture(key, this.glTexture, width, height);\n      }\n    } //  And now render at least once, so our texture isn't blank on the first update\n\n\n    if (this.shader) {\n      var pipeline = renderer.currentPipeline;\n      renderer.clearPipeline();\n      this.load();\n      this.flush();\n      renderer.rebindPipeline(pipeline);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the fragment and, optionally, the vertex shader source code that this Shader will use.\r\n   * This will immediately delete the active shader program, if set, and then create a new one\r\n   * with the given source. Finally, the shader uniforms are initialized.\r\n   *\r\n   * @method Phaser.GameObjects.Shader#setShader\r\n   * @since 3.17.0\r\n   * \r\n   * @param {(string|Phaser.Display.BaseShader)} key - The key of the shader to use from the shader cache, or a BaseShader instance.\r\n   * @param {string[]} [textures] - Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.\r\n   * @param {any} [textureData] - Additional texture data.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setShader: function (key, textures, textureData) {\n    if (textures === undefined) {\n      textures = [];\n    }\n\n    if (typeof key === 'string') {\n      var cache = this.scene.sys.cache.shader;\n\n      if (!cache.has(key)) {\n        console.warn('Shader missing: ' + key);\n        return this;\n      }\n\n      this.shader = cache.get(key);\n    } else {\n      this.shader = key;\n    }\n\n    var gl = this.gl;\n    var renderer = this.renderer;\n\n    if (this.program) {\n      gl.deleteProgram(this.program);\n    }\n\n    var program = renderer.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc); //  The default uniforms available within the vertex shader\n\n    renderer.setMatrix4(program, 'uViewMatrix', false, this.viewMatrix);\n    renderer.setMatrix4(program, 'uProjectionMatrix', false, this.projectionMatrix);\n    renderer.setFloat2(program, 'uResolution', this.width, this.height);\n    this.program = program;\n    var d = new Date(); //  The default uniforms available within the fragment shader\n\n    var defaultUniforms = {\n      resolution: {\n        type: '2f',\n        value: {\n          x: this.width,\n          y: this.height\n        }\n      },\n      time: {\n        type: '1f',\n        value: 0\n      },\n      mouse: {\n        type: '2f',\n        value: {\n          x: this.width / 2,\n          y: this.height / 2\n        }\n      },\n      date: {\n        type: '4fv',\n        value: [d.getFullYear(), d.getMonth(), d.getDate(), d.getHours() * 60 * 60 + d.getMinutes() * 60 + d.getSeconds()]\n      },\n      sampleRate: {\n        type: '1f',\n        value: 44100.0\n      },\n      iChannel0: {\n        type: 'sampler2D',\n        value: null,\n        textureData: {\n          repeat: true\n        }\n      },\n      iChannel1: {\n        type: 'sampler2D',\n        value: null,\n        textureData: {\n          repeat: true\n        }\n      },\n      iChannel2: {\n        type: 'sampler2D',\n        value: null,\n        textureData: {\n          repeat: true\n        }\n      },\n      iChannel3: {\n        type: 'sampler2D',\n        value: null,\n        textureData: {\n          repeat: true\n        }\n      }\n    };\n\n    if (this.shader.uniforms) {\n      this.uniforms = Extend(true, {}, this.shader.uniforms, defaultUniforms);\n    } else {\n      this.uniforms = defaultUniforms;\n    }\n\n    for (var i = 0; i < 4; i++) {\n      if (textures[i]) {\n        this.setSampler2D('iChannel' + i, textures[i], i, textureData);\n      }\n    }\n\n    this.initUniforms();\n    this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0);\n    return this;\n  },\n\n  /**\r\n   * Binds a Phaser Pointer object to this Shader.\r\n   * \r\n   * The screen position of the pointer will be set in to the shaders `mouse` uniform\r\n   * automatically every frame. Call this method with no arguments to unbind the pointer.\r\n   *\r\n   * @method Phaser.GameObjects.Shader#setPointer\r\n   * @since 3.17.0\r\n   * \r\n   * @param {Phaser.Input.Pointer} [pointer] - The Pointer to bind to this shader.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setPointer: function (pointer) {\n    this.pointer = pointer;\n    return this;\n  },\n\n  /**\r\n   * Sets this shader to use an orthographic projection matrix.\r\n   * This matrix is stored locally in the `projectionMatrix` property,\r\n   * as well as being bound to the `uProjectionMatrix` uniform.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#projOrtho\r\n   * @since 3.17.0\r\n   *\r\n   * @param {number} left - The left value.\r\n   * @param {number} right - The right value.\r\n   * @param {number} bottom - The bottom value.\r\n   * @param {number} top - The top value.\r\n   */\n  projOrtho: function (left, right, bottom, top) {\n    var near = -1000;\n    var far = 1000;\n    var leftRight = 1 / (left - right);\n    var bottomTop = 1 / (bottom - top);\n    var nearFar = 1 / (near - far);\n    var pm = this.projectionMatrix;\n    pm[0] = -2 * leftRight;\n    pm[5] = -2 * bottomTop;\n    pm[10] = 2 * nearFar;\n    pm[12] = (left + right) * leftRight;\n    pm[13] = (top + bottom) * bottomTop;\n    pm[14] = (far + near) * nearFar;\n    var program = this.program;\n    this.renderer.setMatrix4(program, 'uProjectionMatrix', false, this.projectionMatrix);\n    this._rendererWidth = right;\n    this._rendererHeight = bottom;\n  },\n  // Uniforms are specified in the GLSL_ES Specification: http://www.khronos.org/registry/webgl/specs/latest/1.0/\n  // http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\n\n  /**\r\n   * Initializes all of the uniforms this shader uses.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#initUniforms\r\n   * @private\r\n   * @since 3.17.0\r\n   */\n  initUniforms: function () {\n    var gl = this.gl;\n    var map = this.renderer.glFuncMap;\n    var program = this.program;\n    this._textureCount = 0;\n\n    for (var key in this.uniforms) {\n      var uniform = this.uniforms[key];\n      var type = uniform.type;\n      var data = map[type];\n      uniform.uniformLocation = gl.getUniformLocation(program, key);\n\n      if (type !== 'sampler2D') {\n        uniform.glMatrix = data.matrix;\n        uniform.glValueLength = data.length;\n        uniform.glFunc = data.func;\n      }\n    }\n  },\n\n  /**\r\n   * Sets a sampler2D uniform on this shader where the source texture is a WebGLTexture.\r\n   * \r\n   * This allows you to feed the output from one Shader into another:\r\n   * \r\n   * ```javascript\r\n   * let shader1 = this.add.shader(baseShader1, 0, 0, 512, 512).setRenderToTexture();\r\n   * let shader2 = this.add.shader(baseShader2, 0, 0, 512, 512).setRenderToTexture('output');\r\n   * \r\n   * shader1.setSampler2DBuffer('iChannel0', shader2.glTexture, 512, 512);\r\n   * shader2.setSampler2DBuffer('iChannel0', shader1.glTexture, 512, 512);\r\n   * ```\r\n   * \r\n   * In the above code, the result of baseShader1 is fed into Shader2 as the `iChannel0` sampler2D uniform.\r\n   * The result of baseShader2 is then fed back into shader1 again, creating a feedback loop.\r\n   * \r\n   * If you wish to use an image from the Texture Manager as a sampler2D input for this shader,\r\n   * see the `Shader.setSampler2D` method.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#setSampler2DBuffer\r\n   * @since 3.19.0\r\n   * \r\n   * @param {string} uniformKey - The key of the sampler2D uniform to be updated, i.e. `iChannel0`.\r\n   * @param {WebGLTexture} texture - A WebGLTexture reference.\r\n   * @param {integer} width - The width of the texture.\r\n   * @param {integer} height - The height of the texture.\r\n   * @param {integer} [textureIndex=0] - The texture index.\r\n   * @param {any} [textureData] - Additional texture data.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setSampler2DBuffer: function (uniformKey, texture, width, height, textureIndex, textureData) {\n    if (textureIndex === undefined) {\n      textureIndex = 0;\n    }\n\n    if (textureData === undefined) {\n      textureData = {};\n    }\n\n    var uniform = this.uniforms[uniformKey];\n    uniform.value = texture;\n    textureData.width = width;\n    textureData.height = height;\n    uniform.textureData = textureData;\n    this._textureCount = textureIndex;\n    this.initSampler2D(uniform);\n    return this;\n  },\n\n  /**\r\n   * Sets a sampler2D uniform on this shader.\r\n   * \r\n   * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n   * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n   * \r\n   * If you wish to use another Shader as a sampler2D input for this shader, see the `Shader.setSampler2DBuffer` method.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#setSampler2D\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} uniformKey - The key of the sampler2D uniform to be updated, i.e. `iChannel0`.\r\n   * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n   * @param {integer} [textureIndex=0] - The texture index.\r\n   * @param {any} [textureData] - Additional texture data.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setSampler2D: function (uniformKey, textureKey, textureIndex, textureData) {\n    if (textureIndex === undefined) {\n      textureIndex = 0;\n    }\n\n    var textureManager = this.scene.sys.textures;\n\n    if (textureManager.exists(textureKey)) {\n      var frame = textureManager.getFrame(textureKey);\n      var uniform = this.uniforms[uniformKey];\n      var source = frame.source;\n      uniform.textureKey = textureKey;\n      uniform.source = source.image;\n      uniform.value = frame.glTexture;\n\n      if (source.isGLTexture) {\n        if (!textureData) {\n          textureData = {};\n        }\n\n        textureData.width = source.width;\n        textureData.height = source.height;\n      }\n\n      if (textureData) {\n        uniform.textureData = textureData;\n      }\n\n      this._textureCount = textureIndex;\n      this.initSampler2D(uniform);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets a property of a uniform already present on this shader.\r\n   * \r\n   * To modify the value of a uniform such as a 1f or 1i use the `value` property directly:\r\n   * \r\n   * ```javascript\r\n   * shader.setUniform('size.value', 16);\r\n   * ```\r\n   * \r\n   * You can use dot notation to access deeper values, for example:\r\n   * \r\n   * ```javascript\r\n   * shader.setUniform('resolution.value.x', 512);\r\n   * ```\r\n   * \r\n   * The change to the uniform will take effect the next time the shader is rendered.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#setUniform\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} key - The key of the uniform to modify. Use dots for deep properties, i.e. `resolution.value.x`.\r\n   * @param {any} value - The value to set into the uniform.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setUniform: function (key, value) {\n    SetValue(this.uniforms, key, value);\n    return this;\n  },\n\n  /**\r\n   * Returns the uniform object for the given key, or `null` if the uniform couldn't be found.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#getUniform\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} key - The key of the uniform to return the value for.\r\n   * \r\n   * @return {any} A reference to the uniform object. This is not a copy, so modifying it will update the original object also.\r\n   */\n  getUniform: function (key) {\n    return GetFastValue(this.uniforms, key, null);\n  },\n\n  /**\r\n   * A short-cut method that will directly set the texture being used by the `iChannel0` sampler2D uniform.\r\n   * \r\n   * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n   * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#setChannel0\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n   * @param {any} [textureData] - Additional texture data.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setChannel0: function (textureKey, textureData) {\n    return this.setSampler2D('iChannel0', textureKey, 0, textureData);\n  },\n\n  /**\r\n   * A short-cut method that will directly set the texture being used by the `iChannel1` sampler2D uniform.\r\n   * \r\n   * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n   * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#setChannel1\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n   * @param {any} [textureData] - Additional texture data.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setChannel1: function (textureKey, textureData) {\n    return this.setSampler2D('iChannel1', textureKey, 1, textureData);\n  },\n\n  /**\r\n   * A short-cut method that will directly set the texture being used by the `iChannel2` sampler2D uniform.\r\n   * \r\n   * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n   * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#setChannel2\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n   * @param {any} [textureData] - Additional texture data.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setChannel2: function (textureKey, textureData) {\n    return this.setSampler2D('iChannel2', textureKey, 2, textureData);\n  },\n\n  /**\r\n   * A short-cut method that will directly set the texture being used by the `iChannel3` sampler2D uniform.\r\n   * \r\n   * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n   * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#setChannel3\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n   * @param {any} [textureData] - Additional texture data.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setChannel3: function (textureKey, textureData) {\n    return this.setSampler2D('iChannel3', textureKey, 3, textureData);\n  },\n\n  /**\r\n   * Internal method that takes a sampler2D uniform and prepares it for use by setting the\r\n   * gl texture parameters.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#initSampler2D\r\n   * @private\r\n   * @since 3.17.0\r\n   * \r\n   * @param {any} uniform - The sampler2D uniform to process.\r\n   */\n  initSampler2D: function (uniform) {\n    if (!uniform.value) {\n      return;\n    }\n\n    var gl = this.gl;\n    gl.activeTexture(gl.TEXTURE0 + this._textureCount);\n    gl.bindTexture(gl.TEXTURE_2D, uniform.value); //  Extended texture data\n\n    var data = uniform.textureData;\n\n    if (data) {\n      // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n      //  mag / minFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST\n      //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT\n      //  format can be: gl.LUMINANCE or gl.RGBA\n      var magFilter = gl[GetFastValue(data, 'magFilter', 'linear').toUpperCase()];\n      var minFilter = gl[GetFastValue(data, 'minFilter', 'linear').toUpperCase()];\n      var wrapS = gl[GetFastValue(data, 'wrapS', 'repeat').toUpperCase()];\n      var wrapT = gl[GetFastValue(data, 'wrapT', 'repeat').toUpperCase()];\n      var format = gl[GetFastValue(data, 'format', 'rgba').toUpperCase()];\n\n      if (data.repeat) {\n        wrapS = gl.REPEAT;\n        wrapT = gl.REPEAT;\n      }\n\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);\n\n      if (data.width) {\n        var width = GetFastValue(data, 'width', 512);\n        var height = GetFastValue(data, 'height', 2);\n        var border = GetFastValue(data, 'border', 0); //  texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels)\n\n        gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);\n      } else {\n        //  texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, ImageData? pixels)\n        gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.source);\n      }\n\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\n    }\n\n    this.renderer.setProgram(this.program);\n    gl.uniform1i(uniform.uniformLocation, this._textureCount);\n    this._textureCount++;\n  },\n\n  /**\r\n   * Synchronizes all of the uniforms this shader uses.\r\n   * Each uniforms gl function is called in turn.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#syncUniforms\r\n   * @private\r\n   * @since 3.17.0\r\n   */\n  syncUniforms: function () {\n    var gl = this.gl;\n    var uniforms = this.uniforms;\n    var uniform;\n    var length;\n    var glFunc;\n    var location;\n    var value;\n    var textureCount = 0;\n\n    for (var key in uniforms) {\n      uniform = uniforms[key];\n      glFunc = uniform.glFunc;\n      length = uniform.glValueLength;\n      location = uniform.uniformLocation;\n      value = uniform.value;\n\n      if (value === null) {\n        continue;\n      }\n\n      if (length === 1) {\n        if (uniform.glMatrix) {\n          glFunc.call(gl, location, uniform.transpose, value);\n        } else {\n          glFunc.call(gl, location, value);\n        }\n      } else if (length === 2) {\n        glFunc.call(gl, location, value.x, value.y);\n      } else if (length === 3) {\n        glFunc.call(gl, location, value.x, value.y, value.z);\n      } else if (length === 4) {\n        glFunc.call(gl, location, value.x, value.y, value.z, value.w);\n      } else if (uniform.type === 'sampler2D') {\n        gl.activeTexture(gl['TEXTURE' + textureCount]);\n        gl.bindTexture(gl.TEXTURE_2D, value);\n        gl.uniform1i(location, textureCount);\n        textureCount++;\n      }\n    }\n  },\n\n  /**\r\n   * Called automatically during render.\r\n   * \r\n   * This method performs matrix ITRS and then stores the resulting value in the `uViewMatrix` uniform.\r\n   * It then sets up the vertex buffer and shader, updates and syncs the uniforms ready\r\n   * for flush to be called.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#load\r\n   * @since 3.17.0\r\n   * \r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} [matrix2D] - The transform matrix to use during rendering.\r\n   */\n  load: function (matrix2D) {\n    //  ITRS\n    var gl = this.gl;\n    var width = this.width;\n    var height = this.height;\n    var renderer = this.renderer;\n    var program = this.program;\n    var vm = this.viewMatrix;\n\n    if (!this.renderToTexture) {\n      var x = -this._displayOriginX;\n      var y = -this._displayOriginY;\n      vm[0] = matrix2D[0];\n      vm[1] = matrix2D[1];\n      vm[4] = matrix2D[2];\n      vm[5] = matrix2D[3];\n      vm[8] = matrix2D[4];\n      vm[9] = matrix2D[5];\n      vm[12] = vm[0] * x + vm[4] * y;\n      vm[13] = vm[1] * x + vm[5] * y;\n    } //  Update vertex shader uniforms\n\n\n    gl.useProgram(program);\n    gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uViewMatrix'), false, vm);\n    gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), this.width, this.height); //  Update fragment shader uniforms\n\n    var uniforms = this.uniforms;\n    var res = uniforms.resolution;\n    res.value.x = width;\n    res.value.y = height;\n    uniforms.time.value = renderer.game.loop.getDuration();\n    var pointer = this.pointer;\n\n    if (pointer) {\n      var mouse = uniforms.mouse;\n      var px = pointer.x / width;\n      var py = 1 - pointer.y / height;\n      mouse.value.x = px.toFixed(2);\n      mouse.value.y = py.toFixed(2);\n    }\n\n    this.syncUniforms();\n  },\n\n  /**\r\n   * Called automatically during render.\r\n   * \r\n   * Sets the active shader, loads the vertex buffer and then draws.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#flush\r\n   * @since 3.17.0\r\n   */\n  flush: function () {\n    //  Bind\n    var width = this.width;\n    var height = this.height;\n    var program = this.program;\n    var gl = this.gl;\n    var vertexBuffer = this.vertexBuffer;\n    var renderer = this.renderer;\n    var vertexSize = Float32Array.BYTES_PER_ELEMENT * 2;\n\n    if (this.renderToTexture) {\n      renderer.setFramebuffer(this.framebuffer);\n      gl.clearColor(0, 0, 0, 0);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n    }\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    var location = gl.getAttribLocation(program, 'inPosition');\n\n    if (location !== -1) {\n      gl.enableVertexAttribArray(location);\n      gl.vertexAttribPointer(location, 2, gl.FLOAT, false, vertexSize, 0);\n    } //  Draw\n\n\n    var vf = this.vertexViewF32;\n    vf[3] = height;\n    vf[4] = width;\n    vf[5] = height;\n    vf[8] = width;\n    vf[9] = height;\n    vf[10] = width; //  Flush\n\n    var vertexCount = 6;\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));\n    gl.drawArrays(gl.TRIANGLES, 0, vertexCount);\n\n    if (this.renderToTexture) {\n      renderer.setFramebuffer(null, false);\n    }\n  },\n\n  /**\r\n   * A NOOP method so you can pass a Shader to a Container.\r\n   * Calling this method will do nothing. It is intentionally empty.\r\n   *\r\n   * @method Phaser.GameObjects.Shader#setAlpha\r\n   * @private\r\n   * @since 3.17.0\r\n   */\n  setAlpha: function () {},\n\n  /**\r\n   * A NOOP method so you can pass a Shader to a Container.\r\n   * Calling this method will do nothing. It is intentionally empty.\r\n   *\r\n   * @method Phaser.GameObjects.Shader#setBlendMode\r\n   * @private\r\n   * @since 3.17.0\r\n   */\n  setBlendMode: function () {},\n\n  /**\r\n   * Internal destroy handler, called as part of the destroy process.\r\n   *\r\n   * @method Phaser.GameObjects.Shader#preDestroy\r\n   * @protected\r\n   * @since 3.17.0\r\n   */\n  preDestroy: function () {\n    var gl = this.gl;\n    gl.deleteProgram(this.program);\n    gl.deleteBuffer(this.vertexBuffer);\n\n    if (this.renderToTexture) {\n      this.renderer.deleteFramebuffer(this.framebuffer);\n      this.texture.destroy();\n      this.framebuffer = null;\n      this.glTexture = null;\n      this.texture = null;\n    }\n  }\n});\nmodule.exports = Shader;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/shader/Shader.js"],"names":["Class","require","Components","GameObject","GetFastValue","Extend","SetValue","ShaderRender","TransformMatrix","Shader","Extends","Mixins","ComputedSize","Depth","GetBounds","Mask","Origin","ScrollFactor","Transform","Visible","initialize","scene","key","x","y","width","height","textures","textureData","undefined","call","blendMode","shader","renderer","sys","gl","vertexData","ArrayBuffer","Float32Array","BYTES_PER_ELEMENT","vertexBuffer","createVertexBuffer","byteLength","STREAM_DRAW","program","bytes","Uint8Array","vertexViewF32","_tempMatrix1","_tempMatrix2","_tempMatrix3","viewMatrix","projectionMatrix","uniforms","pointer","_rendererWidth","_rendererHeight","_textureCount","framebuffer","glTexture","renderToTexture","texture","setPosition","setSize","setOrigin","setShader","willRender","camera","RENDER_MASK","renderFlags","cameraFilter","id","setRenderToTexture","flipY","createTextureFromSource","createFramebuffer","projOrtho","addGLTexture","pipeline","currentPipeline","clearPipeline","load","flush","rebindPipeline","cache","has","console","warn","get","deleteProgram","createProgram","vertexSrc","fragmentSrc","setMatrix4","setFloat2","d","Date","defaultUniforms","resolution","type","value","time","mouse","date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","sampleRate","iChannel0","repeat","iChannel1","iChannel2","iChannel3","i","setSampler2D","initUniforms","setPointer","left","right","bottom","top","near","far","leftRight","bottomTop","nearFar","pm","map","glFuncMap","uniform","data","uniformLocation","getUniformLocation","glMatrix","matrix","glValueLength","length","glFunc","func","setSampler2DBuffer","uniformKey","textureIndex","initSampler2D","textureKey","textureManager","exists","frame","getFrame","source","image","isGLTexture","setUniform","getUniform","setChannel0","setChannel1","setChannel2","setChannel3","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","magFilter","toUpperCase","minFilter","wrapS","wrapT","format","REPEAT","pixelStorei","UNPACK_FLIP_Y_WEBGL","border","texImage2D","UNSIGNED_BYTE","RGBA","texParameteri","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","setProgram","uniform1i","syncUniforms","location","textureCount","transpose","z","w","matrix2D","vm","_displayOriginX","_displayOriginY","useProgram","uniformMatrix4fv","uniform2f","res","game","loop","getDuration","px","py","toFixed","vertexSize","setFramebuffer","clearColor","clear","COLOR_BUFFER_BIT","bindBuffer","ARRAY_BUFFER","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","FLOAT","vf","vertexCount","bufferSubData","subarray","drawArrays","TRIANGLES","setAlpha","setBlendMode","preDestroy","deleteBuffer","deleteFramebuffer","destroy","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Extend = require('../../utils/object/Extend');\r\nvar SetValue = require('../../utils/object/SetValue');\r\nvar ShaderRender = require('./ShaderRender');\r\nvar TransformMatrix = require('../components/TransformMatrix');\r\n\r\n/**\r\n * @classdesc\r\n * A Shader Game Object.\r\n * \r\n * This Game Object allows you to easily add a quad with its own shader into the display list, and manipulate it\r\n * as you would any other Game Object, including scaling, rotating, positioning and adding to Containers. Shaders\r\n * can be masked with either Bitmap or Geometry masks and can also be used as a Bitmap Mask for a Camera or other\r\n * Game Object. They can also be made interactive and used for input events.\r\n * \r\n * It works by taking a reference to a `Phaser.Display.BaseShader` instance, as found in the Shader Cache. These can\r\n * be created dynamically at runtime, or loaded in via the GLSL File Loader:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.glsl('fire', 'shaders/fire.glsl.js');\r\n * }\r\n *  \r\n * function create ()\r\n * {\r\n *     this.add.shader('fire', 400, 300, 512, 512);\r\n * }\r\n * ```\r\n * \r\n * Please see the Phaser 3 Examples GitHub repo for examples of loading and creating shaders dynamically.\r\n * \r\n * Due to the way in which they work, you cannot directly change the alpha or blend mode of a Shader. This should\r\n * be handled via exposed uniforms in the shader code itself.\r\n * \r\n * By default a Shader will be created with a standard set of uniforms. These were added to match those\r\n * found on sites such as ShaderToy or GLSLSandbox, and provide common functionality a shader may need,\r\n * such as the timestamp, resolution or pointer position. You can replace them by specifying your own uniforms\r\n * in the Base Shader.\r\n * \r\n * These Shaders work by halting the current pipeline during rendering, creating a viewport matched to the\r\n * size of this Game Object and then renders a quad using the bound shader. At the end, the pipeline is restored.\r\n * \r\n * Because it blocks the pipeline it means it will interrupt any batching that is currently going on, so you should\r\n * use these Game Objects sparingly. If you need to have a fully batched custom shader, then please look at using\r\n * a custom pipeline instead. However, for background or special masking effects, they are extremely effective.\r\n * \r\n * @class Shader\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @webglOnly\r\n * @since 3.17.0\r\n *\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {(string|Phaser.Display.BaseShader)} key - The key of the shader to use from the shader cache, or a BaseShader instance.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=128] - The width of the Game Object.\r\n * @param {number} [height=128] - The height of the Game Object.\r\n * @param {string[]} [textures] - Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.\r\n * @param {any} [textureData] - Additional texture data if you want to create shader with none NPOT textures.\r\n */\r\nvar Shader = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.ComputedSize,\r\n        Components.Depth,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.ScrollFactor,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        ShaderRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Shader (scene, key, x, y, width, height, textures, textureData)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = 128; }\r\n        if (height === undefined) { height = 128; }\r\n\r\n        GameObject.call(this, scene, 'Shader');\r\n\r\n        /**\r\n         * This Game Object cannot have a blend mode, so skip all checks.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#blendMode\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this.blendMode = -1;\r\n\r\n        /**\r\n         * The underlying shader object being used.\r\n         * Empty by default and set during a call to the `setShader` method.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#shader\r\n         * @type {Phaser.Display.BaseShader}\r\n         * @since 3.17.0\r\n         */\r\n        this.shader;\r\n\r\n        var renderer = scene.sys.renderer;\r\n\r\n        /**\r\n         * A reference to the current renderer.\r\n         * Shaders only work with the WebGL Renderer.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.17.0\r\n         */\r\n        this.renderer = renderer;\r\n\r\n        /**\r\n         * The WebGL context belonging to the renderer.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#gl\r\n         * @type {WebGLRenderingContext}\r\n         * @since 3.17.0\r\n         */\r\n        this.gl = renderer.gl;\r\n\r\n        /**\r\n         * Raw byte buffer of vertices this Shader uses.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#vertexData\r\n         * @type {ArrayBuffer}\r\n         * @since 3.17.0\r\n         */\r\n        this.vertexData = new ArrayBuffer(6 * (Float32Array.BYTES_PER_ELEMENT * 2));\r\n\r\n        /**\r\n         * The WebGL vertex buffer object this shader uses.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#vertexBuffer\r\n         * @type {WebGLBuffer}\r\n         * @since 3.17.0\r\n         */\r\n        this.vertexBuffer = renderer.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW);\r\n\r\n        /**\r\n         * The WebGL shader program this shader uses.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#program\r\n         * @type {WebGLProgram}\r\n         * @since 3.17.0\r\n         */\r\n        this.program = null;\r\n\r\n        /**\r\n         * Uint8 view to the vertex raw buffer. Used for uploading vertex buffer resources to the GPU.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#bytes\r\n         * @type {Uint8Array}\r\n         * @since 3.17.0\r\n         */\r\n        this.bytes = new Uint8Array(this.vertexData);\r\n\r\n        /**\r\n         * Float32 view of the array buffer containing the shaders vertices.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#vertexViewF32\r\n         * @type {Float32Array}\r\n         * @since 3.17.0\r\n         */\r\n        this.vertexViewF32 = new Float32Array(this.vertexData);\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_tempMatrix1\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.17.0\r\n         */\r\n        this._tempMatrix1 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_tempMatrix2\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.17.0\r\n         */\r\n        this._tempMatrix2 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_tempMatrix3\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.17.0\r\n         */\r\n        this._tempMatrix3 = new TransformMatrix();\r\n\r\n        /**\r\n         * The view matrix the shader uses during rendering.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#viewMatrix\r\n         * @type {Float32Array}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.viewMatrix = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);\r\n\r\n        /**\r\n         * The projection matrix the shader uses during rendering.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#projectionMatrix\r\n         * @type {Float32Array}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.projectionMatrix = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);\r\n\r\n        /**\r\n         * The default uniform mappings. These can be added to (or replaced) by specifying your own uniforms when\r\n         * creating this shader game object. The uniforms are updated automatically during the render step.\r\n         * \r\n         * The defaults are:\r\n         * \r\n         * `resolution` (2f) - Set to the size of this shader.\r\n         * `time` (1f) - The elapsed game time, in seconds.\r\n         * `mouse` (2f) - If a pointer has been bound (with `setPointer`), this uniform contains its position each frame.\r\n         * `date` (4fv) - A vec4 containing the year, month, day and time in seconds.\r\n         * `sampleRate` (1f) - Sound sample rate. 44100 by default.\r\n         * `iChannel0...3` (sampler2D) - Input channels 0 to 3. `null` by default.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#uniforms\r\n         * @type {any}\r\n         * @since 3.17.0\r\n         */\r\n        this.uniforms = {};\r\n\r\n        /**\r\n         * The pointer bound to this shader, if any.\r\n         * Set via the chainable `setPointer` method, or by modifying this property directly.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#pointer\r\n         * @type {Phaser.Input.Pointer}\r\n         * @since 3.17.0\r\n         */\r\n        this.pointer = null;\r\n\r\n        /**\r\n         * The cached width of the renderer.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#_rendererWidth\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this._rendererWidth = renderer.width;\r\n\r\n        /**\r\n         * The cached height of the renderer.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#_rendererHeight\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this._rendererHeight = renderer.height;\r\n\r\n        /**\r\n         * Internal texture count tracker.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#_textureCount\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this._textureCount = 0;\r\n\r\n        /**\r\n         * A reference to the GL Frame Buffer this Shader is drawing to.\r\n         * This property is only set if you have called `Shader.setRenderToTexture`.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#framebuffer\r\n         * @type {?WebGLFramebuffer}\r\n         * @since 3.19.0\r\n         */\r\n        this.framebuffer = null;\r\n\r\n        /**\r\n         * A reference to the WebGLTexture this Shader is rendering to.\r\n         * This property is only set if you have called `Shader.setRenderToTexture`.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#glTexture\r\n         * @type {?WebGLTexture}\r\n         * @since 3.19.0\r\n         */\r\n        this.glTexture = null;\r\n\r\n        /**\r\n         * A flag that indicates if this Shader has been set to render to a texture instead of the display list.\r\n         * \r\n         * This property is `true` if you have called `Shader.setRenderToTexture`, otherwise it's `false`.\r\n         * \r\n         * A Shader that is rendering to a texture _does not_ appear on the display list.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#renderToTexture\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.19.0\r\n         */\r\n        this.renderToTexture = false;\r\n\r\n        /**\r\n         * A reference to the Phaser.Textures.Texture that has been stored in the Texture Manager for this Shader.\r\n         * \r\n         * This property is only set if you have called `Shader.setRenderToTexture`, otherwise it is `null`.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#texture\r\n         * @type {Phaser.Textures.Texture}\r\n         * @since 3.19.0\r\n         */\r\n        this.texture = null;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(width, height);\r\n        this.setOrigin(0.5, 0.5);\r\n        this.setShader(key, textures, textureData);\r\n    },\r\n\r\n    /**\r\n     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n     * Also checks the Game Object against the given Cameras exclusion list.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#willRender\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.\r\n     *\r\n     * @return {boolean} True if the Game Object should be rendered, otherwise false.\r\n     */\r\n    willRender: function (camera)\r\n    {\r\n        if (this.renderToTexture)\r\n        {\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            return !(GameObject.RENDER_MASK !== this.renderFlags || (this.cameraFilter !== 0 && (this.cameraFilter & camera.id)));\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Changes this Shader so instead of rendering to the display list it renders to a\r\n     * WebGL Framebuffer and WebGL Texture instead. This allows you to use the output\r\n     * of this shader as an input for another shader, by mapping a sampler2D uniform\r\n     * to it.\r\n     * \r\n     * After calling this method the `Shader.framebuffer` and `Shader.glTexture` properties\r\n     * are populated.\r\n     * \r\n     * Additionally, you can provide a key to this method. Doing so will create a Phaser Texture\r\n     * from this Shader and save it into the Texture Manager, allowing you to then use it for\r\n     * any texture-based Game Object, such as a Sprite or Image:\r\n     * \r\n     * ```javascript\r\n     * var shader = this.add.shader('myShader', x, y, width, height);\r\n     * \r\n     * shader.setRenderToTexture('doodle');\r\n     * \r\n     * this.add.image(400, 300, 'doodle');\r\n     * ```\r\n     * \r\n     * Note that it stores an active reference to this Shader. That means as this shader updates,\r\n     * so does the texture and any object using it to render with. Also, if you destroy this\r\n     * shader, be sure to clear any objects that may have been using it as a texture too.\r\n     * \r\n     * You can access the Phaser Texture that is created via the `Shader.texture` property.\r\n     * \r\n     * By default it will create a single base texture. You can add frames to the texture\r\n     * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n     * to use a specific frame from a Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setRenderToTexture\r\n     * @since 3.19.0\r\n     *\r\n     * @param {string} [key] - The unique key to store the texture as within the global Texture Manager.\r\n     * @param {boolean} [flipY=false] - Does this texture need vertically flipping before rendering? This should usually be set to `true` if being fed from a buffer.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setRenderToTexture: function (key, flipY)\r\n    {\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        if (!this.renderToTexture)\r\n        {\r\n            var width = this.width;\r\n            var height = this.height;\r\n            var renderer = this.renderer;\r\n\r\n            this.glTexture = renderer.createTextureFromSource(null, width, height, 0);\r\n\r\n            this.glTexture.flipY = flipY;\r\n\r\n            this.framebuffer = renderer.createFramebuffer(width, height, this.glTexture, false);\r\n\r\n            this._rendererWidth = width;\r\n            this._rendererHeight = height;\r\n\r\n            this.renderToTexture = true;\r\n\r\n            this.projOrtho(0, this.width, this.height, 0);\r\n\r\n            if (key)\r\n            {\r\n                this.texture = this.scene.sys.textures.addGLTexture(key, this.glTexture, width, height);\r\n            }\r\n        }\r\n\r\n        //  And now render at least once, so our texture isn't blank on the first update\r\n\r\n        if (this.shader)\r\n        {\r\n            var pipeline = renderer.currentPipeline;\r\n\r\n            renderer.clearPipeline();\r\n        \r\n            this.load();\r\n            this.flush();\r\n    \r\n            renderer.rebindPipeline(pipeline);\r\n        }\r\n    \r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the fragment and, optionally, the vertex shader source code that this Shader will use.\r\n     * This will immediately delete the active shader program, if set, and then create a new one\r\n     * with the given source. Finally, the shader uniforms are initialized.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setShader\r\n     * @since 3.17.0\r\n     * \r\n     * @param {(string|Phaser.Display.BaseShader)} key - The key of the shader to use from the shader cache, or a BaseShader instance.\r\n     * @param {string[]} [textures] - Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setShader: function (key, textures, textureData)\r\n    {\r\n        if (textures === undefined) { textures = []; }\r\n\r\n        if (typeof key === 'string')\r\n        {\r\n            var cache = this.scene.sys.cache.shader;\r\n\r\n            if (!cache.has(key))\r\n            {\r\n                console.warn('Shader missing: ' + key);\r\n                return this;\r\n            }\r\n    \r\n            this.shader = cache.get(key);\r\n        }\r\n        else\r\n        {\r\n            this.shader = key;\r\n        }\r\n\r\n        var gl = this.gl;\r\n        var renderer = this.renderer;\r\n\r\n        if (this.program)\r\n        {\r\n            gl.deleteProgram(this.program);\r\n        }\r\n\r\n        var program = renderer.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc);\r\n\r\n        //  The default uniforms available within the vertex shader\r\n        renderer.setMatrix4(program, 'uViewMatrix', false, this.viewMatrix);\r\n        renderer.setMatrix4(program, 'uProjectionMatrix', false, this.projectionMatrix);\r\n        renderer.setFloat2(program, 'uResolution', this.width, this.height);\r\n\r\n        this.program = program;\r\n\r\n        var d = new Date();\r\n\r\n        //  The default uniforms available within the fragment shader\r\n        var defaultUniforms = {\r\n            resolution: { type: '2f', value: { x: this.width, y: this.height } },\r\n            time: { type: '1f', value: 0 },\r\n            mouse: { type: '2f', value: { x: this.width / 2, y: this.height / 2 } },\r\n            date: { type: '4fv', value: [ d.getFullYear(), d.getMonth(), d.getDate(), d.getHours() * 60 * 60 + d.getMinutes() * 60 + d.getSeconds() ] },\r\n            sampleRate: { type: '1f', value: 44100.0 },\r\n            iChannel0: { type: 'sampler2D', value: null, textureData: { repeat: true } },\r\n            iChannel1: { type: 'sampler2D', value: null, textureData: { repeat: true } },\r\n            iChannel2: { type: 'sampler2D', value: null, textureData: { repeat: true } },\r\n            iChannel3: { type: 'sampler2D', value: null, textureData: { repeat: true } }\r\n        };\r\n \r\n        if (this.shader.uniforms)\r\n        {\r\n            this.uniforms = Extend(true, {}, this.shader.uniforms, defaultUniforms);\r\n        }\r\n        else\r\n        {\r\n            this.uniforms = defaultUniforms;\r\n        }\r\n\r\n        for (var i = 0; i < 4; i++)\r\n        {\r\n            if (textures[i])\r\n            {\r\n                this.setSampler2D('iChannel' + i, textures[i], i, textureData);\r\n            }\r\n        }\r\n\r\n        this.initUniforms();\r\n\r\n        this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Binds a Phaser Pointer object to this Shader.\r\n     * \r\n     * The screen position of the pointer will be set in to the shaders `mouse` uniform\r\n     * automatically every frame. Call this method with no arguments to unbind the pointer.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setPointer\r\n     * @since 3.17.0\r\n     * \r\n     * @param {Phaser.Input.Pointer} [pointer] - The Pointer to bind to this shader.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setPointer: function (pointer)\r\n    {\r\n        this.pointer = pointer;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets this shader to use an orthographic projection matrix.\r\n     * This matrix is stored locally in the `projectionMatrix` property,\r\n     * as well as being bound to the `uProjectionMatrix` uniform.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#projOrtho\r\n     * @since 3.17.0\r\n     *\r\n     * @param {number} left - The left value.\r\n     * @param {number} right - The right value.\r\n     * @param {number} bottom - The bottom value.\r\n     * @param {number} top - The top value.\r\n     */\r\n    projOrtho: function (left, right, bottom, top)\r\n    {\r\n        var near = -1000;\r\n        var far = 1000;\r\n\r\n        var leftRight = 1 / (left - right);\r\n        var bottomTop = 1 / (bottom - top);\r\n        var nearFar = 1 / (near - far);\r\n\r\n        var pm = this.projectionMatrix;\r\n\r\n        pm[0] = -2 * leftRight;\r\n        pm[5] = -2 * bottomTop;\r\n        pm[10] = 2 * nearFar;\r\n        pm[12] = (left + right) * leftRight;\r\n        pm[13] = (top + bottom) * bottomTop;\r\n        pm[14] = (far + near) * nearFar;\r\n\r\n        var program = this.program;\r\n\r\n        this.renderer.setMatrix4(program, 'uProjectionMatrix', false, this.projectionMatrix);\r\n\r\n        this._rendererWidth = right;\r\n        this._rendererHeight = bottom;\r\n    },\r\n\r\n    // Uniforms are specified in the GLSL_ES Specification: http://www.khronos.org/registry/webgl/specs/latest/1.0/\r\n    // http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\r\n\r\n    /**\r\n     * Initializes all of the uniforms this shader uses.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#initUniforms\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    initUniforms: function ()\r\n    {\r\n        var gl = this.gl;\r\n        var map = this.renderer.glFuncMap;\r\n        var program = this.program;\r\n\r\n        this._textureCount = 0;\r\n\r\n        for (var key in this.uniforms)\r\n        {\r\n            var uniform = this.uniforms[key];\r\n\r\n            var type = uniform.type;\r\n            var data = map[type];\r\n\r\n            uniform.uniformLocation = gl.getUniformLocation(program, key);\r\n\r\n            if (type !== 'sampler2D')\r\n            {\r\n                uniform.glMatrix = data.matrix;\r\n                uniform.glValueLength = data.length;\r\n                uniform.glFunc = data.func;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets a sampler2D uniform on this shader where the source texture is a WebGLTexture.\r\n     * \r\n     * This allows you to feed the output from one Shader into another:\r\n     * \r\n     * ```javascript\r\n     * let shader1 = this.add.shader(baseShader1, 0, 0, 512, 512).setRenderToTexture();\r\n     * let shader2 = this.add.shader(baseShader2, 0, 0, 512, 512).setRenderToTexture('output');\r\n     * \r\n     * shader1.setSampler2DBuffer('iChannel0', shader2.glTexture, 512, 512);\r\n     * shader2.setSampler2DBuffer('iChannel0', shader1.glTexture, 512, 512);\r\n     * ```\r\n     * \r\n     * In the above code, the result of baseShader1 is fed into Shader2 as the `iChannel0` sampler2D uniform.\r\n     * The result of baseShader2 is then fed back into shader1 again, creating a feedback loop.\r\n     * \r\n     * If you wish to use an image from the Texture Manager as a sampler2D input for this shader,\r\n     * see the `Shader.setSampler2D` method.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#setSampler2DBuffer\r\n     * @since 3.19.0\r\n     * \r\n     * @param {string} uniformKey - The key of the sampler2D uniform to be updated, i.e. `iChannel0`.\r\n     * @param {WebGLTexture} texture - A WebGLTexture reference.\r\n     * @param {integer} width - The width of the texture.\r\n     * @param {integer} height - The height of the texture.\r\n     * @param {integer} [textureIndex=0] - The texture index.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setSampler2DBuffer: function (uniformKey, texture, width, height, textureIndex, textureData)\r\n    {\r\n        if (textureIndex === undefined) { textureIndex = 0; }\r\n        if (textureData === undefined) { textureData = {}; }\r\n\r\n        var uniform = this.uniforms[uniformKey];\r\n\r\n        uniform.value = texture;\r\n\r\n        textureData.width = width;\r\n        textureData.height = height;\r\n\r\n        uniform.textureData = textureData;\r\n\r\n        this._textureCount = textureIndex;\r\n\r\n        this.initSampler2D(uniform);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a sampler2D uniform on this shader.\r\n     * \r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     * \r\n     * If you wish to use another Shader as a sampler2D input for this shader, see the `Shader.setSampler2DBuffer` method.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#setSampler2D\r\n     * @since 3.17.0\r\n     * \r\n     * @param {string} uniformKey - The key of the sampler2D uniform to be updated, i.e. `iChannel0`.\r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {integer} [textureIndex=0] - The texture index.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setSampler2D: function (uniformKey, textureKey, textureIndex, textureData)\r\n    {\r\n        if (textureIndex === undefined) { textureIndex = 0; }\r\n\r\n        var textureManager = this.scene.sys.textures;\r\n\r\n        if (textureManager.exists(textureKey))\r\n        {\r\n            var frame = textureManager.getFrame(textureKey);\r\n            var uniform = this.uniforms[uniformKey];\r\n            var source = frame.source;\r\n\r\n            uniform.textureKey = textureKey;\r\n            uniform.source = source.image;\r\n            uniform.value = frame.glTexture;\r\n\r\n            if (source.isGLTexture)\r\n            {\r\n                if (!textureData)\r\n                {\r\n                    textureData = {};\r\n                }\r\n\r\n                textureData.width = source.width;\r\n                textureData.height = source.height;\r\n            }\r\n\r\n            if (textureData)\r\n            {\r\n                uniform.textureData = textureData;\r\n            }\r\n\r\n            this._textureCount = textureIndex;\r\n\r\n            this.initSampler2D(uniform);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a property of a uniform already present on this shader.\r\n     * \r\n     * To modify the value of a uniform such as a 1f or 1i use the `value` property directly:\r\n     * \r\n     * ```javascript\r\n     * shader.setUniform('size.value', 16);\r\n     * ```\r\n     * \r\n     * You can use dot notation to access deeper values, for example:\r\n     * \r\n     * ```javascript\r\n     * shader.setUniform('resolution.value.x', 512);\r\n     * ```\r\n     * \r\n     * The change to the uniform will take effect the next time the shader is rendered.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#setUniform\r\n     * @since 3.17.0\r\n     * \r\n     * @param {string} key - The key of the uniform to modify. Use dots for deep properties, i.e. `resolution.value.x`.\r\n     * @param {any} value - The value to set into the uniform.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setUniform: function (key, value)\r\n    {\r\n        SetValue(this.uniforms, key, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the uniform object for the given key, or `null` if the uniform couldn't be found.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#getUniform\r\n     * @since 3.17.0\r\n     * \r\n     * @param {string} key - The key of the uniform to return the value for.\r\n     * \r\n     * @return {any} A reference to the uniform object. This is not a copy, so modifying it will update the original object also.\r\n     */\r\n    getUniform: function (key)\r\n    {\r\n        return GetFastValue(this.uniforms, key, null);\r\n    },\r\n\r\n    /**\r\n     * A short-cut method that will directly set the texture being used by the `iChannel0` sampler2D uniform.\r\n     * \r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#setChannel0\r\n     * @since 3.17.0\r\n     * \r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setChannel0: function (textureKey, textureData)\r\n    {\r\n        return this.setSampler2D('iChannel0', textureKey, 0, textureData);\r\n    },\r\n\r\n    /**\r\n     * A short-cut method that will directly set the texture being used by the `iChannel1` sampler2D uniform.\r\n     * \r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#setChannel1\r\n     * @since 3.17.0\r\n     * \r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setChannel1: function (textureKey, textureData)\r\n    {\r\n        return this.setSampler2D('iChannel1', textureKey, 1, textureData);\r\n    },\r\n\r\n    /**\r\n     * A short-cut method that will directly set the texture being used by the `iChannel2` sampler2D uniform.\r\n     * \r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#setChannel2\r\n     * @since 3.17.0\r\n     * \r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setChannel2: function (textureKey, textureData)\r\n    {\r\n        return this.setSampler2D('iChannel2', textureKey, 2, textureData);\r\n    },\r\n\r\n    /**\r\n     * A short-cut method that will directly set the texture being used by the `iChannel3` sampler2D uniform.\r\n     * \r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#setChannel3\r\n     * @since 3.17.0\r\n     * \r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setChannel3: function (textureKey, textureData)\r\n    {\r\n        return this.setSampler2D('iChannel3', textureKey, 3, textureData);\r\n    },\r\n\r\n    /**\r\n     * Internal method that takes a sampler2D uniform and prepares it for use by setting the\r\n     * gl texture parameters.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#initSampler2D\r\n     * @private\r\n     * @since 3.17.0\r\n     * \r\n     * @param {any} uniform - The sampler2D uniform to process.\r\n     */\r\n    initSampler2D: function (uniform)\r\n    {\r\n        if (!uniform.value)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var gl = this.gl;\r\n\r\n        gl.activeTexture(gl.TEXTURE0 + this._textureCount);\r\n        gl.bindTexture(gl.TEXTURE_2D, uniform.value);\r\n    \r\n        //  Extended texture data\r\n\r\n        var data = uniform.textureData;\r\n\r\n        if (data)\r\n        {\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\r\n    \r\n            //  mag / minFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST\r\n            //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT\r\n            //  format can be: gl.LUMINANCE or gl.RGBA\r\n    \r\n            var magFilter = gl[GetFastValue(data, 'magFilter', 'linear').toUpperCase()];\r\n            var minFilter = gl[GetFastValue(data, 'minFilter', 'linear').toUpperCase()];\r\n            var wrapS = gl[GetFastValue(data, 'wrapS', 'repeat').toUpperCase()];\r\n            var wrapT = gl[GetFastValue(data, 'wrapT', 'repeat').toUpperCase()];\r\n            var format = gl[GetFastValue(data, 'format', 'rgba').toUpperCase()];\r\n\r\n            if (data.repeat)\r\n            {\r\n                wrapS = gl.REPEAT;\r\n                wrapT = gl.REPEAT;\r\n            }\r\n\r\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);\r\n\r\n            if (data.width)\r\n            {\r\n                var width = GetFastValue(data, 'width', 512);\r\n                var height = GetFastValue(data, 'height', 2);\r\n                var border = GetFastValue(data, 'border', 0);\r\n    \r\n                //  texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels)\r\n                gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);\r\n            }\r\n            else\r\n            {\r\n                //  texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, ImageData? pixels)\r\n                gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.source);\r\n            }\r\n    \r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\r\n        }\r\n\r\n        this.renderer.setProgram(this.program);\r\n    \r\n        gl.uniform1i(uniform.uniformLocation, this._textureCount);\r\n    \r\n        this._textureCount++;\r\n    },\r\n\r\n    /**\r\n     * Synchronizes all of the uniforms this shader uses.\r\n     * Each uniforms gl function is called in turn.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#syncUniforms\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    syncUniforms: function ()\r\n    {\r\n        var gl = this.gl;\r\n\r\n        var uniforms = this.uniforms;\r\n        var uniform;\r\n        var length;\r\n        var glFunc;\r\n        var location;\r\n        var value;\r\n        var textureCount = 0;\r\n    \r\n        for (var key in uniforms)\r\n        {\r\n            uniform = uniforms[key];\r\n\r\n            glFunc = uniform.glFunc;\r\n            length = uniform.glValueLength;\r\n            location = uniform.uniformLocation;\r\n            value = uniform.value;\r\n\r\n            if (value === null)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (length === 1)\r\n            {\r\n                if (uniform.glMatrix)\r\n                {\r\n                    glFunc.call(gl, location, uniform.transpose, value);\r\n                }\r\n                else\r\n                {\r\n                    glFunc.call(gl, location, value);\r\n                }\r\n            }\r\n            else if (length === 2)\r\n            {\r\n                glFunc.call(gl, location, value.x, value.y);\r\n            }\r\n            else if (length === 3)\r\n            {\r\n                glFunc.call(gl, location, value.x, value.y, value.z);\r\n            }\r\n            else if (length === 4)\r\n            {\r\n                glFunc.call(gl, location, value.x, value.y, value.z, value.w);\r\n            }\r\n            else if (uniform.type === 'sampler2D')\r\n            {\r\n                gl.activeTexture(gl['TEXTURE' + textureCount]);\r\n\r\n                gl.bindTexture(gl.TEXTURE_2D, value);\r\n\r\n                gl.uniform1i(location, textureCount);\r\n\r\n                textureCount++;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically during render.\r\n     * \r\n     * This method performs matrix ITRS and then stores the resulting value in the `uViewMatrix` uniform.\r\n     * It then sets up the vertex buffer and shader, updates and syncs the uniforms ready\r\n     * for flush to be called.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#load\r\n     * @since 3.17.0\r\n     * \r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [matrix2D] - The transform matrix to use during rendering.\r\n     */\r\n    load: function (matrix2D)\r\n    {\r\n        //  ITRS\r\n\r\n        var gl = this.gl;\r\n        var width = this.width;\r\n        var height = this.height;\r\n        var renderer = this.renderer;\r\n        var program = this.program;\r\n        var vm = this.viewMatrix;\r\n\r\n        if (!this.renderToTexture)\r\n        {\r\n            var x = -this._displayOriginX;\r\n            var y = -this._displayOriginY;\r\n    \r\n            vm[0] = matrix2D[0];\r\n            vm[1] = matrix2D[1];\r\n            vm[4] = matrix2D[2];\r\n            vm[5] = matrix2D[3];\r\n            vm[8] = matrix2D[4];\r\n            vm[9] = matrix2D[5];\r\n            vm[12] = vm[0] * x + vm[4] * y;\r\n            vm[13] = vm[1] * x + vm[5] * y;\r\n        }\r\n\r\n        //  Update vertex shader uniforms\r\n\r\n        gl.useProgram(program);\r\n\r\n        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uViewMatrix'), false, vm);\r\n        gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), this.width, this.height);\r\n\r\n        //  Update fragment shader uniforms\r\n\r\n        var uniforms = this.uniforms;\r\n        var res = uniforms.resolution;\r\n\r\n        res.value.x = width;\r\n        res.value.y = height;\r\n\r\n        uniforms.time.value = renderer.game.loop.getDuration();\r\n\r\n        var pointer = this.pointer;\r\n\r\n        if (pointer)\r\n        {\r\n            var mouse = uniforms.mouse;\r\n\r\n            var px = pointer.x / width;\r\n            var py = 1 - pointer.y / height;\r\n    \r\n            mouse.value.x = px.toFixed(2);\r\n            mouse.value.y = py.toFixed(2);\r\n        }\r\n\r\n        this.syncUniforms();\r\n    },\r\n\r\n    /**\r\n     * Called automatically during render.\r\n     * \r\n     * Sets the active shader, loads the vertex buffer and then draws.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#flush\r\n     * @since 3.17.0\r\n     */\r\n    flush: function ()\r\n    {\r\n        //  Bind\r\n\r\n        var width = this.width;\r\n        var height = this.height;\r\n        var program = this.program;\r\n\r\n        var gl = this.gl;\r\n        var vertexBuffer = this.vertexBuffer;\r\n        var renderer = this.renderer;\r\n        var vertexSize = Float32Array.BYTES_PER_ELEMENT * 2;\r\n\r\n        if (this.renderToTexture)\r\n        {\r\n            renderer.setFramebuffer(this.framebuffer);\r\n\r\n            gl.clearColor(0, 0, 0, 0);\r\n\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n        }\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n\r\n        var location = gl.getAttribLocation(program, 'inPosition');\r\n\r\n        if (location !== -1)\r\n        {\r\n            gl.enableVertexAttribArray(location);\r\n\r\n            gl.vertexAttribPointer(location, 2, gl.FLOAT, false, vertexSize, 0);\r\n        }\r\n\r\n        //  Draw\r\n\r\n        var vf = this.vertexViewF32;\r\n\r\n        vf[3] = height;\r\n        vf[4] = width;\r\n        vf[5] = height;\r\n        vf[8] = width;\r\n        vf[9] = height;\r\n        vf[10] = width;\r\n\r\n        //  Flush\r\n\r\n        var vertexCount = 6;\r\n\r\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));\r\n\r\n        gl.drawArrays(gl.TRIANGLES, 0, vertexCount);\r\n\r\n        if (this.renderToTexture)\r\n        {\r\n            renderer.setFramebuffer(null, false);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * A NOOP method so you can pass a Shader to a Container.\r\n     * Calling this method will do nothing. It is intentionally empty.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setAlpha\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    setAlpha: function ()\r\n    {\r\n    },\r\n    \r\n    /**\r\n     * A NOOP method so you can pass a Shader to a Container.\r\n     * Calling this method will do nothing. It is intentionally empty.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setBlendMode\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    setBlendMode: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#preDestroy\r\n     * @protected\r\n     * @since 3.17.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        var gl = this.gl;\r\n\r\n        gl.deleteProgram(this.program);\r\n        gl.deleteBuffer(this.vertexBuffer);\r\n\r\n        if (this.renderToTexture)\r\n        {\r\n            this.renderer.deleteFramebuffer(this.framebuffer);\r\n\r\n            this.texture.destroy();\r\n\r\n            this.framebuffer = null;\r\n            this.glTexture = null;\r\n            this.texture = null;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Shader;\r\n"]},"metadata":{},"sourceType":"script"}