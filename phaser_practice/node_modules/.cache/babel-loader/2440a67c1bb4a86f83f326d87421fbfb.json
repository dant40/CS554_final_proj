{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar GetTilesWithin = require('./GetTilesWithin');\n\nvar GetRandom = require('../../utils/array/GetRandom');\n/**\r\n * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then\r\n * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n * indexes. This method only modifies tile indexes and does not change collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.Randomize\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n * @param {integer[]} [indexes] - An array of indexes to randomly draw from during randomization.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\n\n\nvar Randomize = function (tileX, tileY, width, height, indexes, layer) {\n  var i;\n  var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer); // If no indices are given, then find all the unique indexes within the specified region\n\n  if (indexes === undefined) {\n    indexes = [];\n\n    for (i = 0; i < tiles.length; i++) {\n      if (indexes.indexOf(tiles[i].index) === -1) {\n        indexes.push(tiles[i].index);\n      }\n    }\n  }\n\n  for (i = 0; i < tiles.length; i++) {\n    tiles[i].index = GetRandom(indexes);\n  }\n};\n\nmodule.exports = Randomize;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/tilemaps/components/Randomize.js"],"names":["GetTilesWithin","require","GetRandom","Randomize","tileX","tileY","width","height","indexes","layer","i","tiles","undefined","length","indexOf","index","push","module","exports"],"mappings":"AAAA;;;;;AAMA,IAAIA,cAAc,GAAGC,OAAO,CAAC,kBAAD,CAA5B;;AACA,IAAIC,SAAS,GAAGD,OAAO,CAAC,6BAAD,CAAvB;AAEA;;;;;;;;;;;;;;;;;;;;AAkBA,IAAIE,SAAS,GAAG,UAAUC,KAAV,EAAiBC,KAAjB,EAAwBC,KAAxB,EAA+BC,MAA/B,EAAuCC,OAAvC,EAAgDC,KAAhD,EAChB;AACI,MAAIC,CAAJ;AACA,MAAIC,KAAK,GAAGX,cAAc,CAACI,KAAD,EAAQC,KAAR,EAAeC,KAAf,EAAsBC,MAAtB,EAA8B,IAA9B,EAAoCE,KAApC,CAA1B,CAFJ,CAII;;AACA,MAAID,OAAO,KAAKI,SAAhB,EACA;AACIJ,IAAAA,OAAO,GAAG,EAAV;;AACA,SAAKE,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,KAAK,CAACE,MAAtB,EAA8BH,CAAC,EAA/B,EACA;AACI,UAAIF,OAAO,CAACM,OAAR,CAAgBH,KAAK,CAACD,CAAD,CAAL,CAASK,KAAzB,MAAoC,CAAC,CAAzC,EACA;AACIP,QAAAA,OAAO,CAACQ,IAAR,CAAaL,KAAK,CAACD,CAAD,CAAL,CAASK,KAAtB;AACH;AACJ;AACJ;;AAED,OAAKL,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,KAAK,CAACE,MAAtB,EAA8BH,CAAC,EAA/B,EACA;AACIC,IAAAA,KAAK,CAACD,CAAD,CAAL,CAASK,KAAT,GAAiBb,SAAS,CAACM,OAAD,CAA1B;AACH;AACJ,CAtBD;;AAwBAS,MAAM,CAACC,OAAP,GAAiBf,SAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar GetRandom = require('../../utils/array/GetRandom');\r\n\r\n/**\r\n * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then\r\n * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n * indexes. This method only modifies tile indexes and does not change collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.Randomize\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [tileX=0] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {integer} [tileY=0] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {integer} [width=max width based on tileX] - How many tiles wide from the `tileX` index the area will be.\r\n * @param {integer} [height=max height based on tileY] - How many tiles tall from the `tileY` index the area will be.\r\n * @param {integer[]} [indexes] - An array of indexes to randomly draw from during randomization.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar Randomize = function (tileX, tileY, width, height, indexes, layer)\r\n{\r\n    var i;\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    // If no indices are given, then find all the unique indexes within the specified region\r\n    if (indexes === undefined)\r\n    {\r\n        indexes = [];\r\n        for (i = 0; i < tiles.length; i++)\r\n        {\r\n            if (indexes.indexOf(tiles[i].index) === -1)\r\n            {\r\n                indexes.push(tiles[i].index);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < tiles.length; i++)\r\n    {\r\n        tiles[i].index = GetRandom(indexes);\r\n    }\r\n};\r\n\r\nmodule.exports = Randomize;\r\n"]},"metadata":{},"sourceType":"script"}