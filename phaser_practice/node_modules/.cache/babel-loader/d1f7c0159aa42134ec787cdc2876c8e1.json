{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar ProcessQueue = require('../structs/ProcessQueue');\n\nvar PluginCache = require('../plugins/PluginCache');\n\nvar SceneEvents = require('../scene/events');\n/**\r\n * @classdesc\r\n * The Update List plugin.\r\n *\r\n * Update Lists belong to a Scene and maintain the list Game Objects to be updated every frame.\r\n *\r\n * Some or all of these Game Objects may also be part of the Scene's [Display List]{@link Phaser.GameObjects.DisplayList}, for Rendering.\r\n *\r\n * @class UpdateList\r\n * @extends Phaser.Structs.ProcessQueue.<Phaser.GameObjects.GameObject>\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that the Update List belongs to.\r\n */\n\n\nvar UpdateList = new Class({\n  Extends: ProcessQueue,\n  initialize: function UpdateList(scene) {\n    ProcessQueue.call(this);\n    /**\r\n     * The Scene that the Update List belongs to.\r\n     *\r\n     * @name Phaser.GameObjects.UpdateList#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n\n    this.scene = scene;\n    /**\r\n     * The Scene's Systems.\r\n     *\r\n     * @name Phaser.GameObjects.UpdateList#systems\r\n     * @type {Phaser.Scenes.Systems}\r\n     * @since 3.0.0\r\n     */\n\n    this.systems = scene.sys;\n    /**\r\n     * The `pending` list is a selection of items which are due to be made 'active' in the next update.\r\n     *\r\n     * @name Phaser.GameObjects.UpdateList#_pending\r\n     * @type {Array.<*>}\r\n     * @private\r\n     * @default []\r\n     * @since 3.20.0\r\n     */\n\n    /**\r\n     * The `active` list is a selection of items which are considered active and should be updated.\r\n     *\r\n     * @name Phaser.GameObjects.UpdateList#_active\r\n     * @type {Array.<*>}\r\n     * @private\r\n     * @default []\r\n     * @since 3.20.0\r\n     */\n\n    /**\r\n     * The `destroy` list is a selection of items that were active and are awaiting being destroyed in the next update.\r\n     *\r\n     * @name Phaser.GameObjects.UpdateList#_destroy\r\n     * @type {Array.<*>}\r\n     * @private\r\n     * @default []\r\n     * @since 3.20.0\r\n     */\n\n    /**\r\n     * The total number of items awaiting processing.\r\n     *\r\n     * @name Phaser.GameObjects.UpdateList#_toProcess\r\n     * @type {integer}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\n    scene.sys.events.on(SceneEvents.START, this.start, this);\n  },\n\n  /**\r\n   * This method is called automatically, only once, when the Scene is first created.\r\n   * Do not invoke it directly.\r\n   *\r\n   * @method Phaser.GameObjects.UpdateList#boot\r\n   * @private\r\n   * @since 3.5.1\r\n   */\n  boot: function () {\n    this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\n  },\n\n  /**\r\n   * This method is called automatically by the Scene when it is starting up.\r\n   * It is responsible for creating local systems, properties and listening for Scene events.\r\n   * Do not invoke it directly.\r\n   *\r\n   * @method Phaser.GameObjects.UpdateList#start\r\n   * @private\r\n   * @since 3.5.0\r\n   */\n  start: function () {\n    var eventEmitter = this.systems.events;\n    eventEmitter.on(SceneEvents.PRE_UPDATE, this.update, this);\n    eventEmitter.on(SceneEvents.UPDATE, this.sceneUpdate, this);\n    eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\n  },\n\n  /**\r\n   * The update step.\r\n   *\r\n   * Pre-updates every active Game Object in the list.\r\n   *\r\n   * @method Phaser.GameObjects.UpdateList#sceneUpdate\r\n   * @since 3.20.0\r\n   *\r\n   * @param {number} time - The current timestamp.\r\n   * @param {number} delta - The delta time elapsed since the last frame.\r\n   */\n  sceneUpdate: function (time, delta) {\n    var list = this._active;\n    var length = list.length;\n\n    for (var i = 0; i < length; i++) {\n      var gameObject = list[i];\n\n      if (gameObject.active) {\n        gameObject.preUpdate.call(gameObject, time, delta);\n      }\n    }\n  },\n\n  /**\r\n   * The Scene that owns this plugin is shutting down.\r\n   * \r\n   * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n   *\r\n   * @method Phaser.GameObjects.UpdateList#shutdown\r\n   * @since 3.0.0\r\n   */\n  shutdown: function () {\n    var i = this._active.length;\n\n    while (i--) {\n      this._active[i].destroy(true);\n    }\n\n    i = this._pending.length;\n\n    while (i--) {\n      this._pending[i].destroy(true);\n    }\n\n    i = this._destroy.length;\n\n    while (i--) {\n      this._destroy[i].destroy(true);\n    }\n\n    this._toProcess = 0;\n    this._pending = [];\n    this._active = [];\n    this._destroy = [];\n    this.removeAllListeners();\n    var eventEmitter = this.systems.events;\n    eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);\n    eventEmitter.off(SceneEvents.UPDATE, this.sceneUpdate, this);\n    eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\n  },\n\n  /**\r\n   * The Scene that owns this plugin is being destroyed.\r\n   * \r\n   * We need to shutdown and then kill off all external references.\r\n   *\r\n   * @method Phaser.GameObjects.UpdateList#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.shutdown();\n    this.systems.events.off(SceneEvents.START, this.start, this);\n    this.scene = null;\n    this.systems = null;\n  }\n  /**\r\n   * Adds a new item to the Update List.\r\n   * \r\n   * The item is added to the pending list and made active in the next update.\r\n   *\r\n   * @method Phaser.GameObjects.UpdateList#add\r\n   * @since 3.0.0\r\n   *\r\n   * @param {*} item - The item to add to the queue.\r\n   *\r\n   * @return {*} The item that was added.\r\n   */\n\n  /**\r\n   * Removes an item from the Update List.\r\n   * \r\n   * The item is added to the pending destroy and fully removed in the next update.\r\n   *\r\n   * @method Phaser.GameObjects.UpdateList#remove\r\n   * @since 3.0.0\r\n   *\r\n   * @param {*} item - The item to be removed from the queue.\r\n   *\r\n   * @return {*} The item that was removed.\r\n   */\n\n  /**\r\n   * Removes all active items from this Update List.\r\n   * \r\n   * All the items are marked as 'pending destroy' and fully removed in the next update.\r\n   *\r\n   * @method Phaser.GameObjects.UpdateList#removeAll\r\n   * @since 3.20.0\r\n   *\r\n   * @return {this} This Update List object.\r\n   */\n\n  /**\r\n   * Update this queue. First it will process any items awaiting destruction, and remove them.\r\n   * \r\n   * Then it will check to see if there are any items pending insertion, and move them to an\r\n   * active state. Finally, it will return a list of active items for further processing.\r\n   *\r\n   * @method Phaser.GameObjects.UpdateList#update\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Array.<*>} A list of active items.\r\n   */\n\n  /**\r\n   * Returns the current list of active items.\r\n   * \r\n   * This method returns a reference to the active list array, not a copy of it.\r\n   * Therefore, be careful to not modify this array outside of the ProcessQueue.\r\n   *\r\n   * @method Phaser.GameObjects.UpdateList#getActive\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Array.<*>} A list of active items.\r\n   */\n\n  /**\r\n   * The number of entries in the active list.\r\n   *\r\n   * @name Phaser.GameObjects.UpdateList#length\r\n   * @type {integer}\r\n   * @readonly\r\n   * @since 3.20.0\r\n   */\n\n});\nPluginCache.register('UpdateList', UpdateList, 'updateList');\nmodule.exports = UpdateList;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/UpdateList.js"],"names":["Class","require","ProcessQueue","PluginCache","SceneEvents","UpdateList","Extends","initialize","scene","call","systems","sys","events","once","BOOT","boot","on","START","start","DESTROY","destroy","eventEmitter","PRE_UPDATE","update","UPDATE","sceneUpdate","SHUTDOWN","shutdown","time","delta","list","_active","length","i","gameObject","active","preUpdate","_pending","_destroy","_toProcess","removeAllListeners","off","register","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar ProcessQueue = require('../structs/ProcessQueue');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar SceneEvents = require('../scene/events');\r\n\r\n/**\r\n * @classdesc\r\n * The Update List plugin.\r\n *\r\n * Update Lists belong to a Scene and maintain the list Game Objects to be updated every frame.\r\n *\r\n * Some or all of these Game Objects may also be part of the Scene's [Display List]{@link Phaser.GameObjects.DisplayList}, for Rendering.\r\n *\r\n * @class UpdateList\r\n * @extends Phaser.Structs.ProcessQueue.<Phaser.GameObjects.GameObject>\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that the Update List belongs to.\r\n */\r\nvar UpdateList = new Class({\r\n\r\n    Extends: ProcessQueue,\r\n\r\n    initialize:\r\n\r\n    function UpdateList (scene)\r\n    {\r\n        ProcessQueue.call(this);\r\n\r\n        /**\r\n         * The Scene that the Update List belongs to.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The Scene's Systems.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * The `pending` list is a selection of items which are due to be made 'active' in the next update.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#_pending\r\n         * @type {Array.<*>}\r\n         * @private\r\n         * @default []\r\n         * @since 3.20.0\r\n         */\r\n\r\n        /**\r\n         * The `active` list is a selection of items which are considered active and should be updated.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#_active\r\n         * @type {Array.<*>}\r\n         * @private\r\n         * @default []\r\n         * @since 3.20.0\r\n         */\r\n\r\n        /**\r\n         * The `destroy` list is a selection of items that were active and are awaiting being destroyed in the next update.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#_destroy\r\n         * @type {Array.<*>}\r\n         * @private\r\n         * @default []\r\n         * @since 3.20.0\r\n         */\r\n\r\n        /**\r\n         * The total number of items awaiting processing.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#_toProcess\r\n         * @type {integer}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        scene.sys.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#start\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.on(SceneEvents.PRE_UPDATE, this.update, this);\r\n        eventEmitter.on(SceneEvents.UPDATE, this.sceneUpdate, this);\r\n        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The update step.\r\n     *\r\n     * Pre-updates every active Game Object in the list.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#sceneUpdate\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} time - The current timestamp.\r\n     * @param {number} delta - The delta time elapsed since the last frame.\r\n     */\r\n    sceneUpdate: function (time, delta)\r\n    {\r\n        var list = this._active;\r\n        var length = list.length;\r\n\r\n        for (var i = 0; i < length; i++)\r\n        {\r\n            var gameObject = list[i];\r\n\r\n            if (gameObject.active)\r\n            {\r\n                gameObject.preUpdate.call(gameObject, time, delta);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * \r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#shutdown\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        var i = this._active.length;\r\n\r\n        while (i--)\r\n        {\r\n            this._active[i].destroy(true);\r\n        }\r\n\r\n        i = this._pending.length;\r\n\r\n        while (i--)\r\n        {\r\n            this._pending[i].destroy(true);\r\n        }\r\n\r\n        i = this._destroy.length;\r\n\r\n        while (i--)\r\n        {\r\n            this._destroy[i].destroy(true);\r\n        }\r\n\r\n        this._toProcess = 0;\r\n\r\n        this._pending = [];\r\n        this._active = [];\r\n        this._destroy = [];\r\n\r\n        this.removeAllListeners();\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);\r\n        eventEmitter.off(SceneEvents.UPDATE, this.sceneUpdate, this);\r\n        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * \r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.systems.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n    /**\r\n     * Adds a new item to the Update List.\r\n     * \r\n     * The item is added to the pending list and made active in the next update.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} item - The item to add to the queue.\r\n     *\r\n     * @return {*} The item that was added.\r\n     */\r\n\r\n    /**\r\n     * Removes an item from the Update List.\r\n     * \r\n     * The item is added to the pending destroy and fully removed in the next update.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} item - The item to be removed from the queue.\r\n     *\r\n     * @return {*} The item that was removed.\r\n     */\r\n\r\n    /**\r\n     * Removes all active items from this Update List.\r\n     * \r\n     * All the items are marked as 'pending destroy' and fully removed in the next update.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#removeAll\r\n     * @since 3.20.0\r\n     *\r\n     * @return {this} This Update List object.\r\n     */\r\n\r\n    /**\r\n     * Update this queue. First it will process any items awaiting destruction, and remove them.\r\n     * \r\n     * Then it will check to see if there are any items pending insertion, and move them to an\r\n     * active state. Finally, it will return a list of active items for further processing.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#update\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Array.<*>} A list of active items.\r\n     */\r\n\r\n    /**\r\n     * Returns the current list of active items.\r\n     * \r\n     * This method returns a reference to the active list array, not a copy of it.\r\n     * Therefore, be careful to not modify this array outside of the ProcessQueue.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#getActive\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Array.<*>} A list of active items.\r\n     */\r\n\r\n    /**\r\n     * The number of entries in the active list.\r\n     *\r\n     * @name Phaser.GameObjects.UpdateList#length\r\n     * @type {integer}\r\n     * @readonly\r\n     * @since 3.20.0\r\n     */\r\n});\r\n\r\nPluginCache.register('UpdateList', UpdateList, 'updateList');\r\n\r\nmodule.exports = UpdateList;\r\n"]},"metadata":{},"sourceType":"script"}