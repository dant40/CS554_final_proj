{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar AlignIn = require('../display/align/in/QuickSet');\n\nvar CONST = require('../display/align/const');\n\nvar GetFastValue = require('../utils/object/GetFastValue');\n\nvar NOOP = require('../utils/NOOP');\n\nvar Zone = require('../gameobjects/zone/Zone');\n\nvar tempZone = new Zone({\n  sys: {\n    queueDepthSort: NOOP,\n    events: {\n      once: NOOP\n    }\n  }\n}, 0, 0, 1, 1);\n/**\r\n * Takes an array of Game Objects, or any objects that have public `x` and `y` properties,\r\n * and then aligns them based on the grid configuration given to this action.\r\n *\r\n * @function Phaser.Actions.GridAlign\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {Phaser.Types.Actions.GridAlignConfig} options - The GridAlign Configuration object.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\n\nvar GridAlign = function (items, options) {\n  if (options === undefined) {\n    options = {};\n  }\n\n  var widthSet = options.hasOwnProperty('width');\n  var heightSet = options.hasOwnProperty('height');\n  var width = GetFastValue(options, 'width', -1);\n  var height = GetFastValue(options, 'height', -1);\n  var cellWidth = GetFastValue(options, 'cellWidth', 1);\n  var cellHeight = GetFastValue(options, 'cellHeight', cellWidth);\n  var position = GetFastValue(options, 'position', CONST.TOP_LEFT);\n  var x = GetFastValue(options, 'x', 0);\n  var y = GetFastValue(options, 'y', 0);\n  var cx = 0;\n  var cy = 0;\n  var w = width * cellWidth;\n  var h = height * cellHeight;\n  tempZone.setPosition(x, y);\n  tempZone.setSize(cellWidth, cellHeight);\n\n  for (var i = 0; i < items.length; i++) {\n    AlignIn(items[i], tempZone, position);\n\n    if (widthSet && width === -1) {\n      //  We keep laying them out horizontally until we've done them all\n      tempZone.x += cellWidth;\n    } else if (heightSet && height === -1) {\n      //  We keep laying them out vertically until we've done them all\n      tempZone.y += cellHeight;\n    } else {\n      //  We keep laying them out until we hit the column limit\n      cx += cellWidth;\n      tempZone.x += cellWidth;\n\n      if (cx === w) {\n        cx = 0;\n        cy += cellHeight;\n        tempZone.x = x;\n        tempZone.y += cellHeight;\n\n        if (cy === h) {\n          //  We've hit the column limit, so return, even if there are items left\n          break;\n        }\n      }\n    }\n  }\n\n  return items;\n};\n\nmodule.exports = GridAlign;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/actions/GridAlign.js"],"names":["AlignIn","require","CONST","GetFastValue","NOOP","Zone","tempZone","sys","queueDepthSort","events","once","GridAlign","items","options","undefined","widthSet","hasOwnProperty","heightSet","width","height","cellWidth","cellHeight","position","TOP_LEFT","x","y","cx","cy","w","h","setPosition","setSize","i","length","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AlignIn = require('../display/align/in/QuickSet');\r\nvar CONST = require('../display/align/const');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar NOOP = require('../utils/NOOP');\r\nvar Zone = require('../gameobjects/zone/Zone');\r\n\r\nvar tempZone = new Zone({ sys: { queueDepthSort: NOOP, events: { once: NOOP } } }, 0, 0, 1, 1);\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have public `x` and `y` properties,\r\n * and then aligns them based on the grid configuration given to this action.\r\n *\r\n * @function Phaser.Actions.GridAlign\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {Phaser.Types.Actions.GridAlignConfig} options - The GridAlign Configuration object.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar GridAlign = function (items, options)\r\n{\r\n    if (options === undefined) { options = {}; }\r\n\r\n    var widthSet = options.hasOwnProperty('width');\r\n    var heightSet = options.hasOwnProperty('height');\r\n\r\n    var width = GetFastValue(options, 'width', -1);\r\n    var height = GetFastValue(options, 'height', -1);\r\n\r\n    var cellWidth = GetFastValue(options, 'cellWidth', 1);\r\n    var cellHeight = GetFastValue(options, 'cellHeight', cellWidth);\r\n\r\n    var position = GetFastValue(options, 'position', CONST.TOP_LEFT);\r\n    var x = GetFastValue(options, 'x', 0);\r\n    var y = GetFastValue(options, 'y', 0);\r\n\r\n    var cx = 0;\r\n    var cy = 0;\r\n    var w = (width * cellWidth);\r\n    var h = (height * cellHeight);\r\n\r\n    tempZone.setPosition(x, y);\r\n    tempZone.setSize(cellWidth, cellHeight);\r\n\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        AlignIn(items[i], tempZone, position);\r\n\r\n        if (widthSet && width === -1)\r\n        {\r\n            //  We keep laying them out horizontally until we've done them all\r\n            tempZone.x += cellWidth;\r\n        }\r\n        else if (heightSet && height === -1)\r\n        {\r\n            //  We keep laying them out vertically until we've done them all\r\n            tempZone.y += cellHeight;\r\n        }\r\n        else\r\n        {\r\n            //  We keep laying them out until we hit the column limit\r\n            cx += cellWidth;\r\n            tempZone.x += cellWidth;\r\n\r\n            if (cx === w)\r\n            {\r\n                cx = 0;\r\n                cy += cellHeight;\r\n                tempZone.x = x;\r\n                tempZone.y += cellHeight;\r\n\r\n                if (cy === h)\r\n                {\r\n                    //  We've hit the column limit, so return, even if there are items left\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = GridAlign;\r\n"]},"metadata":{},"sourceType":"script"}