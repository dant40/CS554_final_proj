{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar CONST = require('./const');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar GameEvents = require('../core/events');\n\nvar Keyboard = require('./keyboard/KeyboardManager');\n\nvar Mouse = require('./mouse/MouseManager');\n\nvar Pointer = require('./Pointer');\n\nvar Touch = require('./touch/TouchManager');\n\nvar TransformMatrix = require('../gameobjects/components/TransformMatrix');\n\nvar TransformXY = require('../math/TransformXY');\n/**\r\n * @classdesc\r\n * The Input Manager is responsible for handling the pointer related systems in a single Phaser Game instance.\r\n *\r\n * Based on the Game Config it will create handlers for mouse and touch support.\r\n *\r\n * Keyboard and Gamepad are plugins, handled directly by the InputPlugin class.\r\n *\r\n * It then manages the events, pointer creation and general hit test related operations.\r\n *\r\n * You rarely need to interact with the Input Manager directly, and as such, all of its properties and methods\r\n * should be considered private. Instead, you should use the Input Plugin, which is a Scene level system, responsible\r\n * for dealing with all input events for a Scene.\r\n *\r\n * @class InputManager\r\n * @memberof Phaser.Input\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Game instance that owns the Input Manager.\r\n * @param {object} config - The Input Configuration object, as set in the Game Config.\r\n */\n\n\nvar InputManager = new Class({\n  initialize: function InputManager(game, config) {\n    /**\r\n     * The Game instance that owns the Input Manager.\r\n     * A Game only maintains on instance of the Input Manager at any time.\r\n     *\r\n     * @name Phaser.Input.InputManager#game\r\n     * @type {Phaser.Game}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\n    this.game = game;\n    /**\r\n     * A reference to the global Game Scale Manager.\r\n     * Used for all bounds checks and pointer scaling.\r\n     *\r\n     * @name Phaser.Input.InputManager#scaleManager\r\n     * @type {Phaser.Scale.ScaleManager}\r\n     * @since 3.16.0\r\n     */\n\n    this.scaleManager;\n    /**\r\n     * The Canvas that is used for all DOM event input listeners.\r\n     *\r\n     * @name Phaser.Input.InputManager#canvas\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.0.0\r\n     */\n\n    this.canvas;\n    /**\r\n     * The Game Configuration object, as set during the game boot.\r\n     *\r\n     * @name Phaser.Input.InputManager#config\r\n     * @type {Phaser.Core.Config}\r\n     * @since 3.0.0\r\n     */\n\n    this.config = config;\n    /**\r\n     * If set, the Input Manager will run its update loop every frame.\r\n     *\r\n     * @name Phaser.Input.InputManager#enabled\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.enabled = true;\n    /**\r\n     * The Event Emitter instance that the Input Manager uses to emit events from.\r\n     *\r\n     * @name Phaser.Input.InputManager#events\r\n     * @type {Phaser.Events.EventEmitter}\r\n     * @since 3.0.0\r\n     */\n\n    this.events = new EventEmitter();\n    /**\r\n     * Are any mouse or touch pointers currently over the game canvas?\r\n     * This is updated automatically by the canvas over and out handlers.\r\n     *\r\n     * @name Phaser.Input.InputManager#isOver\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\n\n    this.isOver = true;\n    /**\r\n     * The default CSS cursor to be used when interacting with your game.\r\n     *\r\n     * See the `setDefaultCursor` method for more details.\r\n     *\r\n     * @name Phaser.Input.InputManager#defaultCursor\r\n     * @type {string}\r\n     * @since 3.10.0\r\n     */\n\n    this.defaultCursor = '';\n    /**\r\n     * A reference to the Keyboard Manager class, if enabled via the `input.keyboard` Game Config property.\r\n     *\r\n     * @name Phaser.Input.InputManager#keyboard\r\n     * @type {?Phaser.Input.Keyboard.KeyboardManager}\r\n     * @since 3.16.0\r\n     */\n\n    this.keyboard = config.inputKeyboard ? new Keyboard(this) : null;\n    /**\r\n     * A reference to the Mouse Manager class, if enabled via the `input.mouse` Game Config property.\r\n     *\r\n     * @name Phaser.Input.InputManager#mouse\r\n     * @type {?Phaser.Input.Mouse.MouseManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.mouse = config.inputMouse ? new Mouse(this) : null;\n    /**\r\n     * A reference to the Touch Manager class, if enabled via the `input.touch` Game Config property.\r\n     *\r\n     * @name Phaser.Input.InputManager#touch\r\n     * @type {Phaser.Input.Touch.TouchManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.touch = config.inputTouch ? new Touch(this) : null;\n    /**\r\n     * An array of Pointers that have been added to the game.\r\n     * The first entry is reserved for the Mouse Pointer, the rest are Touch Pointers.\r\n     *\r\n     * By default there is 1 touch pointer enabled. If you need more use the `addPointer` method to start them,\r\n     * or set the `input.activePointers` property in the Game Config.\r\n     *\r\n     * @name Phaser.Input.InputManager#pointers\r\n     * @type {Phaser.Input.Pointer[]}\r\n     * @since 3.10.0\r\n     */\n\n    this.pointers = [];\n    /**\r\n     * The number of touch objects activated and being processed each update.\r\n     *\r\n     * You can change this by either calling `addPointer` at run-time, or by\r\n     * setting the `input.activePointers` property in the Game Config.\r\n     *\r\n     * @name Phaser.Input.InputManager#pointersTotal\r\n     * @type {integer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\n\n    this.pointersTotal = config.inputActivePointers;\n\n    if (config.inputTouch && this.pointersTotal === 1) {\n      this.pointersTotal = 2;\n    }\n\n    for (var i = 0; i <= this.pointersTotal; i++) {\n      var pointer = new Pointer(this, i);\n      pointer.smoothFactor = config.inputSmoothFactor;\n      this.pointers.push(pointer);\n    }\n    /**\r\n     * The mouse has its own unique Pointer object, which you can reference directly if making a _desktop specific game_.\r\n     * If you are supporting both desktop and touch devices then do not use this property, instead use `activePointer`\r\n     * which will always map to the most recently interacted pointer.\r\n     *\r\n     * @name Phaser.Input.InputManager#mousePointer\r\n     * @type {?Phaser.Input.Pointer}\r\n     * @since 3.10.0\r\n     */\n\n\n    this.mousePointer = config.inputMouse ? this.pointers[0] : null;\n    /**\r\n     * The most recently active Pointer object.\r\n     *\r\n     * If you've only 1 Pointer in your game then this will accurately be either the first finger touched, or the mouse.\r\n     *\r\n     * If your game doesn't need to support multi-touch then you can safely use this property in all of your game\r\n     * code and it will adapt to be either the mouse or the touch, based on device.\r\n     *\r\n     * @name Phaser.Input.InputManager#activePointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @since 3.0.0\r\n     */\n\n    this.activePointer = this.pointers[0];\n    /**\r\n     * If the top-most Scene in the Scene List receives an input it will stop input from\r\n     * propagating any lower down the scene list, i.e. if you have a UI Scene at the top\r\n     * and click something on it, that click will not then be passed down to any other\r\n     * Scene below. Disable this to have input events passed through all Scenes, all the time.\r\n     *\r\n     * @name Phaser.Input.InputManager#globalTopOnly\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.globalTopOnly = true;\n    /**\r\n     * The time this Input Manager was last updated.\r\n     * This value is populated by the Game Step each frame.\r\n     *\r\n     * @name Phaser.Input.InputManager#time\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.16.2\r\n     */\n\n    this.time = 0;\n    /**\r\n     * A re-cycled point-like object to store hit test values in.\r\n     *\r\n     * @name Phaser.Input.InputManager#_tempPoint\r\n     * @type {{x:number, y:number}}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._tempPoint = {\n      x: 0,\n      y: 0\n    };\n    /**\r\n     * A re-cycled array to store hit results in.\r\n     *\r\n     * @name Phaser.Input.InputManager#_tempHitTest\r\n     * @type {array}\r\n     * @private\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this._tempHitTest = [];\n    /**\r\n     * A re-cycled matrix used in hit test calculations.\r\n     *\r\n     * @name Phaser.Input.InputManager#_tempMatrix\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @private\r\n     * @since 3.4.0\r\n     */\n\n    this._tempMatrix = new TransformMatrix();\n    /**\r\n     * A re-cycled matrix used in hit test calculations.\r\n     *\r\n     * @name Phaser.Input.InputManager#_tempMatrix2\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix2 = new TransformMatrix();\n    /**\r\n     * An internal private var that records Scenes aborting event processing.\r\n     *\r\n     * @name Phaser.Input.InputManager#_tempSkip\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.18.0\r\n     */\n\n    this._tempSkip = false;\n    /**\r\n     * An internal private array that avoids needing to create a new array on every DOM mouse event.\r\n     *\r\n     * @name Phaser.Input.InputManager#mousePointerContainer\r\n     * @type {Phaser.Input.Pointer[]}\r\n     * @private\r\n     * @since 3.18.0\r\n     */\n\n    this.mousePointerContainer = [this.mousePointer];\n    game.events.once(GameEvents.BOOT, this.boot, this);\n  },\n\n  /**\r\n   * The Boot handler is called by Phaser.Game when it first starts up.\r\n   * The renderer is available by now.\r\n   *\r\n   * @method Phaser.Input.InputManager#boot\r\n   * @protected\r\n   * @fires Phaser.Input.Events#MANAGER_BOOT\r\n   * @since 3.0.0\r\n   */\n  boot: function () {\n    this.canvas = this.game.canvas;\n    this.scaleManager = this.game.scale;\n    this.events.emit(Events.MANAGER_BOOT);\n    this.game.events.on(GameEvents.PRE_RENDER, this.preRender, this);\n    this.game.events.once(GameEvents.DESTROY, this.destroy, this);\n  },\n\n  /**\r\n   * Internal canvas state change, called automatically by the Mouse Manager.\r\n   *\r\n   * @method Phaser.Input.InputManager#setCanvasOver\r\n   * @fires Phaser.Input.Events#GAME_OVER\r\n   * @private\r\n   * @since 3.16.0\r\n   *\r\n   * @param {(MouseEvent|TouchEvent)} event - The DOM Event.\r\n   */\n  setCanvasOver: function (event) {\n    this.isOver = true;\n    this.events.emit(Events.GAME_OVER, event);\n  },\n\n  /**\r\n   * Internal canvas state change, called automatically by the Mouse Manager.\r\n   *\r\n   * @method Phaser.Input.InputManager#setCanvasOut\r\n   * @fires Phaser.Input.Events#GAME_OUT\r\n   * @private\r\n   * @since 3.16.0\r\n   *\r\n   * @param {(MouseEvent|TouchEvent)} event - The DOM Event.\r\n   */\n  setCanvasOut: function (event) {\n    this.isOver = false;\n    this.events.emit(Events.GAME_OUT, event);\n  },\n\n  /**\r\n   * Internal update, called automatically by the Game Step right at the start.\r\n   *\r\n   * @method Phaser.Input.InputManager#preRender\r\n   * @private\r\n   * @since 3.18.0\r\n   */\n  preRender: function () {\n    var time = this.game.loop.now;\n    var delta = this.game.loop.delta;\n    var scenes = this.game.scene.getScenes(true, true);\n    this.time = time;\n    this.events.emit(Events.MANAGER_UPDATE);\n\n    for (var i = 0; i < scenes.length; i++) {\n      var scene = scenes[i];\n\n      if (scene.sys.input && scene.sys.input.updatePoll(time, delta) && this.globalTopOnly) {\n        //  If the Scene returns true, it means it captured some input that no other Scene should get, so we bail out\n        return;\n      }\n    }\n  },\n\n  /**\r\n   * Tells the Input system to set a custom cursor.\r\n   * \r\n   * This cursor will be the default cursor used when interacting with the game canvas.\r\n   *\r\n   * If an Interactive Object also sets a custom cursor, this is the cursor that is reset after its use.\r\n   *\r\n   * Any valid CSS cursor value is allowed, including paths to image files, i.e.:\r\n   *\r\n   * ```javascript\r\n   * this.input.setDefaultCursor('url(assets/cursors/sword.cur), pointer');\r\n   * ```\r\n   * \r\n   * Please read about the differences between browsers when it comes to the file formats and sizes they support:\r\n   *\r\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\r\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_User_Interface/Using_URL_values_for_the_cursor_property\r\n   *\r\n   * It's up to you to pick a suitable cursor format that works across the range of browsers you need to support.\r\n   *\r\n   * @method Phaser.Input.InputManager#setDefaultCursor\r\n   * @since 3.10.0\r\n   * \r\n   * @param {string} cursor - The CSS to be used when setting the default cursor.\r\n   */\n  setDefaultCursor: function (cursor) {\n    this.defaultCursor = cursor;\n\n    if (this.canvas.style.cursor !== cursor) {\n      this.canvas.style.cursor = cursor;\n    }\n  },\n\n  /**\r\n   * Called by the InputPlugin when processing over and out events.\r\n   * \r\n   * Tells the Input Manager to set a custom cursor during its postUpdate step.\r\n   *\r\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\r\n   *\r\n   * @method Phaser.Input.InputManager#setCursor\r\n   * @private\r\n   * @since 3.10.0\r\n   * \r\n   * @param {Phaser.Types.Input.InteractiveObject} interactiveObject - The Interactive Object that called this method.\r\n   */\n  setCursor: function (interactiveObject) {\n    if (interactiveObject.cursor) {\n      this.canvas.style.cursor = interactiveObject.cursor;\n    }\n  },\n\n  /**\r\n   * Called by the InputPlugin when processing over and out events.\r\n   * \r\n   * Tells the Input Manager to clear the hand cursor, if set, during its postUpdate step.\r\n   *\r\n   * @method Phaser.Input.InputManager#resetCursor\r\n   * @private\r\n   * @since 3.10.0\r\n   * \r\n   * @param {Phaser.Types.Input.InteractiveObject} interactiveObject - The Interactive Object that called this method.\r\n   */\n  resetCursor: function (interactiveObject) {\n    if (interactiveObject.cursor && this.canvas) {\n      this.canvas.style.cursor = this.defaultCursor;\n    }\n  },\n\n  /**\r\n   * Adds new Pointer objects to the Input Manager.\r\n   *\r\n   * By default Phaser creates 2 pointer objects: `mousePointer` and `pointer1`.\r\n   *\r\n   * You can create more either by calling this method, or by setting the `input.activePointers` property\r\n   * in the Game Config, up to a maximum of 10 pointers.\r\n   *\r\n   * The first 10 pointers are available via the `InputPlugin.pointerX` properties, once they have been added\r\n   * via this method.\r\n   *\r\n   * @method Phaser.Input.InputManager#addPointer\r\n   * @since 3.10.0\r\n   *\r\n   * @param {integer} [quantity=1] The number of new Pointers to create. A maximum of 10 is allowed in total.\r\n   *\r\n   * @return {Phaser.Input.Pointer[]} An array containing all of the new Pointer objects that were created.\r\n   */\n  addPointer: function (quantity) {\n    if (quantity === undefined) {\n      quantity = 1;\n    }\n\n    var output = [];\n\n    if (this.pointersTotal + quantity > 10) {\n      quantity = 10 - this.pointersTotal;\n    }\n\n    for (var i = 0; i < quantity; i++) {\n      var id = this.pointers.length;\n      var pointer = new Pointer(this, id);\n      pointer.smoothFactor = this.config.inputSmoothFactor;\n      this.pointers.push(pointer);\n      this.pointersTotal++;\n      output.push(pointer);\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Internal method that gets a list of all the active Input Plugins in the game\r\n   * and updates each of them in turn, in reverse order (top to bottom), to allow\r\n   * for DOM top-level event handling simulation.\r\n   *\r\n   * @method Phaser.Input.InputManager#updateInputPlugins\r\n   * @since 3.16.0\r\n   *\r\n   * @param {integer} type - The type of event to process.\r\n   * @param {Phaser.Input.Pointer[]} pointers - An array of Pointers on which the event occurred.\r\n   */\n  updateInputPlugins: function (type, pointers) {\n    var scenes = this.game.scene.getScenes(true, true);\n    this._tempSkip = false;\n\n    for (var i = 0; i < scenes.length; i++) {\n      var scene = scenes[i];\n\n      if (scene.sys.input) {\n        var capture = scene.sys.input.update(type, pointers);\n\n        if (capture && this.globalTopOnly || this._tempSkip) {\n          //  If the Scene returns true, or called stopPropagation, it means it captured some input that no other Scene should get, so we bail out\n          return;\n        }\n      }\n    }\n  },\n  //  event.targetTouches = list of all touches on the TARGET ELEMENT (i.e. game dom element)\n  //  event.touches = list of all touches on the ENTIRE DOCUMENT, not just the target element\n  //  event.changedTouches = the touches that CHANGED in this event, not the total number of them\n\n  /**\r\n   * Processes a touch start event, as passed in by the TouchManager.\r\n   *\r\n   * @method Phaser.Input.InputManager#onTouchStart\r\n   * @private\r\n   * @since 3.18.0\r\n   *\r\n   * @param {TouchEvent} event - The native DOM Touch event.\r\n   */\n  onTouchStart: function (event) {\n    var pointers = this.pointers;\n    var changed = [];\n\n    for (var c = 0; c < event.changedTouches.length; c++) {\n      var changedTouch = event.changedTouches[c];\n\n      for (var i = 1; i < this.pointersTotal; i++) {\n        var pointer = pointers[i];\n\n        if (!pointer.active) {\n          pointer.touchstart(changedTouch, event);\n          this.activePointer = pointer;\n          changed.push(pointer);\n          break;\n        }\n      }\n    }\n\n    this.updateInputPlugins(CONST.TOUCH_START, changed);\n  },\n\n  /**\r\n   * Processes a touch move event, as passed in by the TouchManager.\r\n   *\r\n   * @method Phaser.Input.InputManager#onTouchMove\r\n   * @private\r\n   * @since 3.18.0\r\n   *\r\n   * @param {TouchEvent} event - The native DOM Touch event.\r\n   */\n  onTouchMove: function (event) {\n    var pointers = this.pointers;\n    var changed = [];\n\n    for (var c = 0; c < event.changedTouches.length; c++) {\n      var changedTouch = event.changedTouches[c];\n\n      for (var i = 1; i < this.pointersTotal; i++) {\n        var pointer = pointers[i];\n\n        if (pointer.active && pointer.identifier === changedTouch.identifier) {\n          pointer.touchmove(changedTouch, event);\n          this.activePointer = pointer;\n          changed.push(pointer);\n          break;\n        }\n      }\n    }\n\n    this.updateInputPlugins(CONST.TOUCH_MOVE, changed);\n  },\n  //  For touch end its a list of the touch points that have been removed from the surface\n  //  https://developer.mozilla.org/en-US/docs/DOM/TouchList\n  //  event.changedTouches = the touches that CHANGED in this event, not the total number of them\n\n  /**\r\n   * Processes a touch end event, as passed in by the TouchManager.\r\n   *\r\n   * @method Phaser.Input.InputManager#onTouchEnd\r\n   * @private\r\n   * @since 3.18.0\r\n   *\r\n   * @param {TouchEvent} event - The native DOM Touch event.\r\n   */\n  onTouchEnd: function (event) {\n    var pointers = this.pointers;\n    var changed = [];\n\n    for (var c = 0; c < event.changedTouches.length; c++) {\n      var changedTouch = event.changedTouches[c];\n\n      for (var i = 1; i < this.pointersTotal; i++) {\n        var pointer = pointers[i];\n\n        if (pointer.active && pointer.identifier === changedTouch.identifier) {\n          pointer.touchend(changedTouch, event);\n          changed.push(pointer);\n          break;\n        }\n      }\n    }\n\n    this.updateInputPlugins(CONST.TOUCH_END, changed);\n  },\n\n  /**\r\n   * Processes a touch cancel event, as passed in by the TouchManager.\r\n   *\r\n   * @method Phaser.Input.InputManager#onTouchCancel\r\n   * @private\r\n   * @since 3.18.0\r\n   *\r\n   * @param {TouchEvent} event - The native DOM Touch event.\r\n   */\n  onTouchCancel: function (event) {\n    var pointers = this.pointers;\n    var changed = [];\n\n    for (var c = 0; c < event.changedTouches.length; c++) {\n      var changedTouch = event.changedTouches[c];\n\n      for (var i = 1; i < this.pointersTotal; i++) {\n        var pointer = pointers[i];\n\n        if (pointer.active && pointer.identifier === changedTouch.identifier) {\n          pointer.touchcancel(changedTouch, event);\n          changed.push(pointer);\n          break;\n        }\n      }\n    }\n\n    this.updateInputPlugins(CONST.TOUCH_CANCEL, changed);\n  },\n\n  /**\r\n   * Processes a mouse down event, as passed in by the MouseManager.\r\n   *\r\n   * @method Phaser.Input.InputManager#onMouseDown\r\n   * @private\r\n   * @since 3.18.0\r\n   *\r\n   * @param {MouseEvent} event - The native DOM Mouse event.\r\n   */\n  onMouseDown: function (event) {\n    this.mousePointer.down(event);\n    this.mousePointer.updateMotion();\n    this.updateInputPlugins(CONST.MOUSE_DOWN, this.mousePointerContainer);\n  },\n\n  /**\r\n   * Processes a mouse move event, as passed in by the MouseManager.\r\n   *\r\n   * @method Phaser.Input.InputManager#onMouseMove\r\n   * @private\r\n   * @since 3.18.0\r\n   *\r\n   * @param {MouseEvent} event - The native DOM Mouse event.\r\n   */\n  onMouseMove: function (event) {\n    this.mousePointer.move(event);\n    this.mousePointer.updateMotion();\n    this.updateInputPlugins(CONST.MOUSE_MOVE, this.mousePointerContainer);\n  },\n\n  /**\r\n   * Processes a mouse up event, as passed in by the MouseManager.\r\n   *\r\n   * @method Phaser.Input.InputManager#onMouseUp\r\n   * @private\r\n   * @since 3.18.0\r\n   *\r\n   * @param {MouseEvent} event - The native DOM Mouse event.\r\n   */\n  onMouseUp: function (event) {\n    this.mousePointer.up(event);\n    this.mousePointer.updateMotion();\n    this.updateInputPlugins(CONST.MOUSE_UP, this.mousePointerContainer);\n  },\n\n  /**\r\n   * Processes a mouse wheel event, as passed in by the MouseManager.\r\n   *\r\n   * @method Phaser.Input.InputManager#onMouseWheel\r\n   * @private\r\n   * @since 3.18.0\r\n   *\r\n   * @param {WheelEvent} event - The native DOM Wheel event.\r\n   */\n  onMouseWheel: function (event) {\n    this.mousePointer.wheel(event);\n    this.updateInputPlugins(CONST.MOUSE_WHEEL, this.mousePointerContainer);\n  },\n\n  /**\r\n   * Processes a pointer lock change event, as passed in by the MouseManager.\r\n   *\r\n   * @method Phaser.Input.InputManager#onPointerLockChange\r\n   * @fires Phaser.Input.Events#POINTERLOCK_CHANGE\r\n   * @private\r\n   * @since 3.19.0\r\n   *\r\n   * @param {MouseEvent} event - The native DOM Mouse event.\r\n   */\n  onPointerLockChange: function (event) {\n    var isLocked = this.mouse.locked;\n    this.mousePointer.locked = isLocked;\n    this.events.emit(Events.POINTERLOCK_CHANGE, event, isLocked);\n  },\n\n  /**\r\n   * Checks if the given Game Object should be considered as a candidate for input or not.\r\n   *\r\n   * Checks if the Game Object has an input component that is enabled, that it will render,\r\n   * and finally, if it has a parent, that the parent parent, or any ancestor, is visible or not.\r\n   *\r\n   * @method Phaser.Input.InputManager#inputCandidate\r\n   * @private\r\n   * @since 3.10.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to test.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera which is being tested against.\r\n   *\r\n   * @return {boolean} `true` if the Game Object should be considered for input, otherwise `false`.\r\n   */\n  inputCandidate: function (gameObject, camera) {\n    var input = gameObject.input;\n\n    if (!input || !input.enabled || !input.alwaysEnabled && !gameObject.willRender(camera)) {\n      return false;\n    }\n\n    var visible = true;\n    var parent = gameObject.parentContainer;\n\n    if (parent) {\n      do {\n        if (!parent.willRender(camera)) {\n          visible = false;\n          break;\n        }\n\n        parent = parent.parentContainer;\n      } while (parent);\n    }\n\n    return visible;\n  },\n\n  /**\r\n   * Performs a hit test using the given Pointer and camera, against an array of interactive Game Objects.\r\n   *\r\n   * The Game Objects are culled against the camera, and then the coordinates are translated into the local camera space\r\n   * and used to determine if they fall within the remaining Game Objects hit areas or not.\r\n   *\r\n   * If nothing is matched an empty array is returned.\r\n   *\r\n   * This method is called automatically by InputPlugin.hitTestPointer and doesn't usually need to be invoked directly.\r\n   *\r\n   * @method Phaser.Input.InputManager#hitTest\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer to test against.\r\n   * @param {array} gameObjects - An array of interactive Game Objects to check.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera which is being tested against.\r\n   * @param {array} [output] - An array to store the results in. If not given, a new empty array is created.\r\n   *\r\n   * @return {array} An array of the Game Objects that were hit during this hit test.\r\n   */\n  hitTest: function (pointer, gameObjects, camera, output) {\n    if (output === undefined) {\n      output = this._tempHitTest;\n    }\n\n    var tempPoint = this._tempPoint;\n    var csx = camera.scrollX;\n    var csy = camera.scrollY;\n    output.length = 0;\n    var x = pointer.x;\n    var y = pointer.y;\n\n    if (camera.resolution !== 1) {\n      x += camera._x;\n      y += camera._y;\n    } //  Stores the world point inside of tempPoint\n\n\n    camera.getWorldPoint(x, y, tempPoint);\n    pointer.worldX = tempPoint.x;\n    pointer.worldY = tempPoint.y;\n    var point = {\n      x: 0,\n      y: 0\n    };\n    var matrix = this._tempMatrix;\n    var parentMatrix = this._tempMatrix2;\n\n    for (var i = 0; i < gameObjects.length; i++) {\n      var gameObject = gameObjects[i]; //  Checks if the Game Object can receive input (isn't being ignored by the camera, invisible, etc)\n      //  and also checks all of its parents, if any\n\n      if (!this.inputCandidate(gameObject, camera)) {\n        continue;\n      }\n\n      var px = tempPoint.x + csx * gameObject.scrollFactorX - csx;\n      var py = tempPoint.y + csy * gameObject.scrollFactorY - csy;\n\n      if (gameObject.parentContainer) {\n        gameObject.getWorldTransformMatrix(matrix, parentMatrix);\n        matrix.applyInverse(px, py, point);\n      } else {\n        TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, point);\n      }\n\n      if (this.pointWithinHitArea(gameObject, point.x, point.y)) {\n        output.push(gameObject);\n      }\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Checks if the given x and y coordinate are within the hit area of the Game Object.\r\n   *\r\n   * This method assumes that the coordinate values have already been translated into the space of the Game Object.\r\n   *\r\n   * If the coordinates are within the hit area they are set into the Game Objects Input `localX` and `localY` properties.\r\n   *\r\n   * @method Phaser.Input.InputManager#pointWithinHitArea\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The interactive Game Object to check against.\r\n   * @param {number} x - The translated x coordinate for the hit test.\r\n   * @param {number} y - The translated y coordinate for the hit test.\r\n   *\r\n   * @return {boolean} `true` if the coordinates were inside the Game Objects hit area, otherwise `false`.\r\n   */\n  pointWithinHitArea: function (gameObject, x, y) {\n    //  Normalize the origin\n    x += gameObject.displayOriginX;\n    y += gameObject.displayOriginY;\n    var input = gameObject.input;\n\n    if (input && input.hitAreaCallback(input.hitArea, x, y, gameObject)) {\n      input.localX = x;\n      input.localY = y;\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  /**\r\n   * Checks if the given x and y coordinate are within the hit area of the Interactive Object.\r\n   *\r\n   * This method assumes that the coordinate values have already been translated into the space of the Interactive Object.\r\n   *\r\n   * If the coordinates are within the hit area they are set into the Interactive Objects Input `localX` and `localY` properties.\r\n   *\r\n   * @method Phaser.Input.InputManager#pointWithinInteractiveObject\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.Input.InteractiveObject} object - The Interactive Object to check against.\r\n   * @param {number} x - The translated x coordinate for the hit test.\r\n   * @param {number} y - The translated y coordinate for the hit test.\r\n   *\r\n   * @return {boolean} `true` if the coordinates were inside the Game Objects hit area, otherwise `false`.\r\n   */\n  pointWithinInteractiveObject: function (object, x, y) {\n    if (!object.hitArea) {\n      return false;\n    } //  Normalize the origin\n\n\n    x += object.gameObject.displayOriginX;\n    y += object.gameObject.displayOriginY;\n    object.localX = x;\n    object.localY = y;\n    return object.hitAreaCallback(object.hitArea, x, y, object);\n  },\n\n  /**\r\n   * Transforms the pageX and pageY values of a Pointer into the scaled coordinate space of the Input Manager.\r\n   *\r\n   * @method Phaser.Input.InputManager#transformPointer\r\n   * @since 3.10.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer to transform the values for.\r\n   * @param {number} pageX - The Page X value.\r\n   * @param {number} pageY - The Page Y value.\r\n   * @param {boolean} wasMove - Are we transforming the Pointer from a move event, or an up / down event?\r\n   */\n  transformPointer: function (pointer, pageX, pageY, wasMove) {\n    var p0 = pointer.position;\n    var p1 = pointer.prevPosition; //  Store previous position\n\n    p1.x = p0.x;\n    p1.y = p0.y; //  Translate coordinates\n\n    var x = this.scaleManager.transformX(pageX);\n    var y = this.scaleManager.transformY(pageY);\n    var a = pointer.smoothFactor;\n\n    if (!wasMove || a === 0) {\n      //  Set immediately\n      p0.x = x;\n      p0.y = y;\n    } else {\n      //  Apply smoothing\n      p0.x = x * a + p1.x * (1 - a);\n      p0.y = y * a + p1.y * (1 - a);\n    }\n  },\n\n  /**\r\n   * Destroys the Input Manager and all of its systems.\r\n   *\r\n   * There is no way to recover from doing this.\r\n   *\r\n   * @method Phaser.Input.InputManager#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.events.removeAllListeners();\n    this.game.events.off(GameEvents.PRE_RENDER);\n\n    if (this.keyboard) {\n      this.keyboard.destroy();\n    }\n\n    if (this.mouse) {\n      this.mouse.destroy();\n    }\n\n    if (this.touch) {\n      this.touch.destroy();\n    }\n\n    for (var i = 0; i < this.pointers.length; i++) {\n      this.pointers[i].destroy();\n    }\n\n    this.pointers = [];\n    this._tempHitTest = [];\n\n    this._tempMatrix.destroy();\n\n    this.canvas = null;\n    this.game = null;\n  }\n});\nmodule.exports = InputManager;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/input/InputManager.js"],"names":["Class","require","CONST","EventEmitter","Events","GameEvents","Keyboard","Mouse","Pointer","Touch","TransformMatrix","TransformXY","InputManager","initialize","game","config","scaleManager","canvas","enabled","events","isOver","defaultCursor","keyboard","inputKeyboard","mouse","inputMouse","touch","inputTouch","pointers","pointersTotal","inputActivePointers","i","pointer","smoothFactor","inputSmoothFactor","push","mousePointer","activePointer","globalTopOnly","time","_tempPoint","x","y","_tempHitTest","_tempMatrix","_tempMatrix2","_tempSkip","mousePointerContainer","once","BOOT","boot","scale","emit","MANAGER_BOOT","on","PRE_RENDER","preRender","DESTROY","destroy","setCanvasOver","event","GAME_OVER","setCanvasOut","GAME_OUT","loop","now","delta","scenes","scene","getScenes","MANAGER_UPDATE","length","sys","input","updatePoll","setDefaultCursor","cursor","style","setCursor","interactiveObject","resetCursor","addPointer","quantity","undefined","output","id","updateInputPlugins","type","capture","update","onTouchStart","changed","c","changedTouches","changedTouch","active","touchstart","TOUCH_START","onTouchMove","identifier","touchmove","TOUCH_MOVE","onTouchEnd","touchend","TOUCH_END","onTouchCancel","touchcancel","TOUCH_CANCEL","onMouseDown","down","updateMotion","MOUSE_DOWN","onMouseMove","move","MOUSE_MOVE","onMouseUp","up","MOUSE_UP","onMouseWheel","wheel","MOUSE_WHEEL","onPointerLockChange","isLocked","locked","POINTERLOCK_CHANGE","inputCandidate","gameObject","camera","alwaysEnabled","willRender","visible","parent","parentContainer","hitTest","gameObjects","tempPoint","csx","scrollX","csy","scrollY","resolution","_x","_y","getWorldPoint","worldX","worldY","point","matrix","parentMatrix","px","scrollFactorX","py","scrollFactorY","getWorldTransformMatrix","applyInverse","rotation","scaleX","scaleY","pointWithinHitArea","displayOriginX","displayOriginY","hitAreaCallback","hitArea","localX","localY","pointWithinInteractiveObject","object","transformPointer","pageX","pageY","wasMove","p0","position","p1","prevPosition","transformX","transformY","a","removeAllListeners","off","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar GameEvents = require('../core/events');\r\nvar Keyboard = require('./keyboard/KeyboardManager');\r\nvar Mouse = require('./mouse/MouseManager');\r\nvar Pointer = require('./Pointer');\r\nvar Touch = require('./touch/TouchManager');\r\nvar TransformMatrix = require('../gameobjects/components/TransformMatrix');\r\nvar TransformXY = require('../math/TransformXY');\r\n\r\n/**\r\n * @classdesc\r\n * The Input Manager is responsible for handling the pointer related systems in a single Phaser Game instance.\r\n *\r\n * Based on the Game Config it will create handlers for mouse and touch support.\r\n *\r\n * Keyboard and Gamepad are plugins, handled directly by the InputPlugin class.\r\n *\r\n * It then manages the events, pointer creation and general hit test related operations.\r\n *\r\n * You rarely need to interact with the Input Manager directly, and as such, all of its properties and methods\r\n * should be considered private. Instead, you should use the Input Plugin, which is a Scene level system, responsible\r\n * for dealing with all input events for a Scene.\r\n *\r\n * @class InputManager\r\n * @memberof Phaser.Input\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Game instance that owns the Input Manager.\r\n * @param {object} config - The Input Configuration object, as set in the Game Config.\r\n */\r\nvar InputManager = new Class({\r\n\r\n    initialize:\r\n\r\n    function InputManager (game, config)\r\n    {\r\n        /**\r\n         * The Game instance that owns the Input Manager.\r\n         * A Game only maintains on instance of the Input Manager at any time.\r\n         *\r\n         * @name Phaser.Input.InputManager#game\r\n         * @type {Phaser.Game}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * A reference to the global Game Scale Manager.\r\n         * Used for all bounds checks and pointer scaling.\r\n         *\r\n         * @name Phaser.Input.InputManager#scaleManager\r\n         * @type {Phaser.Scale.ScaleManager}\r\n         * @since 3.16.0\r\n         */\r\n        this.scaleManager;\r\n\r\n        /**\r\n         * The Canvas that is used for all DOM event input listeners.\r\n         *\r\n         * @name Phaser.Input.InputManager#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */\r\n        this.canvas;\r\n\r\n        /**\r\n         * The Game Configuration object, as set during the game boot.\r\n         *\r\n         * @name Phaser.Input.InputManager#config\r\n         * @type {Phaser.Core.Config}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = config;\r\n\r\n        /**\r\n         * If set, the Input Manager will run its update loop every frame.\r\n         *\r\n         * @name Phaser.Input.InputManager#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * The Event Emitter instance that the Input Manager uses to emit events from.\r\n         *\r\n         * @name Phaser.Input.InputManager#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.events = new EventEmitter();\r\n\r\n        /**\r\n         * Are any mouse or touch pointers currently over the game canvas?\r\n         * This is updated automatically by the canvas over and out handlers.\r\n         *\r\n         * @name Phaser.Input.InputManager#isOver\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.16.0\r\n         */\r\n        this.isOver = true;\r\n\r\n        /**\r\n         * The default CSS cursor to be used when interacting with your game.\r\n         *\r\n         * See the `setDefaultCursor` method for more details.\r\n         *\r\n         * @name Phaser.Input.InputManager#defaultCursor\r\n         * @type {string}\r\n         * @since 3.10.0\r\n         */\r\n        this.defaultCursor = '';\r\n\r\n        /**\r\n         * A reference to the Keyboard Manager class, if enabled via the `input.keyboard` Game Config property.\r\n         *\r\n         * @name Phaser.Input.InputManager#keyboard\r\n         * @type {?Phaser.Input.Keyboard.KeyboardManager}\r\n         * @since 3.16.0\r\n         */\r\n        this.keyboard = (config.inputKeyboard) ? new Keyboard(this) : null;\r\n\r\n        /**\r\n         * A reference to the Mouse Manager class, if enabled via the `input.mouse` Game Config property.\r\n         *\r\n         * @name Phaser.Input.InputManager#mouse\r\n         * @type {?Phaser.Input.Mouse.MouseManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.mouse = (config.inputMouse) ? new Mouse(this) : null;\r\n\r\n        /**\r\n         * A reference to the Touch Manager class, if enabled via the `input.touch` Game Config property.\r\n         *\r\n         * @name Phaser.Input.InputManager#touch\r\n         * @type {Phaser.Input.Touch.TouchManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.touch = (config.inputTouch) ? new Touch(this) : null;\r\n\r\n        /**\r\n         * An array of Pointers that have been added to the game.\r\n         * The first entry is reserved for the Mouse Pointer, the rest are Touch Pointers.\r\n         *\r\n         * By default there is 1 touch pointer enabled. If you need more use the `addPointer` method to start them,\r\n         * or set the `input.activePointers` property in the Game Config.\r\n         *\r\n         * @name Phaser.Input.InputManager#pointers\r\n         * @type {Phaser.Input.Pointer[]}\r\n         * @since 3.10.0\r\n         */\r\n        this.pointers = [];\r\n\r\n        /**\r\n         * The number of touch objects activated and being processed each update.\r\n         *\r\n         * You can change this by either calling `addPointer` at run-time, or by\r\n         * setting the `input.activePointers` property in the Game Config.\r\n         *\r\n         * @name Phaser.Input.InputManager#pointersTotal\r\n         * @type {integer}\r\n         * @readonly\r\n         * @since 3.10.0\r\n         */\r\n        this.pointersTotal = config.inputActivePointers;\r\n\r\n        if (config.inputTouch && this.pointersTotal === 1)\r\n        {\r\n            this.pointersTotal = 2;\r\n        }\r\n\r\n        for (var i = 0; i <= this.pointersTotal; i++)\r\n        {\r\n            var pointer = new Pointer(this, i);\r\n\r\n            pointer.smoothFactor = config.inputSmoothFactor;\r\n\r\n            this.pointers.push(pointer);\r\n        }\r\n\r\n        /**\r\n         * The mouse has its own unique Pointer object, which you can reference directly if making a _desktop specific game_.\r\n         * If you are supporting both desktop and touch devices then do not use this property, instead use `activePointer`\r\n         * which will always map to the most recently interacted pointer.\r\n         *\r\n         * @name Phaser.Input.InputManager#mousePointer\r\n         * @type {?Phaser.Input.Pointer}\r\n         * @since 3.10.0\r\n         */\r\n        this.mousePointer = (config.inputMouse) ? this.pointers[0] : null;\r\n\r\n        /**\r\n         * The most recently active Pointer object.\r\n         *\r\n         * If you've only 1 Pointer in your game then this will accurately be either the first finger touched, or the mouse.\r\n         *\r\n         * If your game doesn't need to support multi-touch then you can safely use this property in all of your game\r\n         * code and it will adapt to be either the mouse or the touch, based on device.\r\n         *\r\n         * @name Phaser.Input.InputManager#activePointer\r\n         * @type {Phaser.Input.Pointer}\r\n         * @since 3.0.0\r\n         */\r\n        this.activePointer = this.pointers[0];\r\n\r\n        /**\r\n         * If the top-most Scene in the Scene List receives an input it will stop input from\r\n         * propagating any lower down the scene list, i.e. if you have a UI Scene at the top\r\n         * and click something on it, that click will not then be passed down to any other\r\n         * Scene below. Disable this to have input events passed through all Scenes, all the time.\r\n         *\r\n         * @name Phaser.Input.InputManager#globalTopOnly\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.globalTopOnly = true;\r\n\r\n        /**\r\n         * The time this Input Manager was last updated.\r\n         * This value is populated by the Game Step each frame.\r\n         *\r\n         * @name Phaser.Input.InputManager#time\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.16.2\r\n         */\r\n        this.time = 0;\r\n\r\n        /**\r\n         * A re-cycled point-like object to store hit test values in.\r\n         *\r\n         * @name Phaser.Input.InputManager#_tempPoint\r\n         * @type {{x:number, y:number}}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tempPoint = { x: 0, y: 0 };\r\n\r\n        /**\r\n         * A re-cycled array to store hit results in.\r\n         *\r\n         * @name Phaser.Input.InputManager#_tempHitTest\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._tempHitTest = [];\r\n\r\n        /**\r\n         * A re-cycled matrix used in hit test calculations.\r\n         *\r\n         * @name Phaser.Input.InputManager#_tempMatrix\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this._tempMatrix = new TransformMatrix();\r\n\r\n        /**\r\n         * A re-cycled matrix used in hit test calculations.\r\n         *\r\n         * @name Phaser.Input.InputManager#_tempMatrix2\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix2 = new TransformMatrix();\r\n\r\n        /**\r\n         * An internal private var that records Scenes aborting event processing.\r\n         *\r\n         * @name Phaser.Input.InputManager#_tempSkip\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.18.0\r\n         */\r\n        this._tempSkip = false;\r\n\r\n        /**\r\n         * An internal private array that avoids needing to create a new array on every DOM mouse event.\r\n         *\r\n         * @name Phaser.Input.InputManager#mousePointerContainer\r\n         * @type {Phaser.Input.Pointer[]}\r\n         * @private\r\n         * @since 3.18.0\r\n         */\r\n        this.mousePointerContainer = [ this.mousePointer ];\r\n\r\n        game.events.once(GameEvents.BOOT, this.boot, this);\r\n    },\r\n\r\n    /**\r\n     * The Boot handler is called by Phaser.Game when it first starts up.\r\n     * The renderer is available by now.\r\n     *\r\n     * @method Phaser.Input.InputManager#boot\r\n     * @protected\r\n     * @fires Phaser.Input.Events#MANAGER_BOOT\r\n     * @since 3.0.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.canvas = this.game.canvas;\r\n\r\n        this.scaleManager = this.game.scale;\r\n\r\n        this.events.emit(Events.MANAGER_BOOT);\r\n\r\n        this.game.events.on(GameEvents.PRE_RENDER, this.preRender, this);\r\n\r\n        this.game.events.once(GameEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * Internal canvas state change, called automatically by the Mouse Manager.\r\n     *\r\n     * @method Phaser.Input.InputManager#setCanvasOver\r\n     * @fires Phaser.Input.Events#GAME_OVER\r\n     * @private\r\n     * @since 3.16.0\r\n     *\r\n     * @param {(MouseEvent|TouchEvent)} event - The DOM Event.\r\n     */\r\n    setCanvasOver: function (event)\r\n    {\r\n        this.isOver = true;\r\n\r\n        this.events.emit(Events.GAME_OVER, event);\r\n    },\r\n\r\n    /**\r\n     * Internal canvas state change, called automatically by the Mouse Manager.\r\n     *\r\n     * @method Phaser.Input.InputManager#setCanvasOut\r\n     * @fires Phaser.Input.Events#GAME_OUT\r\n     * @private\r\n     * @since 3.16.0\r\n     *\r\n     * @param {(MouseEvent|TouchEvent)} event - The DOM Event.\r\n     */\r\n    setCanvasOut: function (event)\r\n    {\r\n        this.isOver = false;\r\n\r\n        this.events.emit(Events.GAME_OUT, event);\r\n    },\r\n\r\n    /**\r\n     * Internal update, called automatically by the Game Step right at the start.\r\n     *\r\n     * @method Phaser.Input.InputManager#preRender\r\n     * @private\r\n     * @since 3.18.0\r\n     */\r\n    preRender: function ()\r\n    {\r\n        var time = this.game.loop.now;\r\n        var delta = this.game.loop.delta;\r\n        var scenes = this.game.scene.getScenes(true, true);\r\n\r\n        this.time = time;\r\n\r\n        this.events.emit(Events.MANAGER_UPDATE);\r\n\r\n        for (var i = 0; i < scenes.length; i++)\r\n        {\r\n            var scene = scenes[i];\r\n\r\n            if (scene.sys.input && scene.sys.input.updatePoll(time, delta) && this.globalTopOnly)\r\n            {\r\n                //  If the Scene returns true, it means it captured some input that no other Scene should get, so we bail out\r\n                return;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Tells the Input system to set a custom cursor.\r\n     * \r\n     * This cursor will be the default cursor used when interacting with the game canvas.\r\n     *\r\n     * If an Interactive Object also sets a custom cursor, this is the cursor that is reset after its use.\r\n     *\r\n     * Any valid CSS cursor value is allowed, including paths to image files, i.e.:\r\n     *\r\n     * ```javascript\r\n     * this.input.setDefaultCursor('url(assets/cursors/sword.cur), pointer');\r\n     * ```\r\n     * \r\n     * Please read about the differences between browsers when it comes to the file formats and sizes they support:\r\n     *\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_User_Interface/Using_URL_values_for_the_cursor_property\r\n     *\r\n     * It's up to you to pick a suitable cursor format that works across the range of browsers you need to support.\r\n     *\r\n     * @method Phaser.Input.InputManager#setDefaultCursor\r\n     * @since 3.10.0\r\n     * \r\n     * @param {string} cursor - The CSS to be used when setting the default cursor.\r\n     */\r\n    setDefaultCursor: function (cursor)\r\n    {\r\n        this.defaultCursor = cursor;\r\n\r\n        if (this.canvas.style.cursor !== cursor)\r\n        {\r\n            this.canvas.style.cursor = cursor;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by the InputPlugin when processing over and out events.\r\n     * \r\n     * Tells the Input Manager to set a custom cursor during its postUpdate step.\r\n     *\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\r\n     *\r\n     * @method Phaser.Input.InputManager#setCursor\r\n     * @private\r\n     * @since 3.10.0\r\n     * \r\n     * @param {Phaser.Types.Input.InteractiveObject} interactiveObject - The Interactive Object that called this method.\r\n     */\r\n    setCursor: function (interactiveObject)\r\n    {\r\n        if (interactiveObject.cursor)\r\n        {\r\n            this.canvas.style.cursor = interactiveObject.cursor;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by the InputPlugin when processing over and out events.\r\n     * \r\n     * Tells the Input Manager to clear the hand cursor, if set, during its postUpdate step.\r\n     *\r\n     * @method Phaser.Input.InputManager#resetCursor\r\n     * @private\r\n     * @since 3.10.0\r\n     * \r\n     * @param {Phaser.Types.Input.InteractiveObject} interactiveObject - The Interactive Object that called this method.\r\n     */\r\n    resetCursor: function (interactiveObject)\r\n    {\r\n        if (interactiveObject.cursor && this.canvas)\r\n        {\r\n            this.canvas.style.cursor = this.defaultCursor;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds new Pointer objects to the Input Manager.\r\n     *\r\n     * By default Phaser creates 2 pointer objects: `mousePointer` and `pointer1`.\r\n     *\r\n     * You can create more either by calling this method, or by setting the `input.activePointers` property\r\n     * in the Game Config, up to a maximum of 10 pointers.\r\n     *\r\n     * The first 10 pointers are available via the `InputPlugin.pointerX` properties, once they have been added\r\n     * via this method.\r\n     *\r\n     * @method Phaser.Input.InputManager#addPointer\r\n     * @since 3.10.0\r\n     *\r\n     * @param {integer} [quantity=1] The number of new Pointers to create. A maximum of 10 is allowed in total.\r\n     *\r\n     * @return {Phaser.Input.Pointer[]} An array containing all of the new Pointer objects that were created.\r\n     */\r\n    addPointer: function (quantity)\r\n    {\r\n        if (quantity === undefined) { quantity = 1; }\r\n\r\n        var output = [];\r\n\r\n        if (this.pointersTotal + quantity > 10)\r\n        {\r\n            quantity = 10 - this.pointersTotal;\r\n        }\r\n\r\n        for (var i = 0; i < quantity; i++)\r\n        {\r\n            var id = this.pointers.length;\r\n\r\n            var pointer = new Pointer(this, id);\r\n\r\n            pointer.smoothFactor = this.config.inputSmoothFactor;\r\n\r\n            this.pointers.push(pointer);\r\n\r\n            this.pointersTotal++;\r\n\r\n            output.push(pointer);\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Internal method that gets a list of all the active Input Plugins in the game\r\n     * and updates each of them in turn, in reverse order (top to bottom), to allow\r\n     * for DOM top-level event handling simulation.\r\n     *\r\n     * @method Phaser.Input.InputManager#updateInputPlugins\r\n     * @since 3.16.0\r\n     *\r\n     * @param {integer} type - The type of event to process.\r\n     * @param {Phaser.Input.Pointer[]} pointers - An array of Pointers on which the event occurred.\r\n     */\r\n    updateInputPlugins: function (type, pointers)\r\n    {\r\n        var scenes = this.game.scene.getScenes(true, true);\r\n\r\n        this._tempSkip = false;\r\n\r\n        for (var i = 0; i < scenes.length; i++)\r\n        {\r\n            var scene = scenes[i];\r\n\r\n            if (scene.sys.input)\r\n            {\r\n                var capture = scene.sys.input.update(type, pointers);\r\n\r\n                if ((capture && this.globalTopOnly) || this._tempSkip)\r\n                {\r\n                    //  If the Scene returns true, or called stopPropagation, it means it captured some input that no other Scene should get, so we bail out\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    //  event.targetTouches = list of all touches on the TARGET ELEMENT (i.e. game dom element)\r\n    //  event.touches = list of all touches on the ENTIRE DOCUMENT, not just the target element\r\n    //  event.changedTouches = the touches that CHANGED in this event, not the total number of them\r\n\r\n    /**\r\n     * Processes a touch start event, as passed in by the TouchManager.\r\n     *\r\n     * @method Phaser.Input.InputManager#onTouchStart\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {TouchEvent} event - The native DOM Touch event.\r\n     */\r\n    onTouchStart: function (event)\r\n    {\r\n        var pointers = this.pointers;\r\n        var changed = [];\r\n\r\n        for (var c = 0; c < event.changedTouches.length; c++)\r\n        {\r\n            var changedTouch = event.changedTouches[c];\r\n\r\n            for (var i = 1; i < this.pointersTotal; i++)\r\n            {\r\n                var pointer = pointers[i];\r\n\r\n                if (!pointer.active)\r\n                {\r\n                    pointer.touchstart(changedTouch, event);\r\n\r\n                    this.activePointer = pointer;\r\n\r\n                    changed.push(pointer);\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.updateInputPlugins(CONST.TOUCH_START, changed);\r\n    },\r\n\r\n    /**\r\n     * Processes a touch move event, as passed in by the TouchManager.\r\n     *\r\n     * @method Phaser.Input.InputManager#onTouchMove\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {TouchEvent} event - The native DOM Touch event.\r\n     */\r\n    onTouchMove: function (event)\r\n    {\r\n        var pointers = this.pointers;\r\n        var changed = [];\r\n\r\n        for (var c = 0; c < event.changedTouches.length; c++)\r\n        {\r\n            var changedTouch = event.changedTouches[c];\r\n\r\n            for (var i = 1; i < this.pointersTotal; i++)\r\n            {\r\n                var pointer = pointers[i];\r\n\r\n                if (pointer.active && pointer.identifier === changedTouch.identifier)\r\n                {\r\n                    pointer.touchmove(changedTouch, event);\r\n\r\n                    this.activePointer = pointer;\r\n\r\n                    changed.push(pointer);\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.updateInputPlugins(CONST.TOUCH_MOVE, changed);\r\n    },\r\n\r\n    //  For touch end its a list of the touch points that have been removed from the surface\r\n    //  https://developer.mozilla.org/en-US/docs/DOM/TouchList\r\n    //  event.changedTouches = the touches that CHANGED in this event, not the total number of them\r\n\r\n    /**\r\n     * Processes a touch end event, as passed in by the TouchManager.\r\n     *\r\n     * @method Phaser.Input.InputManager#onTouchEnd\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {TouchEvent} event - The native DOM Touch event.\r\n     */\r\n    onTouchEnd: function (event)\r\n    {\r\n        var pointers = this.pointers;\r\n        var changed = [];\r\n\r\n        for (var c = 0; c < event.changedTouches.length; c++)\r\n        {\r\n            var changedTouch = event.changedTouches[c];\r\n\r\n            for (var i = 1; i < this.pointersTotal; i++)\r\n            {\r\n                var pointer = pointers[i];\r\n\r\n                if (pointer.active && pointer.identifier === changedTouch.identifier)\r\n                {\r\n                    pointer.touchend(changedTouch, event);\r\n\r\n                    changed.push(pointer);\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.updateInputPlugins(CONST.TOUCH_END, changed);\r\n    },\r\n\r\n    /**\r\n     * Processes a touch cancel event, as passed in by the TouchManager.\r\n     *\r\n     * @method Phaser.Input.InputManager#onTouchCancel\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {TouchEvent} event - The native DOM Touch event.\r\n     */\r\n    onTouchCancel: function (event)\r\n    {\r\n        var pointers = this.pointers;\r\n        var changed = [];\r\n\r\n        for (var c = 0; c < event.changedTouches.length; c++)\r\n        {\r\n            var changedTouch = event.changedTouches[c];\r\n\r\n            for (var i = 1; i < this.pointersTotal; i++)\r\n            {\r\n                var pointer = pointers[i];\r\n\r\n                if (pointer.active && pointer.identifier === changedTouch.identifier)\r\n                {\r\n                    pointer.touchcancel(changedTouch, event);\r\n\r\n                    changed.push(pointer);\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.updateInputPlugins(CONST.TOUCH_CANCEL, changed);\r\n    },\r\n\r\n    /**\r\n     * Processes a mouse down event, as passed in by the MouseManager.\r\n     *\r\n     * @method Phaser.Input.InputManager#onMouseDown\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {MouseEvent} event - The native DOM Mouse event.\r\n     */\r\n    onMouseDown: function (event)\r\n    {\r\n        this.mousePointer.down(event);\r\n\r\n        this.mousePointer.updateMotion();\r\n\r\n        this.updateInputPlugins(CONST.MOUSE_DOWN, this.mousePointerContainer);\r\n    },\r\n\r\n    /**\r\n     * Processes a mouse move event, as passed in by the MouseManager.\r\n     *\r\n     * @method Phaser.Input.InputManager#onMouseMove\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {MouseEvent} event - The native DOM Mouse event.\r\n     */\r\n    onMouseMove: function (event)\r\n    {\r\n        this.mousePointer.move(event);\r\n\r\n        this.mousePointer.updateMotion();\r\n\r\n        this.updateInputPlugins(CONST.MOUSE_MOVE, this.mousePointerContainer);\r\n    },\r\n\r\n    /**\r\n     * Processes a mouse up event, as passed in by the MouseManager.\r\n     *\r\n     * @method Phaser.Input.InputManager#onMouseUp\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {MouseEvent} event - The native DOM Mouse event.\r\n     */\r\n    onMouseUp: function (event)\r\n    {\r\n        this.mousePointer.up(event);\r\n\r\n        this.mousePointer.updateMotion();\r\n\r\n        this.updateInputPlugins(CONST.MOUSE_UP, this.mousePointerContainer);\r\n    },\r\n\r\n    /**\r\n     * Processes a mouse wheel event, as passed in by the MouseManager.\r\n     *\r\n     * @method Phaser.Input.InputManager#onMouseWheel\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {WheelEvent} event - The native DOM Wheel event.\r\n     */\r\n    onMouseWheel: function (event)\r\n    {\r\n        this.mousePointer.wheel(event);\r\n\r\n        this.updateInputPlugins(CONST.MOUSE_WHEEL, this.mousePointerContainer);\r\n    },\r\n\r\n    /**\r\n     * Processes a pointer lock change event, as passed in by the MouseManager.\r\n     *\r\n     * @method Phaser.Input.InputManager#onPointerLockChange\r\n     * @fires Phaser.Input.Events#POINTERLOCK_CHANGE\r\n     * @private\r\n     * @since 3.19.0\r\n     *\r\n     * @param {MouseEvent} event - The native DOM Mouse event.\r\n     */\r\n    onPointerLockChange: function (event)\r\n    {\r\n        var isLocked = this.mouse.locked;\r\n\r\n        this.mousePointer.locked = isLocked;\r\n\r\n        this.events.emit(Events.POINTERLOCK_CHANGE, event, isLocked);\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Game Object should be considered as a candidate for input or not.\r\n     *\r\n     * Checks if the Game Object has an input component that is enabled, that it will render,\r\n     * and finally, if it has a parent, that the parent parent, or any ancestor, is visible or not.\r\n     *\r\n     * @method Phaser.Input.InputManager#inputCandidate\r\n     * @private\r\n     * @since 3.10.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to test.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera which is being tested against.\r\n     *\r\n     * @return {boolean} `true` if the Game Object should be considered for input, otherwise `false`.\r\n     */\r\n    inputCandidate: function (gameObject, camera)\r\n    {\r\n        var input = gameObject.input;\r\n\r\n        if (!input || !input.enabled || (!input.alwaysEnabled && !gameObject.willRender(camera)))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var visible = true;\r\n        var parent = gameObject.parentContainer;\r\n\r\n        if (parent)\r\n        {\r\n            do\r\n            {\r\n                if (!parent.willRender(camera))\r\n                {\r\n                    visible = false;\r\n                    break;\r\n                }\r\n\r\n                parent = parent.parentContainer;\r\n\r\n            } while (parent);\r\n        }\r\n\r\n        return visible;\r\n    },\r\n\r\n    /**\r\n     * Performs a hit test using the given Pointer and camera, against an array of interactive Game Objects.\r\n     *\r\n     * The Game Objects are culled against the camera, and then the coordinates are translated into the local camera space\r\n     * and used to determine if they fall within the remaining Game Objects hit areas or not.\r\n     *\r\n     * If nothing is matched an empty array is returned.\r\n     *\r\n     * This method is called automatically by InputPlugin.hitTestPointer and doesn't usually need to be invoked directly.\r\n     *\r\n     * @method Phaser.Input.InputManager#hitTest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to test against.\r\n     * @param {array} gameObjects - An array of interactive Game Objects to check.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera which is being tested against.\r\n     * @param {array} [output] - An array to store the results in. If not given, a new empty array is created.\r\n     *\r\n     * @return {array} An array of the Game Objects that were hit during this hit test.\r\n     */\r\n    hitTest: function (pointer, gameObjects, camera, output)\r\n    {\r\n        if (output === undefined) { output = this._tempHitTest; }\r\n\r\n        var tempPoint = this._tempPoint;\r\n\r\n        var csx = camera.scrollX;\r\n        var csy = camera.scrollY;\r\n\r\n        output.length = 0;\r\n\r\n        var x = pointer.x;\r\n        var y = pointer.y;\r\n\r\n        if (camera.resolution !== 1)\r\n        {\r\n            x += camera._x;\r\n            y += camera._y;\r\n        }\r\n\r\n        //  Stores the world point inside of tempPoint\r\n        camera.getWorldPoint(x, y, tempPoint);\r\n\r\n        pointer.worldX = tempPoint.x;\r\n        pointer.worldY = tempPoint.y;\r\n\r\n        var point = { x: 0, y: 0 };\r\n\r\n        var matrix = this._tempMatrix;\r\n        var parentMatrix = this._tempMatrix2;\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            //  Checks if the Game Object can receive input (isn't being ignored by the camera, invisible, etc)\r\n            //  and also checks all of its parents, if any\r\n            if (!this.inputCandidate(gameObject, camera))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var px = tempPoint.x + (csx * gameObject.scrollFactorX) - csx;\r\n            var py = tempPoint.y + (csy * gameObject.scrollFactorY) - csy;\r\n\r\n            if (gameObject.parentContainer)\r\n            {\r\n                gameObject.getWorldTransformMatrix(matrix, parentMatrix);\r\n\r\n                matrix.applyInverse(px, py, point);\r\n            }\r\n            else\r\n            {\r\n                TransformXY(px, py, gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX, gameObject.scaleY, point);\r\n            }\r\n    \r\n            if (this.pointWithinHitArea(gameObject, point.x, point.y))\r\n            {\r\n                output.push(gameObject);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Checks if the given x and y coordinate are within the hit area of the Game Object.\r\n     *\r\n     * This method assumes that the coordinate values have already been translated into the space of the Game Object.\r\n     *\r\n     * If the coordinates are within the hit area they are set into the Game Objects Input `localX` and `localY` properties.\r\n     *\r\n     * @method Phaser.Input.InputManager#pointWithinHitArea\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The interactive Game Object to check against.\r\n     * @param {number} x - The translated x coordinate for the hit test.\r\n     * @param {number} y - The translated y coordinate for the hit test.\r\n     *\r\n     * @return {boolean} `true` if the coordinates were inside the Game Objects hit area, otherwise `false`.\r\n     */\r\n    pointWithinHitArea: function (gameObject, x, y)\r\n    {\r\n        //  Normalize the origin\r\n        x += gameObject.displayOriginX;\r\n        y += gameObject.displayOriginY;\r\n\r\n        var input = gameObject.input;\r\n\r\n        if (input && input.hitAreaCallback(input.hitArea, x, y, gameObject))\r\n        {\r\n            input.localX = x;\r\n            input.localY = y;\r\n\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks if the given x and y coordinate are within the hit area of the Interactive Object.\r\n     *\r\n     * This method assumes that the coordinate values have already been translated into the space of the Interactive Object.\r\n     *\r\n     * If the coordinates are within the hit area they are set into the Interactive Objects Input `localX` and `localY` properties.\r\n     *\r\n     * @method Phaser.Input.InputManager#pointWithinInteractiveObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Input.InteractiveObject} object - The Interactive Object to check against.\r\n     * @param {number} x - The translated x coordinate for the hit test.\r\n     * @param {number} y - The translated y coordinate for the hit test.\r\n     *\r\n     * @return {boolean} `true` if the coordinates were inside the Game Objects hit area, otherwise `false`.\r\n     */\r\n    pointWithinInteractiveObject: function (object, x, y)\r\n    {\r\n        if (!object.hitArea)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //  Normalize the origin\r\n        x += object.gameObject.displayOriginX;\r\n        y += object.gameObject.displayOriginY;\r\n\r\n        object.localX = x;\r\n        object.localY = y;\r\n\r\n        return object.hitAreaCallback(object.hitArea, x, y, object);\r\n    },\r\n\r\n    /**\r\n     * Transforms the pageX and pageY values of a Pointer into the scaled coordinate space of the Input Manager.\r\n     *\r\n     * @method Phaser.Input.InputManager#transformPointer\r\n     * @since 3.10.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to transform the values for.\r\n     * @param {number} pageX - The Page X value.\r\n     * @param {number} pageY - The Page Y value.\r\n     * @param {boolean} wasMove - Are we transforming the Pointer from a move event, or an up / down event?\r\n     */\r\n    transformPointer: function (pointer, pageX, pageY, wasMove)\r\n    {\r\n        var p0 = pointer.position;\r\n        var p1 = pointer.prevPosition;\r\n\r\n        //  Store previous position\r\n        p1.x = p0.x;\r\n        p1.y = p0.y;\r\n\r\n        //  Translate coordinates\r\n        var x = this.scaleManager.transformX(pageX);\r\n        var y = this.scaleManager.transformY(pageY);\r\n\r\n        var a = pointer.smoothFactor;\r\n\r\n        if (!wasMove || a === 0)\r\n        {\r\n            //  Set immediately\r\n            p0.x = x;\r\n            p0.y = y;\r\n        }\r\n        else\r\n        {\r\n            //  Apply smoothing\r\n            p0.x = x * a + p1.x * (1 - a);\r\n            p0.y = y * a + p1.y * (1 - a);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys the Input Manager and all of its systems.\r\n     *\r\n     * There is no way to recover from doing this.\r\n     *\r\n     * @method Phaser.Input.InputManager#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.events.removeAllListeners();\r\n\r\n        this.game.events.off(GameEvents.PRE_RENDER);\r\n\r\n        if (this.keyboard)\r\n        {\r\n            this.keyboard.destroy();\r\n        }\r\n\r\n        if (this.mouse)\r\n        {\r\n            this.mouse.destroy();\r\n        }\r\n\r\n        if (this.touch)\r\n        {\r\n            this.touch.destroy();\r\n        }\r\n\r\n        for (var i = 0; i < this.pointers.length; i++)\r\n        {\r\n            this.pointers[i].destroy();\r\n        }\r\n\r\n        this.pointers = [];\r\n        this._tempHitTest = [];\r\n        this._tempMatrix.destroy();\r\n        this.canvas = null;\r\n        this.game = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = InputManager;\r\n"]},"metadata":{},"sourceType":"script"}