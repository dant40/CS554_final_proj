{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar GameEvents = require('../core/events');\n\nvar EventEmitter = require('eventemitter3');\n\nvar FileTypesManager = require('../loader/FileTypesManager');\n\nvar GameObjectCreator = require('../gameobjects/GameObjectCreator');\n\nvar GameObjectFactory = require('../gameobjects/GameObjectFactory');\n\nvar GetFastValue = require('../utils/object/GetFastValue');\n\nvar PluginCache = require('./PluginCache');\n\nvar Remove = require('../utils/array/Remove');\n/**\r\n * @classdesc\r\n * The PluginManager is responsible for installing and adding plugins to Phaser.\r\n *\r\n * It is a global system and therefore belongs to the Game instance, not a specific Scene.\r\n *\r\n * It works in conjunction with the PluginCache. Core internal plugins automatically register themselves \r\n * with the Cache, but it's the Plugin Manager that is responsible for injecting them into the Scenes.\r\n *\r\n * There are two types of plugin:\r\n *\r\n * 1. A Global Plugin\r\n * 2. A Scene Plugin\r\n *\r\n * A Global Plugin is a plugin that lives within the Plugin Manager rather than a Scene. You can get\r\n * access to it by calling `PluginManager.get` and providing a key. Any Scene that requests a plugin in\r\n * this way will all get access to the same plugin instance, allowing you to use a single plugin across\r\n * multiple Scenes.\r\n *\r\n * A Scene Plugin is a plugin dedicated to running within a Scene. These are different to Global Plugins\r\n * in that their instances do not live within the Plugin Manager, but within the Scene Systems class instead.\r\n * And that every Scene created is given its own unique instance of a Scene Plugin. Examples of core Scene\r\n * Plugins include the Input Plugin, the Tween Plugin and the physics Plugins.\r\n *\r\n * You can add a plugin to Phaser in three different ways:\r\n *\r\n * 1. Preload it\r\n * 2. Include it in your source code and install it via the Game Config\r\n * 3. Include it in your source code and install it within a Scene\r\n *\r\n * For examples of all of these approaches please see the Phaser 3 Examples Repo `plugins` folder.\r\n *\r\n * For information on creating your own plugin please see the Phaser 3 Plugin Template.\r\n *\r\n * @class PluginManager\r\n * @memberof Phaser.Plugins\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The game instance that owns this Plugin Manager.\r\n */\n\n\nvar PluginManager = new Class({\n  Extends: EventEmitter,\n  initialize: function PluginManager(game) {\n    EventEmitter.call(this);\n    /**\r\n     * The game instance that owns this Plugin Manager.\r\n     *\r\n     * @name Phaser.Plugins.PluginManager#game\r\n     * @type {Phaser.Game}\r\n     * @since 3.0.0\r\n     */\n\n    this.game = game;\n    /**\r\n     * The global plugins currently running and managed by this Plugin Manager.\r\n     * A plugin must have been started at least once in order to appear in this list.\r\n     *\r\n     * @name Phaser.Plugins.PluginManager#plugins\r\n     * @type {Phaser.Types.Plugins.GlobalPlugin[]}\r\n     * @since 3.8.0\r\n     */\n\n    this.plugins = [];\n    /**\r\n     * A list of plugin keys that should be installed into Scenes as well as the Core Plugins.\r\n     *\r\n     * @name Phaser.Plugins.PluginManager#scenePlugins\r\n     * @type {string[]}\r\n     * @since 3.8.0\r\n     */\n\n    this.scenePlugins = [];\n    /**\r\n     * A temporary list of plugins to install when the game has booted.\r\n     *\r\n     * @name Phaser.Plugins.PluginManager#_pendingGlobal\r\n     * @private\r\n     * @type {array}\r\n     * @since 3.8.0\r\n     */\n\n    this._pendingGlobal = [];\n    /**\r\n     * A temporary list of scene plugins to install when the game has booted.\r\n     *\r\n     * @name Phaser.Plugins.PluginManager#_pendingScene\r\n     * @private\r\n     * @type {array}\r\n     * @since 3.8.0\r\n     */\n\n    this._pendingScene = [];\n\n    if (game.isBooted) {\n      this.boot();\n    } else {\n      game.events.once(GameEvents.BOOT, this.boot, this);\n    }\n  },\n\n  /**\r\n   * Run once the game has booted and installs all of the plugins configured in the Game Config.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#boot\r\n   * @protected\r\n   * @since 3.0.0\r\n   */\n  boot: function () {\n    var i;\n    var entry;\n    var key;\n    var plugin;\n    var start;\n    var mapping;\n    var data;\n    var config = this.game.config; //  Any plugins to install?\n\n    var list = config.installGlobalPlugins; //  Any plugins added outside of the game config, but before the game booted?\n\n    list = list.concat(this._pendingGlobal);\n\n    for (i = 0; i < list.length; i++) {\n      entry = list[i]; // { key: 'TestPlugin', plugin: TestPlugin, start: true, mapping: 'test', data: { msg: 'The plugin is alive' } }\n\n      key = GetFastValue(entry, 'key', null);\n      plugin = GetFastValue(entry, 'plugin', null);\n      start = GetFastValue(entry, 'start', false);\n      mapping = GetFastValue(entry, 'mapping', null);\n      data = GetFastValue(entry, 'data', null);\n\n      if (key) {\n        if (plugin) {\n          this.install(key, plugin, start, mapping, data);\n        } else {\n          console.warn('Missing `plugin` for key: ' + key);\n        }\n      }\n    } //  Any scene plugins to install?\n\n\n    list = config.installScenePlugins; //  Any plugins added outside of the game config, but before the game booted?\n\n    list = list.concat(this._pendingScene);\n\n    for (i = 0; i < list.length; i++) {\n      entry = list[i]; // { key: 'moveSpritePlugin', plugin: MoveSpritePlugin, , mapping: 'move' }\n\n      key = GetFastValue(entry, 'key', null);\n      plugin = GetFastValue(entry, 'plugin', null);\n      mapping = GetFastValue(entry, 'mapping', null);\n\n      if (key) {\n        if (plugin) {\n          this.installScenePlugin(key, plugin, mapping);\n        } else {\n          console.warn('Missing `plugin` for key: ' + key);\n        }\n      }\n    }\n\n    this._pendingGlobal = [];\n    this._pendingScene = [];\n    this.game.events.once(GameEvents.DESTROY, this.destroy, this);\n  },\n\n  /**\r\n   * Called by the Scene Systems class. Tells the plugin manager to install all Scene plugins into it.\r\n   *\r\n   * First it will install global references, i.e. references from the Game systems into the Scene Systems (and Scene if mapped.)\r\n   * Then it will install Core Scene Plugins followed by Scene Plugins registered with the PluginManager.\r\n   * Finally it will install any references to Global Plugins that have a Scene mapping property into the Scene itself.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#addToScene\r\n   * @protected\r\n   * @since 3.8.0\r\n   *\r\n   * @param {Phaser.Scenes.Systems} sys - The Scene Systems class to install all the plugins in to.\r\n   * @param {array} globalPlugins - An array of global plugins to install.\r\n   * @param {array} scenePlugins - An array of scene plugins to install.\r\n   */\n  addToScene: function (sys, globalPlugins, scenePlugins) {\n    var i;\n    var pluginKey;\n    var pluginList;\n    var game = this.game;\n    var scene = sys.scene;\n    var map = sys.settings.map;\n    var isBooted = sys.settings.isBooted; //  Reference the GlobalPlugins from Game into Scene.Systems\n\n    for (i = 0; i < globalPlugins.length; i++) {\n      pluginKey = globalPlugins[i];\n\n      if (game[pluginKey]) {\n        sys[pluginKey] = game[pluginKey]; //  Scene level injection\n\n        if (map.hasOwnProperty(pluginKey)) {\n          scene[map[pluginKey]] = sys[pluginKey];\n        }\n      } else if (pluginKey === 'game' && map.hasOwnProperty(pluginKey)) {\n        scene[map[pluginKey]] = game;\n      }\n    }\n\n    for (var s = 0; s < scenePlugins.length; s++) {\n      pluginList = scenePlugins[s];\n\n      for (i = 0; i < pluginList.length; i++) {\n        pluginKey = pluginList[i];\n\n        if (!PluginCache.hasCore(pluginKey)) {\n          continue;\n        }\n\n        var source = PluginCache.getCore(pluginKey);\n        var plugin = new source.plugin(scene, this);\n        sys[source.mapping] = plugin; //  Scene level injection\n\n        if (source.custom) {\n          scene[source.mapping] = plugin;\n        } else if (map.hasOwnProperty(source.mapping)) {\n          scene[map[source.mapping]] = plugin;\n        } //  Scene is already booted, usually because this method is being called at run-time, so boot the plugin\n\n\n        if (isBooted) {\n          plugin.boot();\n        }\n      }\n    } //  And finally, inject any 'global scene plugins'\n\n\n    pluginList = this.plugins;\n\n    for (i = 0; i < pluginList.length; i++) {\n      var entry = pluginList[i];\n\n      if (entry.mapping) {\n        scene[entry.mapping] = entry.plugin;\n      }\n    }\n  },\n\n  /**\r\n   * Called by the Scene Systems class. Returns a list of plugins to be installed.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#getDefaultScenePlugins\r\n   * @protected\r\n   * @since 3.8.0\r\n   *\r\n   * @return {string[]} A list keys of all the Scene Plugins to install.\r\n   */\n  getDefaultScenePlugins: function () {\n    var list = this.game.config.defaultPlugins; //  Merge in custom Scene plugins\n\n    list = list.concat(this.scenePlugins);\n    return list;\n  },\n\n  /**\r\n   * Installs a new Scene Plugin into the Plugin Manager and optionally adds it\r\n   * to the given Scene as well. A Scene Plugin added to the manager in this way\r\n   * will be automatically installed into all new Scenes using the key and mapping given.\r\n   *\r\n   * The `key` property is what the plugin is injected into Scene.Systems as.\r\n   * The `mapping` property is optional, and if specified is what the plugin is installed into\r\n   * the Scene as. For example:\r\n   *\r\n   * ```javascript\r\n   * this.plugins.installScenePlugin('powerupsPlugin', pluginCode, 'powerups');\r\n   * \r\n   * // and from within the scene:\r\n   * this.sys.powerupsPlugin; // key value\r\n   * this.powerups; // mapping value\r\n   * ```\r\n   *\r\n   * This method is called automatically by Phaser if you install your plugins using either the\r\n   * Game Configuration object, or by preloading them via the Loader.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#installScenePlugin\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The property key that will be used to add this plugin to Scene.Systems.\r\n   * @param {function} plugin - The plugin code. This should be the non-instantiated version.\r\n   * @param {string} [mapping] - If this plugin is injected into the Phaser.Scene class, this is the property key to use.\r\n   * @param {Phaser.Scene} [addToScene] - Optionally automatically add this plugin to the given Scene.\r\n   * @param {boolean} [fromLoader=false] - Is this being called by the Loader?\r\n   */\n  installScenePlugin: function (key, plugin, mapping, addToScene, fromLoader) {\n    if (fromLoader === undefined) {\n      fromLoader = false;\n    }\n\n    if (typeof plugin !== 'function') {\n      console.warn('Invalid Scene Plugin: ' + key);\n      return;\n    }\n\n    if (!PluginCache.hasCore(key)) {\n      //  Plugin is freshly loaded\n      PluginCache.register(key, plugin, mapping, true);\n      this.scenePlugins.push(key);\n    } else if (!fromLoader && PluginCache.hasCore(key)) {\n      //  Plugin wasn't from the loader but already exists\n      console.warn('Scene Plugin key in use: ' + key);\n      return;\n    }\n\n    if (addToScene) {\n      var instance = new plugin(addToScene, this);\n      addToScene.sys[key] = instance;\n\n      if (mapping && mapping !== '') {\n        addToScene[mapping] = instance;\n      }\n\n      instance.boot();\n    }\n  },\n\n  /**\r\n   * Installs a new Global Plugin into the Plugin Manager and optionally starts it running.\r\n   * A global plugin belongs to the Plugin Manager, rather than a specific Scene, and can be accessed\r\n   * and used by all Scenes in your game.\r\n   *\r\n   * The `key` property is what you use to access this plugin from the Plugin Manager.\r\n   *\r\n   * ```javascript\r\n   * this.plugins.install('powerupsPlugin', pluginCode);\r\n   * \r\n   * // and from within the scene:\r\n   * this.plugins.get('powerupsPlugin');\r\n   * ```\r\n   *\r\n   * This method is called automatically by Phaser if you install your plugins using either the\r\n   * Game Configuration object, or by preloading them via the Loader.\r\n   *\r\n   * The same plugin can be installed multiple times into the Plugin Manager by simply giving each\r\n   * instance its own unique key.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#install\r\n   * @since 3.8.0\r\n   * \r\n   * @param {string} key - The unique handle given to this plugin within the Plugin Manager.\r\n   * @param {function} plugin - The plugin code. This should be the non-instantiated version.\r\n   * @param {boolean} [start=false] - Automatically start the plugin running? This is always `true` if you provide a mapping value.\r\n   * @param {string} [mapping] - If this plugin is injected into the Phaser.Scene class, this is the property key to use.\r\n   * @param {any} [data] - A value passed to the plugin's `init` method.\r\n   *\r\n   * @return {?Phaser.Plugins.BasePlugin} The plugin that was started, or `null` if `start` was false, or game isn't yet booted.\r\n   */\n  install: function (key, plugin, start, mapping, data) {\n    if (start === undefined) {\n      start = false;\n    }\n\n    if (mapping === undefined) {\n      mapping = null;\n    }\n\n    if (data === undefined) {\n      data = null;\n    }\n\n    if (typeof plugin !== 'function') {\n      console.warn('Invalid Plugin: ' + key);\n      return null;\n    }\n\n    if (PluginCache.hasCustom(key)) {\n      console.warn('Plugin key in use: ' + key);\n      return null;\n    }\n\n    if (mapping !== null) {\n      start = true;\n    }\n\n    if (!this.game.isBooted) {\n      this._pendingGlobal.push({\n        key: key,\n        plugin: plugin,\n        start: start,\n        mapping: mapping,\n        data: data\n      });\n    } else {\n      //  Add it to the plugin store\n      PluginCache.registerCustom(key, plugin, mapping, data);\n\n      if (start) {\n        return this.start(key);\n      }\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Gets an index of a global plugin based on the given key.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#getIndex\r\n   * @protected\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The unique plugin key.\r\n   *\r\n   * @return {integer} The index of the plugin within the plugins array.\r\n   */\n  getIndex: function (key) {\n    var list = this.plugins;\n\n    for (var i = 0; i < list.length; i++) {\n      var entry = list[i];\n\n      if (entry.key === key) {\n        return i;\n      }\n    }\n\n    return -1;\n  },\n\n  /**\r\n   * Gets a global plugin based on the given key.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#getEntry\r\n   * @protected\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The unique plugin key.\r\n   *\r\n   * @return {Phaser.Types.Plugins.GlobalPlugin} The plugin entry.\r\n   */\n  getEntry: function (key) {\n    var idx = this.getIndex(key);\n\n    if (idx !== -1) {\n      return this.plugins[idx];\n    }\n  },\n\n  /**\r\n   * Checks if the given global plugin, based on its key, is active or not.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#isActive\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The unique plugin key.\r\n   *\r\n   * @return {boolean} `true` if the plugin is active, otherwise `false`.\r\n   */\n  isActive: function (key) {\n    var entry = this.getEntry(key);\n    return entry && entry.active;\n  },\n\n  /**\r\n   * Starts a global plugin running.\r\n   *\r\n   * If the plugin was previously active then calling `start` will reset it to an active state and then\r\n   * call its `start` method.\r\n   *\r\n   * If the plugin has never been run before a new instance of it will be created within the Plugin Manager,\r\n   * its active state set and then both of its `init` and `start` methods called, in that order.\r\n   *\r\n   * If the plugin is already running under the given key then nothing happens.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#start\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The key of the plugin to start.\r\n   * @param {string} [runAs] - Run the plugin under a new key. This allows you to run one plugin multiple times.\r\n   *\r\n   * @return {?Phaser.Plugins.BasePlugin} The plugin that was started, or `null` if invalid key given or plugin is already stopped.\r\n   */\n  start: function (key, runAs) {\n    if (runAs === undefined) {\n      runAs = key;\n    }\n\n    var entry = this.getEntry(runAs); //  Plugin already running under this key?\n\n    if (entry && !entry.active) {\n      //  It exists, we just need to start it up again\n      entry.active = true;\n      entry.plugin.start();\n    } else if (!entry) {\n      entry = this.createEntry(key, runAs);\n    }\n\n    return entry ? entry.plugin : null;\n  },\n\n  /**\r\n   * Creates a new instance of a global plugin, adds an entry into the plugins array and returns it.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#createEntry\r\n   * @private\r\n   * @since 3.9.0\r\n   *\r\n   * @param {string} key - The key of the plugin to create an instance of.\r\n   * @param {string} [runAs] - Run the plugin under a new key. This allows you to run one plugin multiple times.\r\n   *\r\n   * @return {?Phaser.Plugins.BasePlugin} The plugin that was started, or `null` if invalid key given.\r\n   */\n  createEntry: function (key, runAs) {\n    var entry = PluginCache.getCustom(key);\n\n    if (entry) {\n      var instance = new entry.plugin(this);\n      entry = {\n        key: runAs,\n        plugin: instance,\n        active: true,\n        mapping: entry.mapping,\n        data: entry.data\n      };\n      this.plugins.push(entry);\n      instance.init(entry.data);\n      instance.start();\n    }\n\n    return entry;\n  },\n\n  /**\r\n   * Stops a global plugin from running.\r\n   *\r\n   * If the plugin is active then its active state will be set to false and the plugins `stop` method\r\n   * will be called.\r\n   *\r\n   * If the plugin is not already running, nothing will happen.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#stop\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The key of the plugin to stop.\r\n   *\r\n   * @return {Phaser.Plugins.PluginManager} The Plugin Manager.\r\n   */\n  stop: function (key) {\n    var entry = this.getEntry(key);\n\n    if (entry && entry.active) {\n      entry.active = false;\n      entry.plugin.stop();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Gets a global plugin from the Plugin Manager based on the given key and returns it.\r\n   *\r\n   * If it cannot find an active plugin based on the key, but there is one in the Plugin Cache with the same key,\r\n   * then it will create a new instance of the cached plugin and return that.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#get\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The key of the plugin to get.\r\n   * @param {boolean} [autoStart=true] - Automatically start a new instance of the plugin if found in the cache, but not actively running.\r\n   *\r\n   * @return {?(Phaser.Plugins.BasePlugin|function)} The plugin, or `null` if no plugin was found matching the key.\r\n   */\n  get: function (key, autoStart) {\n    if (autoStart === undefined) {\n      autoStart = true;\n    }\n\n    var entry = this.getEntry(key);\n\n    if (entry) {\n      return entry.plugin;\n    } else {\n      var plugin = this.getClass(key);\n\n      if (plugin && autoStart) {\n        entry = this.createEntry(key, key);\n        return entry ? entry.plugin : null;\n      } else if (plugin) {\n        return plugin;\n      }\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Returns the plugin class from the cache.\r\n   * Used internally by the Plugin Manager.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#getClass\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The key of the plugin to get.\r\n   *\r\n   * @return {Phaser.Plugins.BasePlugin} A Plugin object\r\n   */\n  getClass: function (key) {\n    return PluginCache.getCustomClass(key);\n  },\n\n  /**\r\n   * Removes a global plugin from the Plugin Manager and Plugin Cache.\r\n   *\r\n   * It is up to you to remove all references to this plugin that you may hold within your game code.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#removeGlobalPlugin\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The key of the plugin to remove.\r\n   */\n  removeGlobalPlugin: function (key) {\n    var entry = this.getEntry(key);\n\n    if (entry) {\n      Remove(this.plugins, entry);\n    }\n\n    PluginCache.removeCustom(key);\n  },\n\n  /**\r\n   * Removes a scene plugin from the Plugin Manager and Plugin Cache.\r\n   *\r\n   * This will not remove the plugin from any active Scenes that are already using it.\r\n   *\r\n   * It is up to you to remove all references to this plugin that you may hold within your game code.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#removeScenePlugin\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The key of the plugin to remove.\r\n   */\n  removeScenePlugin: function (key) {\n    Remove(this.scenePlugins, key);\n    PluginCache.remove(key);\n  },\n\n  /**\r\n   * Registers a new type of Game Object with the global Game Object Factory and / or Creator.\r\n   * This is usually called from within your Plugin code and is a helpful short-cut for creating\r\n   * new Game Objects.\r\n   *\r\n   * The key is the property that will be injected into the factories and used to create the\r\n   * Game Object. For example:\r\n   *\r\n   * ```javascript\r\n   * this.plugins.registerGameObject('clown', clownFactoryCallback, clownCreatorCallback);\r\n   * // later in your game code:\r\n   * this.add.clown();\r\n   * this.make.clown();\r\n   * ```\r\n   * \r\n   * The callbacks are what are called when the factories try to create a Game Object\r\n   * matching the given key. It's important to understand that the callbacks are invoked within\r\n   * the context of the GameObjectFactory. In this context there are several properties available\r\n   * to use:\r\n   * \r\n   * this.scene - A reference to the Scene that owns the GameObjectFactory.\r\n   * this.displayList - A reference to the Display List the Scene owns.\r\n   * this.updateList - A reference to the Update List the Scene owns.\r\n   * \r\n   * See the GameObjectFactory and GameObjectCreator classes for more details.\r\n   * Any public property or method listed is available from your callbacks under `this`.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#registerGameObject\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The key of the Game Object that the given callbacks will create, i.e. `image`, `sprite`.\r\n   * @param {function} [factoryCallback] - The callback to invoke when the Game Object Factory is called.\r\n   * @param {function} [creatorCallback] - The callback to invoke when the Game Object Creator is called.\r\n   */\n  registerGameObject: function (key, factoryCallback, creatorCallback) {\n    if (factoryCallback) {\n      GameObjectFactory.register(key, factoryCallback);\n    }\n\n    if (creatorCallback) {\n      GameObjectCreator.register(key, creatorCallback);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes a previously registered Game Object from the global Game Object Factory and / or Creator.\r\n   * This is usually called from within your Plugin destruction code to help clean-up after your plugin has been removed.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#removeGameObject\r\n   * @since 3.19.0\r\n   *\r\n   * @param {string} key - The key of the Game Object to be removed from the factories.\r\n   * @param {boolean} [removeFromFactory=true] - Should the Game Object be removed from the Game Object Factory?\r\n   * @param {boolean} [removeFromCreator=true] - Should the Game Object be removed from the Game Object Creator?\r\n   */\n  removeGameObject: function (key, removeFromFactory, removeFromCreator) {\n    if (removeFromFactory === undefined) {\n      removeFromFactory = true;\n    }\n\n    if (removeFromCreator === undefined) {\n      removeFromCreator = true;\n    }\n\n    if (removeFromFactory) {\n      GameObjectFactory.remove(key);\n    }\n\n    if (removeFromCreator) {\n      GameObjectCreator.remove(key);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Registers a new file type with the global File Types Manager, making it available to all Loader\r\n   * Plugins created after this.\r\n   * \r\n   * This is usually called from within your Plugin code and is a helpful short-cut for creating\r\n   * new loader file types.\r\n   *\r\n   * The key is the property that will be injected into the Loader Plugin and used to load the\r\n   * files. For example:\r\n   *\r\n   * ```javascript\r\n   * this.plugins.registerFileType('wad', doomWadLoaderCallback);\r\n   * // later in your preload code:\r\n   * this.load.wad();\r\n   * ```\r\n   * \r\n   * The callback is what is called when the loader tries to load a file  matching the given key.\r\n   * It's important to understand that the callback is invoked within\r\n   * the context of the LoaderPlugin. In this context there are several properties / methods available\r\n   * to use:\r\n   * \r\n   * this.addFile - A method to add the new file to the load queue.\r\n   * this.scene - The Scene that owns the Loader Plugin instance.\r\n   *\r\n   * See the LoaderPlugin class for more details. Any public property or method listed is available from\r\n   * your callback under `this`.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#registerFileType\r\n   * @since 3.8.0\r\n   *\r\n   * @param {string} key - The key of the Game Object that the given callbacks will create, i.e. `image`, `sprite`.\r\n   * @param {function} callback - The callback to invoke when the Game Object Factory is called.\r\n   * @param {Phaser.Scene} [addToScene] - Optionally add this file type into the Loader Plugin owned by the given Scene.\r\n   */\n  registerFileType: function (key, callback, addToScene) {\n    FileTypesManager.register(key, callback);\n\n    if (addToScene && addToScene.sys.load) {\n      addToScene.sys.load[key] = callback;\n    }\n  },\n\n  /**\r\n   * Destroys this Plugin Manager and all associated plugins.\r\n   * It will iterate all plugins found and call their `destroy` methods.\r\n   * \r\n   * The PluginCache will remove all custom plugins.\r\n   *\r\n   * @method Phaser.Plugins.PluginManager#destroy\r\n   * @since 3.8.0\r\n   */\n  destroy: function () {\n    for (var i = 0; i < this.plugins.length; i++) {\n      this.plugins[i].plugin.destroy();\n    }\n\n    PluginCache.destroyCustomPlugins();\n\n    if (this.game.noReturn) {\n      PluginCache.destroyCorePlugins();\n    }\n\n    this.game = null;\n    this.plugins = [];\n    this.scenePlugins = [];\n  }\n});\n/*\r\n * \"Sometimes, the elegant implementation is just a function.\r\n * Not a method. Not a class. Not a framework. Just a function.\"\r\n *  -- John Carmack\r\n */\n\nmodule.exports = PluginManager;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/plugins/PluginManager.js"],"names":["Class","require","GameEvents","EventEmitter","FileTypesManager","GameObjectCreator","GameObjectFactory","GetFastValue","PluginCache","Remove","PluginManager","Extends","initialize","game","call","plugins","scenePlugins","_pendingGlobal","_pendingScene","isBooted","boot","events","once","BOOT","i","entry","key","plugin","start","mapping","data","config","list","installGlobalPlugins","concat","length","install","console","warn","installScenePlugins","installScenePlugin","DESTROY","destroy","addToScene","sys","globalPlugins","pluginKey","pluginList","scene","map","settings","hasOwnProperty","s","hasCore","source","getCore","custom","getDefaultScenePlugins","defaultPlugins","fromLoader","undefined","register","push","instance","hasCustom","registerCustom","getIndex","getEntry","idx","isActive","active","runAs","createEntry","getCustom","init","stop","get","autoStart","getClass","getCustomClass","removeGlobalPlugin","removeCustom","removeScenePlugin","remove","registerGameObject","factoryCallback","creatorCallback","removeGameObject","removeFromFactory","removeFromCreator","registerFileType","callback","load","destroyCustomPlugins","noReturn","destroyCorePlugins","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar GameEvents = require('../core/events');\r\nvar EventEmitter = require('eventemitter3');\r\nvar FileTypesManager = require('../loader/FileTypesManager');\r\nvar GameObjectCreator = require('../gameobjects/GameObjectCreator');\r\nvar GameObjectFactory = require('../gameobjects/GameObjectFactory');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar PluginCache = require('./PluginCache');\r\nvar Remove = require('../utils/array/Remove');\r\n\r\n/**\r\n * @classdesc\r\n * The PluginManager is responsible for installing and adding plugins to Phaser.\r\n *\r\n * It is a global system and therefore belongs to the Game instance, not a specific Scene.\r\n *\r\n * It works in conjunction with the PluginCache. Core internal plugins automatically register themselves \r\n * with the Cache, but it's the Plugin Manager that is responsible for injecting them into the Scenes.\r\n *\r\n * There are two types of plugin:\r\n *\r\n * 1. A Global Plugin\r\n * 2. A Scene Plugin\r\n *\r\n * A Global Plugin is a plugin that lives within the Plugin Manager rather than a Scene. You can get\r\n * access to it by calling `PluginManager.get` and providing a key. Any Scene that requests a plugin in\r\n * this way will all get access to the same plugin instance, allowing you to use a single plugin across\r\n * multiple Scenes.\r\n *\r\n * A Scene Plugin is a plugin dedicated to running within a Scene. These are different to Global Plugins\r\n * in that their instances do not live within the Plugin Manager, but within the Scene Systems class instead.\r\n * And that every Scene created is given its own unique instance of a Scene Plugin. Examples of core Scene\r\n * Plugins include the Input Plugin, the Tween Plugin and the physics Plugins.\r\n *\r\n * You can add a plugin to Phaser in three different ways:\r\n *\r\n * 1. Preload it\r\n * 2. Include it in your source code and install it via the Game Config\r\n * 3. Include it in your source code and install it within a Scene\r\n *\r\n * For examples of all of these approaches please see the Phaser 3 Examples Repo `plugins` folder.\r\n *\r\n * For information on creating your own plugin please see the Phaser 3 Plugin Template.\r\n *\r\n * @class PluginManager\r\n * @memberof Phaser.Plugins\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The game instance that owns this Plugin Manager.\r\n */\r\nvar PluginManager = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function PluginManager (game)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The game instance that owns this Plugin Manager.\r\n         *\r\n         * @name Phaser.Plugins.PluginManager#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * The global plugins currently running and managed by this Plugin Manager.\r\n         * A plugin must have been started at least once in order to appear in this list.\r\n         *\r\n         * @name Phaser.Plugins.PluginManager#plugins\r\n         * @type {Phaser.Types.Plugins.GlobalPlugin[]}\r\n         * @since 3.8.0\r\n         */\r\n        this.plugins = [];\r\n\r\n        /**\r\n         * A list of plugin keys that should be installed into Scenes as well as the Core Plugins.\r\n         *\r\n         * @name Phaser.Plugins.PluginManager#scenePlugins\r\n         * @type {string[]}\r\n         * @since 3.8.0\r\n         */\r\n        this.scenePlugins = [];\r\n\r\n        /**\r\n         * A temporary list of plugins to install when the game has booted.\r\n         *\r\n         * @name Phaser.Plugins.PluginManager#_pendingGlobal\r\n         * @private\r\n         * @type {array}\r\n         * @since 3.8.0\r\n         */\r\n        this._pendingGlobal = [];\r\n\r\n        /**\r\n         * A temporary list of scene plugins to install when the game has booted.\r\n         *\r\n         * @name Phaser.Plugins.PluginManager#_pendingScene\r\n         * @private\r\n         * @type {array}\r\n         * @since 3.8.0\r\n         */\r\n        this._pendingScene = [];\r\n\r\n        if (game.isBooted)\r\n        {\r\n            this.boot();\r\n        }\r\n        else\r\n        {\r\n            game.events.once(GameEvents.BOOT, this.boot, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Run once the game has booted and installs all of the plugins configured in the Game Config.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#boot\r\n     * @protected\r\n     * @since 3.0.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        var i;\r\n        var entry;\r\n        var key;\r\n        var plugin;\r\n        var start;\r\n        var mapping;\r\n        var data;\r\n        var config = this.game.config;\r\n\r\n        //  Any plugins to install?\r\n        var list = config.installGlobalPlugins;\r\n\r\n        //  Any plugins added outside of the game config, but before the game booted?\r\n        list = list.concat(this._pendingGlobal);\r\n\r\n        for (i = 0; i < list.length; i++)\r\n        {\r\n            entry = list[i];\r\n\r\n            // { key: 'TestPlugin', plugin: TestPlugin, start: true, mapping: 'test', data: { msg: 'The plugin is alive' } }\r\n\r\n            key = GetFastValue(entry, 'key', null);\r\n            plugin = GetFastValue(entry, 'plugin', null);\r\n            start = GetFastValue(entry, 'start', false);\r\n            mapping = GetFastValue(entry, 'mapping', null);\r\n            data = GetFastValue(entry, 'data', null);\r\n\r\n            if (key)\r\n            {\r\n                if (plugin)\r\n                {\r\n                    this.install(key, plugin, start, mapping, data);\r\n                }\r\n                else\r\n                {\r\n                    console.warn('Missing `plugin` for key: ' + key);\r\n                }\r\n                \r\n            }\r\n        }\r\n\r\n        //  Any scene plugins to install?\r\n        list = config.installScenePlugins;\r\n\r\n        //  Any plugins added outside of the game config, but before the game booted?\r\n        list = list.concat(this._pendingScene);\r\n\r\n        for (i = 0; i < list.length; i++)\r\n        {\r\n            entry = list[i];\r\n\r\n            // { key: 'moveSpritePlugin', plugin: MoveSpritePlugin, , mapping: 'move' }\r\n\r\n            key = GetFastValue(entry, 'key', null);\r\n            plugin = GetFastValue(entry, 'plugin', null);\r\n            mapping = GetFastValue(entry, 'mapping', null);\r\n\r\n            if (key)\r\n            {\r\n                if (plugin)\r\n                {\r\n                    this.installScenePlugin(key, plugin, mapping);\r\n                }\r\n                else\r\n                {\r\n                    console.warn('Missing `plugin` for key: ' + key);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._pendingGlobal = [];\r\n        this._pendingScene = [];\r\n\r\n        this.game.events.once(GameEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * Called by the Scene Systems class. Tells the plugin manager to install all Scene plugins into it.\r\n     *\r\n     * First it will install global references, i.e. references from the Game systems into the Scene Systems (and Scene if mapped.)\r\n     * Then it will install Core Scene Plugins followed by Scene Plugins registered with the PluginManager.\r\n     * Finally it will install any references to Global Plugins that have a Scene mapping property into the Scene itself.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#addToScene\r\n     * @protected\r\n     * @since 3.8.0\r\n     *\r\n     * @param {Phaser.Scenes.Systems} sys - The Scene Systems class to install all the plugins in to.\r\n     * @param {array} globalPlugins - An array of global plugins to install.\r\n     * @param {array} scenePlugins - An array of scene plugins to install.\r\n     */\r\n    addToScene: function (sys, globalPlugins, scenePlugins)\r\n    {\r\n        var i;\r\n        var pluginKey;\r\n        var pluginList;\r\n        var game = this.game;\r\n        var scene = sys.scene;\r\n        var map = sys.settings.map;\r\n        var isBooted = sys.settings.isBooted;\r\n\r\n        //  Reference the GlobalPlugins from Game into Scene.Systems\r\n        for (i = 0; i < globalPlugins.length; i++)\r\n        {\r\n            pluginKey = globalPlugins[i];\r\n\r\n            if (game[pluginKey])\r\n            {\r\n                sys[pluginKey] = game[pluginKey];\r\n\r\n                //  Scene level injection\r\n                if (map.hasOwnProperty(pluginKey))\r\n                {\r\n                    scene[map[pluginKey]] = sys[pluginKey];\r\n                }\r\n            }\r\n            else if (pluginKey === 'game' && map.hasOwnProperty(pluginKey))\r\n            {\r\n                scene[map[pluginKey]] = game;\r\n            }\r\n        }\r\n\r\n        for (var s = 0; s < scenePlugins.length; s++)\r\n        {\r\n            pluginList = scenePlugins[s];\r\n\r\n            for (i = 0; i < pluginList.length; i++)\r\n            {\r\n                pluginKey = pluginList[i];\r\n\r\n                if (!PluginCache.hasCore(pluginKey))\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                var source = PluginCache.getCore(pluginKey);\r\n\r\n                var plugin = new source.plugin(scene, this);\r\n                \r\n                sys[source.mapping] = plugin;\r\n\r\n                //  Scene level injection\r\n                if (source.custom)\r\n                {\r\n                    scene[source.mapping] = plugin;\r\n                }\r\n                else if (map.hasOwnProperty(source.mapping))\r\n                {\r\n                    scene[map[source.mapping]] = plugin;\r\n                }\r\n\r\n                //  Scene is already booted, usually because this method is being called at run-time, so boot the plugin\r\n                if (isBooted)\r\n                {\r\n                    plugin.boot();\r\n                }\r\n            }\r\n        }\r\n\r\n        //  And finally, inject any 'global scene plugins'\r\n        pluginList = this.plugins;\r\n\r\n        for (i = 0; i < pluginList.length; i++)\r\n        {\r\n            var entry = pluginList[i];\r\n\r\n            if (entry.mapping)\r\n            {\r\n                scene[entry.mapping] = entry.plugin;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by the Scene Systems class. Returns a list of plugins to be installed.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#getDefaultScenePlugins\r\n     * @protected\r\n     * @since 3.8.0\r\n     *\r\n     * @return {string[]} A list keys of all the Scene Plugins to install.\r\n     */\r\n    getDefaultScenePlugins: function ()\r\n    {\r\n        var list = this.game.config.defaultPlugins;\r\n\r\n        //  Merge in custom Scene plugins\r\n        list = list.concat(this.scenePlugins);\r\n\r\n        return list;\r\n    },\r\n\r\n    /**\r\n     * Installs a new Scene Plugin into the Plugin Manager and optionally adds it\r\n     * to the given Scene as well. A Scene Plugin added to the manager in this way\r\n     * will be automatically installed into all new Scenes using the key and mapping given.\r\n     *\r\n     * The `key` property is what the plugin is injected into Scene.Systems as.\r\n     * The `mapping` property is optional, and if specified is what the plugin is installed into\r\n     * the Scene as. For example:\r\n     *\r\n     * ```javascript\r\n     * this.plugins.installScenePlugin('powerupsPlugin', pluginCode, 'powerups');\r\n     * \r\n     * // and from within the scene:\r\n     * this.sys.powerupsPlugin; // key value\r\n     * this.powerups; // mapping value\r\n     * ```\r\n     *\r\n     * This method is called automatically by Phaser if you install your plugins using either the\r\n     * Game Configuration object, or by preloading them via the Loader.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#installScenePlugin\r\n     * @since 3.8.0\r\n     *\r\n     * @param {string} key - The property key that will be used to add this plugin to Scene.Systems.\r\n     * @param {function} plugin - The plugin code. This should be the non-instantiated version.\r\n     * @param {string} [mapping] - If this plugin is injected into the Phaser.Scene class, this is the property key to use.\r\n     * @param {Phaser.Scene} [addToScene] - Optionally automatically add this plugin to the given Scene.\r\n     * @param {boolean} [fromLoader=false] - Is this being called by the Loader?\r\n     */\r\n    installScenePlugin: function (key, plugin, mapping, addToScene, fromLoader)\r\n    {\r\n        if (fromLoader === undefined) { fromLoader = false; }\r\n\r\n        if (typeof plugin !== 'function')\r\n        {\r\n            console.warn('Invalid Scene Plugin: ' + key);\r\n            return;\r\n        }\r\n\r\n        if (!PluginCache.hasCore(key))\r\n        {\r\n            //  Plugin is freshly loaded\r\n            PluginCache.register(key, plugin, mapping, true);\r\n\r\n            this.scenePlugins.push(key);\r\n        }\r\n        else if (!fromLoader && PluginCache.hasCore(key))\r\n        {\r\n            //  Plugin wasn't from the loader but already exists\r\n            console.warn('Scene Plugin key in use: ' + key);\r\n            return;\r\n        }\r\n\r\n        if (addToScene)\r\n        {\r\n            var instance = new plugin(addToScene, this);\r\n\r\n            addToScene.sys[key] = instance;\r\n\r\n            if (mapping && mapping !== '')\r\n            {\r\n                addToScene[mapping] = instance;\r\n            }\r\n\r\n            instance.boot();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Installs a new Global Plugin into the Plugin Manager and optionally starts it running.\r\n     * A global plugin belongs to the Plugin Manager, rather than a specific Scene, and can be accessed\r\n     * and used by all Scenes in your game.\r\n     *\r\n     * The `key` property is what you use to access this plugin from the Plugin Manager.\r\n     *\r\n     * ```javascript\r\n     * this.plugins.install('powerupsPlugin', pluginCode);\r\n     * \r\n     * // and from within the scene:\r\n     * this.plugins.get('powerupsPlugin');\r\n     * ```\r\n     *\r\n     * This method is called automatically by Phaser if you install your plugins using either the\r\n     * Game Configuration object, or by preloading them via the Loader.\r\n     *\r\n     * The same plugin can be installed multiple times into the Plugin Manager by simply giving each\r\n     * instance its own unique key.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#install\r\n     * @since 3.8.0\r\n     * \r\n     * @param {string} key - The unique handle given to this plugin within the Plugin Manager.\r\n     * @param {function} plugin - The plugin code. This should be the non-instantiated version.\r\n     * @param {boolean} [start=false] - Automatically start the plugin running? This is always `true` if you provide a mapping value.\r\n     * @param {string} [mapping] - If this plugin is injected into the Phaser.Scene class, this is the property key to use.\r\n     * @param {any} [data] - A value passed to the plugin's `init` method.\r\n     *\r\n     * @return {?Phaser.Plugins.BasePlugin} The plugin that was started, or `null` if `start` was false, or game isn't yet booted.\r\n     */\r\n    install: function (key, plugin, start, mapping, data)\r\n    {\r\n        if (start === undefined) { start = false; }\r\n        if (mapping === undefined) { mapping = null; }\r\n        if (data === undefined) { data = null; }\r\n\r\n        if (typeof plugin !== 'function')\r\n        {\r\n            console.warn('Invalid Plugin: ' + key);\r\n            return null;\r\n        }\r\n\r\n        if (PluginCache.hasCustom(key))\r\n        {\r\n            console.warn('Plugin key in use: ' + key);\r\n            return null;\r\n        }\r\n\r\n        if (mapping !== null)\r\n        {\r\n            start = true;\r\n        }\r\n\r\n        if (!this.game.isBooted)\r\n        {\r\n            this._pendingGlobal.push({ key: key, plugin: plugin, start: start, mapping: mapping, data: data });\r\n        }\r\n        else\r\n        {\r\n            //  Add it to the plugin store\r\n            PluginCache.registerCustom(key, plugin, mapping, data);\r\n\r\n            if (start)\r\n            {\r\n                return this.start(key);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Gets an index of a global plugin based on the given key.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#getIndex\r\n     * @protected\r\n     * @since 3.8.0\r\n     *\r\n     * @param {string} key - The unique plugin key.\r\n     *\r\n     * @return {integer} The index of the plugin within the plugins array.\r\n     */\r\n    getIndex: function (key)\r\n    {\r\n        var list = this.plugins;\r\n\r\n        for (var i = 0; i < list.length; i++)\r\n        {\r\n            var entry = list[i];\r\n\r\n            if (entry.key === key)\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    },\r\n\r\n    /**\r\n     * Gets a global plugin based on the given key.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#getEntry\r\n     * @protected\r\n     * @since 3.8.0\r\n     *\r\n     * @param {string} key - The unique plugin key.\r\n     *\r\n     * @return {Phaser.Types.Plugins.GlobalPlugin} The plugin entry.\r\n     */\r\n    getEntry: function (key)\r\n    {\r\n        var idx = this.getIndex(key);\r\n\r\n        if (idx !== -1)\r\n        {\r\n            return this.plugins[idx];\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks if the given global plugin, based on its key, is active or not.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#isActive\r\n     * @since 3.8.0\r\n     *\r\n     * @param {string} key - The unique plugin key.\r\n     *\r\n     * @return {boolean} `true` if the plugin is active, otherwise `false`.\r\n     */\r\n    isActive: function (key)\r\n    {\r\n        var entry = this.getEntry(key);\r\n\r\n        return (entry && entry.active);\r\n    },\r\n\r\n    /**\r\n     * Starts a global plugin running.\r\n     *\r\n     * If the plugin was previously active then calling `start` will reset it to an active state and then\r\n     * call its `start` method.\r\n     *\r\n     * If the plugin has never been run before a new instance of it will be created within the Plugin Manager,\r\n     * its active state set and then both of its `init` and `start` methods called, in that order.\r\n     *\r\n     * If the plugin is already running under the given key then nothing happens.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#start\r\n     * @since 3.8.0\r\n     *\r\n     * @param {string} key - The key of the plugin to start.\r\n     * @param {string} [runAs] - Run the plugin under a new key. This allows you to run one plugin multiple times.\r\n     *\r\n     * @return {?Phaser.Plugins.BasePlugin} The plugin that was started, or `null` if invalid key given or plugin is already stopped.\r\n     */\r\n    start: function (key, runAs)\r\n    {\r\n        if (runAs === undefined) { runAs = key; }\r\n\r\n        var entry = this.getEntry(runAs);\r\n\r\n        //  Plugin already running under this key?\r\n        if (entry && !entry.active)\r\n        {\r\n            //  It exists, we just need to start it up again\r\n            entry.active = true;\r\n            entry.plugin.start();\r\n        }\r\n        else if (!entry)\r\n        {\r\n            entry = this.createEntry(key, runAs);\r\n        }\r\n\r\n        return (entry) ? entry.plugin : null;\r\n    },\r\n\r\n    /**\r\n     * Creates a new instance of a global plugin, adds an entry into the plugins array and returns it.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#createEntry\r\n     * @private\r\n     * @since 3.9.0\r\n     *\r\n     * @param {string} key - The key of the plugin to create an instance of.\r\n     * @param {string} [runAs] - Run the plugin under a new key. This allows you to run one plugin multiple times.\r\n     *\r\n     * @return {?Phaser.Plugins.BasePlugin} The plugin that was started, or `null` if invalid key given.\r\n     */\r\n    createEntry: function (key, runAs)\r\n    {\r\n        var entry = PluginCache.getCustom(key);\r\n\r\n        if (entry)\r\n        {\r\n            var instance = new entry.plugin(this);\r\n\r\n            entry = {\r\n                key: runAs,\r\n                plugin: instance,\r\n                active: true,\r\n                mapping: entry.mapping,\r\n                data: entry.data\r\n            };\r\n\r\n            this.plugins.push(entry);\r\n\r\n            instance.init(entry.data);\r\n            instance.start();\r\n        }\r\n\r\n        return entry;\r\n    },\r\n\r\n    /**\r\n     * Stops a global plugin from running.\r\n     *\r\n     * If the plugin is active then its active state will be set to false and the plugins `stop` method\r\n     * will be called.\r\n     *\r\n     * If the plugin is not already running, nothing will happen.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#stop\r\n     * @since 3.8.0\r\n     *\r\n     * @param {string} key - The key of the plugin to stop.\r\n     *\r\n     * @return {Phaser.Plugins.PluginManager} The Plugin Manager.\r\n     */\r\n    stop: function (key)\r\n    {\r\n        var entry = this.getEntry(key);\r\n\r\n        if (entry && entry.active)\r\n        {\r\n            entry.active = false;\r\n            entry.plugin.stop();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets a global plugin from the Plugin Manager based on the given key and returns it.\r\n     *\r\n     * If it cannot find an active plugin based on the key, but there is one in the Plugin Cache with the same key,\r\n     * then it will create a new instance of the cached plugin and return that.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#get\r\n     * @since 3.8.0\r\n     *\r\n     * @param {string} key - The key of the plugin to get.\r\n     * @param {boolean} [autoStart=true] - Automatically start a new instance of the plugin if found in the cache, but not actively running.\r\n     *\r\n     * @return {?(Phaser.Plugins.BasePlugin|function)} The plugin, or `null` if no plugin was found matching the key.\r\n     */\r\n    get: function (key, autoStart)\r\n    {\r\n        if (autoStart === undefined) { autoStart = true; }\r\n\r\n        var entry = this.getEntry(key);\r\n\r\n        if (entry)\r\n        {\r\n            return entry.plugin;\r\n        }\r\n        else\r\n        {\r\n            var plugin = this.getClass(key);\r\n\r\n            if (plugin && autoStart)\r\n            {\r\n                entry = this.createEntry(key, key);\r\n\r\n                return (entry) ? entry.plugin : null;\r\n            }\r\n            else if (plugin)\r\n            {\r\n                return plugin;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Returns the plugin class from the cache.\r\n     * Used internally by the Plugin Manager.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#getClass\r\n     * @since 3.8.0\r\n     *\r\n     * @param {string} key - The key of the plugin to get.\r\n     *\r\n     * @return {Phaser.Plugins.BasePlugin} A Plugin object\r\n     */\r\n    getClass: function (key)\r\n    {\r\n        return PluginCache.getCustomClass(key);\r\n    },\r\n\r\n    /**\r\n     * Removes a global plugin from the Plugin Manager and Plugin Cache.\r\n     *\r\n     * It is up to you to remove all references to this plugin that you may hold within your game code.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#removeGlobalPlugin\r\n     * @since 3.8.0\r\n     *\r\n     * @param {string} key - The key of the plugin to remove.\r\n     */\r\n    removeGlobalPlugin: function (key)\r\n    {\r\n        var entry = this.getEntry(key);\r\n\r\n        if (entry)\r\n        {\r\n            Remove(this.plugins, entry);\r\n        }\r\n\r\n        PluginCache.removeCustom(key);\r\n    },\r\n\r\n    /**\r\n     * Removes a scene plugin from the Plugin Manager and Plugin Cache.\r\n     *\r\n     * This will not remove the plugin from any active Scenes that are already using it.\r\n     *\r\n     * It is up to you to remove all references to this plugin that you may hold within your game code.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#removeScenePlugin\r\n     * @since 3.8.0\r\n     *\r\n     * @param {string} key - The key of the plugin to remove.\r\n     */\r\n    removeScenePlugin: function (key)\r\n    {\r\n        Remove(this.scenePlugins, key);\r\n\r\n        PluginCache.remove(key);\r\n    },\r\n\r\n    /**\r\n     * Registers a new type of Game Object with the global Game Object Factory and / or Creator.\r\n     * This is usually called from within your Plugin code and is a helpful short-cut for creating\r\n     * new Game Objects.\r\n     *\r\n     * The key is the property that will be injected into the factories and used to create the\r\n     * Game Object. For example:\r\n     *\r\n     * ```javascript\r\n     * this.plugins.registerGameObject('clown', clownFactoryCallback, clownCreatorCallback);\r\n     * // later in your game code:\r\n     * this.add.clown();\r\n     * this.make.clown();\r\n     * ```\r\n     * \r\n     * The callbacks are what are called when the factories try to create a Game Object\r\n     * matching the given key. It's important to understand that the callbacks are invoked within\r\n     * the context of the GameObjectFactory. In this context there are several properties available\r\n     * to use:\r\n     * \r\n     * this.scene - A reference to the Scene that owns the GameObjectFactory.\r\n     * this.displayList - A reference to the Display List the Scene owns.\r\n     * this.updateList - A reference to the Update List the Scene owns.\r\n     * \r\n     * See the GameObjectFactory and GameObjectCreator classes for more details.\r\n     * Any public property or method listed is available from your callbacks under `this`.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#registerGameObject\r\n     * @since 3.8.0\r\n     *\r\n     * @param {string} key - The key of the Game Object that the given callbacks will create, i.e. `image`, `sprite`.\r\n     * @param {function} [factoryCallback] - The callback to invoke when the Game Object Factory is called.\r\n     * @param {function} [creatorCallback] - The callback to invoke when the Game Object Creator is called.\r\n     */\r\n    registerGameObject: function (key, factoryCallback, creatorCallback)\r\n    {\r\n        if (factoryCallback)\r\n        {\r\n            GameObjectFactory.register(key, factoryCallback);\r\n        }\r\n\r\n        if (creatorCallback)\r\n        {\r\n            GameObjectCreator.register(key, creatorCallback);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a previously registered Game Object from the global Game Object Factory and / or Creator.\r\n     * This is usually called from within your Plugin destruction code to help clean-up after your plugin has been removed.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#removeGameObject\r\n     * @since 3.19.0\r\n     *\r\n     * @param {string} key - The key of the Game Object to be removed from the factories.\r\n     * @param {boolean} [removeFromFactory=true] - Should the Game Object be removed from the Game Object Factory?\r\n     * @param {boolean} [removeFromCreator=true] - Should the Game Object be removed from the Game Object Creator?\r\n     */\r\n    removeGameObject: function (key, removeFromFactory, removeFromCreator)\r\n    {\r\n        if (removeFromFactory === undefined) { removeFromFactory = true; }\r\n        if (removeFromCreator === undefined) { removeFromCreator = true; }\r\n\r\n        if (removeFromFactory)\r\n        {\r\n            GameObjectFactory.remove(key);\r\n        }\r\n\r\n        if (removeFromCreator)\r\n        {\r\n            GameObjectCreator.remove(key);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Registers a new file type with the global File Types Manager, making it available to all Loader\r\n     * Plugins created after this.\r\n     * \r\n     * This is usually called from within your Plugin code and is a helpful short-cut for creating\r\n     * new loader file types.\r\n     *\r\n     * The key is the property that will be injected into the Loader Plugin and used to load the\r\n     * files. For example:\r\n     *\r\n     * ```javascript\r\n     * this.plugins.registerFileType('wad', doomWadLoaderCallback);\r\n     * // later in your preload code:\r\n     * this.load.wad();\r\n     * ```\r\n     * \r\n     * The callback is what is called when the loader tries to load a file  matching the given key.\r\n     * It's important to understand that the callback is invoked within\r\n     * the context of the LoaderPlugin. In this context there are several properties / methods available\r\n     * to use:\r\n     * \r\n     * this.addFile - A method to add the new file to the load queue.\r\n     * this.scene - The Scene that owns the Loader Plugin instance.\r\n     *\r\n     * See the LoaderPlugin class for more details. Any public property or method listed is available from\r\n     * your callback under `this`.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#registerFileType\r\n     * @since 3.8.0\r\n     *\r\n     * @param {string} key - The key of the Game Object that the given callbacks will create, i.e. `image`, `sprite`.\r\n     * @param {function} callback - The callback to invoke when the Game Object Factory is called.\r\n     * @param {Phaser.Scene} [addToScene] - Optionally add this file type into the Loader Plugin owned by the given Scene.\r\n     */\r\n    registerFileType: function (key, callback, addToScene)\r\n    {\r\n        FileTypesManager.register(key, callback);\r\n\r\n        if (addToScene && addToScene.sys.load)\r\n        {\r\n            addToScene.sys.load[key] = callback;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys this Plugin Manager and all associated plugins.\r\n     * It will iterate all plugins found and call their `destroy` methods.\r\n     * \r\n     * The PluginCache will remove all custom plugins.\r\n     *\r\n     * @method Phaser.Plugins.PluginManager#destroy\r\n     * @since 3.8.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        for (var i = 0; i < this.plugins.length; i++)\r\n        {\r\n            this.plugins[i].plugin.destroy();\r\n        }\r\n\r\n        PluginCache.destroyCustomPlugins();\r\n\r\n        if (this.game.noReturn)\r\n        {\r\n            PluginCache.destroyCorePlugins();\r\n        }\r\n\r\n        this.game = null;\r\n        this.plugins = [];\r\n        this.scenePlugins = [];\r\n    }\r\n\r\n});\r\n\r\n/*\r\n * \"Sometimes, the elegant implementation is just a function.\r\n * Not a method. Not a class. Not a framework. Just a function.\"\r\n *  -- John Carmack\r\n */\r\n\r\nmodule.exports = PluginManager;\r\n"]},"metadata":{},"sourceType":"script"}