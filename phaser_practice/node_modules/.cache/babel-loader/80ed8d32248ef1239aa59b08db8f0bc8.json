{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar CanvasPool = require('../display/canvas/CanvasPool');\n\nvar CanvasTexture = require('./CanvasTexture');\n\nvar Class = require('../utils/Class');\n\nvar Color = require('../display/color/Color');\n\nvar CONST = require('../const');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar GameEvents = require('../core/events');\n\nvar GenerateTexture = require('../create/GenerateTexture');\n\nvar GetValue = require('../utils/object/GetValue');\n\nvar Parser = require('./parsers');\n\nvar Texture = require('./Texture');\n/**\r\n * @callback EachTextureCallback\r\n *\r\n * @param {Phaser.Textures.Texture} texture - Each texture in Texture Manager.\r\n * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n */\n\n/**\r\n * @classdesc\r\n * Textures are managed by the global TextureManager. This is a singleton class that is\r\n * responsible for creating and delivering Textures and their corresponding Frames to Game Objects.\r\n *\r\n * Sprites and other Game Objects get the texture data they need from the TextureManager.\r\n *\r\n * Access it via `scene.textures`.\r\n *\r\n * @class TextureManager\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Textures\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser.Game instance this Texture Manager belongs to.\r\n */\n\n\nvar TextureManager = new Class({\n  Extends: EventEmitter,\n  initialize: function TextureManager(game) {\n    EventEmitter.call(this);\n    /**\r\n     * The Game that this TextureManager belongs to.\r\n     *\r\n     * @name Phaser.Textures.TextureManager#game\r\n     * @type {Phaser.Game}\r\n     * @since 3.0.0\r\n     */\n\n    this.game = game;\n    /**\r\n     * The name of this manager.\r\n     *\r\n     * @name Phaser.Textures.TextureManager#name\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\n\n    this.name = 'TextureManager';\n    /**\r\n     * An object that has all of textures that Texture Manager creates.\r\n     * Textures are assigned to keys so we can access to any texture that this object has directly by key value without iteration.\r\n     *\r\n     * @name Phaser.Textures.TextureManager#list\r\n     * @type {object}\r\n     * @default {}\r\n     * @since 3.0.0\r\n     */\n\n    this.list = {};\n    /**\r\n     * The temporary canvas element to save an pixel data of an arbitrary texture in getPixel() and getPixelAlpha() method.\r\n     *\r\n     * @name Phaser.Textures.TextureManager#_tempCanvas\r\n     * @type {HTMLCanvasElement}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._tempCanvas = CanvasPool.create2D(this, 1, 1);\n    /**\r\n     * The context of the temporary canvas element made to save an pixel data in getPixel() and getPixelAlpha() method.\r\n     *\r\n     * @name Phaser.Textures.TextureManager#_tempContext\r\n     * @type {CanvasRenderingContext2D}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._tempContext = this._tempCanvas.getContext('2d');\n    /**\r\n     * An counting value used for emitting 'ready' event after all of managers in game is loaded.\r\n     *\r\n     * @name Phaser.Textures.TextureManager#_pending\r\n     * @type {integer}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this._pending = 0;\n    game.events.once(GameEvents.BOOT, this.boot, this);\n  },\n\n  /**\r\n   * The Boot Handler called by Phaser.Game when it first starts up.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#boot\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  boot: function () {\n    this._pending = 2;\n    this.on(Events.LOAD, this.updatePending, this);\n    this.on(Events.ERROR, this.updatePending, this);\n    this.addBase64('__DEFAULT', this.game.config.defaultImage);\n    this.addBase64('__MISSING', this.game.config.missingImage);\n    this.game.events.once(GameEvents.DESTROY, this.destroy, this);\n  },\n\n  /**\r\n   * After 'onload' or 'onerror' invoked twice, emit 'ready' event.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#updatePending\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  updatePending: function () {\n    this._pending--;\n\n    if (this._pending === 0) {\n      this.off(Events.LOAD);\n      this.off(Events.ERROR);\n      this.emit(Events.READY);\n    }\n  },\n\n  /**\r\n   * Checks the given texture key and throws a console.warn if the key is already in use, then returns false.\r\n   * If you wish to avoid the console.warn then use `TextureManager.exists` instead.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#checkKey\r\n   * @since 3.7.0\r\n   *\r\n   * @param {string} key - The texture key to check.\r\n   *\r\n   * @return {boolean} `true` if it's safe to use the texture key, otherwise `false`.\r\n   */\n  checkKey: function (key) {\n    if (this.exists(key)) {\n      // eslint-disable-next-line no-console\n      console.error('Texture key already in use: ' + key);\n      return false;\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Removes a Texture from the Texture Manager and destroys it. This will immediately\r\n   * clear all references to it from the Texture Manager, and if it has one, destroy its\r\n   * WebGLTexture. This will emit a `removetexture` event.\r\n   *\r\n   * Note: If you have any Game Objects still using this texture they will start throwing\r\n   * errors the next time they try to render. Make sure that removing the texture is the final\r\n   * step when clearing down to avoid this.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#remove\r\n   * @fires Phaser.Textures.Events#REMOVE\r\n   * @since 3.7.0\r\n   *\r\n   * @param {(string|Phaser.Textures.Texture)} key - The key of the Texture to remove, or a reference to it.\r\n   *\r\n   * @return {Phaser.Textures.TextureManager} The Texture Manager.\r\n   */\n  remove: function (key) {\n    if (typeof key === 'string') {\n      if (this.exists(key)) {\n        key = this.get(key);\n      } else {\n        console.warn('No texture found matching key: ' + key);\n        return this;\n      }\n    } //  By this point key should be a Texture, if not, the following fails anyway\n\n\n    if (this.list.hasOwnProperty(key.key)) {\n      key.destroy();\n      this.emit(Events.REMOVE, key.key);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes a key from the Texture Manager but does not destroy the Texture that was using the key.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#removeKey\r\n   * @since 3.17.0\r\n   *\r\n   * @param {string} key - The key to remove from the texture list.\r\n   *\r\n   * @return {Phaser.Textures.TextureManager} The Texture Manager.\r\n   */\n  removeKey: function (key) {\n    if (this.list.hasOwnProperty(key)) {\n      delete this.list[key];\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Adds a new Texture to the Texture Manager created from the given Base64 encoded data.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addBase64\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @fires Phaser.Textures.Events#ERROR\r\n   * @fires Phaser.Textures.Events#LOAD\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {*} data - The Base64 encoded data.\r\n   * \r\n   * @return {this} This Texture Manager instance.\r\n   */\n  addBase64: function (key, data) {\n    if (this.checkKey(key)) {\n      var _this = this;\n\n      var image = new Image();\n\n      image.onerror = function () {\n        _this.emit(Events.ERROR, key);\n      };\n\n      image.onload = function () {\n        var texture = _this.create(key, image);\n\n        Parser.Image(texture, 0);\n\n        _this.emit(Events.ADD, key, texture);\n\n        _this.emit(Events.LOAD, key, texture);\n      };\n\n      image.src = data;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Gets an existing texture frame and converts it into a base64 encoded image and returns the base64 data.\r\n   * \r\n   * You can also provide the image type and encoder options.\r\n   * \r\n   * This will only work with bitmap based texture frames, such as those created from Texture Atlases.\r\n   * It will not work with GL Texture objects, such as Shaders, or Render Textures. For those please\r\n   * see the WebGL Snapshot function instead.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#getBase64\r\n   * @since 3.12.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {(string|integer)} [frame] - The string-based name, or integer based index, of the Frame to get from the Texture.\r\n   * @param {string} [type='image/png'] - [description]\r\n   * @param {number} [encoderOptions=0.92] - [description]\r\n   * \r\n   * @return {string} The base64 encoded data, or an empty string if the texture frame could not be found.\r\n   */\n  getBase64: function (key, frame, type, encoderOptions) {\n    if (type === undefined) {\n      type = 'image/png';\n    }\n\n    if (encoderOptions === undefined) {\n      encoderOptions = 0.92;\n    }\n\n    var data = '';\n    var textureFrame = this.getFrame(key, frame);\n\n    if (textureFrame && (textureFrame.source.isRenderTexture || textureFrame.source.isGLTexture)) {\n      console.warn('Cannot getBase64 from WebGL Texture');\n    } else if (textureFrame) {\n      var cd = textureFrame.canvasData;\n      var canvas = CanvasPool.create2D(this, cd.width, cd.height);\n      var ctx = canvas.getContext('2d');\n      ctx.drawImage(textureFrame.source.image, cd.x, cd.y, cd.width, cd.height, 0, 0, cd.width, cd.height);\n      data = canvas.toDataURL(type, encoderOptions);\n      CanvasPool.remove(canvas);\n    }\n\n    return data;\n  },\n\n  /**\r\n   * Adds a new Texture to the Texture Manager created from the given Image element.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addImage\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {HTMLImageElement} source - The source Image element.\r\n   * @param {HTMLImageElement|HTMLCanvasElement} [dataSource] - An optional data Image element.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addImage: function (key, source, dataSource) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = this.create(key, source);\n      Parser.Image(texture, 0);\n\n      if (dataSource) {\n        texture.setDataSource(dataSource);\n      }\n\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Takes a WebGL Texture and creates a Phaser Texture from it, which is added to the Texture Manager using the given key.\r\n   * \r\n   * This allows you to then use the Texture as a normal texture for texture based Game Objects like Sprites.\r\n   * \r\n   * This is a WebGL only feature.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addGLTexture\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.19.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {WebGLTexture} glTexture - The source Render Texture.\r\n   * @param {number} width - The new width of the Texture.\r\n   * @param {number} height - The new height of the Texture.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addGLTexture: function (key, glTexture, width, height) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = this.create(key, glTexture, width, height);\n      texture.add('__BASE', 0, 0, 0, width, height);\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Adds a Render Texture to the Texture Manager using the given key.\r\n   * This allows you to then use the Render Texture as a normal texture for texture based Game Objects like Sprites.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addRenderTexture\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.12.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {Phaser.GameObjects.RenderTexture} renderTexture - The source Render Texture.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addRenderTexture: function (key, renderTexture) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = this.create(key, renderTexture);\n      texture.add('__BASE', 0, 0, 0, renderTexture.width, renderTexture.height);\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Creates a new Texture using the given config values.\r\n   * Generated textures consist of a Canvas element to which the texture data is drawn.\r\n   * See the Phaser.Create function for the more direct way to create textures.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#generate\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {object} config - The configuration object needed to generate the texture.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  generate: function (key, config) {\n    if (this.checkKey(key)) {\n      var canvas = CanvasPool.create(this, 1, 1);\n      config.canvas = canvas;\n      GenerateTexture(config);\n      return this.addCanvas(key, canvas);\n    } else {\n      return null;\n    }\n  },\n\n  /**\r\n   * Creates a new Texture using a blank Canvas element of the size given.\r\n   *\r\n   * Canvas elements are automatically pooled and calling this method will\r\n   * extract a free canvas from the CanvasPool, or create one if none are available.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#createCanvas\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {integer} [width=256] - The width of the Canvas element.\r\n   * @param {integer} [height=256] - The height of the Canvas element.\r\n   *\r\n   * @return {?Phaser.Textures.CanvasTexture} The Canvas Texture that was created, or `null` if the key is already in use.\r\n   */\n  createCanvas: function (key, width, height) {\n    if (width === undefined) {\n      width = 256;\n    }\n\n    if (height === undefined) {\n      height = 256;\n    }\n\n    if (this.checkKey(key)) {\n      var canvas = CanvasPool.create(this, width, height, CONST.CANVAS, true);\n      return this.addCanvas(key, canvas);\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Creates a new Canvas Texture object from an existing Canvas element\r\n   * and adds it to this Texture Manager, unless `skipCache` is true.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addCanvas\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {HTMLCanvasElement} source - The Canvas element to form the base of the new Texture.\r\n   * @param {boolean} [skipCache=false] - Skip adding this Texture into the Cache?\r\n   *\r\n   * @return {?Phaser.Textures.CanvasTexture} The Canvas Texture that was created, or `null` if the key is already in use.\r\n   */\n  addCanvas: function (key, source, skipCache) {\n    if (skipCache === undefined) {\n      skipCache = false;\n    }\n\n    var texture = null;\n\n    if (skipCache) {\n      texture = new CanvasTexture(this, key, source, source.width, source.height);\n    } else if (this.checkKey(key)) {\n      texture = new CanvasTexture(this, key, source, source.width, source.height);\n      this.list[key] = texture;\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Adds a new Texture Atlas to this Texture Manager.\r\n   * It can accept either JSON Array or JSON Hash formats, as exported by Texture Packer and similar software.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addAtlas\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {HTMLImageElement} source - The source Image element.\r\n   * @param {object} data - The Texture Atlas data.\r\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addAtlas: function (key, source, data, dataSource) {\n    //  New Texture Packer format?\n    if (Array.isArray(data.textures) || Array.isArray(data.frames)) {\n      return this.addAtlasJSONArray(key, source, data, dataSource);\n    } else {\n      return this.addAtlasJSONHash(key, source, data, dataSource);\n    }\n  },\n\n  /**\r\n   * Adds a Texture Atlas to this Texture Manager.\r\n   * The frame data of the atlas must be stored in an Array within the JSON.\r\n   * This is known as a JSON Array in software such as Texture Packer.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addAtlasJSONArray\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {(HTMLImageElement|HTMLImageElement[])} source - The source Image element/s.\r\n   * @param {(object|object[])} data - The Texture Atlas data/s.\r\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addAtlasJSONArray: function (key, source, data, dataSource) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = this.create(key, source); //  Multi-Atlas?\n\n      if (Array.isArray(data)) {\n        var singleAtlasFile = data.length === 1; // multi-pack with one atlas file for all images\n        //  !! Assumes the textures are in the same order in the source array as in the json data !!\n\n        for (var i = 0; i < texture.source.length; i++) {\n          var atlasData = singleAtlasFile ? data[0] : data[i];\n          Parser.JSONArray(texture, i, atlasData);\n        }\n      } else {\n        Parser.JSONArray(texture, 0, data);\n      }\n\n      if (dataSource) {\n        texture.setDataSource(dataSource);\n      }\n\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Adds a Texture Atlas to this Texture Manager.\r\n   * The frame data of the atlas must be stored in an Object within the JSON.\r\n   * This is known as a JSON Hash in software such as Texture Packer.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addAtlasJSONHash\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {HTMLImageElement} source - The source Image element.\r\n   * @param {object} data - The Texture Atlas data.\r\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addAtlasJSONHash: function (key, source, data, dataSource) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = this.create(key, source);\n\n      if (Array.isArray(data)) {\n        for (var i = 0; i < data.length; i++) {\n          Parser.JSONHash(texture, i, data[i]);\n        }\n      } else {\n        Parser.JSONHash(texture, 0, data);\n      }\n\n      if (dataSource) {\n        texture.setDataSource(dataSource);\n      }\n\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Adds a Texture Atlas to this Texture Manager, where the atlas data is given\r\n   * in the XML format.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addAtlasXML\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.7.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {HTMLImageElement} source - The source Image element.\r\n   * @param {object} data - The Texture Atlas XML data.\r\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addAtlasXML: function (key, source, data, dataSource) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = this.create(key, source);\n      Parser.AtlasXML(texture, 0, data);\n\n      if (dataSource) {\n        texture.setDataSource(dataSource);\n      }\n\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Adds a Unity Texture Atlas to this Texture Manager.\r\n   * The data must be in the form of a Unity YAML file.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addUnityAtlas\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {HTMLImageElement} source - The source Image element.\r\n   * @param {object} data - The Texture Atlas data.\r\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addUnityAtlas: function (key, source, data, dataSource) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = this.create(key, source);\n      Parser.UnityYAML(texture, 0, data);\n\n      if (dataSource) {\n        texture.setDataSource(dataSource);\n      }\n\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Adds a Sprite Sheet to this Texture Manager.\r\n   *\r\n   * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact\r\n   * same size and cannot be trimmed or rotated.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addSpriteSheet\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {HTMLImageElement} source - The source Image element.\r\n   * @param {Phaser.Types.Textures.SpriteSheetConfig} config - The configuration object for this Sprite Sheet.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addSpriteSheet: function (key, source, config) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = this.create(key, source);\n      var width = texture.source[0].width;\n      var height = texture.source[0].height;\n      Parser.SpriteSheet(texture, 0, 0, 0, width, height, config);\n      this.emit(Events.ADD, key, texture);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Adds a Sprite Sheet to this Texture Manager, where the Sprite Sheet exists as a Frame within a Texture Atlas.\r\n   *\r\n   * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact\r\n   * same size and cannot be trimmed or rotated.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#addSpriteSheetFromAtlas\r\n   * @fires Phaser.Textures.Events#ADD\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {Phaser.Types.Textures.SpriteSheetFromAtlasConfig} config - The configuration object for this Sprite Sheet.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  addSpriteSheetFromAtlas: function (key, config) {\n    if (!this.checkKey(key)) {\n      return null;\n    }\n\n    var atlasKey = GetValue(config, 'atlas', null);\n    var atlasFrame = GetValue(config, 'frame', null);\n\n    if (!atlasKey || !atlasFrame) {\n      return;\n    }\n\n    var atlas = this.get(atlasKey);\n    var sheet = atlas.get(atlasFrame);\n\n    if (sheet) {\n      var texture = this.create(key, sheet.source.image);\n\n      if (sheet.trimmed) {\n        //  If trimmed we need to help the parser adjust\n        Parser.SpriteSheetFromAtlas(texture, sheet, config);\n      } else {\n        Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, config);\n      }\n\n      this.emit(Events.ADD, key, texture);\n      return texture;\n    }\n  },\n\n  /**\r\n   * Creates a new Texture using the given source and dimensions.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#create\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {HTMLImageElement} source - The source Image element.\r\n   * @param {integer} width - The width of the Texture.\r\n   * @param {integer} height - The height of the Texture.\r\n   *\r\n   * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n   */\n  create: function (key, source, width, height) {\n    var texture = null;\n\n    if (this.checkKey(key)) {\n      texture = new Texture(this, key, source, width, height);\n      this.list[key] = texture;\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * Checks the given key to see if a Texture using it exists within this Texture Manager.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#exists\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   *\r\n   * @return {boolean} Returns `true` if a Texture matching the given key exists in this Texture Manager.\r\n   */\n  exists: function (key) {\n    return this.list.hasOwnProperty(key);\n  },\n\n  /**\r\n   * Returns a Texture from the Texture Manager that matches the given key.\r\n   * \r\n   * If the key is `undefined` it will return the `__DEFAULT` Texture.\r\n   * \r\n   * If the key is an instance of a Texture, it will return the key directly.\r\n   * \r\n   * Finally. if the key is given, but not found and not a Texture instance, it will return the `__MISSING` Texture.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#get\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|Phaser.Textures.Texture)} key - The unique string-based key of the Texture, or a Texture instance.\r\n   *\r\n   * @return {Phaser.Textures.Texture} The Texture that was created.\r\n   */\n  get: function (key) {\n    if (key === undefined) {\n      key = '__DEFAULT';\n    }\n\n    if (this.list[key]) {\n      return this.list[key];\n    } else if (key instanceof Texture) {\n      return key;\n    } else {\n      return this.list['__MISSING'];\n    }\n  },\n\n  /**\r\n   * Takes a Texture key and Frame name and returns a clone of that Frame if found.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#cloneFrame\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {(string|integer)} frame - The string or index of the Frame to be cloned.\r\n   *\r\n   * @return {Phaser.Textures.Frame} A Clone of the given Frame.\r\n   */\n  cloneFrame: function (key, frame) {\n    if (this.list[key]) {\n      return this.list[key].get(frame).clone();\n    }\n  },\n\n  /**\r\n   * Takes a Texture key and Frame name and returns a reference to that Frame, if found.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#getFrame\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {(string|integer)} [frame] - The string-based name, or integer based index, of the Frame to get from the Texture.\r\n   *\r\n   * @return {Phaser.Textures.Frame} A Texture Frame object.\r\n   */\n  getFrame: function (key, frame) {\n    if (this.list[key]) {\n      return this.list[key].get(frame);\n    }\n  },\n\n  /**\r\n   * Returns an array with all of the keys of all Textures in this Texture Manager.\r\n   * The output array will exclude the `__DEFAULT` and `__MISSING` keys.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#getTextureKeys\r\n   * @since 3.0.0\r\n   *\r\n   * @return {string[]} An array containing all of the Texture keys stored in this Texture Manager.\r\n   */\n  getTextureKeys: function () {\n    var output = [];\n\n    for (var key in this.list) {\n      if (key !== '__DEFAULT' && key !== '__MISSING') {\n        output.push(key);\n      }\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Given a Texture and an `x` and `y` coordinate this method will return a new\r\n   * Color object that has been populated with the color and alpha values of the pixel\r\n   * at that location in the Texture.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#getPixel\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} x - The x coordinate of the pixel within the Texture.\r\n   * @param {integer} y - The y coordinate of the pixel within the Texture.\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {(string|integer)} [frame] - The string or index of the Frame.\r\n   *\r\n   * @return {?Phaser.Display.Color} A Color object populated with the color values of the requested pixel,\r\n   * or `null` if the coordinates were out of bounds.\r\n   */\n  getPixel: function (x, y, key, frame) {\n    var textureFrame = this.getFrame(key, frame);\n\n    if (textureFrame) {\n      //  Adjust for trim (if not trimmed x and y are just zero)\n      x -= textureFrame.x;\n      y -= textureFrame.y;\n      var data = textureFrame.data.cut;\n      x += data.x;\n      y += data.y;\n\n      if (x >= data.x && x < data.r && y >= data.y && y < data.b) {\n        var ctx = this._tempContext;\n        ctx.clearRect(0, 0, 1, 1);\n        ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);\n        var rgb = ctx.getImageData(0, 0, 1, 1);\n        return new Color(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);\n      }\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Given a Texture and an `x` and `y` coordinate this method will return a value between 0 and 255\r\n   * corresponding to the alpha value of the pixel at that location in the Texture. If the coordinate\r\n   * is out of bounds it will return null.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#getPixelAlpha\r\n   * @since 3.10.0\r\n   *\r\n   * @param {integer} x - The x coordinate of the pixel within the Texture.\r\n   * @param {integer} y - The y coordinate of the pixel within the Texture.\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {(string|integer)} [frame] - The string or index of the Frame.\r\n   *\r\n   * @return {integer} A value between 0 and 255, or `null` if the coordinates were out of bounds.\r\n   */\n  getPixelAlpha: function (x, y, key, frame) {\n    var textureFrame = this.getFrame(key, frame);\n\n    if (textureFrame) {\n      //  Adjust for trim (if not trimmed x and y are just zero)\n      x -= textureFrame.x;\n      y -= textureFrame.y;\n      var data = textureFrame.data.cut;\n      x += data.x;\n      y += data.y;\n\n      if (x >= data.x && x < data.r && y >= data.y && y < data.b) {\n        var ctx = this._tempContext;\n        ctx.clearRect(0, 0, 1, 1);\n        ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);\n        var rgb = ctx.getImageData(0, 0, 1, 1);\n        return rgb.data[3];\n      }\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Sets the given Game Objects `texture` and `frame` properties so that it uses\r\n   * the Texture and Frame specified in the `key` and `frame` arguments to this method.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#setTexture\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object the texture would be set on.\r\n   * @param {string} key - The unique string-based key of the Texture.\r\n   * @param {(string|integer)} [frame] - The string or index of the Frame.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject} The Game Object the texture was set on.\r\n   */\n  setTexture: function (gameObject, key, frame) {\n    if (this.list[key]) {\n      gameObject.texture = this.list[key];\n      gameObject.frame = gameObject.texture.get(frame);\n    }\n\n    return gameObject;\n  },\n\n  /**\r\n   * Changes the key being used by a Texture to the new key provided.\r\n   * \r\n   * The old key is removed, allowing it to be re-used.\r\n   * \r\n   * Game Objects are linked to Textures by a reference to the Texture object, so\r\n   * all existing references will be retained.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#renameTexture\r\n   * @since 3.12.0\r\n   *\r\n   * @param {string} currentKey - The current string-based key of the Texture you wish to rename.\r\n   * @param {string} newKey - The new unique string-based key to use for the Texture.\r\n   *\r\n   * @return {boolean} `true` if the Texture key was successfully renamed, otherwise `false`.\r\n   */\n  renameTexture: function (currentKey, newKey) {\n    var texture = this.get(currentKey);\n\n    if (texture && currentKey !== newKey) {\n      texture.key = newKey;\n      this.list[newKey] = texture;\n      delete this.list[currentKey];\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Passes all Textures to the given callback.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#each\r\n   * @since 3.0.0\r\n   *\r\n   * @param {EachTextureCallback} callback - The callback function to be sent the Textures.\r\n   * @param {object} scope - The value to use as `this` when executing the callback.\r\n   * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n   */\n  each: function (callback, scope) {\n    var args = [null];\n\n    for (var i = 1; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    for (var texture in this.list) {\n      args[0] = this.list[texture];\n      callback.apply(scope, args);\n    }\n  },\n\n  /**\r\n   * Destroys the Texture Manager and all Textures stored within it.\r\n   *\r\n   * @method Phaser.Textures.TextureManager#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    for (var texture in this.list) {\n      this.list[texture].destroy();\n    }\n\n    this.list = {};\n    this.game = null;\n    CanvasPool.remove(this._tempCanvas);\n  }\n});\nmodule.exports = TextureManager;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/textures/TextureManager.js"],"names":["CanvasPool","require","CanvasTexture","Class","Color","CONST","EventEmitter","Events","GameEvents","GenerateTexture","GetValue","Parser","Texture","TextureManager","Extends","initialize","game","call","name","list","_tempCanvas","create2D","_tempContext","getContext","_pending","events","once","BOOT","boot","on","LOAD","updatePending","ERROR","addBase64","config","defaultImage","missingImage","DESTROY","destroy","off","emit","READY","checkKey","key","exists","console","error","remove","get","warn","hasOwnProperty","REMOVE","removeKey","data","_this","image","Image","onerror","onload","texture","create","ADD","src","getBase64","frame","type","encoderOptions","undefined","textureFrame","getFrame","source","isRenderTexture","isGLTexture","cd","canvasData","canvas","width","height","ctx","drawImage","x","y","toDataURL","addImage","dataSource","setDataSource","addGLTexture","glTexture","add","addRenderTexture","renderTexture","generate","addCanvas","createCanvas","CANVAS","skipCache","addAtlas","Array","isArray","textures","frames","addAtlasJSONArray","addAtlasJSONHash","singleAtlasFile","length","i","atlasData","JSONArray","JSONHash","addAtlasXML","AtlasXML","addUnityAtlas","UnityYAML","addSpriteSheet","SpriteSheet","addSpriteSheetFromAtlas","atlasKey","atlasFrame","atlas","sheet","trimmed","SpriteSheetFromAtlas","cutX","cutY","cutWidth","cutHeight","cloneFrame","clone","getTextureKeys","output","push","getPixel","cut","r","b","clearRect","rgb","getImageData","getPixelAlpha","setTexture","gameObject","renameTexture","currentKey","newKey","each","callback","scope","args","arguments","apply","module","exports"],"mappings":"AAAA;;;;;AAMA,IAAIA,UAAU,GAAGC,OAAO,CAAC,8BAAD,CAAxB;;AACA,IAAIC,aAAa,GAAGD,OAAO,CAAC,iBAAD,CAA3B;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,gBAAD,CAAnB;;AACA,IAAIG,KAAK,GAAGH,OAAO,CAAC,wBAAD,CAAnB;;AACA,IAAII,KAAK,GAAGJ,OAAO,CAAC,UAAD,CAAnB;;AACA,IAAIK,YAAY,GAAGL,OAAO,CAAC,eAAD,CAA1B;;AACA,IAAIM,MAAM,GAAGN,OAAO,CAAC,UAAD,CAApB;;AACA,IAAIO,UAAU,GAAGP,OAAO,CAAC,gBAAD,CAAxB;;AACA,IAAIQ,eAAe,GAAGR,OAAO,CAAC,2BAAD,CAA7B;;AACA,IAAIS,QAAQ,GAAGT,OAAO,CAAC,0BAAD,CAAtB;;AACA,IAAIU,MAAM,GAAGV,OAAO,CAAC,WAAD,CAApB;;AACA,IAAIW,OAAO,GAAGX,OAAO,CAAC,WAAD,CAArB;AAEA;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;AAiBA,IAAIY,cAAc,GAAG,IAAIV,KAAJ,CAAU;AAE3BW,EAAAA,OAAO,EAAER,YAFkB;AAI3BS,EAAAA,UAAU,EAEV,SAASF,cAAT,CAAyBG,IAAzB,EACA;AACIV,IAAAA,YAAY,CAACW,IAAb,CAAkB,IAAlB;AAEA;;;;;;;;AAOA,SAAKD,IAAL,GAAYA,IAAZ;AAEA;;;;;;;;AAOA,SAAKE,IAAL,GAAY,gBAAZ;AAEA;;;;;;;;;;AASA,SAAKC,IAAL,GAAY,EAAZ;AAEA;;;;;;;;;AAQA,SAAKC,WAAL,GAAmBpB,UAAU,CAACqB,QAAX,CAAoB,IAApB,EAA0B,CAA1B,EAA6B,CAA7B,CAAnB;AAEA;;;;;;;;;AAQA,SAAKC,YAAL,GAAoB,KAAKF,WAAL,CAAiBG,UAAjB,CAA4B,IAA5B,CAApB;AAEA;;;;;;;;;;AASA,SAAKC,QAAL,GAAgB,CAAhB;AAEAR,IAAAA,IAAI,CAACS,MAAL,CAAYC,IAAZ,CAAiBlB,UAAU,CAACmB,IAA5B,EAAkC,KAAKC,IAAvC,EAA6C,IAA7C;AACH,GAvE0B;;AAyE3B;;;;;;;AAOAA,EAAAA,IAAI,EAAE,YACN;AACI,SAAKJ,QAAL,GAAgB,CAAhB;AAEA,SAAKK,EAAL,CAAQtB,MAAM,CAACuB,IAAf,EAAqB,KAAKC,aAA1B,EAAyC,IAAzC;AACA,SAAKF,EAAL,CAAQtB,MAAM,CAACyB,KAAf,EAAsB,KAAKD,aAA3B,EAA0C,IAA1C;AAEA,SAAKE,SAAL,CAAe,WAAf,EAA4B,KAAKjB,IAAL,CAAUkB,MAAV,CAAiBC,YAA7C;AACA,SAAKF,SAAL,CAAe,WAAf,EAA4B,KAAKjB,IAAL,CAAUkB,MAAV,CAAiBE,YAA7C;AAEA,SAAKpB,IAAL,CAAUS,MAAV,CAAiBC,IAAjB,CAAsBlB,UAAU,CAAC6B,OAAjC,EAA0C,KAAKC,OAA/C,EAAwD,IAAxD;AACH,GA3F0B;;AA6F3B;;;;;;;AAOAP,EAAAA,aAAa,EAAE,YACf;AACI,SAAKP,QAAL;;AAEA,QAAI,KAAKA,QAAL,KAAkB,CAAtB,EACA;AACI,WAAKe,GAAL,CAAShC,MAAM,CAACuB,IAAhB;AACA,WAAKS,GAAL,CAAShC,MAAM,CAACyB,KAAhB;AAEA,WAAKQ,IAAL,CAAUjC,MAAM,CAACkC,KAAjB;AACH;AACJ,GA/G0B;;AAiH3B;;;;;;;;;;;AAWAC,EAAAA,QAAQ,EAAE,UAAUC,GAAV,EACV;AACI,QAAI,KAAKC,MAAL,CAAYD,GAAZ,CAAJ,EACA;AACI;AACAE,MAAAA,OAAO,CAACC,KAAR,CAAc,iCAAiCH,GAA/C;AAEA,aAAO,KAAP;AACH;;AAED,WAAO,IAAP;AACH,GAvI0B;;AAyI3B;;;;;;;;;;;;;;;;;AAiBAI,EAAAA,MAAM,EAAE,UAAUJ,GAAV,EACR;AACI,QAAI,OAAOA,GAAP,KAAe,QAAnB,EACA;AACI,UAAI,KAAKC,MAAL,CAAYD,GAAZ,CAAJ,EACA;AACIA,QAAAA,GAAG,GAAG,KAAKK,GAAL,CAASL,GAAT,CAAN;AACH,OAHD,MAKA;AACIE,QAAAA,OAAO,CAACI,IAAR,CAAa,oCAAoCN,GAAjD;AACA,eAAO,IAAP;AACH;AACJ,KAZL,CAcI;;;AACA,QAAI,KAAKxB,IAAL,CAAU+B,cAAV,CAAyBP,GAAG,CAACA,GAA7B,CAAJ,EACA;AACIA,MAAAA,GAAG,CAACL,OAAJ;AAEA,WAAKE,IAAL,CAAUjC,MAAM,CAAC4C,MAAjB,EAAyBR,GAAG,CAACA,GAA7B;AACH;;AAED,WAAO,IAAP;AACH,GAlL0B;;AAoL3B;;;;;;;;;;AAUAS,EAAAA,SAAS,EAAE,UAAUT,GAAV,EACX;AACI,QAAI,KAAKxB,IAAL,CAAU+B,cAAV,CAAyBP,GAAzB,CAAJ,EACA;AACI,aAAO,KAAKxB,IAAL,CAAUwB,GAAV,CAAP;AACH;;AAED,WAAO,IAAP;AACH,GAtM0B;;AAwM3B;;;;;;;;;;;;;;AAcAV,EAAAA,SAAS,EAAE,UAAUU,GAAV,EAAeU,IAAf,EACX;AACI,QAAI,KAAKX,QAAL,CAAcC,GAAd,CAAJ,EACA;AACI,UAAIW,KAAK,GAAG,IAAZ;;AAEA,UAAIC,KAAK,GAAG,IAAIC,KAAJ,EAAZ;;AAEAD,MAAAA,KAAK,CAACE,OAAN,GAAgB,YAChB;AACIH,QAAAA,KAAK,CAACd,IAAN,CAAWjC,MAAM,CAACyB,KAAlB,EAAyBW,GAAzB;AACH,OAHD;;AAKAY,MAAAA,KAAK,CAACG,MAAN,GAAe,YACf;AACI,YAAIC,OAAO,GAAGL,KAAK,CAACM,MAAN,CAAajB,GAAb,EAAkBY,KAAlB,CAAd;;AAEA5C,QAAAA,MAAM,CAAC6C,KAAP,CAAaG,OAAb,EAAsB,CAAtB;;AAEAL,QAAAA,KAAK,CAACd,IAAN,CAAWjC,MAAM,CAACsD,GAAlB,EAAuBlB,GAAvB,EAA4BgB,OAA5B;;AAEAL,QAAAA,KAAK,CAACd,IAAN,CAAWjC,MAAM,CAACuB,IAAlB,EAAwBa,GAAxB,EAA6BgB,OAA7B;AACH,OATD;;AAWAJ,MAAAA,KAAK,CAACO,GAAN,GAAYT,IAAZ;AACH;;AAED,WAAO,IAAP;AACH,GAlP0B;;AAoP3B;;;;;;;;;;;;;;;;;;;AAmBAU,EAAAA,SAAS,EAAE,UAAUpB,GAAV,EAAeqB,KAAf,EAAsBC,IAAtB,EAA4BC,cAA5B,EACX;AACI,QAAID,IAAI,KAAKE,SAAb,EAAwB;AAAEF,MAAAA,IAAI,GAAG,WAAP;AAAqB;;AAC/C,QAAIC,cAAc,KAAKC,SAAvB,EAAkC;AAAED,MAAAA,cAAc,GAAG,IAAjB;AAAwB;;AAE5D,QAAIb,IAAI,GAAG,EAAX;AAEA,QAAIe,YAAY,GAAG,KAAKC,QAAL,CAAc1B,GAAd,EAAmBqB,KAAnB,CAAnB;;AAEA,QAAII,YAAY,KAAKA,YAAY,CAACE,MAAb,CAAoBC,eAApB,IAAuCH,YAAY,CAACE,MAAb,CAAoBE,WAAhE,CAAhB,EACA;AACI3B,MAAAA,OAAO,CAACI,IAAR,CAAa,qCAAb;AACH,KAHD,MAIK,IAAImB,YAAJ,EACL;AACI,UAAIK,EAAE,GAAGL,YAAY,CAACM,UAAtB;AAEA,UAAIC,MAAM,GAAG3E,UAAU,CAACqB,QAAX,CAAoB,IAApB,EAA0BoD,EAAE,CAACG,KAA7B,EAAoCH,EAAE,CAACI,MAAvC,CAAb;AACA,UAAIC,GAAG,GAAGH,MAAM,CAACpD,UAAP,CAAkB,IAAlB,CAAV;AAEAuD,MAAAA,GAAG,CAACC,SAAJ,CACIX,YAAY,CAACE,MAAb,CAAoBf,KADxB,EAEIkB,EAAE,CAACO,CAFP,EAGIP,EAAE,CAACQ,CAHP,EAIIR,EAAE,CAACG,KAJP,EAKIH,EAAE,CAACI,MALP,EAMI,CANJ,EAOI,CAPJ,EAQIJ,EAAE,CAACG,KARP,EASIH,EAAE,CAACI,MATP;AAYAxB,MAAAA,IAAI,GAAGsB,MAAM,CAACO,SAAP,CAAiBjB,IAAjB,EAAuBC,cAAvB,CAAP;AAEAlE,MAAAA,UAAU,CAAC+C,MAAX,CAAkB4B,MAAlB;AACH;;AAED,WAAOtB,IAAP;AACH,GA7S0B;;AA+S3B;;;;;;;;;;;;;AAaA8B,EAAAA,QAAQ,EAAE,UAAUxC,GAAV,EAAe2B,MAAf,EAAuBc,UAAvB,EACV;AACI,QAAIzB,OAAO,GAAG,IAAd;;AAEA,QAAI,KAAKjB,QAAL,CAAcC,GAAd,CAAJ,EACA;AACIgB,MAAAA,OAAO,GAAG,KAAKC,MAAL,CAAYjB,GAAZ,EAAiB2B,MAAjB,CAAV;AAEA3D,MAAAA,MAAM,CAAC6C,KAAP,CAAaG,OAAb,EAAsB,CAAtB;;AAEA,UAAIyB,UAAJ,EACA;AACIzB,QAAAA,OAAO,CAAC0B,aAAR,CAAsBD,UAAtB;AACH;;AAED,WAAK5C,IAAL,CAAUjC,MAAM,CAACsD,GAAjB,EAAsBlB,GAAtB,EAA2BgB,OAA3B;AACH;;AAED,WAAOA,OAAP;AACH,GA/U0B;;AAiV3B;;;;;;;;;;;;;;;;;;AAkBA2B,EAAAA,YAAY,EAAE,UAAU3C,GAAV,EAAe4C,SAAf,EAA0BX,KAA1B,EAAiCC,MAAjC,EACd;AACI,QAAIlB,OAAO,GAAG,IAAd;;AAEA,QAAI,KAAKjB,QAAL,CAAcC,GAAd,CAAJ,EACA;AACIgB,MAAAA,OAAO,GAAG,KAAKC,MAAL,CAAYjB,GAAZ,EAAiB4C,SAAjB,EAA4BX,KAA5B,EAAmCC,MAAnC,CAAV;AAEAlB,MAAAA,OAAO,CAAC6B,GAAR,CAAY,QAAZ,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+BZ,KAA/B,EAAsCC,MAAtC;AAEA,WAAKrC,IAAL,CAAUjC,MAAM,CAACsD,GAAjB,EAAsBlB,GAAtB,EAA2BgB,OAA3B;AACH;;AAED,WAAOA,OAAP;AACH,GAjX0B;;AAmX3B;;;;;;;;;;;;;AAaA8B,EAAAA,gBAAgB,EAAE,UAAU9C,GAAV,EAAe+C,aAAf,EAClB;AACI,QAAI/B,OAAO,GAAG,IAAd;;AAEA,QAAI,KAAKjB,QAAL,CAAcC,GAAd,CAAJ,EACA;AACIgB,MAAAA,OAAO,GAAG,KAAKC,MAAL,CAAYjB,GAAZ,EAAiB+C,aAAjB,CAAV;AAEA/B,MAAAA,OAAO,CAAC6B,GAAR,CAAY,QAAZ,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+BE,aAAa,CAACd,KAA7C,EAAoDc,aAAa,CAACb,MAAlE;AAEA,WAAKrC,IAAL,CAAUjC,MAAM,CAACsD,GAAjB,EAAsBlB,GAAtB,EAA2BgB,OAA3B;AACH;;AAED,WAAOA,OAAP;AACH,GA9Y0B;;AAgZ3B;;;;;;;;;;;;;AAaAgC,EAAAA,QAAQ,EAAE,UAAUhD,GAAV,EAAeT,MAAf,EACV;AACI,QAAI,KAAKQ,QAAL,CAAcC,GAAd,CAAJ,EACA;AACI,UAAIgC,MAAM,GAAG3E,UAAU,CAAC4D,MAAX,CAAkB,IAAlB,EAAwB,CAAxB,EAA2B,CAA3B,CAAb;AAEA1B,MAAAA,MAAM,CAACyC,MAAP,GAAgBA,MAAhB;AAEAlE,MAAAA,eAAe,CAACyB,MAAD,CAAf;AAEA,aAAO,KAAK0D,SAAL,CAAejD,GAAf,EAAoBgC,MAApB,CAAP;AACH,KATD,MAWA;AACI,aAAO,IAAP;AACH;AACJ,GA7a0B;;AA+a3B;;;;;;;;;;;;;;;AAeAkB,EAAAA,YAAY,EAAE,UAAUlD,GAAV,EAAeiC,KAAf,EAAsBC,MAAtB,EACd;AACI,QAAID,KAAK,KAAKT,SAAd,EAAyB;AAAES,MAAAA,KAAK,GAAG,GAAR;AAAc;;AACzC,QAAIC,MAAM,KAAKV,SAAf,EAA0B;AAAEU,MAAAA,MAAM,GAAG,GAAT;AAAe;;AAE3C,QAAI,KAAKnC,QAAL,CAAcC,GAAd,CAAJ,EACA;AACI,UAAIgC,MAAM,GAAG3E,UAAU,CAAC4D,MAAX,CAAkB,IAAlB,EAAwBgB,KAAxB,EAA+BC,MAA/B,EAAuCxE,KAAK,CAACyF,MAA7C,EAAqD,IAArD,CAAb;AAEA,aAAO,KAAKF,SAAL,CAAejD,GAAf,EAAoBgC,MAApB,CAAP;AACH;;AAED,WAAO,IAAP;AACH,GA3c0B;;AA6c3B;;;;;;;;;;;;;;AAcAiB,EAAAA,SAAS,EAAE,UAAUjD,GAAV,EAAe2B,MAAf,EAAuByB,SAAvB,EACX;AACI,QAAIA,SAAS,KAAK5B,SAAlB,EAA6B;AAAE4B,MAAAA,SAAS,GAAG,KAAZ;AAAoB;;AAEnD,QAAIpC,OAAO,GAAG,IAAd;;AAEA,QAAIoC,SAAJ,EACA;AACIpC,MAAAA,OAAO,GAAG,IAAIzD,aAAJ,CAAkB,IAAlB,EAAwByC,GAAxB,EAA6B2B,MAA7B,EAAqCA,MAAM,CAACM,KAA5C,EAAmDN,MAAM,CAACO,MAA1D,CAAV;AACH,KAHD,MAIK,IAAI,KAAKnC,QAAL,CAAcC,GAAd,CAAJ,EACL;AACIgB,MAAAA,OAAO,GAAG,IAAIzD,aAAJ,CAAkB,IAAlB,EAAwByC,GAAxB,EAA6B2B,MAA7B,EAAqCA,MAAM,CAACM,KAA5C,EAAmDN,MAAM,CAACO,MAA1D,CAAV;AAEA,WAAK1D,IAAL,CAAUwB,GAAV,IAAiBgB,OAAjB;AAEA,WAAKnB,IAAL,CAAUjC,MAAM,CAACsD,GAAjB,EAAsBlB,GAAtB,EAA2BgB,OAA3B;AACH;;AAED,WAAOA,OAAP;AACH,GA/e0B;;AAif3B;;;;;;;;;;;;;;AAcAqC,EAAAA,QAAQ,EAAE,UAAUrD,GAAV,EAAe2B,MAAf,EAAuBjB,IAAvB,EAA6B+B,UAA7B,EACV;AACI;AACA,QAAIa,KAAK,CAACC,OAAN,CAAc7C,IAAI,CAAC8C,QAAnB,KAAgCF,KAAK,CAACC,OAAN,CAAc7C,IAAI,CAAC+C,MAAnB,CAApC,EACA;AACI,aAAO,KAAKC,iBAAL,CAAuB1D,GAAvB,EAA4B2B,MAA5B,EAAoCjB,IAApC,EAA0C+B,UAA1C,CAAP;AACH,KAHD,MAKA;AACI,aAAO,KAAKkB,gBAAL,CAAsB3D,GAAtB,EAA2B2B,MAA3B,EAAmCjB,IAAnC,EAAyC+B,UAAzC,CAAP;AACH;AACJ,GA1gB0B;;AA4gB3B;;;;;;;;;;;;;;;;AAgBAiB,EAAAA,iBAAiB,EAAE,UAAU1D,GAAV,EAAe2B,MAAf,EAAuBjB,IAAvB,EAA6B+B,UAA7B,EACnB;AACI,QAAIzB,OAAO,GAAG,IAAd;;AAEA,QAAI,KAAKjB,QAAL,CAAcC,GAAd,CAAJ,EACA;AACIgB,MAAAA,OAAO,GAAG,KAAKC,MAAL,CAAYjB,GAAZ,EAAiB2B,MAAjB,CAAV,CADJ,CAGI;;AACA,UAAI2B,KAAK,CAACC,OAAN,CAAc7C,IAAd,CAAJ,EACA;AACI,YAAIkD,eAAe,GAAIlD,IAAI,CAACmD,MAAL,KAAgB,CAAvC,CADJ,CAC+C;AAE3C;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG9C,OAAO,CAACW,MAAR,CAAekC,MAAnC,EAA2CC,CAAC,EAA5C,EACA;AACI,cAAIC,SAAS,GAAGH,eAAe,GAAGlD,IAAI,CAAC,CAAD,CAAP,GAAaA,IAAI,CAACoD,CAAD,CAAhD;AAEA9F,UAAAA,MAAM,CAACgG,SAAP,CAAiBhD,OAAjB,EAA0B8C,CAA1B,EAA6BC,SAA7B;AACH;AACJ,OAXD,MAaA;AACI/F,QAAAA,MAAM,CAACgG,SAAP,CAAiBhD,OAAjB,EAA0B,CAA1B,EAA6BN,IAA7B;AACH;;AAED,UAAI+B,UAAJ,EACA;AACIzB,QAAAA,OAAO,CAAC0B,aAAR,CAAsBD,UAAtB;AACH;;AAED,WAAK5C,IAAL,CAAUjC,MAAM,CAACsD,GAAjB,EAAsBlB,GAAtB,EAA2BgB,OAA3B;AACH;;AAED,WAAOA,OAAP;AACH,GA/jB0B;;AAikB3B;;;;;;;;;;;;;;;;AAgBA2C,EAAAA,gBAAgB,EAAE,UAAU3D,GAAV,EAAe2B,MAAf,EAAuBjB,IAAvB,EAA6B+B,UAA7B,EAClB;AACI,QAAIzB,OAAO,GAAG,IAAd;;AAEA,QAAI,KAAKjB,QAAL,CAAcC,GAAd,CAAJ,EACA;AACIgB,MAAAA,OAAO,GAAG,KAAKC,MAAL,CAAYjB,GAAZ,EAAiB2B,MAAjB,CAAV;;AAEA,UAAI2B,KAAK,CAACC,OAAN,CAAc7C,IAAd,CAAJ,EACA;AACI,aAAK,IAAIoD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpD,IAAI,CAACmD,MAAzB,EAAiCC,CAAC,EAAlC,EACA;AACI9F,UAAAA,MAAM,CAACiG,QAAP,CAAgBjD,OAAhB,EAAyB8C,CAAzB,EAA4BpD,IAAI,CAACoD,CAAD,CAAhC;AACH;AACJ,OAND,MAQA;AACI9F,QAAAA,MAAM,CAACiG,QAAP,CAAgBjD,OAAhB,EAAyB,CAAzB,EAA4BN,IAA5B;AACH;;AAED,UAAI+B,UAAJ,EACA;AACIzB,QAAAA,OAAO,CAAC0B,aAAR,CAAsBD,UAAtB;AACH;;AAED,WAAK5C,IAAL,CAAUjC,MAAM,CAACsD,GAAjB,EAAsBlB,GAAtB,EAA2BgB,OAA3B;AACH;;AAED,WAAOA,OAAP;AACH,GA9mB0B;;AAgnB3B;;;;;;;;;;;;;;;AAeAkD,EAAAA,WAAW,EAAE,UAAUlE,GAAV,EAAe2B,MAAf,EAAuBjB,IAAvB,EAA6B+B,UAA7B,EACb;AACI,QAAIzB,OAAO,GAAG,IAAd;;AAEA,QAAI,KAAKjB,QAAL,CAAcC,GAAd,CAAJ,EACA;AACIgB,MAAAA,OAAO,GAAG,KAAKC,MAAL,CAAYjB,GAAZ,EAAiB2B,MAAjB,CAAV;AAEA3D,MAAAA,MAAM,CAACmG,QAAP,CAAgBnD,OAAhB,EAAyB,CAAzB,EAA4BN,IAA5B;;AAEA,UAAI+B,UAAJ,EACA;AACIzB,QAAAA,OAAO,CAAC0B,aAAR,CAAsBD,UAAtB;AACH;;AAED,WAAK5C,IAAL,CAAUjC,MAAM,CAACsD,GAAjB,EAAsBlB,GAAtB,EAA2BgB,OAA3B;AACH;;AAED,WAAOA,OAAP;AACH,GAlpB0B;;AAopB3B;;;;;;;;;;;;;;;AAeAoD,EAAAA,aAAa,EAAE,UAAUpE,GAAV,EAAe2B,MAAf,EAAuBjB,IAAvB,EAA6B+B,UAA7B,EACf;AACI,QAAIzB,OAAO,GAAG,IAAd;;AAEA,QAAI,KAAKjB,QAAL,CAAcC,GAAd,CAAJ,EACA;AACIgB,MAAAA,OAAO,GAAG,KAAKC,MAAL,CAAYjB,GAAZ,EAAiB2B,MAAjB,CAAV;AAEA3D,MAAAA,MAAM,CAACqG,SAAP,CAAiBrD,OAAjB,EAA0B,CAA1B,EAA6BN,IAA7B;;AAEA,UAAI+B,UAAJ,EACA;AACIzB,QAAAA,OAAO,CAAC0B,aAAR,CAAsBD,UAAtB;AACH;;AAED,WAAK5C,IAAL,CAAUjC,MAAM,CAACsD,GAAjB,EAAsBlB,GAAtB,EAA2BgB,OAA3B;AACH;;AAED,WAAOA,OAAP;AACH,GAtrB0B;;AAwrB3B;;;;;;;;;;;;;;;;AAgBAsD,EAAAA,cAAc,EAAE,UAAUtE,GAAV,EAAe2B,MAAf,EAAuBpC,MAAvB,EAChB;AACI,QAAIyB,OAAO,GAAG,IAAd;;AAEA,QAAI,KAAKjB,QAAL,CAAcC,GAAd,CAAJ,EACA;AACIgB,MAAAA,OAAO,GAAG,KAAKC,MAAL,CAAYjB,GAAZ,EAAiB2B,MAAjB,CAAV;AAEA,UAAIM,KAAK,GAAGjB,OAAO,CAACW,MAAR,CAAe,CAAf,EAAkBM,KAA9B;AACA,UAAIC,MAAM,GAAGlB,OAAO,CAACW,MAAR,CAAe,CAAf,EAAkBO,MAA/B;AAEAlE,MAAAA,MAAM,CAACuG,WAAP,CAAmBvD,OAAnB,EAA4B,CAA5B,EAA+B,CAA/B,EAAkC,CAAlC,EAAqCiB,KAArC,EAA4CC,MAA5C,EAAoD3C,MAApD;AAEA,WAAKM,IAAL,CAAUjC,MAAM,CAACsD,GAAjB,EAAsBlB,GAAtB,EAA2BgB,OAA3B;AACH;;AAED,WAAOA,OAAP;AACH,GAztB0B;;AA2tB3B;;;;;;;;;;;;;;;AAeAwD,EAAAA,uBAAuB,EAAE,UAAUxE,GAAV,EAAeT,MAAf,EACzB;AACI,QAAI,CAAC,KAAKQ,QAAL,CAAcC,GAAd,CAAL,EACA;AACI,aAAO,IAAP;AACH;;AAED,QAAIyE,QAAQ,GAAG1G,QAAQ,CAACwB,MAAD,EAAS,OAAT,EAAkB,IAAlB,CAAvB;AACA,QAAImF,UAAU,GAAG3G,QAAQ,CAACwB,MAAD,EAAS,OAAT,EAAkB,IAAlB,CAAzB;;AAEA,QAAI,CAACkF,QAAD,IAAa,CAACC,UAAlB,EACA;AACI;AACH;;AAED,QAAIC,KAAK,GAAG,KAAKtE,GAAL,CAASoE,QAAT,CAAZ;AACA,QAAIG,KAAK,GAAGD,KAAK,CAACtE,GAAN,CAAUqE,UAAV,CAAZ;;AAEA,QAAIE,KAAJ,EACA;AACI,UAAI5D,OAAO,GAAG,KAAKC,MAAL,CAAYjB,GAAZ,EAAiB4E,KAAK,CAACjD,MAAN,CAAaf,KAA9B,CAAd;;AAEA,UAAIgE,KAAK,CAACC,OAAV,EACA;AACI;AACA7G,QAAAA,MAAM,CAAC8G,oBAAP,CAA4B9D,OAA5B,EAAqC4D,KAArC,EAA4CrF,MAA5C;AACH,OAJD,MAMA;AACIvB,QAAAA,MAAM,CAACuG,WAAP,CAAmBvD,OAAnB,EAA4B,CAA5B,EAA+B4D,KAAK,CAACG,IAArC,EAA2CH,KAAK,CAACI,IAAjD,EAAuDJ,KAAK,CAACK,QAA7D,EAAuEL,KAAK,CAACM,SAA7E,EAAwF3F,MAAxF;AACH;;AAED,WAAKM,IAAL,CAAUjC,MAAM,CAACsD,GAAjB,EAAsBlB,GAAtB,EAA2BgB,OAA3B;AAEA,aAAOA,OAAP;AACH;AACJ,GA9wB0B;;AAgxB3B;;;;;;;;;;;;;AAaAC,EAAAA,MAAM,EAAE,UAAUjB,GAAV,EAAe2B,MAAf,EAAuBM,KAAvB,EAA8BC,MAA9B,EACR;AACI,QAAIlB,OAAO,GAAG,IAAd;;AAEA,QAAI,KAAKjB,QAAL,CAAcC,GAAd,CAAJ,EACA;AACIgB,MAAAA,OAAO,GAAG,IAAI/C,OAAJ,CAAY,IAAZ,EAAkB+B,GAAlB,EAAuB2B,MAAvB,EAA+BM,KAA/B,EAAsCC,MAAtC,CAAV;AAEA,WAAK1D,IAAL,CAAUwB,GAAV,IAAiBgB,OAAjB;AACH;;AAED,WAAOA,OAAP;AACH,GAzyB0B;;AA2yB3B;;;;;;;;;;AAUAf,EAAAA,MAAM,EAAE,UAAUD,GAAV,EACR;AACI,WAAQ,KAAKxB,IAAL,CAAU+B,cAAV,CAAyBP,GAAzB,CAAR;AACH,GAxzB0B;;AA0zB3B;;;;;;;;;;;;;;;;AAgBAK,EAAAA,GAAG,EAAE,UAAUL,GAAV,EACL;AACI,QAAIA,GAAG,KAAKwB,SAAZ,EAAuB;AAAExB,MAAAA,GAAG,GAAG,WAAN;AAAoB;;AAE7C,QAAI,KAAKxB,IAAL,CAAUwB,GAAV,CAAJ,EACA;AACI,aAAO,KAAKxB,IAAL,CAAUwB,GAAV,CAAP;AACH,KAHD,MAIK,IAAIA,GAAG,YAAY/B,OAAnB,EACL;AACI,aAAO+B,GAAP;AACH,KAHI,MAKL;AACI,aAAO,KAAKxB,IAAL,CAAU,WAAV,CAAP;AACH;AACJ,GA11B0B;;AA41B3B;;;;;;;;;;;AAWA2G,EAAAA,UAAU,EAAE,UAAUnF,GAAV,EAAeqB,KAAf,EACZ;AACI,QAAI,KAAK7C,IAAL,CAAUwB,GAAV,CAAJ,EACA;AACI,aAAO,KAAKxB,IAAL,CAAUwB,GAAV,EAAeK,GAAf,CAAmBgB,KAAnB,EAA0B+D,KAA1B,EAAP;AACH;AACJ,GA72B0B;;AA+2B3B;;;;;;;;;;;AAWA1D,EAAAA,QAAQ,EAAE,UAAU1B,GAAV,EAAeqB,KAAf,EACV;AACI,QAAI,KAAK7C,IAAL,CAAUwB,GAAV,CAAJ,EACA;AACI,aAAO,KAAKxB,IAAL,CAAUwB,GAAV,EAAeK,GAAf,CAAmBgB,KAAnB,CAAP;AACH;AACJ,GAh4B0B;;AAk4B3B;;;;;;;;;AASAgE,EAAAA,cAAc,EAAE,YAChB;AACI,QAAIC,MAAM,GAAG,EAAb;;AAEA,SAAK,IAAItF,GAAT,IAAgB,KAAKxB,IAArB,EACA;AACI,UAAIwB,GAAG,KAAK,WAAR,IAAuBA,GAAG,KAAK,WAAnC,EACA;AACIsF,QAAAA,MAAM,CAACC,IAAP,CAAYvF,GAAZ;AACH;AACJ;;AAED,WAAOsF,MAAP;AACH,GAx5B0B;;AA05B3B;;;;;;;;;;;;;;;;AAgBAE,EAAAA,QAAQ,EAAE,UAAUnD,CAAV,EAAaC,CAAb,EAAgBtC,GAAhB,EAAqBqB,KAArB,EACV;AACI,QAAII,YAAY,GAAG,KAAKC,QAAL,CAAc1B,GAAd,EAAmBqB,KAAnB,CAAnB;;AAEA,QAAII,YAAJ,EACA;AACI;AACAY,MAAAA,CAAC,IAAIZ,YAAY,CAACY,CAAlB;AACAC,MAAAA,CAAC,IAAIb,YAAY,CAACa,CAAlB;AAEA,UAAI5B,IAAI,GAAGe,YAAY,CAACf,IAAb,CAAkB+E,GAA7B;AAEApD,MAAAA,CAAC,IAAI3B,IAAI,CAAC2B,CAAV;AACAC,MAAAA,CAAC,IAAI5B,IAAI,CAAC4B,CAAV;;AAEA,UAAID,CAAC,IAAI3B,IAAI,CAAC2B,CAAV,IAAeA,CAAC,GAAG3B,IAAI,CAACgF,CAAxB,IAA6BpD,CAAC,IAAI5B,IAAI,CAAC4B,CAAvC,IAA4CA,CAAC,GAAG5B,IAAI,CAACiF,CAAzD,EACA;AACI,YAAIxD,GAAG,GAAG,KAAKxD,YAAf;AAEAwD,QAAAA,GAAG,CAACyD,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB;AACAzD,QAAAA,GAAG,CAACC,SAAJ,CAAcX,YAAY,CAACE,MAAb,CAAoBf,KAAlC,EAAyCyB,CAAzC,EAA4CC,CAA5C,EAA+C,CAA/C,EAAkD,CAAlD,EAAqD,CAArD,EAAwD,CAAxD,EAA2D,CAA3D,EAA8D,CAA9D;AAEA,YAAIuD,GAAG,GAAG1D,GAAG,CAAC2D,YAAJ,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,CAAV;AAEA,eAAO,IAAIrI,KAAJ,CAAUoI,GAAG,CAACnF,IAAJ,CAAS,CAAT,CAAV,EAAuBmF,GAAG,CAACnF,IAAJ,CAAS,CAAT,CAAvB,EAAoCmF,GAAG,CAACnF,IAAJ,CAAS,CAAT,CAApC,EAAiDmF,GAAG,CAACnF,IAAJ,CAAS,CAAT,CAAjD,CAAP;AACH;AACJ;;AAED,WAAO,IAAP;AACH,GAv8B0B;;AAy8B3B;;;;;;;;;;;;;;;AAeAqF,EAAAA,aAAa,EAAE,UAAU1D,CAAV,EAAaC,CAAb,EAAgBtC,GAAhB,EAAqBqB,KAArB,EACf;AACI,QAAII,YAAY,GAAG,KAAKC,QAAL,CAAc1B,GAAd,EAAmBqB,KAAnB,CAAnB;;AAEA,QAAII,YAAJ,EACA;AACI;AACAY,MAAAA,CAAC,IAAIZ,YAAY,CAACY,CAAlB;AACAC,MAAAA,CAAC,IAAIb,YAAY,CAACa,CAAlB;AAEA,UAAI5B,IAAI,GAAGe,YAAY,CAACf,IAAb,CAAkB+E,GAA7B;AAEApD,MAAAA,CAAC,IAAI3B,IAAI,CAAC2B,CAAV;AACAC,MAAAA,CAAC,IAAI5B,IAAI,CAAC4B,CAAV;;AAEA,UAAID,CAAC,IAAI3B,IAAI,CAAC2B,CAAV,IAAeA,CAAC,GAAG3B,IAAI,CAACgF,CAAxB,IAA6BpD,CAAC,IAAI5B,IAAI,CAAC4B,CAAvC,IAA4CA,CAAC,GAAG5B,IAAI,CAACiF,CAAzD,EACA;AACI,YAAIxD,GAAG,GAAG,KAAKxD,YAAf;AAEAwD,QAAAA,GAAG,CAACyD,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB;AACAzD,QAAAA,GAAG,CAACC,SAAJ,CAAcX,YAAY,CAACE,MAAb,CAAoBf,KAAlC,EAAyCyB,CAAzC,EAA4CC,CAA5C,EAA+C,CAA/C,EAAkD,CAAlD,EAAqD,CAArD,EAAwD,CAAxD,EAA2D,CAA3D,EAA8D,CAA9D;AAEA,YAAIuD,GAAG,GAAG1D,GAAG,CAAC2D,YAAJ,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,CAAV;AAEA,eAAOD,GAAG,CAACnF,IAAJ,CAAS,CAAT,CAAP;AACH;AACJ;;AAED,WAAO,IAAP;AACH,GAr/B0B;;AAu/B3B;;;;;;;;;;;;;AAaAsF,EAAAA,UAAU,EAAE,UAAUC,UAAV,EAAsBjG,GAAtB,EAA2BqB,KAA3B,EACZ;AACI,QAAI,KAAK7C,IAAL,CAAUwB,GAAV,CAAJ,EACA;AACIiG,MAAAA,UAAU,CAACjF,OAAX,GAAqB,KAAKxC,IAAL,CAAUwB,GAAV,CAArB;AACAiG,MAAAA,UAAU,CAAC5E,KAAX,GAAmB4E,UAAU,CAACjF,OAAX,CAAmBX,GAAnB,CAAuBgB,KAAvB,CAAnB;AACH;;AAED,WAAO4E,UAAP;AACH,GA7gC0B;;AA+gC3B;;;;;;;;;;;;;;;;AAgBAC,EAAAA,aAAa,EAAE,UAAUC,UAAV,EAAsBC,MAAtB,EACf;AACI,QAAIpF,OAAO,GAAG,KAAKX,GAAL,CAAS8F,UAAT,CAAd;;AAEA,QAAInF,OAAO,IAAImF,UAAU,KAAKC,MAA9B,EACA;AACIpF,MAAAA,OAAO,CAAChB,GAAR,GAAcoG,MAAd;AAEA,WAAK5H,IAAL,CAAU4H,MAAV,IAAoBpF,OAApB;AAEA,aAAO,KAAKxC,IAAL,CAAU2H,UAAV,CAAP;AAEA,aAAO,IAAP;AACH;;AAED,WAAO,KAAP;AACH,GA/iC0B;;AAijC3B;;;;;;;;;;AAUAE,EAAAA,IAAI,EAAE,UAAUC,QAAV,EAAoBC,KAApB,EACN;AACI,QAAIC,IAAI,GAAG,CAAE,IAAF,CAAX;;AAEA,SAAK,IAAI1C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2C,SAAS,CAAC5C,MAA9B,EAAsCC,CAAC,EAAvC,EACA;AACI0C,MAAAA,IAAI,CAACjB,IAAL,CAAUkB,SAAS,CAAC3C,CAAD,CAAnB;AACH;;AAED,SAAK,IAAI9C,OAAT,IAAoB,KAAKxC,IAAzB,EACA;AACIgI,MAAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,KAAKhI,IAAL,CAAUwC,OAAV,CAAV;AAEAsF,MAAAA,QAAQ,CAACI,KAAT,CAAeH,KAAf,EAAsBC,IAAtB;AACH;AACJ,GA1kC0B;;AA4kC3B;;;;;;AAMA7G,EAAAA,OAAO,EAAE,YACT;AACI,SAAK,IAAIqB,OAAT,IAAoB,KAAKxC,IAAzB,EACA;AACI,WAAKA,IAAL,CAAUwC,OAAV,EAAmBrB,OAAnB;AACH;;AAED,SAAKnB,IAAL,GAAY,EAAZ;AAEA,SAAKH,IAAL,GAAY,IAAZ;AAEAhB,IAAAA,UAAU,CAAC+C,MAAX,CAAkB,KAAK3B,WAAvB;AACH;AA9lC0B,CAAV,CAArB;AAkmCAkI,MAAM,CAACC,OAAP,GAAiB1I,cAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CanvasPool = require('../display/canvas/CanvasPool');\r\nvar CanvasTexture = require('./CanvasTexture');\r\nvar Class = require('../utils/Class');\r\nvar Color = require('../display/color/Color');\r\nvar CONST = require('../const');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar GameEvents = require('../core/events');\r\nvar GenerateTexture = require('../create/GenerateTexture');\r\nvar GetValue = require('../utils/object/GetValue');\r\nvar Parser = require('./parsers');\r\nvar Texture = require('./Texture');\r\n\r\n/**\r\n * @callback EachTextureCallback\r\n *\r\n * @param {Phaser.Textures.Texture} texture - Each texture in Texture Manager.\r\n * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Textures are managed by the global TextureManager. This is a singleton class that is\r\n * responsible for creating and delivering Textures and their corresponding Frames to Game Objects.\r\n *\r\n * Sprites and other Game Objects get the texture data they need from the TextureManager.\r\n *\r\n * Access it via `scene.textures`.\r\n *\r\n * @class TextureManager\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Textures\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser.Game instance this Texture Manager belongs to.\r\n */\r\nvar TextureManager = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function TextureManager (game)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The Game that this TextureManager belongs to.\r\n         *\r\n         * @name Phaser.Textures.TextureManager#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * The name of this manager.\r\n         *\r\n         * @name Phaser.Textures.TextureManager#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = 'TextureManager';\r\n\r\n        /**\r\n         * An object that has all of textures that Texture Manager creates.\r\n         * Textures are assigned to keys so we can access to any texture that this object has directly by key value without iteration.\r\n         *\r\n         * @name Phaser.Textures.TextureManager#list\r\n         * @type {object}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */\r\n        this.list = {};\r\n\r\n        /**\r\n         * The temporary canvas element to save an pixel data of an arbitrary texture in getPixel() and getPixelAlpha() method.\r\n         *\r\n         * @name Phaser.Textures.TextureManager#_tempCanvas\r\n         * @type {HTMLCanvasElement}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tempCanvas = CanvasPool.create2D(this, 1, 1);\r\n\r\n        /**\r\n         * The context of the temporary canvas element made to save an pixel data in getPixel() and getPixelAlpha() method.\r\n         *\r\n         * @name Phaser.Textures.TextureManager#_tempContext\r\n         * @type {CanvasRenderingContext2D}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tempContext = this._tempCanvas.getContext('2d');\r\n\r\n        /**\r\n         * An counting value used for emitting 'ready' event after all of managers in game is loaded.\r\n         *\r\n         * @name Phaser.Textures.TextureManager#_pending\r\n         * @type {integer}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._pending = 0;\r\n\r\n        game.events.once(GameEvents.BOOT, this.boot, this);\r\n    },\r\n\r\n    /**\r\n     * The Boot Handler called by Phaser.Game when it first starts up.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#boot\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        this._pending = 2;\r\n\r\n        this.on(Events.LOAD, this.updatePending, this);\r\n        this.on(Events.ERROR, this.updatePending, this);\r\n\r\n        this.addBase64('__DEFAULT', this.game.config.defaultImage);\r\n        this.addBase64('__MISSING', this.game.config.missingImage);\r\n\r\n        this.game.events.once(GameEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * After 'onload' or 'onerror' invoked twice, emit 'ready' event.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#updatePending\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    updatePending: function ()\r\n    {\r\n        this._pending--;\r\n\r\n        if (this._pending === 0)\r\n        {\r\n            this.off(Events.LOAD);\r\n            this.off(Events.ERROR);\r\n\r\n            this.emit(Events.READY);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks the given texture key and throws a console.warn if the key is already in use, then returns false.\r\n     * If you wish to avoid the console.warn then use `TextureManager.exists` instead.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#checkKey\r\n     * @since 3.7.0\r\n     *\r\n     * @param {string} key - The texture key to check.\r\n     *\r\n     * @return {boolean} `true` if it's safe to use the texture key, otherwise `false`.\r\n     */\r\n    checkKey: function (key)\r\n    {\r\n        if (this.exists(key))\r\n        {\r\n            // eslint-disable-next-line no-console\r\n            console.error('Texture key already in use: ' + key);\r\n\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Removes a Texture from the Texture Manager and destroys it. This will immediately\r\n     * clear all references to it from the Texture Manager, and if it has one, destroy its\r\n     * WebGLTexture. This will emit a `removetexture` event.\r\n     *\r\n     * Note: If you have any Game Objects still using this texture they will start throwing\r\n     * errors the next time they try to render. Make sure that removing the texture is the final\r\n     * step when clearing down to avoid this.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#remove\r\n     * @fires Phaser.Textures.Events#REMOVE\r\n     * @since 3.7.0\r\n     *\r\n     * @param {(string|Phaser.Textures.Texture)} key - The key of the Texture to remove, or a reference to it.\r\n     *\r\n     * @return {Phaser.Textures.TextureManager} The Texture Manager.\r\n     */\r\n    remove: function (key)\r\n    {\r\n        if (typeof key === 'string')\r\n        {\r\n            if (this.exists(key))\r\n            {\r\n                key = this.get(key);\r\n            }\r\n            else\r\n            {\r\n                console.warn('No texture found matching key: ' + key);\r\n                return this;\r\n            }\r\n        }\r\n\r\n        //  By this point key should be a Texture, if not, the following fails anyway\r\n        if (this.list.hasOwnProperty(key.key))\r\n        {\r\n            key.destroy();\r\n\r\n            this.emit(Events.REMOVE, key.key);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a key from the Texture Manager but does not destroy the Texture that was using the key.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#removeKey\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} key - The key to remove from the texture list.\r\n     *\r\n     * @return {Phaser.Textures.TextureManager} The Texture Manager.\r\n     */\r\n    removeKey: function (key)\r\n    {\r\n        if (this.list.hasOwnProperty(key))\r\n        {\r\n            delete this.list[key];\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a new Texture to the Texture Manager created from the given Base64 encoded data.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addBase64\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @fires Phaser.Textures.Events#ERROR\r\n     * @fires Phaser.Textures.Events#LOAD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {*} data - The Base64 encoded data.\r\n     * \r\n     * @return {this} This Texture Manager instance.\r\n     */\r\n    addBase64: function (key, data)\r\n    {\r\n        if (this.checkKey(key))\r\n        {\r\n            var _this = this;\r\n\r\n            var image = new Image();\r\n\r\n            image.onerror = function ()\r\n            {\r\n                _this.emit(Events.ERROR, key);\r\n            };\r\n\r\n            image.onload = function ()\r\n            {\r\n                var texture = _this.create(key, image);\r\n\r\n                Parser.Image(texture, 0);\r\n\r\n                _this.emit(Events.ADD, key, texture);\r\n\r\n                _this.emit(Events.LOAD, key, texture);\r\n            };\r\n\r\n            image.src = data;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets an existing texture frame and converts it into a base64 encoded image and returns the base64 data.\r\n     * \r\n     * You can also provide the image type and encoder options.\r\n     * \r\n     * This will only work with bitmap based texture frames, such as those created from Texture Atlases.\r\n     * It will not work with GL Texture objects, such as Shaders, or Render Textures. For those please\r\n     * see the WebGL Snapshot function instead.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#getBase64\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|integer)} [frame] - The string-based name, or integer based index, of the Frame to get from the Texture.\r\n     * @param {string} [type='image/png'] - [description]\r\n     * @param {number} [encoderOptions=0.92] - [description]\r\n     * \r\n     * @return {string} The base64 encoded data, or an empty string if the texture frame could not be found.\r\n     */\r\n    getBase64: function (key, frame, type, encoderOptions)\r\n    {\r\n        if (type === undefined) { type = 'image/png'; }\r\n        if (encoderOptions === undefined) { encoderOptions = 0.92; }\r\n\r\n        var data = '';\r\n\r\n        var textureFrame = this.getFrame(key, frame);\r\n\r\n        if (textureFrame && (textureFrame.source.isRenderTexture || textureFrame.source.isGLTexture))\r\n        {\r\n            console.warn('Cannot getBase64 from WebGL Texture');\r\n        }\r\n        else if (textureFrame)\r\n        {\r\n            var cd = textureFrame.canvasData;\r\n\r\n            var canvas = CanvasPool.create2D(this, cd.width, cd.height);\r\n            var ctx = canvas.getContext('2d');\r\n\r\n            ctx.drawImage(\r\n                textureFrame.source.image,\r\n                cd.x,\r\n                cd.y,\r\n                cd.width,\r\n                cd.height,\r\n                0,\r\n                0,\r\n                cd.width,\r\n                cd.height\r\n            );\r\n\r\n            data = canvas.toDataURL(type, encoderOptions);\r\n\r\n            CanvasPool.remove(canvas);\r\n        }\r\n\r\n        return data;\r\n    },\r\n\r\n    /**\r\n     * Adds a new Texture to the Texture Manager created from the given Image element.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addImage\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {HTMLImageElement|HTMLCanvasElement} [dataSource] - An optional data Image element.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addImage: function (key, source, dataSource)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = this.create(key, source);\r\n\r\n            Parser.Image(texture, 0);\r\n\r\n            if (dataSource)\r\n            {\r\n                texture.setDataSource(dataSource);\r\n            }\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n        \r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Takes a WebGL Texture and creates a Phaser Texture from it, which is added to the Texture Manager using the given key.\r\n     * \r\n     * This allows you to then use the Texture as a normal texture for texture based Game Objects like Sprites.\r\n     * \r\n     * This is a WebGL only feature.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addGLTexture\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.19.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {WebGLTexture} glTexture - The source Render Texture.\r\n     * @param {number} width - The new width of the Texture.\r\n     * @param {number} height - The new height of the Texture.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addGLTexture: function (key, glTexture, width, height)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = this.create(key, glTexture, width, height);\r\n\r\n            texture.add('__BASE', 0, 0, 0, width, height);\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n        \r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Adds a Render Texture to the Texture Manager using the given key.\r\n     * This allows you to then use the Render Texture as a normal texture for texture based Game Objects like Sprites.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addRenderTexture\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {Phaser.GameObjects.RenderTexture} renderTexture - The source Render Texture.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addRenderTexture: function (key, renderTexture)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = this.create(key, renderTexture);\r\n\r\n            texture.add('__BASE', 0, 0, 0, renderTexture.width, renderTexture.height);\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n        \r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Texture using the given config values.\r\n     * Generated textures consist of a Canvas element to which the texture data is drawn.\r\n     * See the Phaser.Create function for the more direct way to create textures.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#generate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {object} config - The configuration object needed to generate the texture.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    generate: function (key, config)\r\n    {\r\n        if (this.checkKey(key))\r\n        {\r\n            var canvas = CanvasPool.create(this, 1, 1);\r\n\r\n            config.canvas = canvas;\r\n\r\n            GenerateTexture(config);\r\n\r\n            return this.addCanvas(key, canvas);\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a new Texture using a blank Canvas element of the size given.\r\n     *\r\n     * Canvas elements are automatically pooled and calling this method will\r\n     * extract a free canvas from the CanvasPool, or create one if none are available.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#createCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {integer} [width=256] - The width of the Canvas element.\r\n     * @param {integer} [height=256] - The height of the Canvas element.\r\n     *\r\n     * @return {?Phaser.Textures.CanvasTexture} The Canvas Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    createCanvas: function (key, width, height)\r\n    {\r\n        if (width === undefined) { width = 256; }\r\n        if (height === undefined) { height = 256; }\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            var canvas = CanvasPool.create(this, width, height, CONST.CANVAS, true);\r\n\r\n            return this.addCanvas(key, canvas);\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Canvas Texture object from an existing Canvas element\r\n     * and adds it to this Texture Manager, unless `skipCache` is true.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addCanvas\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLCanvasElement} source - The Canvas element to form the base of the new Texture.\r\n     * @param {boolean} [skipCache=false] - Skip adding this Texture into the Cache?\r\n     *\r\n     * @return {?Phaser.Textures.CanvasTexture} The Canvas Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addCanvas: function (key, source, skipCache)\r\n    {\r\n        if (skipCache === undefined) { skipCache = false; }\r\n\r\n        var texture = null;\r\n\r\n        if (skipCache)\r\n        {\r\n            texture = new CanvasTexture(this, key, source, source.width, source.height);\r\n        }\r\n        else if (this.checkKey(key))\r\n        {\r\n            texture = new CanvasTexture(this, key, source, source.width, source.height);\r\n\r\n            this.list[key] = texture;\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Adds a new Texture Atlas to this Texture Manager.\r\n     * It can accept either JSON Array or JSON Hash formats, as exported by Texture Packer and similar software.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addAtlas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {object} data - The Texture Atlas data.\r\n     * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addAtlas: function (key, source, data, dataSource)\r\n    {\r\n        //  New Texture Packer format?\r\n        if (Array.isArray(data.textures) || Array.isArray(data.frames))\r\n        {\r\n            return this.addAtlasJSONArray(key, source, data, dataSource);\r\n        }\r\n        else\r\n        {\r\n            return this.addAtlasJSONHash(key, source, data, dataSource);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds a Texture Atlas to this Texture Manager.\r\n     * The frame data of the atlas must be stored in an Array within the JSON.\r\n     * This is known as a JSON Array in software such as Texture Packer.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addAtlasJSONArray\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(HTMLImageElement|HTMLImageElement[])} source - The source Image element/s.\r\n     * @param {(object|object[])} data - The Texture Atlas data/s.\r\n     * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addAtlasJSONArray: function (key, source, data, dataSource)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = this.create(key, source);\r\n\r\n            //  Multi-Atlas?\r\n            if (Array.isArray(data))\r\n            {\r\n                var singleAtlasFile = (data.length === 1); // multi-pack with one atlas file for all images\r\n\r\n                //  !! Assumes the textures are in the same order in the source array as in the json data !!\r\n                for (var i = 0; i < texture.source.length; i++)\r\n                {\r\n                    var atlasData = singleAtlasFile ? data[0] : data[i];\r\n\r\n                    Parser.JSONArray(texture, i, atlasData);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                Parser.JSONArray(texture, 0, data);\r\n            }\r\n\r\n            if (dataSource)\r\n            {\r\n                texture.setDataSource(dataSource);\r\n            }\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Adds a Texture Atlas to this Texture Manager.\r\n     * The frame data of the atlas must be stored in an Object within the JSON.\r\n     * This is known as a JSON Hash in software such as Texture Packer.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addAtlasJSONHash\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {object} data - The Texture Atlas data.\r\n     * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addAtlasJSONHash: function (key, source, data, dataSource)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = this.create(key, source);\r\n\r\n            if (Array.isArray(data))\r\n            {\r\n                for (var i = 0; i < data.length; i++)\r\n                {\r\n                    Parser.JSONHash(texture, i, data[i]);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                Parser.JSONHash(texture, 0, data);\r\n            }\r\n\r\n            if (dataSource)\r\n            {\r\n                texture.setDataSource(dataSource);\r\n            }\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Adds a Texture Atlas to this Texture Manager, where the atlas data is given\r\n     * in the XML format.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addAtlasXML\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.7.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {object} data - The Texture Atlas XML data.\r\n     * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addAtlasXML: function (key, source, data, dataSource)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = this.create(key, source);\r\n            \r\n            Parser.AtlasXML(texture, 0, data);\r\n\r\n            if (dataSource)\r\n            {\r\n                texture.setDataSource(dataSource);\r\n            }\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Adds a Unity Texture Atlas to this Texture Manager.\r\n     * The data must be in the form of a Unity YAML file.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addUnityAtlas\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {object} data - The Texture Atlas data.\r\n     * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addUnityAtlas: function (key, source, data, dataSource)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = this.create(key, source);\r\n\r\n            Parser.UnityYAML(texture, 0, data);\r\n\r\n            if (dataSource)\r\n            {\r\n                texture.setDataSource(dataSource);\r\n            }\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Adds a Sprite Sheet to this Texture Manager.\r\n     *\r\n     * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact\r\n     * same size and cannot be trimmed or rotated.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addSpriteSheet\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {Phaser.Types.Textures.SpriteSheetConfig} config - The configuration object for this Sprite Sheet.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addSpriteSheet: function (key, source, config)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = this.create(key, source);\r\n\r\n            var width = texture.source[0].width;\r\n            var height = texture.source[0].height;\r\n\r\n            Parser.SpriteSheet(texture, 0, 0, 0, width, height, config);\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Adds a Sprite Sheet to this Texture Manager, where the Sprite Sheet exists as a Frame within a Texture Atlas.\r\n     *\r\n     * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact\r\n     * same size and cannot be trimmed or rotated.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addSpriteSheetFromAtlas\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {Phaser.Types.Textures.SpriteSheetFromAtlasConfig} config - The configuration object for this Sprite Sheet.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addSpriteSheetFromAtlas: function (key, config)\r\n    {\r\n        if (!this.checkKey(key))\r\n        {\r\n            return null;\r\n        }\r\n\r\n        var atlasKey = GetValue(config, 'atlas', null);\r\n        var atlasFrame = GetValue(config, 'frame', null);\r\n\r\n        if (!atlasKey || !atlasFrame)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var atlas = this.get(atlasKey);\r\n        var sheet = atlas.get(atlasFrame);\r\n\r\n        if (sheet)\r\n        {\r\n            var texture = this.create(key, sheet.source.image);\r\n\r\n            if (sheet.trimmed)\r\n            {\r\n                //  If trimmed we need to help the parser adjust\r\n                Parser.SpriteSheetFromAtlas(texture, sheet, config);\r\n            }\r\n            else\r\n            {\r\n                Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, config);\r\n            }\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n\r\n            return texture;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a new Texture using the given source and dimensions.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {integer} width - The width of the Texture.\r\n     * @param {integer} height - The height of the Texture.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    create: function (key, source, width, height)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = new Texture(this, key, source, width, height);\r\n\r\n            this.list[key] = texture;\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Checks the given key to see if a Texture using it exists within this Texture Manager.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#exists\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     *\r\n     * @return {boolean} Returns `true` if a Texture matching the given key exists in this Texture Manager.\r\n     */\r\n    exists: function (key)\r\n    {\r\n        return (this.list.hasOwnProperty(key));\r\n    },\r\n\r\n    /**\r\n     * Returns a Texture from the Texture Manager that matches the given key.\r\n     * \r\n     * If the key is `undefined` it will return the `__DEFAULT` Texture.\r\n     * \r\n     * If the key is an instance of a Texture, it will return the key directly.\r\n     * \r\n     * Finally. if the key is given, but not found and not a Texture instance, it will return the `__MISSING` Texture.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Textures.Texture)} key - The unique string-based key of the Texture, or a Texture instance.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was created.\r\n     */\r\n    get: function (key)\r\n    {\r\n        if (key === undefined) { key = '__DEFAULT'; }\r\n\r\n        if (this.list[key])\r\n        {\r\n            return this.list[key];\r\n        }\r\n        else if (key instanceof Texture)\r\n        {\r\n            return key;\r\n        }\r\n        else\r\n        {\r\n            return this.list['__MISSING'];\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Takes a Texture key and Frame name and returns a clone of that Frame if found.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#cloneFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|integer)} frame - The string or index of the Frame to be cloned.\r\n     *\r\n     * @return {Phaser.Textures.Frame} A Clone of the given Frame.\r\n     */\r\n    cloneFrame: function (key, frame)\r\n    {\r\n        if (this.list[key])\r\n        {\r\n            return this.list[key].get(frame).clone();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Takes a Texture key and Frame name and returns a reference to that Frame, if found.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#getFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|integer)} [frame] - The string-based name, or integer based index, of the Frame to get from the Texture.\r\n     *\r\n     * @return {Phaser.Textures.Frame} A Texture Frame object.\r\n     */\r\n    getFrame: function (key, frame)\r\n    {\r\n        if (this.list[key])\r\n        {\r\n            return this.list[key].get(frame);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns an array with all of the keys of all Textures in this Texture Manager.\r\n     * The output array will exclude the `__DEFAULT` and `__MISSING` keys.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#getTextureKeys\r\n     * @since 3.0.0\r\n     *\r\n     * @return {string[]} An array containing all of the Texture keys stored in this Texture Manager.\r\n     */\r\n    getTextureKeys: function ()\r\n    {\r\n        var output = [];\r\n\r\n        for (var key in this.list)\r\n        {\r\n            if (key !== '__DEFAULT' && key !== '__MISSING')\r\n            {\r\n                output.push(key);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Given a Texture and an `x` and `y` coordinate this method will return a new\r\n     * Color object that has been populated with the color and alpha values of the pixel\r\n     * at that location in the Texture.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#getPixel\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} x - The x coordinate of the pixel within the Texture.\r\n     * @param {integer} y - The y coordinate of the pixel within the Texture.\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|integer)} [frame] - The string or index of the Frame.\r\n     *\r\n     * @return {?Phaser.Display.Color} A Color object populated with the color values of the requested pixel,\r\n     * or `null` if the coordinates were out of bounds.\r\n     */\r\n    getPixel: function (x, y, key, frame)\r\n    {\r\n        var textureFrame = this.getFrame(key, frame);\r\n\r\n        if (textureFrame)\r\n        {\r\n            //  Adjust for trim (if not trimmed x and y are just zero)\r\n            x -= textureFrame.x;\r\n            y -= textureFrame.y;\r\n\r\n            var data = textureFrame.data.cut;\r\n\r\n            x += data.x;\r\n            y += data.y;\r\n\r\n            if (x >= data.x && x < data.r && y >= data.y && y < data.b)\r\n            {\r\n                var ctx = this._tempContext;\r\n\r\n                ctx.clearRect(0, 0, 1, 1);\r\n                ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);\r\n\r\n                var rgb = ctx.getImageData(0, 0, 1, 1);\r\n\r\n                return new Color(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Given a Texture and an `x` and `y` coordinate this method will return a value between 0 and 255\r\n     * corresponding to the alpha value of the pixel at that location in the Texture. If the coordinate\r\n     * is out of bounds it will return null.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#getPixelAlpha\r\n     * @since 3.10.0\r\n     *\r\n     * @param {integer} x - The x coordinate of the pixel within the Texture.\r\n     * @param {integer} y - The y coordinate of the pixel within the Texture.\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|integer)} [frame] - The string or index of the Frame.\r\n     *\r\n     * @return {integer} A value between 0 and 255, or `null` if the coordinates were out of bounds.\r\n     */\r\n    getPixelAlpha: function (x, y, key, frame)\r\n    {\r\n        var textureFrame = this.getFrame(key, frame);\r\n\r\n        if (textureFrame)\r\n        {\r\n            //  Adjust for trim (if not trimmed x and y are just zero)\r\n            x -= textureFrame.x;\r\n            y -= textureFrame.y;\r\n\r\n            var data = textureFrame.data.cut;\r\n\r\n            x += data.x;\r\n            y += data.y;\r\n\r\n            if (x >= data.x && x < data.r && y >= data.y && y < data.b)\r\n            {\r\n                var ctx = this._tempContext;\r\n\r\n                ctx.clearRect(0, 0, 1, 1);\r\n                ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);\r\n    \r\n                var rgb = ctx.getImageData(0, 0, 1, 1);\r\n    \r\n                return rgb.data[3];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Sets the given Game Objects `texture` and `frame` properties so that it uses\r\n     * the Texture and Frame specified in the `key` and `frame` arguments to this method.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#setTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object the texture would be set on.\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|integer)} [frame] - The string or index of the Frame.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object the texture was set on.\r\n     */\r\n    setTexture: function (gameObject, key, frame)\r\n    {\r\n        if (this.list[key])\r\n        {\r\n            gameObject.texture = this.list[key];\r\n            gameObject.frame = gameObject.texture.get(frame);\r\n        }\r\n\r\n        return gameObject;\r\n    },\r\n\r\n    /**\r\n     * Changes the key being used by a Texture to the new key provided.\r\n     * \r\n     * The old key is removed, allowing it to be re-used.\r\n     * \r\n     * Game Objects are linked to Textures by a reference to the Texture object, so\r\n     * all existing references will be retained.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#renameTexture\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} currentKey - The current string-based key of the Texture you wish to rename.\r\n     * @param {string} newKey - The new unique string-based key to use for the Texture.\r\n     *\r\n     * @return {boolean} `true` if the Texture key was successfully renamed, otherwise `false`.\r\n     */\r\n    renameTexture: function (currentKey, newKey)\r\n    {\r\n        var texture = this.get(currentKey);\r\n\r\n        if (texture && currentKey !== newKey)\r\n        {\r\n            texture.key = newKey;\r\n\r\n            this.list[newKey] = texture;\r\n\r\n            delete this.list[currentKey];\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Passes all Textures to the given callback.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#each\r\n     * @since 3.0.0\r\n     *\r\n     * @param {EachTextureCallback} callback - The callback function to be sent the Textures.\r\n     * @param {object} scope - The value to use as `this` when executing the callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     */\r\n    each: function (callback, scope)\r\n    {\r\n        var args = [ null ];\r\n\r\n        for (var i = 1; i < arguments.length; i++)\r\n        {\r\n            args.push(arguments[i]);\r\n        }\r\n\r\n        for (var texture in this.list)\r\n        {\r\n            args[0] = this.list[texture];\r\n\r\n            callback.apply(scope, args);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys the Texture Manager and all Textures stored within it.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        for (var texture in this.list)\r\n        {\r\n            this.list[texture].destroy();\r\n        }\r\n\r\n        this.list = {};\r\n\r\n        this.game = null;\r\n\r\n        CanvasPool.remove(this._tempCanvas);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = TextureManager;\r\n"]},"metadata":{},"sourceType":"script"}