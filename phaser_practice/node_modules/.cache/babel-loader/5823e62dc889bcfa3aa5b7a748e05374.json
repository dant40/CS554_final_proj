{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n/**\r\n * @classdesc\r\n * A Geometry Mask can be applied to a Game Object to hide any pixels of it which don't intersect\r\n * a visible pixel from the geometry mask. The mask is essentially a clipping path which can only\r\n * make a masked pixel fully visible or fully invisible without changing its alpha (opacity).\r\n *\r\n * A Geometry Mask uses a Graphics Game Object to determine which pixels of the masked Game Object(s)\r\n * should be clipped. For any given point of a masked Game Object's texture, the pixel will only be displayed\r\n * if the Graphics Game Object of the Geometry Mask has a visible pixel at the same position. The color and\r\n * alpha of the pixel from the Geometry Mask do not matter.\r\n *\r\n * The Geometry Mask's location matches the location of its Graphics object, not the location of the masked objects.\r\n * Moving or transforming the underlying Graphics object will change the mask (and affect the visibility\r\n * of any masked objects), whereas moving or transforming a masked object will not affect the mask.\r\n * You can think of the Geometry Mask (or rather, of its Graphics object) as an invisible curtain placed\r\n * in front of all masked objects which has its own visual properties and, naturally, respects the camera's\r\n * visual properties, but isn't affected by and doesn't follow the masked objects by itself.\r\n *\r\n * @class GeometryMask\r\n * @memberof Phaser.Display.Masks\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - This parameter is not used.\r\n * @param {Phaser.GameObjects.Graphics} graphicsGeometry - The Graphics Game Object to use for the Geometry Mask. Doesn't have to be in the Display List.\r\n */\n\n\nvar GeometryMask = new Class({\n  initialize: function GeometryMask(scene, graphicsGeometry) {\n    /**\r\n     * The Graphics object which describes the Geometry Mask.\r\n     *\r\n     * @name Phaser.Display.Masks.GeometryMask#geometryMask\r\n     * @type {Phaser.GameObjects.Graphics}\r\n     * @since 3.0.0\r\n     */\n    this.geometryMask = graphicsGeometry;\n    /**\r\n     * Similar to the BitmapMasks invertAlpha setting this to true will then hide all pixels\r\n     * drawn to the Geometry Mask.\r\n     *\r\n     * @name Phaser.Display.Masks.GeometryMask#invertAlpha\r\n     * @type {boolean}\r\n     * @since 3.16.0\r\n     */\n\n    this.invertAlpha = false;\n    /**\r\n     * Is this mask a stencil mask?\r\n     *\r\n     * @name Phaser.Display.Masks.GeometryMask#isStencil\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.17.0\r\n     */\n\n    this.isStencil = true;\n    /**\r\n     * The current stencil level.\r\n     *\r\n     * @name Phaser.Display.Masks.GeometryMask#level\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.17.0\r\n     */\n\n    this.level = 0;\n  },\n\n  /**\r\n   * Sets a new Graphics object for the Geometry Mask.\r\n   *\r\n   * @method Phaser.Display.Masks.GeometryMask#setShape\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Graphics} graphicsGeometry - The Graphics object which will be used for the Geometry Mask.\r\n   * \r\n   * @return {this} This Geometry Mask\r\n   */\n  setShape: function (graphicsGeometry) {\n    this.geometryMask = graphicsGeometry;\n    return this;\n  },\n\n  /**\r\n   * Sets the `invertAlpha` property of this Geometry Mask.\r\n   * Inverting the alpha essentially flips the way the mask works.\r\n   *\r\n   * @method Phaser.Display.Masks.GeometryMask#setInvertAlpha\r\n   * @since 3.17.0\r\n   *\r\n   * @param {boolean} [value=true] - Invert the alpha of this mask?\r\n   * \r\n   * @return {this} This Geometry Mask\r\n   */\n  setInvertAlpha: function (value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.invertAlpha = value;\n    return this;\n  },\n\n  /**\r\n   * Renders the Geometry Mask's underlying Graphics object to the OpenGL stencil buffer and enables the stencil test, which clips rendered pixels according to the mask.\r\n   *\r\n   * @method Phaser.Display.Masks.GeometryMask#preRenderWebGL\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer instance to draw to.\r\n   * @param {Phaser.GameObjects.GameObject} child - The Game Object being rendered.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera the Game Object is being rendered through.\r\n   */\n  preRenderWebGL: function (renderer, child, camera) {\n    var gl = renderer.gl; //  Force flushing before drawing to stencil buffer\n\n    renderer.flush();\n\n    if (renderer.maskStack.length === 0) {\n      gl.enable(gl.STENCIL_TEST);\n      gl.clear(gl.STENCIL_BUFFER_BIT);\n      renderer.maskCount = 0;\n    }\n\n    if (renderer.currentCameraMask.mask !== this) {\n      renderer.currentMask.mask = this;\n    }\n\n    renderer.maskStack.push({\n      mask: this,\n      camera: camera\n    });\n    this.applyStencil(renderer, camera, true);\n    renderer.maskCount++;\n  },\n\n  /**\r\n   * Applies the current stencil mask to the renderer.\r\n   *\r\n   * @method Phaser.Display.Masks.GeometryMask#applyStencil\r\n   * @since 3.17.0\r\n   *\r\n   * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer instance to draw to.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera the Game Object is being rendered through.\r\n   * @param {boolean} inc - Is this an INCR stencil or a DECR stencil?\r\n   */\n  applyStencil: function (renderer, camera, inc) {\n    var gl = renderer.gl;\n    var geometryMask = this.geometryMask;\n    var level = renderer.maskCount;\n    gl.colorMask(false, false, false, false);\n\n    if (inc) {\n      gl.stencilFunc(gl.EQUAL, level, 0xFF);\n      gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);\n    } else {\n      gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);\n      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);\n    } //  Write stencil buffer\n\n\n    geometryMask.renderWebGL(renderer, geometryMask, 0, camera);\n    renderer.flush();\n    gl.colorMask(true, true, true, true);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n\n    if (inc) {\n      if (this.invertAlpha) {\n        gl.stencilFunc(gl.NOTEQUAL, level + 1, 0xFF);\n      } else {\n        gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);\n      }\n    } else if (this.invertAlpha) {\n      gl.stencilFunc(gl.NOTEQUAL, level, 0xFF);\n    } else {\n      gl.stencilFunc(gl.EQUAL, level, 0xFF);\n    }\n  },\n\n  /**\r\n   * Flushes all rendered pixels and disables the stencil test of a WebGL context, thus disabling the mask for it.\r\n   *\r\n   * @method Phaser.Display.Masks.GeometryMask#postRenderWebGL\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer instance to draw flush.\r\n   */\n  postRenderWebGL: function (renderer) {\n    var gl = renderer.gl;\n    renderer.maskStack.pop();\n    renderer.maskCount--;\n\n    if (renderer.maskStack.length === 0) {\n      //  If this is the only mask in the stack, flush and disable\n      renderer.flush();\n      renderer.currentMask.mask = null;\n      gl.disable(gl.STENCIL_TEST);\n    } else {\n      //  Force flush before disabling stencil test\n      renderer.flush();\n      var prev = renderer.maskStack[renderer.maskStack.length - 1];\n      prev.mask.applyStencil(renderer, prev.camera, false);\n\n      if (renderer.currentCameraMask.mask !== prev.mask) {\n        renderer.currentMask.mask = prev.mask;\n        renderer.currentMask.camera = prev.camera;\n      } else {\n        renderer.currentMask.mask = null;\n      }\n    }\n  },\n\n  /**\r\n   * Sets the clipping path of a 2D canvas context to the Geometry Mask's underlying Graphics object.\r\n   *\r\n   * @method Phaser.Display.Masks.GeometryMask#preRenderCanvas\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - The Canvas Renderer instance to set the clipping path on.\r\n   * @param {Phaser.GameObjects.GameObject} mask - The Game Object being rendered.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera the Game Object is being rendered through.\r\n   */\n  preRenderCanvas: function (renderer, mask, camera) {\n    var geometryMask = this.geometryMask;\n    renderer.currentContext.save();\n    geometryMask.renderCanvas(renderer, geometryMask, 0, camera, null, null, true);\n    renderer.currentContext.clip();\n  },\n\n  /**\r\n   * Restore the canvas context's previous clipping path, thus turning off the mask for it.\r\n   *\r\n   * @method Phaser.Display.Masks.GeometryMask#postRenderCanvas\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - The Canvas Renderer instance being restored.\r\n   */\n  postRenderCanvas: function (renderer) {\n    renderer.currentContext.restore();\n  },\n\n  /**\r\n   * Destroys this GeometryMask and nulls any references it holds.\r\n   *\r\n   * Note that if a Game Object is currently using this mask it will _not_ automatically detect you have destroyed it,\r\n   * so be sure to call `clearMask` on any Game Object using it, before destroying it.\r\n   *\r\n   * @method Phaser.Display.Masks.GeometryMask#destroy\r\n   * @since 3.7.0\r\n   */\n  destroy: function () {\n    this.geometryMask = null;\n  }\n});\nmodule.exports = GeometryMask;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/display/mask/GeometryMask.js"],"names":["Class","require","GeometryMask","initialize","scene","graphicsGeometry","geometryMask","invertAlpha","isStencil","level","setShape","setInvertAlpha","value","undefined","preRenderWebGL","renderer","child","camera","gl","flush","maskStack","length","enable","STENCIL_TEST","clear","STENCIL_BUFFER_BIT","maskCount","currentCameraMask","mask","currentMask","push","applyStencil","inc","colorMask","stencilFunc","EQUAL","stencilOp","KEEP","INCR","DECR","renderWebGL","NOTEQUAL","postRenderWebGL","pop","disable","prev","preRenderCanvas","currentContext","save","renderCanvas","clip","postRenderCanvas","restore","destroy","module","exports"],"mappings":"AAAA;;;;;AAMA,IAAIA,KAAK,GAAGC,OAAO,CAAC,mBAAD,CAAnB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,IAAIC,YAAY,GAAG,IAAIF,KAAJ,CAAU;AAEzBG,EAAAA,UAAU,EAEV,SAASD,YAAT,CAAuBE,KAAvB,EAA8BC,gBAA9B,EACA;AACI;;;;;;;AAOA,SAAKC,YAAL,GAAoBD,gBAApB;AAEA;;;;;;;;;AAQA,SAAKE,WAAL,GAAmB,KAAnB;AAEA;;;;;;;;;AAQA,SAAKC,SAAL,GAAiB,IAAjB;AAEA;;;;;;;;;AAQA,SAAKC,KAAL,GAAa,CAAb;AACH,GA5CwB;;AA8CzB;;;;;;;;;;AAUAC,EAAAA,QAAQ,EAAE,UAAUL,gBAAV,EACV;AACI,SAAKC,YAAL,GAAoBD,gBAApB;AAEA,WAAO,IAAP;AACH,GA7DwB;;AA+DzB;;;;;;;;;;;AAWAM,EAAAA,cAAc,EAAE,UAAUC,KAAV,EAChB;AACI,QAAIA,KAAK,KAAKC,SAAd,EAAyB;AAAED,MAAAA,KAAK,GAAG,IAAR;AAAe;;AAE1C,SAAKL,WAAL,GAAmBK,KAAnB;AAEA,WAAO,IAAP;AACH,GAjFwB;;AAmFzB;;;;;;;;;;AAUAE,EAAAA,cAAc,EAAE,UAAUC,QAAV,EAAoBC,KAApB,EAA2BC,MAA3B,EAChB;AACI,QAAIC,EAAE,GAAGH,QAAQ,CAACG,EAAlB,CADJ,CAGI;;AACAH,IAAAA,QAAQ,CAACI,KAAT;;AAEA,QAAIJ,QAAQ,CAACK,SAAT,CAAmBC,MAAnB,KAA8B,CAAlC,EACA;AACIH,MAAAA,EAAE,CAACI,MAAH,CAAUJ,EAAE,CAACK,YAAb;AACAL,MAAAA,EAAE,CAACM,KAAH,CAASN,EAAE,CAACO,kBAAZ;AAEAV,MAAAA,QAAQ,CAACW,SAAT,GAAqB,CAArB;AACH;;AAED,QAAIX,QAAQ,CAACY,iBAAT,CAA2BC,IAA3B,KAAoC,IAAxC,EACA;AACIb,MAAAA,QAAQ,CAACc,WAAT,CAAqBD,IAArB,GAA4B,IAA5B;AACH;;AAEDb,IAAAA,QAAQ,CAACK,SAAT,CAAmBU,IAAnB,CAAwB;AAAEF,MAAAA,IAAI,EAAE,IAAR;AAAcX,MAAAA,MAAM,EAAEA;AAAtB,KAAxB;AAEA,SAAKc,YAAL,CAAkBhB,QAAlB,EAA4BE,MAA5B,EAAoC,IAApC;AAEAF,IAAAA,QAAQ,CAACW,SAAT;AACH,GAtHwB;;AAwHzB;;;;;;;;;;AAUAK,EAAAA,YAAY,EAAE,UAAUhB,QAAV,EAAoBE,MAApB,EAA4Be,GAA5B,EACd;AACI,QAAId,EAAE,GAAGH,QAAQ,CAACG,EAAlB;AACA,QAAIZ,YAAY,GAAG,KAAKA,YAAxB;AACA,QAAIG,KAAK,GAAGM,QAAQ,CAACW,SAArB;AAEAR,IAAAA,EAAE,CAACe,SAAH,CAAa,KAAb,EAAoB,KAApB,EAA2B,KAA3B,EAAkC,KAAlC;;AAEA,QAAID,GAAJ,EACA;AACId,MAAAA,EAAE,CAACgB,WAAH,CAAehB,EAAE,CAACiB,KAAlB,EAAyB1B,KAAzB,EAAgC,IAAhC;AACAS,MAAAA,EAAE,CAACkB,SAAH,CAAalB,EAAE,CAACmB,IAAhB,EAAsBnB,EAAE,CAACmB,IAAzB,EAA+BnB,EAAE,CAACoB,IAAlC;AACH,KAJD,MAMA;AACIpB,MAAAA,EAAE,CAACgB,WAAH,CAAehB,EAAE,CAACiB,KAAlB,EAAyB1B,KAAK,GAAG,CAAjC,EAAoC,IAApC;AACAS,MAAAA,EAAE,CAACkB,SAAH,CAAalB,EAAE,CAACmB,IAAhB,EAAsBnB,EAAE,CAACmB,IAAzB,EAA+BnB,EAAE,CAACqB,IAAlC;AACH,KAhBL,CAkBI;;;AACAjC,IAAAA,YAAY,CAACkC,WAAb,CAAyBzB,QAAzB,EAAmCT,YAAnC,EAAiD,CAAjD,EAAoDW,MAApD;AAEAF,IAAAA,QAAQ,CAACI,KAAT;AAEAD,IAAAA,EAAE,CAACe,SAAH,CAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B;AACAf,IAAAA,EAAE,CAACkB,SAAH,CAAalB,EAAE,CAACmB,IAAhB,EAAsBnB,EAAE,CAACmB,IAAzB,EAA+BnB,EAAE,CAACmB,IAAlC;;AAEA,QAAIL,GAAJ,EACA;AACI,UAAI,KAAKzB,WAAT,EACA;AACIW,QAAAA,EAAE,CAACgB,WAAH,CAAehB,EAAE,CAACuB,QAAlB,EAA4BhC,KAAK,GAAG,CAApC,EAAuC,IAAvC;AACH,OAHD,MAKA;AACIS,QAAAA,EAAE,CAACgB,WAAH,CAAehB,EAAE,CAACiB,KAAlB,EAAyB1B,KAAK,GAAG,CAAjC,EAAoC,IAApC;AACH;AACJ,KAVD,MAWK,IAAI,KAAKF,WAAT,EACL;AACIW,MAAAA,EAAE,CAACgB,WAAH,CAAehB,EAAE,CAACuB,QAAlB,EAA4BhC,KAA5B,EAAmC,IAAnC;AACH,KAHI,MAKL;AACIS,MAAAA,EAAE,CAACgB,WAAH,CAAehB,EAAE,CAACiB,KAAlB,EAAyB1B,KAAzB,EAAgC,IAAhC;AACH;AACJ,GAhLwB;;AAkLzB;;;;;;;;AAQAiC,EAAAA,eAAe,EAAE,UAAU3B,QAAV,EACjB;AACI,QAAIG,EAAE,GAAGH,QAAQ,CAACG,EAAlB;AAEAH,IAAAA,QAAQ,CAACK,SAAT,CAAmBuB,GAAnB;AAEA5B,IAAAA,QAAQ,CAACW,SAAT;;AAEA,QAAIX,QAAQ,CAACK,SAAT,CAAmBC,MAAnB,KAA8B,CAAlC,EACA;AACI;AACAN,MAAAA,QAAQ,CAACI,KAAT;AAEAJ,MAAAA,QAAQ,CAACc,WAAT,CAAqBD,IAArB,GAA4B,IAA5B;AAEAV,MAAAA,EAAE,CAAC0B,OAAH,CAAW1B,EAAE,CAACK,YAAd;AACH,KARD,MAUA;AACI;AACAR,MAAAA,QAAQ,CAACI,KAAT;AAEA,UAAI0B,IAAI,GAAG9B,QAAQ,CAACK,SAAT,CAAmBL,QAAQ,CAACK,SAAT,CAAmBC,MAAnB,GAA4B,CAA/C,CAAX;AAEAwB,MAAAA,IAAI,CAACjB,IAAL,CAAUG,YAAV,CAAuBhB,QAAvB,EAAiC8B,IAAI,CAAC5B,MAAtC,EAA8C,KAA9C;;AAEA,UAAIF,QAAQ,CAACY,iBAAT,CAA2BC,IAA3B,KAAoCiB,IAAI,CAACjB,IAA7C,EACA;AACIb,QAAAA,QAAQ,CAACc,WAAT,CAAqBD,IAArB,GAA4BiB,IAAI,CAACjB,IAAjC;AACAb,QAAAA,QAAQ,CAACc,WAAT,CAAqBZ,MAArB,GAA8B4B,IAAI,CAAC5B,MAAnC;AACH,OAJD,MAMA;AACIF,QAAAA,QAAQ,CAACc,WAAT,CAAqBD,IAArB,GAA4B,IAA5B;AACH;AACJ;AACJ,GA9NwB;;AAgOzB;;;;;;;;;;AAUAkB,EAAAA,eAAe,EAAE,UAAU/B,QAAV,EAAoBa,IAApB,EAA0BX,MAA1B,EACjB;AACI,QAAIX,YAAY,GAAG,KAAKA,YAAxB;AAEAS,IAAAA,QAAQ,CAACgC,cAAT,CAAwBC,IAAxB;AAEA1C,IAAAA,YAAY,CAAC2C,YAAb,CAA0BlC,QAA1B,EAAoCT,YAApC,EAAkD,CAAlD,EAAqDW,MAArD,EAA6D,IAA7D,EAAmE,IAAnE,EAAyE,IAAzE;AAEAF,IAAAA,QAAQ,CAACgC,cAAT,CAAwBG,IAAxB;AACH,GAnPwB;;AAqPzB;;;;;;;;AAQAC,EAAAA,gBAAgB,EAAE,UAAUpC,QAAV,EAClB;AACIA,IAAAA,QAAQ,CAACgC,cAAT,CAAwBK,OAAxB;AACH,GAhQwB;;AAkQzB;;;;;;;;;AASAC,EAAAA,OAAO,EAAE,YACT;AACI,SAAK/C,YAAL,GAAoB,IAApB;AACH;AA9QwB,CAAV,CAAnB;AAkRAgD,MAAM,CAACC,OAAP,GAAiBrD,YAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A Geometry Mask can be applied to a Game Object to hide any pixels of it which don't intersect\r\n * a visible pixel from the geometry mask. The mask is essentially a clipping path which can only\r\n * make a masked pixel fully visible or fully invisible without changing its alpha (opacity).\r\n *\r\n * A Geometry Mask uses a Graphics Game Object to determine which pixels of the masked Game Object(s)\r\n * should be clipped. For any given point of a masked Game Object's texture, the pixel will only be displayed\r\n * if the Graphics Game Object of the Geometry Mask has a visible pixel at the same position. The color and\r\n * alpha of the pixel from the Geometry Mask do not matter.\r\n *\r\n * The Geometry Mask's location matches the location of its Graphics object, not the location of the masked objects.\r\n * Moving or transforming the underlying Graphics object will change the mask (and affect the visibility\r\n * of any masked objects), whereas moving or transforming a masked object will not affect the mask.\r\n * You can think of the Geometry Mask (or rather, of its Graphics object) as an invisible curtain placed\r\n * in front of all masked objects which has its own visual properties and, naturally, respects the camera's\r\n * visual properties, but isn't affected by and doesn't follow the masked objects by itself.\r\n *\r\n * @class GeometryMask\r\n * @memberof Phaser.Display.Masks\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - This parameter is not used.\r\n * @param {Phaser.GameObjects.Graphics} graphicsGeometry - The Graphics Game Object to use for the Geometry Mask. Doesn't have to be in the Display List.\r\n */\r\nvar GeometryMask = new Class({\r\n\r\n    initialize:\r\n\r\n    function GeometryMask (scene, graphicsGeometry)\r\n    {\r\n        /**\r\n         * The Graphics object which describes the Geometry Mask.\r\n         *\r\n         * @name Phaser.Display.Masks.GeometryMask#geometryMask\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.0.0\r\n         */\r\n        this.geometryMask = graphicsGeometry;\r\n\r\n        /**\r\n         * Similar to the BitmapMasks invertAlpha setting this to true will then hide all pixels\r\n         * drawn to the Geometry Mask.\r\n         *\r\n         * @name Phaser.Display.Masks.GeometryMask#invertAlpha\r\n         * @type {boolean}\r\n         * @since 3.16.0\r\n         */\r\n        this.invertAlpha = false;\r\n\r\n        /**\r\n         * Is this mask a stencil mask?\r\n         *\r\n         * @name Phaser.Display.Masks.GeometryMask#isStencil\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.isStencil = true;\r\n\r\n        /**\r\n         * The current stencil level.\r\n         *\r\n         * @name Phaser.Display.Masks.GeometryMask#level\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this.level = 0;\r\n    },\r\n\r\n    /**\r\n     * Sets a new Graphics object for the Geometry Mask.\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#setShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphicsGeometry - The Graphics object which will be used for the Geometry Mask.\r\n     * \r\n     * @return {this} This Geometry Mask\r\n     */\r\n    setShape: function (graphicsGeometry)\r\n    {\r\n        this.geometryMask = graphicsGeometry;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the `invertAlpha` property of this Geometry Mask.\r\n     * Inverting the alpha essentially flips the way the mask works.\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#setInvertAlpha\r\n     * @since 3.17.0\r\n     *\r\n     * @param {boolean} [value=true] - Invert the alpha of this mask?\r\n     * \r\n     * @return {this} This Geometry Mask\r\n     */\r\n    setInvertAlpha: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.invertAlpha = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders the Geometry Mask's underlying Graphics object to the OpenGL stencil buffer and enables the stencil test, which clips rendered pixels according to the mask.\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#preRenderWebGL\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer instance to draw to.\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object being rendered.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera the Game Object is being rendered through.\r\n     */\r\n    preRenderWebGL: function (renderer, child, camera)\r\n    {\r\n        var gl = renderer.gl;\r\n\r\n        //  Force flushing before drawing to stencil buffer\r\n        renderer.flush();\r\n\r\n        if (renderer.maskStack.length === 0)\r\n        {\r\n            gl.enable(gl.STENCIL_TEST);\r\n            gl.clear(gl.STENCIL_BUFFER_BIT);\r\n\r\n            renderer.maskCount = 0;\r\n        }\r\n\r\n        if (renderer.currentCameraMask.mask !== this)\r\n        {\r\n            renderer.currentMask.mask = this;\r\n        }\r\n\r\n        renderer.maskStack.push({ mask: this, camera: camera });\r\n\r\n        this.applyStencil(renderer, camera, true);\r\n\r\n        renderer.maskCount++;\r\n    },\r\n\r\n    /**\r\n     * Applies the current stencil mask to the renderer.\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#applyStencil\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer instance to draw to.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera the Game Object is being rendered through.\r\n     * @param {boolean} inc - Is this an INCR stencil or a DECR stencil?\r\n     */\r\n    applyStencil: function (renderer, camera, inc)\r\n    {\r\n        var gl = renderer.gl;\r\n        var geometryMask = this.geometryMask;\r\n        var level = renderer.maskCount;\r\n\r\n        gl.colorMask(false, false, false, false);\r\n\r\n        if (inc)\r\n        {\r\n            gl.stencilFunc(gl.EQUAL, level, 0xFF);\r\n            gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);\r\n        }\r\n        else\r\n        {\r\n            gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);\r\n            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);\r\n        }\r\n\r\n        //  Write stencil buffer\r\n        geometryMask.renderWebGL(renderer, geometryMask, 0, camera);\r\n\r\n        renderer.flush();\r\n\r\n        gl.colorMask(true, true, true, true);\r\n        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\r\n\r\n        if (inc)\r\n        {\r\n            if (this.invertAlpha)\r\n            {\r\n                gl.stencilFunc(gl.NOTEQUAL, level + 1, 0xFF);\r\n            }\r\n            else\r\n            {\r\n                gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);\r\n            }\r\n        }\r\n        else if (this.invertAlpha)\r\n        {\r\n            gl.stencilFunc(gl.NOTEQUAL, level, 0xFF);\r\n        }\r\n        else\r\n        {\r\n            gl.stencilFunc(gl.EQUAL, level, 0xFF);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Flushes all rendered pixels and disables the stencil test of a WebGL context, thus disabling the mask for it.\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#postRenderWebGL\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer instance to draw flush.\r\n     */\r\n    postRenderWebGL: function (renderer)\r\n    {\r\n        var gl = renderer.gl;\r\n\r\n        renderer.maskStack.pop();\r\n\r\n        renderer.maskCount--;\r\n\r\n        if (renderer.maskStack.length === 0)\r\n        {\r\n            //  If this is the only mask in the stack, flush and disable\r\n            renderer.flush();\r\n\r\n            renderer.currentMask.mask = null;\r\n\r\n            gl.disable(gl.STENCIL_TEST);\r\n        }\r\n        else\r\n        {\r\n            //  Force flush before disabling stencil test\r\n            renderer.flush();\r\n\r\n            var prev = renderer.maskStack[renderer.maskStack.length - 1];\r\n\r\n            prev.mask.applyStencil(renderer, prev.camera, false);\r\n\r\n            if (renderer.currentCameraMask.mask !== prev.mask)\r\n            {\r\n                renderer.currentMask.mask = prev.mask;\r\n                renderer.currentMask.camera = prev.camera;\r\n            }\r\n            else\r\n            {\r\n                renderer.currentMask.mask = null;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the clipping path of a 2D canvas context to the Geometry Mask's underlying Graphics object.\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#preRenderCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - The Canvas Renderer instance to set the clipping path on.\r\n     * @param {Phaser.GameObjects.GameObject} mask - The Game Object being rendered.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera the Game Object is being rendered through.\r\n     */\r\n    preRenderCanvas: function (renderer, mask, camera)\r\n    {\r\n        var geometryMask = this.geometryMask;\r\n\r\n        renderer.currentContext.save();\r\n\r\n        geometryMask.renderCanvas(renderer, geometryMask, 0, camera, null, null, true);\r\n\r\n        renderer.currentContext.clip();\r\n    },\r\n\r\n    /**\r\n     * Restore the canvas context's previous clipping path, thus turning off the mask for it.\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#postRenderCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - The Canvas Renderer instance being restored.\r\n     */\r\n    postRenderCanvas: function (renderer)\r\n    {\r\n        renderer.currentContext.restore();\r\n    },\r\n\r\n    /**\r\n     * Destroys this GeometryMask and nulls any references it holds.\r\n     *\r\n     * Note that if a Game Object is currently using this mask it will _not_ automatically detect you have destroyed it,\r\n     * so be sure to call `clearMask` on any Game Object using it, before destroying it.\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#destroy\r\n     * @since 3.7.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.geometryMask = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = GeometryMask;\r\n"]},"metadata":{},"sourceType":"script"}