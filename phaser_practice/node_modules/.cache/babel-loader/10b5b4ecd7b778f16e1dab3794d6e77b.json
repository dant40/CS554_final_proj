{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar TileCheckX = require('./TileCheckX');\n\nvar TileCheckY = require('./TileCheckY');\n\nvar TileIntersectsBody = require('./TileIntersectsBody');\n/**\r\n * The core separation function to separate a physics body and a tile.\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.SeparateTile\r\n * @since 3.0.0\r\n *\r\n * @param {number} i - The index of the tile within the map data.\r\n * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\r\n * @param {Phaser.Tilemaps.Tile} tile - The tile to collide against.\r\n * @param {Phaser.Geom.Rectangle} tileWorldRect - A rectangle-like object defining the dimensions of the tile.\r\n * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The tilemapLayer to collide against.\r\n * @param {number} tileBias - The tile bias value. Populated by the `World.TILE_BIAS` constant.\r\n * @param {boolean} isLayer - Is this check coming from a TilemapLayer or an array of tiles?\r\n *\r\n * @return {boolean} `true` if the body was separated, otherwise `false`.\r\n */\n\n\nvar SeparateTile = function (i, body, tile, tileWorldRect, tilemapLayer, tileBias, isLayer) {\n  var tileLeft = tileWorldRect.left;\n  var tileTop = tileWorldRect.top;\n  var tileRight = tileWorldRect.right;\n  var tileBottom = tileWorldRect.bottom;\n  var faceHorizontal = tile.faceLeft || tile.faceRight;\n  var faceVertical = tile.faceTop || tile.faceBottom;\n\n  if (!isLayer) {\n    faceHorizontal = true;\n    faceVertical = true;\n  } //  We don't need to go any further if this tile doesn't actually have any colliding faces. This\n  //  could happen if the tile was meant to be collided with re: a callback, but otherwise isn't\n  //  needed for separation.\n\n\n  if (!faceHorizontal && !faceVertical) {\n    return false;\n  }\n\n  var ox = 0;\n  var oy = 0;\n  var minX = 0;\n  var minY = 1;\n\n  if (body.deltaAbsX() > body.deltaAbsY()) {\n    //  Moving faster horizontally, check X axis first\n    minX = -1;\n  } else if (body.deltaAbsX() < body.deltaAbsY()) {\n    //  Moving faster vertically, check Y axis first\n    minY = -1;\n  }\n\n  if (body.deltaX() !== 0 && body.deltaY() !== 0 && faceHorizontal && faceVertical) {\n    //  We only need do this if both axes have colliding faces AND we're moving in both\n    //  directions\n    minX = Math.min(Math.abs(body.position.x - tileRight), Math.abs(body.right - tileLeft));\n    minY = Math.min(Math.abs(body.position.y - tileBottom), Math.abs(body.bottom - tileTop));\n  }\n\n  if (minX < minY) {\n    if (faceHorizontal) {\n      ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer); //  That's horizontal done, check if we still intersects? If not then we can return now\n\n      if (ox !== 0 && !TileIntersectsBody(tileWorldRect, body)) {\n        return true;\n      }\n    }\n\n    if (faceVertical) {\n      oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);\n    }\n  } else {\n    if (faceVertical) {\n      oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer); //  That's vertical done, check if we still intersects? If not then we can return now\n\n      if (oy !== 0 && !TileIntersectsBody(tileWorldRect, body)) {\n        return true;\n      }\n    }\n\n    if (faceHorizontal) {\n      ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);\n    }\n  }\n\n  return ox !== 0 || oy !== 0;\n};\n\nmodule.exports = SeparateTile;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/arcade/tilemap/SeparateTile.js"],"names":["TileCheckX","require","TileCheckY","TileIntersectsBody","SeparateTile","i","body","tile","tileWorldRect","tilemapLayer","tileBias","isLayer","tileLeft","left","tileTop","top","tileRight","right","tileBottom","bottom","faceHorizontal","faceLeft","faceRight","faceVertical","faceTop","faceBottom","ox","oy","minX","minY","deltaAbsX","deltaAbsY","deltaX","deltaY","Math","min","abs","position","x","y","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TileCheckX = require('./TileCheckX');\r\nvar TileCheckY = require('./TileCheckY');\r\nvar TileIntersectsBody = require('./TileIntersectsBody');\r\n\r\n/**\r\n * The core separation function to separate a physics body and a tile.\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.SeparateTile\r\n * @since 3.0.0\r\n *\r\n * @param {number} i - The index of the tile within the map data.\r\n * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\r\n * @param {Phaser.Tilemaps.Tile} tile - The tile to collide against.\r\n * @param {Phaser.Geom.Rectangle} tileWorldRect - A rectangle-like object defining the dimensions of the tile.\r\n * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The tilemapLayer to collide against.\r\n * @param {number} tileBias - The tile bias value. Populated by the `World.TILE_BIAS` constant.\r\n * @param {boolean} isLayer - Is this check coming from a TilemapLayer or an array of tiles?\r\n *\r\n * @return {boolean} `true` if the body was separated, otherwise `false`.\r\n */\r\nvar SeparateTile = function (i, body, tile, tileWorldRect, tilemapLayer, tileBias, isLayer)\r\n{\r\n    var tileLeft = tileWorldRect.left;\r\n    var tileTop = tileWorldRect.top;\r\n    var tileRight = tileWorldRect.right;\r\n    var tileBottom = tileWorldRect.bottom;\r\n    var faceHorizontal = tile.faceLeft || tile.faceRight;\r\n    var faceVertical = tile.faceTop || tile.faceBottom;\r\n\r\n    if (!isLayer)\r\n    {\r\n        faceHorizontal = true;\r\n        faceVertical = true;\r\n    }\r\n\r\n    //  We don't need to go any further if this tile doesn't actually have any colliding faces. This\r\n    //  could happen if the tile was meant to be collided with re: a callback, but otherwise isn't\r\n    //  needed for separation.\r\n    if (!faceHorizontal && !faceVertical)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    var ox = 0;\r\n    var oy = 0;\r\n    var minX = 0;\r\n    var minY = 1;\r\n\r\n    if (body.deltaAbsX() > body.deltaAbsY())\r\n    {\r\n        //  Moving faster horizontally, check X axis first\r\n        minX = -1;\r\n    }\r\n    else if (body.deltaAbsX() < body.deltaAbsY())\r\n    {\r\n        //  Moving faster vertically, check Y axis first\r\n        minY = -1;\r\n    }\r\n\r\n    if (body.deltaX() !== 0 && body.deltaY() !== 0 && faceHorizontal && faceVertical)\r\n    {\r\n        //  We only need do this if both axes have colliding faces AND we're moving in both\r\n        //  directions\r\n        minX = Math.min(Math.abs(body.position.x - tileRight), Math.abs(body.right - tileLeft));\r\n        minY = Math.min(Math.abs(body.position.y - tileBottom), Math.abs(body.bottom - tileTop));\r\n    }\r\n\r\n    if (minX < minY)\r\n    {\r\n        if (faceHorizontal)\r\n        {\r\n            ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);\r\n\r\n            //  That's horizontal done, check if we still intersects? If not then we can return now\r\n            if (ox !== 0 && !TileIntersectsBody(tileWorldRect, body))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (faceVertical)\r\n        {\r\n            oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        if (faceVertical)\r\n        {\r\n            oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);\r\n\r\n            //  That's vertical done, check if we still intersects? If not then we can return now\r\n            if (oy !== 0 && !TileIntersectsBody(tileWorldRect, body))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (faceHorizontal)\r\n        {\r\n            ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);\r\n        }\r\n    }\r\n\r\n    return (ox !== 0 || oy !== 0);\r\n};\r\n\r\nmodule.exports = SeparateTile;\r\n"]},"metadata":{},"sourceType":"script"}