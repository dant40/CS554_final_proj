{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\n//  Contains the plugins that Phaser uses globally and locally.\n//  These are the source objects, not instantiated.\nvar corePlugins = {}; //  Contains the plugins that the dev has loaded into their game\n//  These are the source objects, not instantiated.\n\nvar customPlugins = {};\nvar PluginCache = {};\n/**\r\n * @namespace Phaser.Plugins.PluginCache\r\n */\n\n/**\r\n * Static method called directly by the Core internal Plugins.\r\n * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)\r\n * Plugin is the object to instantiate to create the plugin\r\n * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)\r\n *\r\n * @method Phaser.Plugins.PluginCache.register\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {boolean} [custom=false] - Core Scene plugin or a Custom Scene plugin?\r\n */\n\nPluginCache.register = function (key, plugin, mapping, custom) {\n  if (custom === undefined) {\n    custom = false;\n  }\n\n  corePlugins[key] = {\n    plugin: plugin,\n    mapping: mapping,\n    custom: custom\n  };\n};\n/**\r\n * Stores a custom plugin in the global plugin cache.\r\n * The key must be unique, within the scope of the cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.registerCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {?any} data - A value to be passed to the plugin's `init` method.\r\n */\n\n\nPluginCache.registerCustom = function (key, plugin, mapping, data) {\n  customPlugins[key] = {\n    plugin: plugin,\n    mapping: mapping,\n    data: data\n  };\n};\n/**\r\n * Checks if the given key is already being used in the core plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the core cache, otherwise `false`.\r\n */\n\n\nPluginCache.hasCore = function (key) {\n  return corePlugins.hasOwnProperty(key);\n};\n/**\r\n * Checks if the given key is already being used in the custom plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the custom cache, otherwise `false`.\r\n */\n\n\nPluginCache.hasCustom = function (key) {\n  return customPlugins.hasOwnProperty(key);\n};\n/**\r\n * Returns the core plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CorePluginContainer} The core plugin object.\r\n */\n\n\nPluginCache.getCore = function (key) {\n  return corePlugins[key];\n};\n/**\r\n * Returns the custom plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CustomPluginContainer} The custom plugin object.\r\n */\n\n\nPluginCache.getCustom = function (key) {\n  return customPlugins[key];\n};\n/**\r\n * Returns an object from the custom cache based on the given key that can be instantiated.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustomClass\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {function} The custom plugin object.\r\n */\n\n\nPluginCache.getCustomClass = function (key) {\n  return customPlugins.hasOwnProperty(key) ? customPlugins[key].plugin : null;\n};\n/**\r\n * Removes a core plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.remove\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to remove.\r\n */\n\n\nPluginCache.remove = function (key) {\n  if (corePlugins.hasOwnProperty(key)) {\n    delete corePlugins[key];\n  }\n};\n/**\r\n * Removes a custom plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.removeCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to remove.\r\n */\n\n\nPluginCache.removeCustom = function (key) {\n  if (customPlugins.hasOwnProperty(key)) {\n    delete customPlugins[key];\n  }\n};\n/**\r\n * Removes all Core Plugins.\r\n * \r\n * This includes all of the internal system plugins that Phaser needs, like the Input Plugin and Loader Plugin.\r\n * So be sure you only call this if you do not wish to run Phaser again.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCorePlugins\r\n * @since 3.12.0\r\n */\n\n\nPluginCache.destroyCorePlugins = function () {\n  for (var key in corePlugins) {\n    if (corePlugins.hasOwnProperty(key)) {\n      delete corePlugins[key];\n    }\n  }\n};\n/**\r\n * Removes all Custom Plugins.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCustomPlugins\r\n * @since 3.12.0\r\n */\n\n\nPluginCache.destroyCustomPlugins = function () {\n  for (var key in customPlugins) {\n    if (customPlugins.hasOwnProperty(key)) {\n      delete customPlugins[key];\n    }\n  }\n};\n\nmodule.exports = PluginCache;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/plugins/PluginCache.js"],"names":["corePlugins","customPlugins","PluginCache","register","key","plugin","mapping","custom","undefined","registerCustom","data","hasCore","hasOwnProperty","hasCustom","getCore","getCustom","getCustomClass","remove","removeCustom","destroyCorePlugins","destroyCustomPlugins","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Contains the plugins that Phaser uses globally and locally.\r\n//  These are the source objects, not instantiated.\r\nvar corePlugins = {};\r\n\r\n//  Contains the plugins that the dev has loaded into their game\r\n//  These are the source objects, not instantiated.\r\nvar customPlugins = {};\r\n\r\nvar PluginCache = {};\r\n\r\n/**\r\n * @namespace Phaser.Plugins.PluginCache\r\n */\r\n\r\n/**\r\n * Static method called directly by the Core internal Plugins.\r\n * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)\r\n * Plugin is the object to instantiate to create the plugin\r\n * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)\r\n *\r\n * @method Phaser.Plugins.PluginCache.register\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {boolean} [custom=false] - Core Scene plugin or a Custom Scene plugin?\r\n */\r\nPluginCache.register = function (key, plugin, mapping, custom)\r\n{\r\n    if (custom === undefined) { custom = false; }\r\n\r\n    corePlugins[key] = { plugin: plugin, mapping: mapping, custom: custom };\r\n};\r\n\r\n/**\r\n * Stores a custom plugin in the global plugin cache.\r\n * The key must be unique, within the scope of the cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.registerCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {?any} data - A value to be passed to the plugin's `init` method.\r\n */\r\nPluginCache.registerCustom = function (key, plugin, mapping, data)\r\n{\r\n    customPlugins[key] = { plugin: plugin, mapping: mapping, data: data };\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the core plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the core cache, otherwise `false`.\r\n */\r\nPluginCache.hasCore = function (key)\r\n{\r\n    return corePlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the custom plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the custom cache, otherwise `false`.\r\n */\r\nPluginCache.hasCustom = function (key)\r\n{\r\n    return customPlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Returns the core plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CorePluginContainer} The core plugin object.\r\n */\r\nPluginCache.getCore = function (key)\r\n{\r\n    return corePlugins[key];\r\n};\r\n\r\n/**\r\n * Returns the custom plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CustomPluginContainer} The custom plugin object.\r\n */\r\nPluginCache.getCustom = function (key)\r\n{\r\n    return customPlugins[key];\r\n};\r\n\r\n/**\r\n * Returns an object from the custom cache based on the given key that can be instantiated.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustomClass\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {function} The custom plugin object.\r\n */\r\nPluginCache.getCustomClass = function (key)\r\n{\r\n    return (customPlugins.hasOwnProperty(key)) ? customPlugins[key].plugin : null;\r\n};\r\n\r\n/**\r\n * Removes a core plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.remove\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to remove.\r\n */\r\nPluginCache.remove = function (key)\r\n{\r\n    if (corePlugins.hasOwnProperty(key))\r\n    {\r\n        delete corePlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes a custom plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.removeCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to remove.\r\n */\r\nPluginCache.removeCustom = function (key)\r\n{\r\n    if (customPlugins.hasOwnProperty(key))\r\n    {\r\n        delete customPlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Core Plugins.\r\n * \r\n * This includes all of the internal system plugins that Phaser needs, like the Input Plugin and Loader Plugin.\r\n * So be sure you only call this if you do not wish to run Phaser again.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCorePlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCorePlugins = function ()\r\n{\r\n    for (var key in corePlugins)\r\n    {\r\n        if (corePlugins.hasOwnProperty(key))\r\n        {\r\n            delete corePlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Custom Plugins.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCustomPlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCustomPlugins = function ()\r\n{\r\n    for (var key in customPlugins)\r\n    {\r\n        if (customPlugins.hasOwnProperty(key))\r\n        {\r\n            delete customPlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = PluginCache;\r\n"]},"metadata":{},"sourceType":"script"}