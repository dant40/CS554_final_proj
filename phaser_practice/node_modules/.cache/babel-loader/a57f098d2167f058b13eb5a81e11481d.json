{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Actions = require('../../actions/');\n\nvar Class = require('../../utils/Class');\n\nvar Events = require('../events');\n\nvar GetFastValue = require('../../utils/object/GetFastValue');\n\nvar GetValue = require('../../utils/object/GetValue');\n\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\n\nvar Range = require('../../utils/array/Range');\n\nvar Set = require('../../structs/Set');\n\nvar Sprite = require('../sprite/Sprite');\n/**\r\n * @classdesc\r\n * A Group is a way for you to create, manipulate, or recycle similar Game Objects.\r\n *\r\n * Group membership is non-exclusive. A Game Object can belong to several groups, one group, or none.\r\n *\r\n * Groups themselves aren't displayable, and can't be positioned, rotated, scaled, or hidden.\r\n *\r\n * @class Group\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n * @param {Phaser.Scene} scene - The scene this group belongs to.\r\n * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig)} [children] - Game Objects to add to this group; or the `config` argument.\r\n * @param {Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - Settings for this group. If `key` is set, Phaser.GameObjects.Group#createMultiple is also called with these settings.\r\n *\r\n * @see Phaser.Physics.Arcade.Group\r\n * @see Phaser.Physics.Arcade.StaticGroup\r\n */\n\n\nvar Group = new Class({\n  initialize: function Group(scene, children, config) {\n    //  They can pass in any of the following as the first argument:\n    //  1) A single child\n    //  2) An array of children\n    //  3) A config object\n    //  4) An array of config objects\n    //  Or they can pass in a child, or array of children AND a config object\n    if (config) {\n      //  config has been set, are the children an array?\n      if (children && !Array.isArray(children)) {\n        children = [children];\n      }\n    } else if (Array.isArray(children)) {\n      //  No config, so let's check the children argument\n      if (IsPlainObject(children[0])) {\n        //  It's an array of plain config objects\n        config = children;\n        children = null;\n      }\n    } else if (IsPlainObject(children)) {\n      //  Children isn't an array. Is it a config object though?\n      config = children;\n      children = null;\n    }\n    /**\r\n     * This scene this group belongs to.\r\n     *\r\n     * @name Phaser.GameObjects.Group#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.scene = scene;\n    /**\r\n     * Members of this group.\r\n     *\r\n     * @name Phaser.GameObjects.Group#children\r\n     * @type {Phaser.Structs.Set.<Phaser.GameObjects.GameObject>}\r\n     * @since 3.0.0\r\n     */\n\n    this.children = new Set(children);\n    /**\r\n     * A flag identifying this object as a group.\r\n     *\r\n     * @name Phaser.GameObjects.Group#isParent\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.isParent = true;\n    /**\r\n     * A textual representation of this Game Object.\r\n     * Used internally by Phaser but is available for your own custom classes to populate.\r\n     *\r\n     * @name Phaser.GameObjects.Group#type\r\n     * @type {string}\r\n     * @default 'Group'\r\n     * @since 3.21.0\r\n     */\n\n    this.type = 'Group';\n    /**\r\n     * The class to create new group members from.\r\n     *\r\n     * @name Phaser.GameObjects.Group#classType\r\n     * @type {Function}\r\n     * @since 3.0.0\r\n     * @default Phaser.GameObjects.Sprite\r\n     */\n\n    this.classType = GetFastValue(config, 'classType', Sprite);\n    /**\r\n     * The name of this group.\r\n     * Empty by default and never populated by Phaser, this is left for developers to use.\r\n     *\r\n     * @name Phaser.GameObjects.Group#name\r\n     * @type {string}\r\n     * @default ''\r\n     * @since 3.18.0\r\n     */\n\n    this.name = GetFastValue(config, 'name', '');\n    /**\r\n     * Whether this group runs its {@link Phaser.GameObjects.Group#preUpdate} method\r\n     * (which may update any members).\r\n     *\r\n     * @name Phaser.GameObjects.Group#active\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.active = GetFastValue(config, 'active', true);\n    /**\r\n     * The maximum size of this group, if used as a pool. -1 is no limit.\r\n     *\r\n     * @name Phaser.GameObjects.Group#maxSize\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     * @default -1\r\n     */\n\n    this.maxSize = GetFastValue(config, 'maxSize', -1);\n    /**\r\n     * A default texture key to use when creating new group members.\r\n     *\r\n     * This is used in {@link Phaser.GameObjects.Group#create}\r\n     * but not in {@link Phaser.GameObjects.Group#createMultiple}.\r\n     *\r\n     * @name Phaser.GameObjects.Group#defaultKey\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\n\n    this.defaultKey = GetFastValue(config, 'defaultKey', null);\n    /**\r\n     * A default texture frame to use when creating new group members.\r\n     *\r\n     * @name Phaser.GameObjects.Group#defaultFrame\r\n     * @type {(string|integer)}\r\n     * @since 3.0.0\r\n     */\n\n    this.defaultFrame = GetFastValue(config, 'defaultFrame', null);\n    /**\r\n     * Whether to call the update method of any members.\r\n     *\r\n     * @name Phaser.GameObjects.Group#runChildUpdate\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     * @see Phaser.GameObjects.Group#preUpdate\r\n     */\n\n    this.runChildUpdate = GetFastValue(config, 'runChildUpdate', false);\n    /**\r\n     * A function to be called when adding or creating group members.\r\n     *\r\n     * @name Phaser.GameObjects.Group#createCallback\r\n     * @type {?Phaser.Types.GameObjects.Group.GroupCallback}\r\n     * @since 3.0.0\r\n     */\n\n    this.createCallback = GetFastValue(config, 'createCallback', null);\n    /**\r\n     * A function to be called when removing group members.\r\n     *\r\n     * @name Phaser.GameObjects.Group#removeCallback\r\n     * @type {?Phaser.Types.GameObjects.Group.GroupCallback}\r\n     * @since 3.0.0\r\n     */\n\n    this.removeCallback = GetFastValue(config, 'removeCallback', null);\n    /**\r\n     * A function to be called when creating several group members at once.\r\n     *\r\n     * @name Phaser.GameObjects.Group#createMultipleCallback\r\n     * @type {?Phaser.Types.GameObjects.Group.GroupMultipleCreateCallback}\r\n     * @since 3.0.0\r\n     */\n\n    this.createMultipleCallback = GetFastValue(config, 'createMultipleCallback', null);\n    /**\r\n     * A function to be called when adding or creating group members.\r\n     * For internal use only by a Group, or any class that extends it.\r\n     *\r\n     * @name Phaser.GameObjects.Group#internalCreateCallback\r\n     * @type {?Phaser.Types.GameObjects.Group.GroupCallback}\r\n     * @private\r\n     * @since 3.22.0\r\n     */\n\n    this.internalCreateCallback = GetFastValue(config, 'internalCreateCallback', null);\n    /**\r\n     * A function to be called when removing group members.\r\n     * For internal use only by a Group, or any class that extends it.\r\n     *\r\n     * @name Phaser.GameObjects.Group#internalRemoveCallback\r\n     * @type {?Phaser.Types.GameObjects.Group.GroupCallback}\r\n     * @private\r\n     * @since 3.22.0\r\n     */\n\n    this.internalRemoveCallback = GetFastValue(config, 'internalRemoveCallback', null);\n\n    if (config) {\n      this.createMultiple(config);\n    }\n  },\n\n  /**\r\n   * Creates a new Game Object and adds it to this group, unless the group {@link Phaser.GameObjects.Group#isFull is full}.\r\n   *\r\n   * Calls {@link Phaser.GameObjects.Group#createCallback}.\r\n   *\r\n   * @method Phaser.GameObjects.Group#create\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [x=0] - The horizontal position of the new Game Object in the world.\r\n   * @param {number} [y=0] - The vertical position of the new Game Object in the world.\r\n   * @param {string} [key=defaultKey] - The texture key of the new Game Object.\r\n   * @param {(string|integer)} [frame=defaultFrame] - The texture frame of the new Game Object.\r\n   * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of the new Game Object.\r\n   * @param {boolean} [active=true] - The {@link Phaser.GameObjects.GameObject#active} state of the new Game Object.\r\n   *\r\n   * @return {any} The new Game Object (usually a Sprite, etc.).\r\n   */\n  create: function (x, y, key, frame, visible, active) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (key === undefined) {\n      key = this.defaultKey;\n    }\n\n    if (frame === undefined) {\n      frame = this.defaultFrame;\n    }\n\n    if (visible === undefined) {\n      visible = true;\n    }\n\n    if (active === undefined) {\n      active = true;\n    } //  Pool?\n\n\n    if (this.isFull()) {\n      return null;\n    }\n\n    var child = new this.classType(this.scene, x, y, key, frame);\n    this.scene.sys.displayList.add(child);\n\n    if (child.preUpdate) {\n      this.scene.sys.updateList.add(child);\n    }\n\n    child.visible = visible;\n    child.setActive(active);\n    this.add(child);\n    return child;\n  },\n\n  /**\r\n   * Creates several Game Objects and adds them to this group.\r\n   *\r\n   * If the group becomes {@link Phaser.GameObjects.Group#isFull}, no further Game Objects are created.\r\n   *\r\n   * Calls {@link Phaser.GameObjects.Group#createMultipleCallback} and {@link Phaser.GameObjects.Group#createCallback}.\r\n   *\r\n   * @method Phaser.GameObjects.Group#createMultiple\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.GameObjects.Group.GroupCreateConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig[]} config - Creation settings. This can be a single configuration object or an array of such objects, which will be applied in turn.\r\n   *\r\n   * @return {any[]} The newly created Game Objects.\r\n   */\n  createMultiple: function (config) {\n    if (this.isFull()) {\n      return [];\n    }\n\n    if (!Array.isArray(config)) {\n      config = [config];\n    }\n\n    var output = [];\n\n    if (config[0].key) {\n      for (var i = 0; i < config.length; i++) {\n        var entries = this.createFromConfig(config[i]);\n        output = output.concat(entries);\n      }\n    }\n\n    return output;\n  },\n\n  /**\r\n   * A helper for {@link Phaser.GameObjects.Group#createMultiple}.\r\n   *\r\n   * @method Phaser.GameObjects.Group#createFromConfig\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.GameObjects.Group.GroupCreateConfig} options - Creation settings.\r\n   *\r\n   * @return {any[]} The newly created Game Objects.\r\n   */\n  createFromConfig: function (options) {\n    if (this.isFull()) {\n      return [];\n    }\n\n    this.classType = GetFastValue(options, 'classType', this.classType);\n    var key = GetFastValue(options, 'key', undefined);\n    var frame = GetFastValue(options, 'frame', null);\n    var visible = GetFastValue(options, 'visible', true);\n    var active = GetFastValue(options, 'active', true);\n    var entries = []; //  Can't do anything without at least a key\n\n    if (key === undefined) {\n      return entries;\n    } else {\n      if (!Array.isArray(key)) {\n        key = [key];\n      }\n\n      if (!Array.isArray(frame)) {\n        frame = [frame];\n      }\n    } //  Build an array of key frame pairs to loop through\n\n\n    var repeat = GetFastValue(options, 'repeat', 0);\n    var randomKey = GetFastValue(options, 'randomKey', false);\n    var randomFrame = GetFastValue(options, 'randomFrame', false);\n    var yoyo = GetFastValue(options, 'yoyo', false);\n    var quantity = GetFastValue(options, 'quantity', false);\n    var frameQuantity = GetFastValue(options, 'frameQuantity', 1);\n    var max = GetFastValue(options, 'max', 0); //  If a quantity value is set we use that to override the frameQuantity\n\n    var range = Range(key, frame, {\n      max: max,\n      qty: quantity ? quantity : frameQuantity,\n      random: randomKey,\n      randomB: randomFrame,\n      repeat: repeat,\n      yoyo: yoyo\n    });\n\n    if (options.createCallback) {\n      this.createCallback = options.createCallback;\n    }\n\n    if (options.removeCallback) {\n      this.removeCallback = options.removeCallback;\n    }\n\n    for (var c = 0; c < range.length; c++) {\n      var created = this.create(0, 0, range[c].a, range[c].b, visible, active);\n\n      if (!created) {\n        break;\n      }\n\n      entries.push(created);\n    } //  Post-creation options (applied only to those items created in this call):\n\n\n    var x = GetValue(options, 'setXY.x', 0);\n    var y = GetValue(options, 'setXY.y', 0);\n    var stepX = GetValue(options, 'setXY.stepX', 0);\n    var stepY = GetValue(options, 'setXY.stepY', 0);\n    Actions.SetXY(entries, x, y, stepX, stepY);\n    var rotation = GetValue(options, 'setRotation.value', 0);\n    var stepRotation = GetValue(options, 'setRotation.step', 0);\n    Actions.SetRotation(entries, rotation, stepRotation);\n    var scaleX = GetValue(options, 'setScale.x', 1);\n    var scaleY = GetValue(options, 'setScale.y', scaleX);\n    var stepScaleX = GetValue(options, 'setScale.stepX', 0);\n    var stepScaleY = GetValue(options, 'setScale.stepY', 0);\n    Actions.SetScale(entries, scaleX, scaleY, stepScaleX, stepScaleY);\n    var alpha = GetValue(options, 'setAlpha.value', 1);\n    var stepAlpha = GetValue(options, 'setAlpha.step', 0);\n    Actions.SetAlpha(entries, alpha, stepAlpha);\n    var depth = GetValue(options, 'setDepth.value', 0);\n    var stepDepth = GetValue(options, 'setDepth.step', 0);\n    Actions.SetDepth(entries, depth, stepDepth);\n    var scrollFactorX = GetValue(options, 'setScrollFactor.x', 1);\n    var scrollFactorY = GetValue(options, 'setScrollFactor.y', scrollFactorX);\n    var stepScrollFactorX = GetValue(options, 'setScrollFactor.stepX', 0);\n    var stepScrollFactorY = GetValue(options, 'setScrollFactor.stepY', 0);\n    Actions.SetScrollFactor(entries, scrollFactorX, scrollFactorY, stepScrollFactorX, stepScrollFactorY);\n    var hitArea = GetFastValue(options, 'hitArea', null);\n    var hitAreaCallback = GetFastValue(options, 'hitAreaCallback', null);\n\n    if (hitArea) {\n      Actions.SetHitArea(entries, hitArea, hitAreaCallback);\n    }\n\n    var grid = GetFastValue(options, 'gridAlign', false);\n\n    if (grid) {\n      Actions.GridAlign(entries, grid);\n    }\n\n    if (this.createMultipleCallback) {\n      this.createMultipleCallback.call(this, entries);\n    }\n\n    return entries;\n  },\n\n  /**\r\n   * Updates any group members, if {@link Phaser.GameObjects.Group#runChildUpdate} is enabled.\r\n   *\r\n   * @method Phaser.GameObjects.Group#preUpdate\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} time - The current timestamp.\r\n   * @param {number} delta - The delta time elapsed since the last frame.\r\n   */\n  preUpdate: function (time, delta) {\n    if (!this.runChildUpdate || this.children.size === 0) {\n      return;\n    } //  Because a Group child may mess with the length of the Group during its update\n\n\n    var temp = this.children.entries.slice();\n\n    for (var i = 0; i < temp.length; i++) {\n      var item = temp[i];\n\n      if (item.active) {\n        item.update(time, delta);\n      }\n    }\n  },\n\n  /**\r\n   * Adds a Game Object to this group.\r\n   *\r\n   * Calls {@link Phaser.GameObjects.Group#createCallback}.\r\n   *\r\n   * @method Phaser.GameObjects.Group#add\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} child - The Game Object to add.\r\n   * @param {boolean} [addToScene=false] - Also add the Game Object to the scene.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  add: function (child, addToScene) {\n    if (addToScene === undefined) {\n      addToScene = false;\n    }\n\n    if (this.isFull()) {\n      return this;\n    }\n\n    this.children.set(child);\n\n    if (this.internalCreateCallback) {\n      this.internalCreateCallback.call(this, child);\n    }\n\n    if (this.createCallback) {\n      this.createCallback.call(this, child);\n    }\n\n    if (addToScene) {\n      this.scene.sys.displayList.add(child);\n\n      if (child.preUpdate) {\n        this.scene.sys.updateList.add(child);\n      }\n    }\n\n    child.on(Events.DESTROY, this.remove, this);\n    return this;\n  },\n\n  /**\r\n   * Adds several Game Objects to this group.\r\n   *\r\n   * Calls {@link Phaser.GameObjects.Group#createCallback}.\r\n   *\r\n   * @method Phaser.GameObjects.Group#addMultiple\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject[]} children - The Game Objects to add.\r\n   * @param {boolean} [addToScene=false] - Also add the Game Objects to the scene.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This group.\r\n   */\n  addMultiple: function (children, addToScene) {\n    if (addToScene === undefined) {\n      addToScene = false;\n    }\n\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        this.add(children[i], addToScene);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes a member of this Group and optionally removes it from the Scene and / or destroys it.\r\n   *\r\n   * Calls {@link Phaser.GameObjects.Group#removeCallback}.\r\n   *\r\n   * @method Phaser.GameObjects.Group#remove\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} child - The Game Object to remove.\r\n   * @param {boolean} [removeFromScene=false] - Optionally remove the Group member from the Scene it belongs to.\r\n   * @param {boolean} [destroyChild=false] - Optionally call destroy on the removed Group member.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  remove: function (child, removeFromScene, destroyChild) {\n    if (removeFromScene === undefined) {\n      removeFromScene = false;\n    }\n\n    if (destroyChild === undefined) {\n      destroyChild = false;\n    }\n\n    if (!this.children.contains(child)) {\n      return this;\n    }\n\n    this.children.delete(child);\n\n    if (this.internalRemoveCallback) {\n      this.internalRemoveCallback.call(this, child);\n    }\n\n    if (this.removeCallback) {\n      this.removeCallback.call(this, child);\n    }\n\n    child.off(Events.DESTROY, this.remove, this);\n\n    if (destroyChild) {\n      child.destroy();\n    } else if (removeFromScene) {\n      child.scene.sys.displayList.remove(child);\n\n      if (child.preUpdate) {\n        child.scene.sys.updateList.remove(child);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes all members of this Group and optionally removes them from the Scene and / or destroys them.\r\n   *\r\n   * Does not call {@link Phaser.GameObjects.Group#removeCallback}.\r\n   *\r\n   * @method Phaser.GameObjects.Group#clear\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [removeFromScene=false] - Optionally remove each Group member from the Scene.\r\n   * @param {boolean} [destroyChild=false] - Optionally call destroy on the removed Group members.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This group.\r\n   */\n  clear: function (removeFromScene, destroyChild) {\n    if (removeFromScene === undefined) {\n      removeFromScene = false;\n    }\n\n    if (destroyChild === undefined) {\n      destroyChild = false;\n    }\n\n    var children = this.children;\n\n    for (var i = 0; i < children.size; i++) {\n      var gameObject = children.entries[i];\n      gameObject.off(Events.DESTROY, this.remove, this);\n\n      if (destroyChild) {\n        gameObject.destroy();\n      } else if (removeFromScene) {\n        gameObject.scene.sys.displayList.remove(gameObject);\n\n        if (gameObject.preUpdate) {\n          gameObject.scene.sys.updateList.remove(gameObject);\n        }\n      }\n    }\n\n    this.children.clear();\n    return this;\n  },\n\n  /**\r\n   * Tests if a Game Object is a member of this group.\r\n   *\r\n   * @method Phaser.GameObjects.Group#contains\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} child - A Game Object.\r\n   *\r\n   * @return {boolean} True if the Game Object is a member of this group.\r\n   */\n  contains: function (child) {\n    return this.children.contains(child);\n  },\n\n  /**\r\n   * All members of the group.\r\n   *\r\n   * @method Phaser.GameObjects.Group#getChildren\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject[]} The group members.\r\n   */\n  getChildren: function () {\n    return this.children.entries;\n  },\n\n  /**\r\n   * The number of members of the group.\r\n   *\r\n   * @method Phaser.GameObjects.Group#getLength\r\n   * @since 3.0.0\r\n   *\r\n   * @return {integer}\r\n   */\n  getLength: function () {\n    return this.children.size;\n  },\n\n  /**\r\n   * Scans the Group, from top to bottom, for the first member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n   * assigns `x` and `y`, and returns the member.\r\n   *\r\n   * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n   * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n   *\r\n   * @method Phaser.GameObjects.Group#getFirst\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n   * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n   * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n   * @param {number} [y] - The vertical position of the Game Object in the world.\r\n   * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n   * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n   * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n   *\r\n   * @return {?any} The first matching group member, or a newly created member, or null.\r\n   */\n  getFirst: function (state, createIfNull, x, y, key, frame, visible) {\n    return this.getHandler(true, 1, state, createIfNull, x, y, key, frame, visible);\n  },\n\n  /**\r\n   * Scans the Group, from top to bottom, for the nth member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n   * assigns `x` and `y`, and returns the member.\r\n   *\r\n   * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n   * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n   *\r\n   * @method Phaser.GameObjects.Group#getFirstNth\r\n   * @since 3.6.0\r\n   *\r\n   * @param {integer} nth - The nth matching Group member to search for.\r\n   * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n   * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n   * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n   * @param {number} [y] - The vertical position of the Game Object in the world.\r\n   * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n   * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n   * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n   *\r\n   * @return {?any} The first matching group member, or a newly created member, or null.\r\n   */\n  getFirstNth: function (nth, state, createIfNull, x, y, key, frame, visible) {\n    return this.getHandler(true, nth, state, createIfNull, x, y, key, frame, visible);\n  },\n\n  /**\r\n   * Scans the Group for the last member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n   * assigns `x` and `y`, and returns the member.\r\n   *\r\n   * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n   * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n   *\r\n   * @method Phaser.GameObjects.Group#getLast\r\n   * @since 3.6.0\r\n   *\r\n   * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n   * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n   * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n   * @param {number} [y] - The vertical position of the Game Object in the world.\r\n   * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n   * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n   * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n   *\r\n   * @return {?any} The first matching group member, or a newly created member, or null.\r\n   */\n  getLast: function (state, createIfNull, x, y, key, frame, visible) {\n    return this.getHandler(false, 1, state, createIfNull, x, y, key, frame, visible);\n  },\n\n  /**\r\n   * Scans the Group for the last nth member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n   * assigns `x` and `y`, and returns the member.\r\n   *\r\n   * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n   * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n   *\r\n   * @method Phaser.GameObjects.Group#getLastNth\r\n   * @since 3.6.0\r\n   *\r\n   * @param {integer} nth - The nth matching Group member to search for.\r\n   * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n   * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n   * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n   * @param {number} [y] - The vertical position of the Game Object in the world.\r\n   * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n   * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n   * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n   *\r\n   * @return {?any} The first matching group member, or a newly created member, or null.\r\n   */\n  getLastNth: function (nth, state, createIfNull, x, y, key, frame, visible) {\n    return this.getHandler(false, nth, state, createIfNull, x, y, key, frame, visible);\n  },\n\n  /**\r\n   * Scans the group for the last member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n   * assigns `x` and `y`, and returns the member.\r\n   *\r\n   * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n   * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n   *\r\n   * @method Phaser.GameObjects.Group#getHandler\r\n   * @private\r\n   * @since 3.6.0\r\n   *\r\n   * @param {boolean} forwards - Search front to back or back to front?\r\n   * @param {integer} nth - Stop matching after nth successful matches.\r\n   * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n   * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n   * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n   * @param {number} [y] - The vertical position of the Game Object in the world.\r\n   * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n   * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n   * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n   *\r\n   * @return {?any} The first matching group member, or a newly created member, or null.\r\n   */\n  getHandler: function (forwards, nth, state, createIfNull, x, y, key, frame, visible) {\n    if (state === undefined) {\n      state = false;\n    }\n\n    if (createIfNull === undefined) {\n      createIfNull = false;\n    }\n\n    var gameObject;\n    var i;\n    var total = 0;\n    var children = this.children.entries;\n\n    if (forwards) {\n      for (i = 0; i < children.length; i++) {\n        gameObject = children[i];\n\n        if (gameObject.active === state) {\n          total++;\n\n          if (total === nth) {\n            break;\n          }\n        } else {\n          gameObject = null;\n        }\n      }\n    } else {\n      for (i = children.length - 1; i >= 0; i--) {\n        gameObject = children[i];\n\n        if (gameObject.active === state) {\n          total++;\n\n          if (total === nth) {\n            break;\n          }\n        } else {\n          gameObject = null;\n        }\n      }\n    }\n\n    if (gameObject) {\n      if (typeof x === 'number') {\n        gameObject.x = x;\n      }\n\n      if (typeof y === 'number') {\n        gameObject.y = y;\n      }\n\n      return gameObject;\n    } //  Got this far? We need to create or bail\n\n\n    if (createIfNull) {\n      return this.create(x, y, key, frame, visible);\n    } else {\n      return null;\n    }\n  },\n\n  /**\r\n   * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `false`,\r\n   * assigns `x` and `y`, and returns the member.\r\n   *\r\n   * If no inactive member is found and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n   * The new Game Object will have its active state set to `true`.\r\n   * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n   *\r\n   * @method Phaser.GameObjects.Group#get\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n   * @param {number} [y] - The vertical position of the Game Object in the world.\r\n   * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n   * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n   * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n   *\r\n   * @return {?any} The first inactive group member, or a newly created member, or null.\r\n   */\n  get: function (x, y, key, frame, visible) {\n    return this.getFirst(false, true, x, y, key, frame, visible);\n  },\n\n  /**\r\n   * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `true`,\r\n   * assigns `x` and `y`, and returns the member.\r\n   *\r\n   * If no active member is found and `createIfNull` is `true` and the group isn't full then it will create a new one using `x`, `y`, `key`, `frame`, and `visible`.\r\n   * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n   *\r\n   * @method Phaser.GameObjects.Group#getFirstAlive\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n   * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n   * @param {number} [y] - The vertical position of the Game Object in the world.\r\n   * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n   * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n   * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n   *\r\n   * @return {any} The first active group member, or a newly created member, or null.\r\n   */\n  getFirstAlive: function (createIfNull, x, y, key, frame, visible) {\n    return this.getFirst(true, createIfNull, x, y, key, frame, visible);\n  },\n\n  /**\r\n   * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `false`,\r\n   * assigns `x` and `y`, and returns the member.\r\n   *\r\n   * If no inactive member is found and `createIfNull` is `true` and the group isn't full then it will create a new one using `x`, `y`, `key`, `frame`, and `visible`.\r\n   * The new Game Object will have an active state set to `true`.\r\n   * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n   *\r\n   * @method Phaser.GameObjects.Group#getFirstDead\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n   * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n   * @param {number} [y] - The vertical position of the Game Object in the world.\r\n   * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n   * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n   * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n   *\r\n   * @return {any} The first inactive group member, or a newly created member, or null.\r\n   */\n  getFirstDead: function (createIfNull, x, y, key, frame, visible) {\n    return this.getFirst(false, createIfNull, x, y, key, frame, visible);\n  },\n\n  /**\r\n   * {@link Phaser.GameObjects.Components.Animation#play Plays} an animation for all members of this group.\r\n   *\r\n   * @method Phaser.GameObjects.Group#playAnimation\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The string-based key of the animation to play.\r\n   * @param {string} [startFrame=0] - Optionally start the animation playing from this frame index.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  playAnimation: function (key, startFrame) {\n    Actions.PlayAnimation(this.children.entries, key, startFrame);\n    return this;\n  },\n\n  /**\r\n   * Whether this group's size at its {@link Phaser.GameObjects.Group#maxSize maximum}.\r\n   *\r\n   * @method Phaser.GameObjects.Group#isFull\r\n   * @since 3.0.0\r\n   *\r\n   * @return {boolean} True if the number of members equals {@link Phaser.GameObjects.Group#maxSize}.\r\n   */\n  isFull: function () {\n    if (this.maxSize === -1) {\n      return false;\n    } else {\n      return this.children.size >= this.maxSize;\n    }\n  },\n\n  /**\r\n   * Counts the number of active (or inactive) group members.\r\n   *\r\n   * @method Phaser.GameObjects.Group#countActive\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [value=true] - Count active (true) or inactive (false) group members.\r\n   *\r\n   * @return {integer} The number of group members with an active state matching the `active` argument.\r\n   */\n  countActive: function (value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    var total = 0;\n\n    for (var i = 0; i < this.children.size; i++) {\n      if (this.children.entries[i].active === value) {\n        total++;\n      }\n    }\n\n    return total;\n  },\n\n  /**\r\n   * Counts the number of in-use (active) group members.\r\n   *\r\n   * @method Phaser.GameObjects.Group#getTotalUsed\r\n   * @since 3.0.0\r\n   *\r\n   * @return {integer} The number of group members with an active state of true.\r\n   */\n  getTotalUsed: function () {\n    return this.countActive();\n  },\n\n  /**\r\n   * The difference of {@link Phaser.GameObjects.Group#maxSize} and the number of active group members.\r\n   *\r\n   * This represents the number of group members that could be created or reactivated before reaching the size limit.\r\n   *\r\n   * @method Phaser.GameObjects.Group#getTotalFree\r\n   * @since 3.0.0\r\n   *\r\n   * @return {integer} maxSize minus the number of active group numbers; or a large number (if maxSize is -1).\r\n   */\n  getTotalFree: function () {\n    var used = this.getTotalUsed();\n    var capacity = this.maxSize === -1 ? 999999999999 : this.maxSize;\n    return capacity - used;\n  },\n\n  /**\r\n   * Sets the property as defined in `key` of each group member to the given value.\r\n   *\r\n   * @method Phaser.GameObjects.Group#propertyValueSet\r\n   * @since 3.21.0\r\n   *\r\n   * @param {string} key - The property to be updated.\r\n   * @param {number} value - The amount to set the property to.\r\n   * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n   * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n   * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  propertyValueSet: function (key, value, step, index, direction) {\n    Actions.PropertyValueSet(this.children.entries, key, value, step, index, direction);\n    return this;\n  },\n\n  /**\r\n   * Adds the given value to the property as defined in `key` of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#propertyValueInc\r\n   * @since 3.21.0\r\n   *\r\n   * @param {string} key - The property to be updated.\r\n   * @param {number} value - The amount to set the property to.\r\n   * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n   * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n   * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  propertyValueInc: function (key, value, step, index, direction) {\n    Actions.PropertyValueInc(this.children.entries, key, value, step, index, direction);\n    return this;\n  },\n\n  /**\r\n   * Sets the x of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#setX\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} value - The amount to set the property to.\r\n   * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  setX: function (value, step) {\n    Actions.SetX(this.children.entries, value, step);\n    return this;\n  },\n\n  /**\r\n   * Sets the y of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#setY\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} value - The amount to set the property to.\r\n   * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  setY: function (value, step) {\n    Actions.SetY(this.children.entries, value, step);\n    return this;\n  },\n\n  /**\r\n   * Sets the x, y of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#setXY\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} x - The amount to set the `x` property to.\r\n   * @param {number} [y=x] - The amount to set the `y` property to. If `undefined` or `null` it uses the `x` value.\r\n   * @param {number} [stepX=0] - This is added to the `x` amount, multiplied by the iteration counter.\r\n   * @param {number} [stepY=0] - This is added to the `y` amount, multiplied by the iteration counter.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  setXY: function (x, y, stepX, stepY) {\n    Actions.SetXY(this.children.entries, x, y, stepX, stepY);\n    return this;\n  },\n\n  /**\r\n   * Adds the given value to the x of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#incX\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} value - The amount to be added to the `x` property.\r\n   * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  incX: function (value, step) {\n    Actions.IncX(this.children.entries, value, step);\n    return this;\n  },\n\n  /**\r\n   * Adds the given value to the y of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#incY\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} value - The amount to be added to the `y` property.\r\n   * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  incY: function (value, step) {\n    Actions.IncY(this.children.entries, value, step);\n    return this;\n  },\n\n  /**\r\n   * Adds the given value to the x, y of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#incXY\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} x - The amount to be added to the `x` property.\r\n   * @param {number} [y=x] - The amount to be added to the `y` property. If `undefined` or `null` it uses the `x` value.\r\n   * @param {number} [stepX=0] - This is added to the `x` amount, multiplied by the iteration counter.\r\n   * @param {number} [stepY=0] - This is added to the `y` amount, multiplied by the iteration counter.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  incXY: function (x, y, stepX, stepY) {\n    Actions.IncXY(this.children.entries, x, y, stepX, stepY);\n    return this;\n  },\n\n  /**\r\n   * Iterate through the group members changing the position of each element to be that of the element that came before\r\n   * it in the array (or after it if direction = 1)\r\n   * \r\n   * The first group member position is set to x/y.\r\n   *\r\n   * @method Phaser.GameObjects.Group#shiftPosition\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} x - The x coordinate to place the first item in the array at.\r\n   * @param {number} y - The y coordinate to place the first item in the array at.\r\n   * @param {integer} [direction=0] - The iteration direction. 0 = first to last and 1 = last to first.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  shiftPosition: function (x, y, direction) {\n    Actions.ShiftPosition(this.children.entries, x, y, direction);\n    return this;\n  },\n\n  /**\r\n   * Sets the angle of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#angle\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} value - The amount to set the angle to, in degrees.\r\n   * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  angle: function (value, step) {\n    Actions.Angle(this.children.entries, value, step);\n    return this;\n  },\n\n  /**\r\n   * Sets the rotation of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#rotate\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} value - The amount to set the rotation to, in radians.\r\n   * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  rotate: function (value, step) {\n    Actions.Rotate(this.children.entries, value, step);\n    return this;\n  },\n\n  /**\r\n   * Rotates each group member around the given point by the given angle.\r\n   *\r\n   * @method Phaser.GameObjects.Group#rotateAround\r\n   * @since 3.21.0\r\n   *\r\n   * @param {Phaser.Types.Math.Vector2Like} point - Any object with public `x` and `y` properties.\r\n   * @param {number} angle - The angle to rotate by, in radians.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  rotateAround: function (point, angle) {\n    Actions.RotateAround(this.children.entries, point, angle);\n    return this;\n  },\n\n  /**\r\n   * Rotates each group member around the given point by the given angle and distance.\r\n   *\r\n   * @method Phaser.GameObjects.Group#rotateAroundDistance\r\n   * @since 3.21.0\r\n   *\r\n   * @param {Phaser.Types.Math.Vector2Like} point - Any object with public `x` and `y` properties.\r\n   * @param {number} angle - The angle to rotate by, in radians.\r\n   * @param {number} distance - The distance from the point of rotation in pixels.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  rotateAroundDistance: function (point, angle, distance) {\n    Actions.RotateAroundDistance(this.children.entries, point, angle, distance);\n    return this;\n  },\n\n  /**\r\n   * Sets the alpha of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#setAlpha\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} value - The amount to set the alpha to.\r\n   * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  setAlpha: function (value, step) {\n    Actions.SetAlpha(this.children.entries, value, step);\n    return this;\n  },\n\n  /**\r\n   * Sets the tint of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#setTint\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} topLeft - The tint being applied to top-left corner of item. If other parameters are given no value, this tint will be applied to whole item.\r\n   * @param {number} [topRight] - The tint to be applied to top-right corner of item.\r\n   * @param {number} [bottomLeft] - The tint to be applied to the bottom-left corner of item.\r\n   * @param {number} [bottomRight] - The tint to be applied to the bottom-right corner of item.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  setTint: function (topLeft, topRight, bottomLeft, bottomRight) {\n    Actions.SetTint(this.children.entries, topLeft, topRight, bottomLeft, bottomRight);\n    return this;\n  },\n\n  /**\r\n   * Sets the originX, originY of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#setOrigin\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} originX - The amount to set the `originX` property to.\r\n   * @param {number} [originY] - The amount to set the `originY` property to. If `undefined` or `null` it uses the `originX` value.\r\n   * @param {number} [stepX=0] - This is added to the `originX` amount, multiplied by the iteration counter.\r\n   * @param {number} [stepY=0] - This is added to the `originY` amount, multiplied by the iteration counter.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  setOrigin: function (originX, originY, stepX, stepY) {\n    Actions.SetOrigin(this.children.entries, originX, originY, stepX, stepY);\n    return this;\n  },\n\n  /**\r\n   * Sets the scaleX of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#scaleX\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} value - The amount to set the property to.\r\n   * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  scaleX: function (value, step) {\n    Actions.ScaleX(this.children.entries, value, step);\n    return this;\n  },\n\n  /**\r\n   * Sets the scaleY of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#scaleY\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} value - The amount to set the property to.\r\n   * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  scaleY: function (value, step) {\n    Actions.ScaleY(this.children.entries, value, step);\n    return this;\n  },\n\n  /**\r\n   * Sets the scaleX, scaleY of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#scaleXY\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} scaleX - The amount to be added to the `scaleX` property.\r\n   * @param {number} [scaleY] - The amount to be added to the `scaleY` property. If `undefined` or `null` it uses the `scaleX` value.\r\n   * @param {number} [stepX=0] - This is added to the `scaleX` amount, multiplied by the iteration counter.\r\n   * @param {number} [stepY=0] - This is added to the `scaleY` amount, multiplied by the iteration counter.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  scaleXY: function (scaleX, scaleY, stepX, stepY) {\n    Actions.ScaleXY(this.children.entries, scaleX, scaleY, stepX, stepY);\n    return this;\n  },\n\n  /**\r\n   * Sets the depth of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#setDepth\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The amount to set the property to.\r\n   * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  setDepth: function (value, step) {\n    Actions.SetDepth(this.children.entries, value, step);\n    return this;\n  },\n\n  /**\r\n   * Sets the blendMode of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#setBlendMode\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} value - The amount to set the property to.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  setBlendMode: function (value) {\n    Actions.SetBlendMode(this.children.entries, value);\n    return this;\n  },\n\n  /**\r\n   * Passes all group members to the Input Manager to enable them for input with identical areas and callbacks.\r\n   *\r\n   * @method Phaser.GameObjects.Group#setHitArea\r\n   * @since 3.21.0\r\n   *\r\n   * @param {*} hitArea - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n   * @param {Phaser.Types.Input.HitAreaCallback} hitAreaCallback - A callback to be invoked when the Game Object is interacted with. If you provide a shape you must also provide a callback.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  setHitArea: function (hitArea, hitAreaCallback) {\n    Actions.SetHitArea(this.children.entries, hitArea, hitAreaCallback);\n    return this;\n  },\n\n  /**\r\n   * Shuffles the group members in place.\r\n   *\r\n   * @method Phaser.GameObjects.Group#shuffle\r\n   * @since 3.21.0\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  shuffle: function () {\n    Actions.Shuffle(this.children.entries);\n    return this;\n  },\n\n  /**\r\n   * Deactivates a member of this group.\r\n   *\r\n   * @method Phaser.GameObjects.Group#kill\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - A member of this group.\r\n   */\n  kill: function (gameObject) {\n    if (this.children.contains(gameObject)) {\n      gameObject.setActive(false);\n    }\n  },\n\n  /**\r\n   * Deactivates and hides a member of this group.\r\n   *\r\n   * @method Phaser.GameObjects.Group#killAndHide\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - A member of this group.\r\n   */\n  killAndHide: function (gameObject) {\n    if (this.children.contains(gameObject)) {\n      gameObject.setActive(false);\n      gameObject.setVisible(false);\n    }\n  },\n\n  /**\r\n   * Sets the visible of each group member.\r\n   *\r\n   * @method Phaser.GameObjects.Group#setVisible\r\n   * @since 3.21.0\r\n   *\r\n   * @param {boolean} value - The value to set the property to.\r\n   * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n   * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  setVisible: function (value, index, direction) {\n    Actions.SetVisible(this.children.entries, value, index, direction);\n    return this;\n  },\n\n  /**\r\n   * Toggles (flips) the visible state of each member of this group.\r\n   *\r\n   * @method Phaser.GameObjects.Group#toggleVisible\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.GameObjects.Group} This Group object.\r\n   */\n  toggleVisible: function () {\n    Actions.ToggleVisible(this.children.entries);\n    return this;\n  },\n\n  /**\r\n   * Empties this group and removes it from the Scene.\r\n   *\r\n   * Does not call {@link Phaser.GameObjects.Group#removeCallback}.\r\n   *\r\n   * @method Phaser.GameObjects.Group#destroy\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [destroyChildren=false] - Also {@link Phaser.GameObjects.GameObject#destroy} each group member.\r\n   */\n  destroy: function (destroyChildren) {\n    if (destroyChildren === undefined) {\n      destroyChildren = false;\n    } //  This Game Object had already been destroyed\n\n\n    if (!this.scene || this.ignoreDestroy) {\n      return;\n    }\n\n    this.clear(false, destroyChildren);\n    this.scene = undefined;\n    this.children = undefined;\n  }\n});\nmodule.exports = Group;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/group/Group.js"],"names":["Actions","require","Class","Events","GetFastValue","GetValue","IsPlainObject","Range","Set","Sprite","Group","initialize","scene","children","config","Array","isArray","isParent","type","classType","name","active","maxSize","defaultKey","defaultFrame","runChildUpdate","createCallback","removeCallback","createMultipleCallback","internalCreateCallback","internalRemoveCallback","createMultiple","create","x","y","key","frame","visible","undefined","isFull","child","sys","displayList","add","preUpdate","updateList","setActive","output","i","length","entries","createFromConfig","concat","options","repeat","randomKey","randomFrame","yoyo","quantity","frameQuantity","max","range","qty","random","randomB","c","created","a","b","push","stepX","stepY","SetXY","rotation","stepRotation","SetRotation","scaleX","scaleY","stepScaleX","stepScaleY","SetScale","alpha","stepAlpha","SetAlpha","depth","stepDepth","SetDepth","scrollFactorX","scrollFactorY","stepScrollFactorX","stepScrollFactorY","SetScrollFactor","hitArea","hitAreaCallback","SetHitArea","grid","GridAlign","call","time","delta","size","temp","slice","item","update","addToScene","set","on","DESTROY","remove","addMultiple","removeFromScene","destroyChild","contains","delete","off","destroy","clear","gameObject","getChildren","getLength","getFirst","state","createIfNull","getHandler","getFirstNth","nth","getLast","getLastNth","forwards","total","get","getFirstAlive","getFirstDead","playAnimation","startFrame","PlayAnimation","countActive","value","getTotalUsed","getTotalFree","used","capacity","propertyValueSet","step","index","direction","PropertyValueSet","propertyValueInc","PropertyValueInc","setX","SetX","setY","SetY","setXY","incX","IncX","incY","IncY","incXY","IncXY","shiftPosition","ShiftPosition","angle","Angle","rotate","Rotate","rotateAround","point","RotateAround","rotateAroundDistance","distance","RotateAroundDistance","setAlpha","setTint","topLeft","topRight","bottomLeft","bottomRight","SetTint","setOrigin","originX","originY","SetOrigin","ScaleX","ScaleY","scaleXY","ScaleXY","setDepth","setBlendMode","SetBlendMode","setHitArea","shuffle","Shuffle","kill","killAndHide","setVisible","SetVisible","toggleVisible","ToggleVisible","destroyChildren","ignoreDestroy","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Actions = require('../../actions/');\r\nvar Class = require('../../utils/Class');\r\nvar Events = require('../events');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar Range = require('../../utils/array/Range');\r\nvar Set = require('../../structs/Set');\r\nvar Sprite = require('../sprite/Sprite');\r\n\r\n/**\r\n * @classdesc\r\n * A Group is a way for you to create, manipulate, or recycle similar Game Objects.\r\n *\r\n * Group membership is non-exclusive. A Game Object can belong to several groups, one group, or none.\r\n *\r\n * Groups themselves aren't displayable, and can't be positioned, rotated, scaled, or hidden.\r\n *\r\n * @class Group\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n * @param {Phaser.Scene} scene - The scene this group belongs to.\r\n * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig)} [children] - Game Objects to add to this group; or the `config` argument.\r\n * @param {Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - Settings for this group. If `key` is set, Phaser.GameObjects.Group#createMultiple is also called with these settings.\r\n *\r\n * @see Phaser.Physics.Arcade.Group\r\n * @see Phaser.Physics.Arcade.StaticGroup\r\n */\r\nvar Group = new Class({\r\n\r\n    initialize:\r\n\r\n    function Group (scene, children, config)\r\n    {\r\n        //  They can pass in any of the following as the first argument:\r\n\r\n        //  1) A single child\r\n        //  2) An array of children\r\n        //  3) A config object\r\n        //  4) An array of config objects\r\n\r\n        //  Or they can pass in a child, or array of children AND a config object\r\n\r\n        if (config)\r\n        {\r\n            //  config has been set, are the children an array?\r\n\r\n            if (children && !Array.isArray(children))\r\n            {\r\n                children = [ children ];\r\n            }\r\n        }\r\n        else if (Array.isArray(children))\r\n        {\r\n            //  No config, so let's check the children argument\r\n\r\n            if (IsPlainObject(children[0]))\r\n            {\r\n                //  It's an array of plain config objects\r\n                config = children;\r\n                children = null;\r\n            }\r\n        }\r\n        else if (IsPlainObject(children))\r\n        {\r\n            //  Children isn't an array. Is it a config object though?\r\n            config = children;\r\n            children = null;\r\n        }\r\n\r\n        /**\r\n         * This scene this group belongs to.\r\n         *\r\n         * @name Phaser.GameObjects.Group#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * Members of this group.\r\n         *\r\n         * @name Phaser.GameObjects.Group#children\r\n         * @type {Phaser.Structs.Set.<Phaser.GameObjects.GameObject>}\r\n         * @since 3.0.0\r\n         */\r\n        this.children = new Set(children);\r\n\r\n        /**\r\n         * A flag identifying this object as a group.\r\n         *\r\n         * @name Phaser.GameObjects.Group#isParent\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.isParent = true;\r\n\r\n        /**\r\n         * A textual representation of this Game Object.\r\n         * Used internally by Phaser but is available for your own custom classes to populate.\r\n         *\r\n         * @name Phaser.GameObjects.Group#type\r\n         * @type {string}\r\n         * @default 'Group'\r\n         * @since 3.21.0\r\n         */\r\n        this.type = 'Group';\r\n\r\n        /**\r\n         * The class to create new group members from.\r\n         *\r\n         * @name Phaser.GameObjects.Group#classType\r\n         * @type {Function}\r\n         * @since 3.0.0\r\n         * @default Phaser.GameObjects.Sprite\r\n         */\r\n        this.classType = GetFastValue(config, 'classType', Sprite);\r\n\r\n        /**\r\n         * The name of this group.\r\n         * Empty by default and never populated by Phaser, this is left for developers to use.\r\n         *\r\n         * @name Phaser.GameObjects.Group#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.18.0\r\n         */\r\n        this.name = GetFastValue(config, 'name', '');\r\n\r\n        /**\r\n         * Whether this group runs its {@link Phaser.GameObjects.Group#preUpdate} method\r\n         * (which may update any members).\r\n         *\r\n         * @name Phaser.GameObjects.Group#active\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.active = GetFastValue(config, 'active', true);\r\n\r\n        /**\r\n         * The maximum size of this group, if used as a pool. -1 is no limit.\r\n         *\r\n         * @name Phaser.GameObjects.Group#maxSize\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         * @default -1\r\n         */\r\n        this.maxSize = GetFastValue(config, 'maxSize', -1);\r\n\r\n        /**\r\n         * A default texture key to use when creating new group members.\r\n         *\r\n         * This is used in {@link Phaser.GameObjects.Group#create}\r\n         * but not in {@link Phaser.GameObjects.Group#createMultiple}.\r\n         *\r\n         * @name Phaser.GameObjects.Group#defaultKey\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultKey = GetFastValue(config, 'defaultKey', null);\r\n\r\n        /**\r\n         * A default texture frame to use when creating new group members.\r\n         *\r\n         * @name Phaser.GameObjects.Group#defaultFrame\r\n         * @type {(string|integer)}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultFrame = GetFastValue(config, 'defaultFrame', null);\r\n\r\n        /**\r\n         * Whether to call the update method of any members.\r\n         *\r\n         * @name Phaser.GameObjects.Group#runChildUpdate\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Group#preUpdate\r\n         */\r\n        this.runChildUpdate = GetFastValue(config, 'runChildUpdate', false);\r\n\r\n        /**\r\n         * A function to be called when adding or creating group members.\r\n         *\r\n         * @name Phaser.GameObjects.Group#createCallback\r\n         * @type {?Phaser.Types.GameObjects.Group.GroupCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.createCallback = GetFastValue(config, 'createCallback', null);\r\n\r\n        /**\r\n         * A function to be called when removing group members.\r\n         *\r\n         * @name Phaser.GameObjects.Group#removeCallback\r\n         * @type {?Phaser.Types.GameObjects.Group.GroupCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.removeCallback = GetFastValue(config, 'removeCallback', null);\r\n\r\n        /**\r\n         * A function to be called when creating several group members at once.\r\n         *\r\n         * @name Phaser.GameObjects.Group#createMultipleCallback\r\n         * @type {?Phaser.Types.GameObjects.Group.GroupMultipleCreateCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.createMultipleCallback = GetFastValue(config, 'createMultipleCallback', null);\r\n\r\n        /**\r\n         * A function to be called when adding or creating group members.\r\n         * For internal use only by a Group, or any class that extends it.\r\n         *\r\n         * @name Phaser.GameObjects.Group#internalCreateCallback\r\n         * @type {?Phaser.Types.GameObjects.Group.GroupCallback}\r\n         * @private\r\n         * @since 3.22.0\r\n         */\r\n        this.internalCreateCallback = GetFastValue(config, 'internalCreateCallback', null);\r\n\r\n        /**\r\n         * A function to be called when removing group members.\r\n         * For internal use only by a Group, or any class that extends it.\r\n         *\r\n         * @name Phaser.GameObjects.Group#internalRemoveCallback\r\n         * @type {?Phaser.Types.GameObjects.Group.GroupCallback}\r\n         * @private\r\n         * @since 3.22.0\r\n         */\r\n        this.internalRemoveCallback = GetFastValue(config, 'internalRemoveCallback', null);\r\n\r\n        if (config)\r\n        {\r\n            this.createMultiple(config);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a new Game Object and adds it to this group, unless the group {@link Phaser.GameObjects.Group#isFull is full}.\r\n     *\r\n     * Calls {@link Phaser.GameObjects.Group#createCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal position of the new Game Object in the world.\r\n     * @param {number} [y=0] - The vertical position of the new Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key of the new Game Object.\r\n     * @param {(string|integer)} [frame=defaultFrame] - The texture frame of the new Game Object.\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of the new Game Object.\r\n     * @param {boolean} [active=true] - The {@link Phaser.GameObjects.GameObject#active} state of the new Game Object.\r\n     *\r\n     * @return {any} The new Game Object (usually a Sprite, etc.).\r\n     */\r\n    create: function (x, y, key, frame, visible, active)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (key === undefined) { key = this.defaultKey; }\r\n        if (frame === undefined) { frame = this.defaultFrame; }\r\n        if (visible === undefined) { visible = true; }\r\n        if (active === undefined) { active = true; }\r\n\r\n        //  Pool?\r\n        if (this.isFull())\r\n        {\r\n            return null;\r\n        }\r\n\r\n        var child = new this.classType(this.scene, x, y, key, frame);\r\n\r\n        this.scene.sys.displayList.add(child);\r\n\r\n        if (child.preUpdate)\r\n        {\r\n            this.scene.sys.updateList.add(child);\r\n        }\r\n\r\n        child.visible = visible;\r\n        child.setActive(active);\r\n\r\n        this.add(child);\r\n\r\n        return child;\r\n    },\r\n\r\n    /**\r\n     * Creates several Game Objects and adds them to this group.\r\n     *\r\n     * If the group becomes {@link Phaser.GameObjects.Group#isFull}, no further Game Objects are created.\r\n     *\r\n     * Calls {@link Phaser.GameObjects.Group#createMultipleCallback} and {@link Phaser.GameObjects.Group#createCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#createMultiple\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Group.GroupCreateConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig[]} config - Creation settings. This can be a single configuration object or an array of such objects, which will be applied in turn.\r\n     *\r\n     * @return {any[]} The newly created Game Objects.\r\n     */\r\n    createMultiple: function (config)\r\n    {\r\n        if (this.isFull())\r\n        {\r\n            return [];\r\n        }\r\n\r\n        if (!Array.isArray(config))\r\n        {\r\n            config = [ config ];\r\n        }\r\n\r\n        var output = [];\r\n\r\n        if (config[0].key)\r\n        {\r\n            for (var i = 0; i < config.length; i++)\r\n            {\r\n                var entries = this.createFromConfig(config[i]);\r\n\r\n                output = output.concat(entries);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * A helper for {@link Phaser.GameObjects.Group#createMultiple}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#createFromConfig\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Group.GroupCreateConfig} options - Creation settings.\r\n     *\r\n     * @return {any[]} The newly created Game Objects.\r\n     */\r\n    createFromConfig: function (options)\r\n    {\r\n        if (this.isFull())\r\n        {\r\n            return [];\r\n        }\r\n\r\n        this.classType = GetFastValue(options, 'classType', this.classType);\r\n\r\n        var key = GetFastValue(options, 'key', undefined);\r\n        var frame = GetFastValue(options, 'frame', null);\r\n        var visible = GetFastValue(options, 'visible', true);\r\n        var active = GetFastValue(options, 'active', true);\r\n\r\n        var entries = [];\r\n\r\n        //  Can't do anything without at least a key\r\n        if (key === undefined)\r\n        {\r\n            return entries;\r\n        }\r\n        else\r\n        {\r\n            if (!Array.isArray(key))\r\n            {\r\n                key = [ key ];\r\n            }\r\n\r\n            if (!Array.isArray(frame))\r\n            {\r\n                frame = [ frame ];\r\n            }\r\n        }\r\n\r\n        //  Build an array of key frame pairs to loop through\r\n\r\n        var repeat = GetFastValue(options, 'repeat', 0);\r\n        var randomKey = GetFastValue(options, 'randomKey', false);\r\n        var randomFrame = GetFastValue(options, 'randomFrame', false);\r\n        var yoyo = GetFastValue(options, 'yoyo', false);\r\n        var quantity = GetFastValue(options, 'quantity', false);\r\n        var frameQuantity = GetFastValue(options, 'frameQuantity', 1);\r\n        var max = GetFastValue(options, 'max', 0);\r\n\r\n        //  If a quantity value is set we use that to override the frameQuantity\r\n\r\n        var range = Range(key, frame, {\r\n            max: max,\r\n            qty: (quantity) ? quantity : frameQuantity,\r\n            random: randomKey,\r\n            randomB: randomFrame,\r\n            repeat: repeat,\r\n            yoyo: yoyo\r\n        });\r\n\r\n        if (options.createCallback)\r\n        {\r\n            this.createCallback = options.createCallback;\r\n        }\r\n\r\n        if (options.removeCallback)\r\n        {\r\n            this.removeCallback = options.removeCallback;\r\n        }\r\n\r\n        for (var c = 0; c < range.length; c++)\r\n        {\r\n            var created = this.create(0, 0, range[c].a, range[c].b, visible, active);\r\n\r\n            if (!created)\r\n            {\r\n                break;\r\n            }\r\n\r\n            entries.push(created);\r\n        }\r\n\r\n        //  Post-creation options (applied only to those items created in this call):\r\n\r\n        var x = GetValue(options, 'setXY.x', 0);\r\n        var y = GetValue(options, 'setXY.y', 0);\r\n        var stepX = GetValue(options, 'setXY.stepX', 0);\r\n        var stepY = GetValue(options, 'setXY.stepY', 0);\r\n\r\n        Actions.SetXY(entries, x, y, stepX, stepY);\r\n\r\n        var rotation = GetValue(options, 'setRotation.value', 0);\r\n        var stepRotation = GetValue(options, 'setRotation.step', 0);\r\n\r\n        Actions.SetRotation(entries, rotation, stepRotation);\r\n\r\n        var scaleX = GetValue(options, 'setScale.x', 1);\r\n        var scaleY = GetValue(options, 'setScale.y', scaleX);\r\n        var stepScaleX = GetValue(options, 'setScale.stepX', 0);\r\n        var stepScaleY = GetValue(options, 'setScale.stepY', 0);\r\n\r\n        Actions.SetScale(entries, scaleX, scaleY, stepScaleX, stepScaleY);\r\n\r\n        var alpha = GetValue(options, 'setAlpha.value', 1);\r\n        var stepAlpha = GetValue(options, 'setAlpha.step', 0);\r\n\r\n        Actions.SetAlpha(entries, alpha, stepAlpha);\r\n\r\n        var depth = GetValue(options, 'setDepth.value', 0);\r\n        var stepDepth = GetValue(options, 'setDepth.step', 0);\r\n\r\n        Actions.SetDepth(entries, depth, stepDepth);\r\n\r\n        var scrollFactorX = GetValue(options, 'setScrollFactor.x', 1);\r\n        var scrollFactorY = GetValue(options, 'setScrollFactor.y', scrollFactorX);\r\n        var stepScrollFactorX = GetValue(options, 'setScrollFactor.stepX', 0);\r\n        var stepScrollFactorY = GetValue(options, 'setScrollFactor.stepY', 0);\r\n\r\n        Actions.SetScrollFactor(entries, scrollFactorX, scrollFactorY, stepScrollFactorX, stepScrollFactorY);\r\n\r\n        var hitArea = GetFastValue(options, 'hitArea', null);\r\n        var hitAreaCallback = GetFastValue(options, 'hitAreaCallback', null);\r\n\r\n        if (hitArea)\r\n        {\r\n            Actions.SetHitArea(entries, hitArea, hitAreaCallback);\r\n        }\r\n\r\n        var grid = GetFastValue(options, 'gridAlign', false);\r\n\r\n        if (grid)\r\n        {\r\n            Actions.GridAlign(entries, grid);\r\n        }\r\n\r\n        if (this.createMultipleCallback)\r\n        {\r\n            this.createMultipleCallback.call(this, entries);\r\n        }\r\n\r\n        return entries;\r\n    },\r\n\r\n    /**\r\n     * Updates any group members, if {@link Phaser.GameObjects.Group#runChildUpdate} is enabled.\r\n     *\r\n     * @method Phaser.GameObjects.Group#preUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp.\r\n     * @param {number} delta - The delta time elapsed since the last frame.\r\n     */\r\n    preUpdate: function (time, delta)\r\n    {\r\n        if (!this.runChildUpdate || this.children.size === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  Because a Group child may mess with the length of the Group during its update\r\n        var temp = this.children.entries.slice();\r\n\r\n        for (var i = 0; i < temp.length; i++)\r\n        {\r\n            var item = temp[i];\r\n\r\n            if (item.active)\r\n            {\r\n                item.update(time, delta);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds a Game Object to this group.\r\n     *\r\n     * Calls {@link Phaser.GameObjects.Group#createCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to add.\r\n     * @param {boolean} [addToScene=false] - Also add the Game Object to the scene.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    add: function (child, addToScene)\r\n    {\r\n        if (addToScene === undefined) { addToScene = false; }\r\n\r\n        if (this.isFull())\r\n        {\r\n            return this;\r\n        }\r\n\r\n        this.children.set(child);\r\n\r\n        if (this.internalCreateCallback)\r\n        {\r\n            this.internalCreateCallback.call(this, child);\r\n        }\r\n\r\n        if (this.createCallback)\r\n        {\r\n            this.createCallback.call(this, child);\r\n        }\r\n\r\n        if (addToScene)\r\n        {\r\n            this.scene.sys.displayList.add(child);\r\n\r\n            if (child.preUpdate)\r\n            {\r\n                this.scene.sys.updateList.add(child);\r\n            }\r\n        }\r\n\r\n        child.on(Events.DESTROY, this.remove, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds several Game Objects to this group.\r\n     *\r\n     * Calls {@link Phaser.GameObjects.Group#createCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#addMultiple\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} children - The Game Objects to add.\r\n     * @param {boolean} [addToScene=false] - Also add the Game Objects to the scene.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This group.\r\n     */\r\n    addMultiple: function (children, addToScene)\r\n    {\r\n        if (addToScene === undefined) { addToScene = false; }\r\n\r\n        if (Array.isArray(children))\r\n        {\r\n            for (var i = 0; i < children.length; i++)\r\n            {\r\n                this.add(children[i], addToScene);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a member of this Group and optionally removes it from the Scene and / or destroys it.\r\n     *\r\n     * Calls {@link Phaser.GameObjects.Group#removeCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to remove.\r\n     * @param {boolean} [removeFromScene=false] - Optionally remove the Group member from the Scene it belongs to.\r\n     * @param {boolean} [destroyChild=false] - Optionally call destroy on the removed Group member.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    remove: function (child, removeFromScene, destroyChild)\r\n    {\r\n        if (removeFromScene === undefined) { removeFromScene = false; }\r\n        if (destroyChild === undefined) { destroyChild = false; }\r\n\r\n        if (!this.children.contains(child))\r\n        {\r\n            return this;\r\n        }\r\n\r\n        this.children.delete(child);\r\n\r\n        if (this.internalRemoveCallback)\r\n        {\r\n            this.internalRemoveCallback.call(this, child);\r\n        }\r\n\r\n        if (this.removeCallback)\r\n        {\r\n            this.removeCallback.call(this, child);\r\n        }\r\n\r\n        child.off(Events.DESTROY, this.remove, this);\r\n\r\n        if (destroyChild)\r\n        {\r\n            child.destroy();\r\n        }\r\n        else if (removeFromScene)\r\n        {\r\n            child.scene.sys.displayList.remove(child);\r\n\r\n            if (child.preUpdate)\r\n            {\r\n                child.scene.sys.updateList.remove(child);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes all members of this Group and optionally removes them from the Scene and / or destroys them.\r\n     *\r\n     * Does not call {@link Phaser.GameObjects.Group#removeCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [removeFromScene=false] - Optionally remove each Group member from the Scene.\r\n     * @param {boolean} [destroyChild=false] - Optionally call destroy on the removed Group members.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This group.\r\n     */\r\n    clear: function (removeFromScene, destroyChild)\r\n    {\r\n        if (removeFromScene === undefined) { removeFromScene = false; }\r\n        if (destroyChild === undefined) { destroyChild = false; }\r\n\r\n        var children = this.children;\r\n\r\n        for (var i = 0; i < children.size; i++)\r\n        {\r\n            var gameObject = children.entries[i];\r\n\r\n            gameObject.off(Events.DESTROY, this.remove, this);\r\n\r\n            if (destroyChild)\r\n            {\r\n                gameObject.destroy();\r\n            }\r\n            else if (removeFromScene)\r\n            {\r\n                gameObject.scene.sys.displayList.remove(gameObject);\r\n\r\n                if (gameObject.preUpdate)\r\n                {\r\n                    gameObject.scene.sys.updateList.remove(gameObject);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.children.clear();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Tests if a Game Object is a member of this group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - A Game Object.\r\n     *\r\n     * @return {boolean} True if the Game Object is a member of this group.\r\n     */\r\n    contains: function (child)\r\n    {\r\n        return this.children.contains(child);\r\n    },\r\n\r\n    /**\r\n     * All members of the group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getChildren\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} The group members.\r\n     */\r\n    getChildren: function ()\r\n    {\r\n        return this.children.entries;\r\n    },\r\n\r\n    /**\r\n     * The number of members of the group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getLength\r\n     * @since 3.0.0\r\n     *\r\n     * @return {integer}\r\n     */\r\n    getLength: function ()\r\n    {\r\n        return this.children.size;\r\n    },\r\n\r\n    /**\r\n     * Scans the Group, from top to bottom, for the first member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getFirst\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first matching group member, or a newly created member, or null.\r\n     */\r\n    getFirst: function (state, createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getHandler(true, 1, state, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the Group, from top to bottom, for the nth member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getFirstNth\r\n     * @since 3.6.0\r\n     *\r\n     * @param {integer} nth - The nth matching Group member to search for.\r\n     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first matching group member, or a newly created member, or null.\r\n     */\r\n    getFirstNth: function (nth, state, createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getHandler(true, nth, state, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the Group for the last member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getLast\r\n     * @since 3.6.0\r\n     *\r\n     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first matching group member, or a newly created member, or null.\r\n     */\r\n    getLast: function (state, createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getHandler(false, 1, state, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the Group for the last nth member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getLastNth\r\n     * @since 3.6.0\r\n     *\r\n     * @param {integer} nth - The nth matching Group member to search for.\r\n     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first matching group member, or a newly created member, or null.\r\n     */\r\n    getLastNth: function (nth, state, createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getHandler(false, nth, state, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the group for the last member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getHandler\r\n     * @private\r\n     * @since 3.6.0\r\n     *\r\n     * @param {boolean} forwards - Search front to back or back to front?\r\n     * @param {integer} nth - Stop matching after nth successful matches.\r\n     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first matching group member, or a newly created member, or null.\r\n     */\r\n    getHandler: function (forwards, nth, state, createIfNull, x, y, key, frame, visible)\r\n    {\r\n        if (state === undefined) { state = false; }\r\n        if (createIfNull === undefined) { createIfNull = false; }\r\n\r\n        var gameObject;\r\n\r\n        var i;\r\n        var total = 0;\r\n        var children = this.children.entries;\r\n\r\n        if (forwards)\r\n        {\r\n            for (i = 0; i < children.length; i++)\r\n            {\r\n                gameObject = children[i];\r\n\r\n                if (gameObject.active === state)\r\n                {\r\n                    total++;\r\n\r\n                    if (total === nth)\r\n                    {\r\n                        break;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    gameObject = null;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (i = children.length - 1; i >= 0; i--)\r\n            {\r\n                gameObject = children[i];\r\n\r\n                if (gameObject.active === state)\r\n                {\r\n                    total++;\r\n\r\n                    if (total === nth)\r\n                    {\r\n                        break;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    gameObject = null;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (gameObject)\r\n        {\r\n            if (typeof(x) === 'number')\r\n            {\r\n                gameObject.x = x;\r\n            }\r\n\r\n            if (typeof(y) === 'number')\r\n            {\r\n                gameObject.y = y;\r\n            }\r\n\r\n            return gameObject;\r\n        }\r\n\r\n        //  Got this far? We need to create or bail\r\n        if (createIfNull)\r\n        {\r\n            return this.create(x, y, key, frame, visible);\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `false`,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no inactive member is found and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * The new Game Object will have its active state set to `true`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first inactive group member, or a newly created member, or null.\r\n     */\r\n    get: function (x, y, key, frame, visible)\r\n    {\r\n        return this.getFirst(false, true, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `true`,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no active member is found and `createIfNull` is `true` and the group isn't full then it will create a new one using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getFirstAlive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {any} The first active group member, or a newly created member, or null.\r\n     */\r\n    getFirstAlive: function (createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getFirst(true, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `false`,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no inactive member is found and `createIfNull` is `true` and the group isn't full then it will create a new one using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * The new Game Object will have an active state set to `true`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getFirstDead\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|integer)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {any} The first inactive group member, or a newly created member, or null.\r\n     */\r\n    getFirstDead: function (createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getFirst(false, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * {@link Phaser.GameObjects.Components.Animation#play Plays} an animation for all members of this group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#playAnimation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The string-based key of the animation to play.\r\n     * @param {string} [startFrame=0] - Optionally start the animation playing from this frame index.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    playAnimation: function (key, startFrame)\r\n    {\r\n        Actions.PlayAnimation(this.children.entries, key, startFrame);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Whether this group's size at its {@link Phaser.GameObjects.Group#maxSize maximum}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#isFull\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} True if the number of members equals {@link Phaser.GameObjects.Group#maxSize}.\r\n     */\r\n    isFull: function ()\r\n    {\r\n        if (this.maxSize === -1)\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            return (this.children.size >= this.maxSize);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Counts the number of active (or inactive) group members.\r\n     *\r\n     * @method Phaser.GameObjects.Group#countActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [value=true] - Count active (true) or inactive (false) group members.\r\n     *\r\n     * @return {integer} The number of group members with an active state matching the `active` argument.\r\n     */\r\n    countActive: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        var total = 0;\r\n\r\n        for (var i = 0; i < this.children.size; i++)\r\n        {\r\n            if (this.children.entries[i].active === value)\r\n            {\r\n                total++;\r\n            }\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * Counts the number of in-use (active) group members.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getTotalUsed\r\n     * @since 3.0.0\r\n     *\r\n     * @return {integer} The number of group members with an active state of true.\r\n     */\r\n    getTotalUsed: function ()\r\n    {\r\n        return this.countActive();\r\n    },\r\n\r\n    /**\r\n     * The difference of {@link Phaser.GameObjects.Group#maxSize} and the number of active group members.\r\n     *\r\n     * This represents the number of group members that could be created or reactivated before reaching the size limit.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getTotalFree\r\n     * @since 3.0.0\r\n     *\r\n     * @return {integer} maxSize minus the number of active group numbers; or a large number (if maxSize is -1).\r\n     */\r\n    getTotalFree: function ()\r\n    {\r\n        var used = this.getTotalUsed();\r\n        var capacity = (this.maxSize === -1) ? 999999999999 : this.maxSize;\r\n\r\n        return (capacity - used);\r\n    },\r\n\r\n    /**\r\n     * Sets the property as defined in `key` of each group member to the given value.\r\n     *\r\n     * @method Phaser.GameObjects.Group#propertyValueSet\r\n     * @since 3.21.0\r\n     *\r\n     * @param {string} key - The property to be updated.\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n     * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    propertyValueSet: function (key, value, step, index, direction)\r\n    {\r\n        Actions.PropertyValueSet(this.children.entries, key, value, step, index, direction);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds the given value to the property as defined in `key` of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#propertyValueInc\r\n     * @since 3.21.0\r\n     *\r\n     * @param {string} key - The property to be updated.\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n     * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    propertyValueInc: function (key, value, step, index, direction)\r\n    {\r\n        Actions.PropertyValueInc(this.children.entries, key, value, step, index, direction);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the x of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setX\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    setX: function (value, step)\r\n    {\r\n        Actions.SetX(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the y of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    setY: function (value, step)\r\n    {\r\n        Actions.SetY(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the x, y of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setXY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} x - The amount to set the `x` property to.\r\n     * @param {number} [y=x] - The amount to set the `y` property to. If `undefined` or `null` it uses the `x` value.\r\n     * @param {number} [stepX=0] - This is added to the `x` amount, multiplied by the iteration counter.\r\n     * @param {number} [stepY=0] - This is added to the `y` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    setXY: function (x, y, stepX, stepY)\r\n    {\r\n        Actions.SetXY(this.children.entries, x, y, stepX, stepY);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds the given value to the x of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#incX\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to be added to the `x` property.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    incX: function (value, step)\r\n    {\r\n        Actions.IncX(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds the given value to the y of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#incY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to be added to the `y` property.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    incY: function (value, step)\r\n    {\r\n        Actions.IncY(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds the given value to the x, y of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#incXY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} x - The amount to be added to the `x` property.\r\n     * @param {number} [y=x] - The amount to be added to the `y` property. If `undefined` or `null` it uses the `x` value.\r\n     * @param {number} [stepX=0] - This is added to the `x` amount, multiplied by the iteration counter.\r\n     * @param {number} [stepY=0] - This is added to the `y` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    incXY: function (x, y, stepX, stepY)\r\n    {\r\n        Actions.IncXY(this.children.entries, x, y, stepX, stepY);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Iterate through the group members changing the position of each element to be that of the element that came before\r\n     * it in the array (or after it if direction = 1)\r\n     * \r\n     * The first group member position is set to x/y.\r\n     *\r\n     * @method Phaser.GameObjects.Group#shiftPosition\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} x - The x coordinate to place the first item in the array at.\r\n     * @param {number} y - The y coordinate to place the first item in the array at.\r\n     * @param {integer} [direction=0] - The iteration direction. 0 = first to last and 1 = last to first.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    shiftPosition: function (x, y, direction)\r\n    {\r\n        Actions.ShiftPosition(this.children.entries, x, y, direction);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the angle of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#angle\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the angle to, in degrees.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    angle: function (value, step)\r\n    {\r\n        Actions.Angle(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the rotation of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#rotate\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the rotation to, in radians.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    rotate: function (value, step)\r\n    {\r\n        Actions.Rotate(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotates each group member around the given point by the given angle.\r\n     *\r\n     * @method Phaser.GameObjects.Group#rotateAround\r\n     * @since 3.21.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} point - Any object with public `x` and `y` properties.\r\n     * @param {number} angle - The angle to rotate by, in radians.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    rotateAround: function (point, angle)\r\n    {\r\n        Actions.RotateAround(this.children.entries, point, angle);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotates each group member around the given point by the given angle and distance.\r\n     *\r\n     * @method Phaser.GameObjects.Group#rotateAroundDistance\r\n     * @since 3.21.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} point - Any object with public `x` and `y` properties.\r\n     * @param {number} angle - The angle to rotate by, in radians.\r\n     * @param {number} distance - The distance from the point of rotation in pixels.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    rotateAroundDistance: function (point, angle, distance)\r\n    {\r\n        Actions.RotateAroundDistance(this.children.entries, point, angle, distance);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the alpha of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setAlpha\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the alpha to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    setAlpha: function (value, step)\r\n    {\r\n        Actions.SetAlpha(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tint of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setTint\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} topLeft - The tint being applied to top-left corner of item. If other parameters are given no value, this tint will be applied to whole item.\r\n     * @param {number} [topRight] - The tint to be applied to top-right corner of item.\r\n     * @param {number} [bottomLeft] - The tint to be applied to the bottom-left corner of item.\r\n     * @param {number} [bottomRight] - The tint to be applied to the bottom-right corner of item.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    setTint: function (topLeft, topRight, bottomLeft, bottomRight)\r\n    {\r\n        Actions.SetTint(this.children.entries, topLeft, topRight, bottomLeft, bottomRight);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the originX, originY of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setOrigin\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} originX - The amount to set the `originX` property to.\r\n     * @param {number} [originY] - The amount to set the `originY` property to. If `undefined` or `null` it uses the `originX` value.\r\n     * @param {number} [stepX=0] - This is added to the `originX` amount, multiplied by the iteration counter.\r\n     * @param {number} [stepY=0] - This is added to the `originY` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    setOrigin: function (originX, originY, stepX, stepY)\r\n    {\r\n        Actions.SetOrigin(this.children.entries, originX, originY, stepX, stepY);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scaleX of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#scaleX\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    scaleX: function (value, step)\r\n    {\r\n        Actions.ScaleX(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scaleY of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#scaleY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    scaleY: function (value, step)\r\n    {\r\n        Actions.ScaleY(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scaleX, scaleY of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#scaleXY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} scaleX - The amount to be added to the `scaleX` property.\r\n     * @param {number} [scaleY] - The amount to be added to the `scaleY` property. If `undefined` or `null` it uses the `scaleX` value.\r\n     * @param {number} [stepX=0] - This is added to the `scaleX` amount, multiplied by the iteration counter.\r\n     * @param {number} [stepY=0] - This is added to the `scaleY` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    scaleXY: function (scaleX, scaleY, stepX, stepY)\r\n    {\r\n        Actions.ScaleXY(this.children.entries, scaleX, scaleY, stepX, stepY);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the depth of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setDepth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    setDepth: function (value, step)\r\n    {\r\n        Actions.SetDepth(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the blendMode of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setBlendMode\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    setBlendMode: function (value)\r\n    {\r\n        Actions.SetBlendMode(this.children.entries, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Passes all group members to the Input Manager to enable them for input with identical areas and callbacks.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setHitArea\r\n     * @since 3.21.0\r\n     *\r\n     * @param {*} hitArea - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} hitAreaCallback - A callback to be invoked when the Game Object is interacted with. If you provide a shape you must also provide a callback.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    setHitArea: function (hitArea, hitAreaCallback)\r\n    {\r\n        Actions.SetHitArea(this.children.entries, hitArea, hitAreaCallback);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuffles the group members in place.\r\n     *\r\n     * @method Phaser.GameObjects.Group#shuffle\r\n     * @since 3.21.0\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    shuffle: function ()\r\n    {\r\n        Actions.Shuffle(this.children.entries);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Deactivates a member of this group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#kill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - A member of this group.\r\n     */\r\n    kill: function (gameObject)\r\n    {\r\n        if (this.children.contains(gameObject))\r\n        {\r\n            gameObject.setActive(false);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Deactivates and hides a member of this group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#killAndHide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - A member of this group.\r\n     */\r\n    killAndHide: function (gameObject)\r\n    {\r\n        if (this.children.contains(gameObject))\r\n        {\r\n            gameObject.setActive(false);\r\n            gameObject.setVisible(false);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the visible of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setVisible\r\n     * @since 3.21.0\r\n     *\r\n     * @param {boolean} value - The value to set the property to.\r\n     * @param {integer} [index=0] - An optional offset to start searching from within the items array.\r\n     * @param {integer} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    setVisible: function (value, index, direction)\r\n    {\r\n        Actions.SetVisible(this.children.entries, value, index, direction);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Toggles (flips) the visible state of each member of this group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#toggleVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Group} This Group object.\r\n     */\r\n    toggleVisible: function ()\r\n    {\r\n        Actions.ToggleVisible(this.children.entries);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Empties this group and removes it from the Scene.\r\n     *\r\n     * Does not call {@link Phaser.GameObjects.Group#removeCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#destroy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [destroyChildren=false] - Also {@link Phaser.GameObjects.GameObject#destroy} each group member.\r\n     */\r\n    destroy: function (destroyChildren)\r\n    {\r\n        if (destroyChildren === undefined) { destroyChildren = false; }\r\n\r\n        //  This Game Object had already been destroyed\r\n        if (!this.scene || this.ignoreDestroy)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.clear(false, destroyChildren);\r\n\r\n        this.scene = undefined;\r\n        this.children = undefined;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Group;\r\n"]},"metadata":{},"sourceType":"script"}