{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar DefaultDefs = require('./DefaultDefs');\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class CollisionMap\r\n * @memberof Phaser.Physics.Impact\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [tilesize=32] - [description]\r\n * @param {array} [data] - [description]\r\n */\n\n\nvar CollisionMap = new Class({\n  initialize: function CollisionMap(tilesize, data) {\n    if (tilesize === undefined) {\n      tilesize = 32;\n    }\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.CollisionMap#tilesize\r\n     * @type {integer}\r\n     * @default 32\r\n     * @since 3.0.0\r\n     */\n\n\n    this.tilesize = tilesize;\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.CollisionMap#data\r\n     * @type {array}\r\n     * @since 3.0.0\r\n     */\n\n    this.data = Array.isArray(data) ? data : [];\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.CollisionMap#width\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.width = Array.isArray(data) ? data[0].length : 0;\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.CollisionMap#height\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.height = Array.isArray(data) ? data.length : 0;\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.CollisionMap#lastSlope\r\n     * @type {integer}\r\n     * @default 55\r\n     * @since 3.0.0\r\n     */\n\n    this.lastSlope = 55;\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.CollisionMap#tiledef\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.tiledef = DefaultDefs;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.CollisionMap#trace\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - [description]\r\n   * @param {number} y - [description]\r\n   * @param {number} vx - [description]\r\n   * @param {number} vy - [description]\r\n   * @param {number} objectWidth - [description]\r\n   * @param {number} objectHeight - [description]\r\n   *\r\n   * @return {boolean} [description]\r\n   */\n  trace: function (x, y, vx, vy, objectWidth, objectHeight) {\n    // Set up the trace-result\n    var res = {\n      collision: {\n        x: false,\n        y: false,\n        slope: false\n      },\n      pos: {\n        x: x + vx,\n        y: y + vy\n      },\n      tile: {\n        x: 0,\n        y: 0\n      }\n    };\n\n    if (!this.data) {\n      return res;\n    }\n\n    var steps = Math.ceil(Math.max(Math.abs(vx), Math.abs(vy)) / this.tilesize);\n\n    if (steps > 1) {\n      var sx = vx / steps;\n      var sy = vy / steps;\n\n      for (var i = 0; i < steps && (sx || sy); i++) {\n        this.step(res, x, y, sx, sy, objectWidth, objectHeight, vx, vy, i);\n        x = res.pos.x;\n        y = res.pos.y;\n\n        if (res.collision.x) {\n          sx = 0;\n          vx = 0;\n        }\n\n        if (res.collision.y) {\n          sy = 0;\n          vy = 0;\n        }\n\n        if (res.collision.slope) {\n          break;\n        }\n      }\n    } else {\n      this.step(res, x, y, vx, vy, objectWidth, objectHeight, vx, vy, 0);\n    }\n\n    return res;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.CollisionMap#step\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} res - [description]\r\n   * @param {number} x - [description]\r\n   * @param {number} y - [description]\r\n   * @param {number} vx - [description]\r\n   * @param {number} vy - [description]\r\n   * @param {number} width - [description]\r\n   * @param {number} height - [description]\r\n   * @param {number} rvx - [description]\r\n   * @param {number} rvy - [description]\r\n   * @param {number} step - [description]\r\n   */\n  step: function (res, x, y, vx, vy, width, height, rvx, rvy, step) {\n    var t = 0;\n    var tileX;\n    var tileY;\n    var tilesize = this.tilesize;\n    var mapWidth = this.width;\n    var mapHeight = this.height; //  Horizontal\n\n    if (vx) {\n      var pxOffsetX = vx > 0 ? width : 0;\n      var tileOffsetX = vx < 0 ? tilesize : 0;\n      var firstTileY = Math.max(Math.floor(y / tilesize), 0);\n      var lastTileY = Math.min(Math.ceil((y + height) / tilesize), mapHeight);\n      tileX = Math.floor((res.pos.x + pxOffsetX) / tilesize);\n      var prevTileX = Math.floor((x + pxOffsetX) / tilesize);\n\n      if (step > 0 || tileX === prevTileX || prevTileX < 0 || prevTileX >= mapWidth) {\n        prevTileX = -1;\n      }\n\n      if (tileX >= 0 && tileX < mapWidth) {\n        for (tileY = firstTileY; tileY < lastTileY; tileY++) {\n          if (prevTileX !== -1) {\n            t = this.data[tileY][prevTileX];\n\n            if (t > 1 && t <= this.lastSlope && this.checkDef(res, t, x, y, rvx, rvy, width, height, prevTileX, tileY)) {\n              break;\n            }\n          }\n\n          t = this.data[tileY][tileX];\n\n          if (t === 1 || t > this.lastSlope || t > 1 && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, tileY)) {\n            if (t > 1 && t <= this.lastSlope && res.collision.slope) {\n              break;\n            }\n\n            res.collision.x = true;\n            res.tile.x = t;\n            res.pos.x = tileX * tilesize - pxOffsetX + tileOffsetX;\n            x = res.pos.x;\n            rvx = 0;\n            break;\n          }\n        }\n      }\n    } //  Vertical\n\n\n    if (vy) {\n      var pxOffsetY = vy > 0 ? height : 0;\n      var tileOffsetY = vy < 0 ? tilesize : 0;\n      var firstTileX = Math.max(Math.floor(res.pos.x / tilesize), 0);\n      var lastTileX = Math.min(Math.ceil((res.pos.x + width) / tilesize), mapWidth);\n      tileY = Math.floor((res.pos.y + pxOffsetY) / tilesize);\n      var prevTileY = Math.floor((y + pxOffsetY) / tilesize);\n\n      if (step > 0 || tileY === prevTileY || prevTileY < 0 || prevTileY >= mapHeight) {\n        prevTileY = -1;\n      }\n\n      if (tileY >= 0 && tileY < mapHeight) {\n        for (tileX = firstTileX; tileX < lastTileX; tileX++) {\n          if (prevTileY !== -1) {\n            t = this.data[prevTileY][tileX];\n\n            if (t > 1 && t <= this.lastSlope && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, prevTileY)) {\n              break;\n            }\n          }\n\n          t = this.data[tileY][tileX];\n\n          if (t === 1 || t > this.lastSlope || t > 1 && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, tileY)) {\n            if (t > 1 && t <= this.lastSlope && res.collision.slope) {\n              break;\n            }\n\n            res.collision.y = true;\n            res.tile.y = t;\n            res.pos.y = tileY * tilesize - pxOffsetY + tileOffsetY;\n            break;\n          }\n        }\n      }\n    }\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.CollisionMap#checkDef\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} res - [description]\r\n   * @param {number} t - [description]\r\n   * @param {number} x - [description]\r\n   * @param {number} y - [description]\r\n   * @param {number} vx - [description]\r\n   * @param {number} vy - [description]\r\n   * @param {number} width - [description]\r\n   * @param {number} height - [description]\r\n   * @param {number} tileX - [description]\r\n   * @param {number} tileY - [description]\r\n   *\r\n   * @return {boolean} [description]\r\n   */\n  checkDef: function (res, t, x, y, vx, vy, width, height, tileX, tileY) {\n    var def = this.tiledef[t];\n\n    if (!def) {\n      return false;\n    }\n\n    var tilesize = this.tilesize;\n    var lx = (tileX + def[0]) * tilesize;\n    var ly = (tileY + def[1]) * tilesize;\n    var lvx = (def[2] - def[0]) * tilesize;\n    var lvy = (def[3] - def[1]) * tilesize;\n    var solid = def[4];\n    var tx = x + vx + (lvy < 0 ? width : 0) - lx;\n    var ty = y + vy + (lvx > 0 ? height : 0) - ly;\n\n    if (lvx * ty - lvy * tx > 0) {\n      if (vx * -lvy + vy * lvx < 0) {\n        return solid;\n      }\n\n      var length = Math.sqrt(lvx * lvx + lvy * lvy);\n      var nx = lvy / length;\n      var ny = -lvx / length;\n      var proj = tx * nx + ty * ny;\n      var px = nx * proj;\n      var py = ny * proj;\n\n      if (px * px + py * py >= vx * vx + vy * vy) {\n        return solid || lvx * (ty - vy) - lvy * (tx - vx) < 0.5;\n      }\n\n      res.pos.x = x + vx - px;\n      res.pos.y = y + vy - py;\n      res.collision.slope = {\n        x: lvx,\n        y: lvy,\n        nx: nx,\n        ny: ny\n      };\n      return true;\n    }\n\n    return false;\n  }\n});\nmodule.exports = CollisionMap;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/impact/CollisionMap.js"],"names":["Class","require","DefaultDefs","CollisionMap","initialize","tilesize","data","undefined","Array","isArray","width","length","height","lastSlope","tiledef","trace","x","y","vx","vy","objectWidth","objectHeight","res","collision","slope","pos","tile","steps","Math","ceil","max","abs","sx","sy","i","step","rvx","rvy","t","tileX","tileY","mapWidth","mapHeight","pxOffsetX","tileOffsetX","firstTileY","floor","lastTileY","min","prevTileX","checkDef","pxOffsetY","tileOffsetY","firstTileX","lastTileX","prevTileY","def","lx","ly","lvx","lvy","solid","tx","ty","sqrt","nx","ny","proj","px","py","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar DefaultDefs = require('./DefaultDefs');\r\n\r\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class CollisionMap\r\n * @memberof Phaser.Physics.Impact\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [tilesize=32] - [description]\r\n * @param {array} [data] - [description]\r\n */\r\nvar CollisionMap = new Class({\r\n\r\n    initialize:\r\n\r\n    function CollisionMap (tilesize, data)\r\n    {\r\n        if (tilesize === undefined) { tilesize = 32; }\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#tilesize\r\n         * @type {integer}\r\n         * @default 32\r\n         * @since 3.0.0\r\n         */\r\n        this.tilesize = tilesize;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#data\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.data = (Array.isArray(data)) ? data : [];\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = (Array.isArray(data)) ? data[0].length : 0;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = (Array.isArray(data)) ? data.length : 0;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#lastSlope\r\n         * @type {integer}\r\n         * @default 55\r\n         * @since 3.0.0\r\n         */\r\n        this.lastSlope = 55;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#tiledef\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.tiledef = DefaultDefs;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.CollisionMap#trace\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} vx - [description]\r\n     * @param {number} vy - [description]\r\n     * @param {number} objectWidth - [description]\r\n     * @param {number} objectHeight - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */\r\n    trace: function (x, y, vx, vy, objectWidth, objectHeight)\r\n    {\r\n        // Set up the trace-result\r\n        var res = {\r\n            collision: { x: false, y: false, slope: false },\r\n            pos: { x: x + vx, y: y + vy },\r\n            tile: { x: 0, y: 0 }\r\n        };\r\n\r\n        if (!this.data)\r\n        {\r\n            return res;\r\n        }\r\n        \r\n        var steps = Math.ceil(Math.max(Math.abs(vx), Math.abs(vy)) / this.tilesize);\r\n\r\n        if (steps > 1)\r\n        {\r\n            var sx = vx / steps;\r\n            var sy = vy / steps;\r\n            \r\n            for (var i = 0; i < steps && (sx || sy); i++)\r\n            {\r\n                this.step(res, x, y, sx, sy, objectWidth, objectHeight, vx, vy, i);\r\n                \r\n                x = res.pos.x;\r\n                y = res.pos.y;\r\n\r\n                if (res.collision.x)\r\n                {\r\n                    sx = 0;\r\n                    vx = 0;\r\n                }\r\n\r\n                if (res.collision.y)\r\n                {\r\n                    sy = 0;\r\n                    vy = 0;\r\n                }\r\n\r\n                if (res.collision.slope)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.step(res, x, y, vx, vy, objectWidth, objectHeight, vx, vy, 0);\r\n        }\r\n        \r\n        return res;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.CollisionMap#step\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} res - [description]\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} vx - [description]\r\n     * @param {number} vy - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} rvx - [description]\r\n     * @param {number} rvy - [description]\r\n     * @param {number} step - [description]\r\n     */\r\n    step: function (res, x, y, vx, vy, width, height, rvx, rvy, step)\r\n    {\r\n        var t = 0;\r\n        var tileX;\r\n        var tileY;\r\n        var tilesize = this.tilesize;\r\n        var mapWidth = this.width;\r\n        var mapHeight = this.height;\r\n        \r\n        //  Horizontal\r\n        if (vx)\r\n        {\r\n            var pxOffsetX = (vx > 0 ? width : 0);\r\n            var tileOffsetX = (vx < 0 ? tilesize : 0);\r\n            \r\n            var firstTileY = Math.max(Math.floor(y / tilesize), 0);\r\n            var lastTileY = Math.min(Math.ceil((y + height) / tilesize), mapHeight);\r\n            \r\n            tileX = Math.floor((res.pos.x + pxOffsetX) / tilesize);\r\n\r\n            var prevTileX = Math.floor((x + pxOffsetX) / tilesize);\r\n\r\n            if (step > 0 || tileX === prevTileX || prevTileX < 0 || prevTileX >= mapWidth)\r\n            {\r\n                prevTileX = -1;\r\n            }\r\n           \r\n            if (tileX >= 0 && tileX < mapWidth)\r\n            {\r\n                for (tileY = firstTileY; tileY < lastTileY; tileY++)\r\n                {\r\n                    if (prevTileX !== -1)\r\n                    {\r\n                        t = this.data[tileY][prevTileX];\r\n\r\n                        if (t > 1 && t <= this.lastSlope && this.checkDef(res, t, x, y, rvx, rvy, width, height, prevTileX, tileY))\r\n                        {\r\n                            break;\r\n                        }\r\n                    }\r\n                    \r\n                    t = this.data[tileY][tileX];\r\n\r\n                    if (t === 1 || t > this.lastSlope || (t > 1 && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, tileY)))\r\n                    {\r\n                        if (t > 1 && t <= this.lastSlope && res.collision.slope)\r\n                        {\r\n                            break;\r\n                        }\r\n                        \r\n                        res.collision.x = true;\r\n                        res.tile.x = t;\r\n                        res.pos.x = (tileX * tilesize) - pxOffsetX + tileOffsetX;\r\n                        x = res.pos.x;\r\n                        rvx = 0;\r\n\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        //  Vertical\r\n        if (vy)\r\n        {\r\n            var pxOffsetY = (vy > 0 ? height : 0);\r\n            var tileOffsetY = (vy < 0 ? tilesize : 0);\r\n            \r\n            var firstTileX = Math.max(Math.floor(res.pos.x / tilesize), 0);\r\n            var lastTileX = Math.min(Math.ceil((res.pos.x + width) / tilesize), mapWidth);\r\n            \r\n            tileY = Math.floor((res.pos.y + pxOffsetY) / tilesize);\r\n            \r\n            var prevTileY = Math.floor((y + pxOffsetY) / tilesize);\r\n\r\n            if (step > 0 || tileY === prevTileY || prevTileY < 0 || prevTileY >= mapHeight)\r\n            {\r\n                prevTileY = -1;\r\n            }\r\n            \r\n            if (tileY >= 0 && tileY < mapHeight)\r\n            {\r\n                for (tileX = firstTileX; tileX < lastTileX; tileX++)\r\n                {\r\n                    if (prevTileY !== -1)\r\n                    {\r\n                        t = this.data[prevTileY][tileX];\r\n\r\n                        if (t > 1 && t <= this.lastSlope && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, prevTileY))\r\n                        {\r\n                            break;\r\n                        }\r\n                    }\r\n                    \r\n                    t = this.data[tileY][tileX];\r\n\r\n                    if (t === 1 || t > this.lastSlope || (t > 1 && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, tileY)))\r\n                    {\r\n                        if (t > 1 && t <= this.lastSlope && res.collision.slope)\r\n                        {\r\n                            break;\r\n                        }\r\n                        \r\n                        res.collision.y = true;\r\n                        res.tile.y = t;\r\n                        res.pos.y = tileY * tilesize - pxOffsetY + tileOffsetY;\r\n\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    },\r\n    \r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.CollisionMap#checkDef\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} res - [description]\r\n     * @param {number} t - [description]\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} vx - [description]\r\n     * @param {number} vy - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} tileX - [description]\r\n     * @param {number} tileY - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */\r\n    checkDef: function (res, t, x, y, vx, vy, width, height, tileX, tileY)\r\n    {\r\n        var def = this.tiledef[t];\r\n\r\n        if (!def)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var tilesize = this.tilesize;\r\n        \r\n        var lx = (tileX + def[0]) * tilesize;\r\n        var ly = (tileY + def[1]) * tilesize;\r\n        var lvx = (def[2] - def[0]) * tilesize;\r\n        var lvy = (def[3] - def[1]) * tilesize;\r\n        var solid = def[4];\r\n        \r\n        var tx = x + vx + (lvy < 0 ? width : 0) - lx;\r\n        var ty = y + vy + (lvx > 0 ? height : 0) - ly;\r\n        \r\n        if (lvx * ty - lvy * tx > 0)\r\n        {\r\n            if (vx * -lvy + vy * lvx < 0)\r\n            {\r\n                return solid;\r\n            }\r\n            \r\n            var length = Math.sqrt(lvx * lvx + lvy * lvy);\r\n            var nx = lvy / length;\r\n            var ny = -lvx / length;\r\n            \r\n            var proj = tx * nx + ty * ny;\r\n            var px = nx * proj;\r\n            var py = ny * proj;\r\n            \r\n            if (px * px + py * py >= vx * vx + vy * vy)\r\n            {\r\n                return solid || (lvx * (ty - vy) - lvy * (tx - vx) < 0.5);\r\n            }\r\n            \r\n            res.pos.x = x + vx - px;\r\n            res.pos.y = y + vy - py;\r\n            res.collision.slope = { x: lvx, y: lvy, nx: nx, ny: ny };\r\n\r\n            return true;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = CollisionMap;\r\n"]},"metadata":{},"sourceType":"script"}