{"ast":null,"code":"/**\r\n* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.\r\n*\r\n* @class Pair\r\n*/\nvar Pair = {};\nmodule.exports = Pair;\n\n(function () {\n  /**\r\n   * Creates a pair.\r\n   * @method create\r\n   * @param {collision} collision\r\n   * @param {number} timestamp\r\n   * @return {pair} A new pair\r\n   */\n  Pair.create = function (collision, timestamp) {\n    var bodyA = collision.bodyA,\n        bodyB = collision.bodyB;\n    var pair = {\n      id: Pair.id(bodyA, bodyB),\n      bodyA: bodyA,\n      bodyB: bodyB,\n      activeContacts: [],\n      separation: 0,\n      isActive: true,\n      confirmedActive: true,\n      isSensor: bodyA.isSensor || bodyB.isSensor,\n      timeCreated: timestamp,\n      timeUpdated: timestamp,\n      collision: null,\n      inverseMass: 0,\n      friction: 0,\n      frictionStatic: 0,\n      restitution: 0,\n      slop: 0\n    };\n    Pair.update(pair, collision, timestamp);\n    return pair;\n  };\n  /**\r\n   * Updates a pair given a collision.\r\n   * @method update\r\n   * @param {pair} pair\r\n   * @param {collision} collision\r\n   * @param {number} timestamp\r\n   */\n\n\n  Pair.update = function (pair, collision, timestamp) {\n    pair.collision = collision;\n\n    if (collision.collided) {\n      var supports = collision.supports,\n          activeContacts = pair.activeContacts,\n          parentA = collision.parentA,\n          parentB = collision.parentB;\n      pair.inverseMass = parentA.inverseMass + parentB.inverseMass;\n      pair.friction = Math.min(parentA.friction, parentB.friction);\n      pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);\n      pair.restitution = Math.max(parentA.restitution, parentB.restitution);\n      pair.slop = Math.max(parentA.slop, parentB.slop);\n\n      for (var i = 0; i < supports.length; i++) {\n        activeContacts[i] = supports[i].contact;\n      } // optimise array size\n\n\n      var supportCount = supports.length;\n\n      if (supportCount < activeContacts.length) {\n        activeContacts.length = supportCount;\n      }\n\n      pair.separation = collision.depth;\n      Pair.setActive(pair, true, timestamp);\n    } else {\n      if (pair.isActive === true) Pair.setActive(pair, false, timestamp);\n    }\n  };\n  /**\r\n   * Set a pair as active or inactive.\r\n   * @method setActive\r\n   * @param {pair} pair\r\n   * @param {bool} isActive\r\n   * @param {number} timestamp\r\n   */\n\n\n  Pair.setActive = function (pair, isActive, timestamp) {\n    if (isActive) {\n      pair.isActive = true;\n      pair.timeUpdated = timestamp;\n    } else {\n      pair.isActive = false;\n      pair.activeContacts.length = 0;\n    }\n  };\n  /**\r\n   * Get the id for the given pair.\r\n   * @method id\r\n   * @param {body} bodyA\r\n   * @param {body} bodyB\r\n   * @return {string} Unique pairId\r\n   */\n\n\n  Pair.id = function (bodyA, bodyB) {\n    if (bodyA.id < bodyB.id) {\n      return 'A' + bodyA.id + 'B' + bodyB.id;\n    } else {\n      return 'A' + bodyB.id + 'B' + bodyA.id;\n    }\n  };\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/lib/collision/Pair.js"],"names":["Pair","module","exports","create","collision","timestamp","bodyA","bodyB","pair","id","activeContacts","separation","isActive","confirmedActive","isSensor","timeCreated","timeUpdated","inverseMass","friction","frictionStatic","restitution","slop","update","collided","supports","parentA","parentB","Math","min","max","i","length","contact","supportCount","depth","setActive"],"mappings":"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","sourcesContent":["/**\r\n* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.\r\n*\r\n* @class Pair\r\n*/\r\n\r\nvar Pair = {};\r\n\r\nmodule.exports = Pair;\r\n\r\n(function() {\r\n    \r\n    /**\r\n     * Creates a pair.\r\n     * @method create\r\n     * @param {collision} collision\r\n     * @param {number} timestamp\r\n     * @return {pair} A new pair\r\n     */\r\n    Pair.create = function(collision, timestamp) {\r\n        var bodyA = collision.bodyA,\r\n            bodyB = collision.bodyB;\r\n\r\n        var pair = {\r\n            id: Pair.id(bodyA, bodyB),\r\n            bodyA: bodyA,\r\n            bodyB: bodyB,\r\n            activeContacts: [],\r\n            separation: 0,\r\n            isActive: true,\r\n            confirmedActive: true,\r\n            isSensor: bodyA.isSensor || bodyB.isSensor,\r\n            timeCreated: timestamp,\r\n            timeUpdated: timestamp,\r\n            collision: null,\r\n            inverseMass: 0,\r\n            friction: 0,\r\n            frictionStatic: 0,\r\n            restitution: 0,\r\n            slop: 0\r\n        };\r\n\r\n        Pair.update(pair, collision, timestamp);\r\n\r\n        return pair;\r\n    };\r\n\r\n    /**\r\n     * Updates a pair given a collision.\r\n     * @method update\r\n     * @param {pair} pair\r\n     * @param {collision} collision\r\n     * @param {number} timestamp\r\n     */\r\n    Pair.update = function(pair, collision, timestamp) {\r\n        pair.collision = collision;\r\n\r\n        if (collision.collided) {\r\n            var supports = collision.supports,\r\n                activeContacts = pair.activeContacts,\r\n                parentA = collision.parentA,\r\n                parentB = collision.parentB;\r\n\r\n            pair.inverseMass = parentA.inverseMass + parentB.inverseMass;\r\n            pair.friction = Math.min(parentA.friction, parentB.friction);\r\n            pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);\r\n            pair.restitution = Math.max(parentA.restitution, parentB.restitution);\r\n            pair.slop = Math.max(parentA.slop, parentB.slop);\r\n\r\n            for (var i = 0; i < supports.length; i++) {\r\n                activeContacts[i] = supports[i].contact;\r\n            }\r\n\r\n            // optimise array size\r\n            var supportCount = supports.length;\r\n            if (supportCount < activeContacts.length) {\r\n                activeContacts.length = supportCount;\r\n            }\r\n\r\n            pair.separation = collision.depth;\r\n            Pair.setActive(pair, true, timestamp);\r\n        } else {\r\n            if (pair.isActive === true)\r\n                Pair.setActive(pair, false, timestamp);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Set a pair as active or inactive.\r\n     * @method setActive\r\n     * @param {pair} pair\r\n     * @param {bool} isActive\r\n     * @param {number} timestamp\r\n     */\r\n    Pair.setActive = function(pair, isActive, timestamp) {\r\n        if (isActive) {\r\n            pair.isActive = true;\r\n            pair.timeUpdated = timestamp;\r\n        } else {\r\n            pair.isActive = false;\r\n            pair.activeContacts.length = 0;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get the id for the given pair.\r\n     * @method id\r\n     * @param {body} bodyA\r\n     * @param {body} bodyB\r\n     * @return {string} Unique pairId\r\n     */\r\n    Pair.id = function(bodyA, bodyB) {\r\n        if (bodyA.id < bodyB.id) {\r\n            return 'A' + bodyA.id + 'B' + bodyB.id;\r\n        } else {\r\n            return 'A' + bodyB.id + 'B' + bodyA.id;\r\n        }\r\n    };\r\n\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}