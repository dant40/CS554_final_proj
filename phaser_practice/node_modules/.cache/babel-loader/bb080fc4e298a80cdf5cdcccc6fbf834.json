{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Bodies = require('./lib/factory/Bodies');\n\nvar Body = require('./lib/body/Body');\n\nvar Class = require('../../utils/Class');\n\nvar Components = require('./components');\n\nvar GetFastValue = require('../../utils/object/GetFastValue');\n\nvar HasValue = require('../../utils/object/HasValue');\n\nvar Vertices = require('./lib/geometry/Vertices');\n/**\r\n * @classdesc\r\n * A wrapper around a Tile that provides access to a corresponding Matter body. A tile can only\r\n * have one Matter body associated with it. You can either pass in an existing Matter body for\r\n * the tile or allow the constructor to create the corresponding body for you. If the Tile has a\r\n * collision group (defined in Tiled), those shapes will be used to create the body. If not, the\r\n * tile's rectangle bounding box will be used.\r\n *\r\n * The corresponding body will be accessible on the Tile itself via Tile.physics.matterBody.\r\n *\r\n * Note: not all Tiled collision shapes are supported. See\r\n * Phaser.Physics.Matter.TileBody#setFromTileCollision for more information.\r\n *\r\n * @class TileBody\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Physics.Matter.Components.Bounce\r\n * @extends Phaser.Physics.Matter.Components.Collision\r\n * @extends Phaser.Physics.Matter.Components.Friction\r\n * @extends Phaser.Physics.Matter.Components.Gravity\r\n * @extends Phaser.Physics.Matter.Components.Mass\r\n * @extends Phaser.Physics.Matter.Components.Sensor\r\n * @extends Phaser.Physics.Matter.Components.Sleep\r\n * @extends Phaser.Physics.Matter.Components.Static\r\n *\r\n * @param {Phaser.Physics.Matter.World} world - The Matter world instance this body belongs to.\r\n * @param {Phaser.Tilemaps.Tile} tile - The target tile that should have a Matter body.\r\n * @param {Phaser.Types.Physics.Matter.MatterTileOptions} [options] - Options to be used when creating the Matter body.\r\n */\n\n\nvar MatterTileBody = new Class({\n  Mixins: [Components.Bounce, Components.Collision, Components.Friction, Components.Gravity, Components.Mass, Components.Sensor, Components.Sleep, Components.Static],\n  initialize: function MatterTileBody(world, tile, options) {\n    /**\r\n     * The tile object the body is associated with.\r\n     *\r\n     * @name Phaser.Physics.Matter.TileBody#tile\r\n     * @type {Phaser.Tilemaps.Tile}\r\n     * @since 3.0.0\r\n     */\n    this.tile = tile;\n    /**\r\n     * The Matter world the body exists within.\r\n     *\r\n     * @name Phaser.Physics.Matter.TileBody#world\r\n     * @type {Phaser.Physics.Matter.World}\r\n     * @since 3.0.0\r\n     */\n\n    this.world = world; // Install a reference to 'this' on the tile and ensure there can only be one matter body\n    // associated with the tile\n\n    if (tile.physics.matterBody) {\n      tile.physics.matterBody.destroy();\n    }\n\n    tile.physics.matterBody = this; // Set the body either from an existing body (if provided), the shapes in the tileset\n    // collision layer (if it exists) or a rectangle matching the tile.\n\n    var body = GetFastValue(options, 'body', null);\n    var addToWorld = GetFastValue(options, 'addToWorld', true);\n\n    if (!body) {\n      var collisionGroup = tile.getCollisionGroup();\n      var collisionObjects = GetFastValue(collisionGroup, 'objects', []);\n\n      if (collisionObjects.length > 0) {\n        this.setFromTileCollision(options);\n      } else {\n        this.setFromTileRectangle(options);\n      }\n    } else {\n      this.setBody(body, addToWorld);\n    }\n  },\n\n  /**\r\n   * Sets the current body to a rectangle that matches the bounds of the tile.\r\n   *\r\n   * @method Phaser.Physics.Matter.TileBody#setFromTileRectangle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Matter.MatterBodyTileOptions} [options] - Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.\r\n   * \r\n   * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n   */\n  setFromTileRectangle: function (options) {\n    if (options === undefined) {\n      options = {};\n    }\n\n    if (!HasValue(options, 'isStatic')) {\n      options.isStatic = true;\n    }\n\n    if (!HasValue(options, 'addToWorld')) {\n      options.addToWorld = true;\n    }\n\n    var bounds = this.tile.getBounds();\n    var cx = bounds.x + bounds.width / 2;\n    var cy = bounds.y + bounds.height / 2;\n    var body = Bodies.rectangle(cx, cy, bounds.width, bounds.height, options);\n    this.setBody(body, options.addToWorld);\n    return this;\n  },\n\n  /**\r\n   * Sets the current body from the collision group associated with the Tile. This is typically\r\n   * set up in Tiled's collision editor.\r\n   *\r\n   * Note: Matter doesn't support all shapes from Tiled. Rectangles and polygons are directly\r\n   * supported. Ellipses are converted into circle bodies. Polylines are treated as if they are\r\n   * closed polygons. If a tile has multiple shapes, a multi-part body will be created. Concave\r\n   * shapes are supported if poly-decomp library is included. Decomposition is not guaranteed to\r\n   * work for complex shapes (e.g. holes), so it's often best to manually decompose a concave\r\n   * polygon into multiple convex polygons yourself.\r\n   *\r\n   * @method Phaser.Physics.Matter.TileBody#setFromTileCollision\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Matter.MatterBodyTileOptions} [options] - Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.\r\n   * \r\n   * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n   */\n  setFromTileCollision: function (options) {\n    if (options === undefined) {\n      options = {};\n    }\n\n    if (!HasValue(options, 'isStatic')) {\n      options.isStatic = true;\n    }\n\n    if (!HasValue(options, 'addToWorld')) {\n      options.addToWorld = true;\n    }\n\n    var sx = this.tile.tilemapLayer.scaleX;\n    var sy = this.tile.tilemapLayer.scaleY;\n    var tileX = this.tile.getLeft();\n    var tileY = this.tile.getTop();\n    var collisionGroup = this.tile.getCollisionGroup();\n    var collisionObjects = GetFastValue(collisionGroup, 'objects', []);\n    var parts = [];\n\n    for (var i = 0; i < collisionObjects.length; i++) {\n      var object = collisionObjects[i];\n      var ox = tileX + object.x * sx;\n      var oy = tileY + object.y * sy;\n      var ow = object.width * sx;\n      var oh = object.height * sy;\n      var body = null;\n\n      if (object.rectangle) {\n        body = Bodies.rectangle(ox + ow / 2, oy + oh / 2, ow, oh, options);\n      } else if (object.ellipse) {\n        body = Bodies.circle(ox + ow / 2, oy + oh / 2, ow / 2, options);\n      } else if (object.polygon || object.polyline) {\n        // Polygons and polylines are both treated as closed polygons\n        var originalPoints = object.polygon ? object.polygon : object.polyline;\n        var points = originalPoints.map(function (p) {\n          return {\n            x: p.x * sx,\n            y: p.y * sy\n          };\n        });\n        var vertices = Vertices.create(points); // Points are relative to the object's origin (first point placed in Tiled), but\n        // matter expects points to be relative to the center of mass. This only applies to\n        // convex shapes. When a concave shape is decomposed, multiple parts are created and\n        // the individual parts are positioned relative to (ox, oy).\n        //\n        //  Update: 8th January 2019 - the latest version of Matter needs the Vertices adjusted,\n        //  regardless if convex or concave.\n\n        var center = Vertices.centre(vertices);\n        ox += center.x;\n        oy += center.y;\n        body = Bodies.fromVertices(ox, oy, vertices, options);\n      }\n\n      if (body) {\n        parts.push(body);\n      }\n    }\n\n    if (parts.length === 1) {\n      this.setBody(parts[0], options.addToWorld);\n    } else if (parts.length > 1) {\n      options.parts = parts;\n      this.setBody(Body.create(options), options.addToWorld);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the current body to the given body. This will remove the previous body, if one already\r\n   * exists.\r\n   *\r\n   * @method Phaser.Physics.Matter.TileBody#setBody\r\n   * @since 3.0.0\r\n   *\r\n   * @param {MatterJS.BodyType} body - The new Matter body to use.\r\n   * @param {boolean} [addToWorld=true] - Whether or not to add the body to the Matter world.\r\n   * \r\n   * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n   */\n  setBody: function (body, addToWorld) {\n    if (addToWorld === undefined) {\n      addToWorld = true;\n    }\n\n    if (this.body) {\n      this.removeBody();\n    }\n\n    this.body = body;\n    this.body.gameObject = this;\n\n    if (addToWorld) {\n      this.world.add(this.body);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes the current body from the TileBody and from the Matter world\r\n   *\r\n   * @method Phaser.Physics.Matter.TileBody#removeBody\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n   */\n  removeBody: function () {\n    if (this.body) {\n      this.world.remove(this.body);\n      this.body.gameObject = undefined;\n      this.body = undefined;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes the current body from the tile and the world.\r\n   *\r\n   * @method Phaser.Physics.Matter.TileBody#destroy\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n   */\n  destroy: function () {\n    this.removeBody();\n    this.tile.physics.matterBody = undefined;\n  }\n});\nmodule.exports = MatterTileBody;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/MatterTileBody.js"],"names":["Bodies","require","Body","Class","Components","GetFastValue","HasValue","Vertices","MatterTileBody","Mixins","Bounce","Collision","Friction","Gravity","Mass","Sensor","Sleep","Static","initialize","world","tile","options","physics","matterBody","destroy","body","addToWorld","collisionGroup","getCollisionGroup","collisionObjects","length","setFromTileCollision","setFromTileRectangle","setBody","undefined","isStatic","bounds","getBounds","cx","x","width","cy","y","height","rectangle","sx","tilemapLayer","scaleX","sy","scaleY","tileX","getLeft","tileY","getTop","parts","i","object","ox","oy","ow","oh","ellipse","circle","polygon","polyline","originalPoints","points","map","p","vertices","create","center","centre","fromVertices","push","removeBody","gameObject","add","remove","module","exports"],"mappings":"AAAA;;;;;AAMA,IAAIA,MAAM,GAAGC,OAAO,CAAC,sBAAD,CAApB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,iBAAD,CAAlB;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,mBAAD,CAAnB;;AACA,IAAIG,UAAU,GAAGH,OAAO,CAAC,cAAD,CAAxB;;AACA,IAAII,YAAY,GAAGJ,OAAO,CAAC,iCAAD,CAA1B;;AACA,IAAIK,QAAQ,GAAGL,OAAO,CAAC,6BAAD,CAAtB;;AACA,IAAIM,QAAQ,GAAGN,OAAO,CAAC,yBAAD,CAAtB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,IAAIO,cAAc,GAAG,IAAIL,KAAJ,CAAU;AAE3BM,EAAAA,MAAM,EAAE,CACJL,UAAU,CAACM,MADP,EAEJN,UAAU,CAACO,SAFP,EAGJP,UAAU,CAACQ,QAHP,EAIJR,UAAU,CAACS,OAJP,EAKJT,UAAU,CAACU,IALP,EAMJV,UAAU,CAACW,MANP,EAOJX,UAAU,CAACY,KAPP,EAQJZ,UAAU,CAACa,MARP,CAFmB;AAa3BC,EAAAA,UAAU,EAEV,SAASV,cAAT,CAAyBW,KAAzB,EAAgCC,IAAhC,EAAsCC,OAAtC,EACA;AACI;;;;;;;AAOA,SAAKD,IAAL,GAAYA,IAAZ;AAEA;;;;;;;;AAOA,SAAKD,KAAL,GAAaA,KAAb,CAjBJ,CAmBI;AACA;;AACA,QAAIC,IAAI,CAACE,OAAL,CAAaC,UAAjB,EACA;AACIH,MAAAA,IAAI,CAACE,OAAL,CAAaC,UAAb,CAAwBC,OAAxB;AACH;;AAEDJ,IAAAA,IAAI,CAACE,OAAL,CAAaC,UAAb,GAA0B,IAA1B,CA1BJ,CA4BI;AACA;;AACA,QAAIE,IAAI,GAAGpB,YAAY,CAACgB,OAAD,EAAU,MAAV,EAAkB,IAAlB,CAAvB;AAEA,QAAIK,UAAU,GAAGrB,YAAY,CAACgB,OAAD,EAAU,YAAV,EAAwB,IAAxB,CAA7B;;AAEA,QAAI,CAACI,IAAL,EACA;AACI,UAAIE,cAAc,GAAGP,IAAI,CAACQ,iBAAL,EAArB;AACA,UAAIC,gBAAgB,GAAGxB,YAAY,CAACsB,cAAD,EAAiB,SAAjB,EAA4B,EAA5B,CAAnC;;AAEA,UAAIE,gBAAgB,CAACC,MAAjB,GAA0B,CAA9B,EACA;AACI,aAAKC,oBAAL,CAA0BV,OAA1B;AACH,OAHD,MAKA;AACI,aAAKW,oBAAL,CAA0BX,OAA1B;AACH;AACJ,KAbD,MAeA;AACI,WAAKY,OAAL,CAAaR,IAAb,EAAmBC,UAAnB;AACH;AACJ,GApE0B;;AAsE3B;;;;;;;;;;AAUAM,EAAAA,oBAAoB,EAAE,UAAUX,OAAV,EACtB;AACI,QAAIA,OAAO,KAAKa,SAAhB,EAA2B;AAAEb,MAAAA,OAAO,GAAG,EAAV;AAAe;;AAC5C,QAAI,CAACf,QAAQ,CAACe,OAAD,EAAU,UAAV,CAAb,EAAoC;AAAEA,MAAAA,OAAO,CAACc,QAAR,GAAmB,IAAnB;AAA0B;;AAChE,QAAI,CAAC7B,QAAQ,CAACe,OAAD,EAAU,YAAV,CAAb,EAAsC;AAAEA,MAAAA,OAAO,CAACK,UAAR,GAAqB,IAArB;AAA4B;;AAEpE,QAAIU,MAAM,GAAG,KAAKhB,IAAL,CAAUiB,SAAV,EAAb;AACA,QAAIC,EAAE,GAAGF,MAAM,CAACG,CAAP,GAAYH,MAAM,CAACI,KAAP,GAAe,CAApC;AACA,QAAIC,EAAE,GAAGL,MAAM,CAACM,CAAP,GAAYN,MAAM,CAACO,MAAP,GAAgB,CAArC;AACA,QAAIlB,IAAI,GAAGzB,MAAM,CAAC4C,SAAP,CAAiBN,EAAjB,EAAqBG,EAArB,EAAyBL,MAAM,CAACI,KAAhC,EAAuCJ,MAAM,CAACO,MAA9C,EAAsDtB,OAAtD,CAAX;AAEA,SAAKY,OAAL,CAAaR,IAAb,EAAmBJ,OAAO,CAACK,UAA3B;AAEA,WAAO,IAAP;AACH,GA9F0B;;AAgG3B;;;;;;;;;;;;;;;;;;AAkBAK,EAAAA,oBAAoB,EAAE,UAAUV,OAAV,EACtB;AACI,QAAIA,OAAO,KAAKa,SAAhB,EAA2B;AAAEb,MAAAA,OAAO,GAAG,EAAV;AAAe;;AAC5C,QAAI,CAACf,QAAQ,CAACe,OAAD,EAAU,UAAV,CAAb,EAAoC;AAAEA,MAAAA,OAAO,CAACc,QAAR,GAAmB,IAAnB;AAA0B;;AAChE,QAAI,CAAC7B,QAAQ,CAACe,OAAD,EAAU,YAAV,CAAb,EAAsC;AAAEA,MAAAA,OAAO,CAACK,UAAR,GAAqB,IAArB;AAA4B;;AAEpE,QAAImB,EAAE,GAAG,KAAKzB,IAAL,CAAU0B,YAAV,CAAuBC,MAAhC;AACA,QAAIC,EAAE,GAAG,KAAK5B,IAAL,CAAU0B,YAAV,CAAuBG,MAAhC;AACA,QAAIC,KAAK,GAAG,KAAK9B,IAAL,CAAU+B,OAAV,EAAZ;AACA,QAAIC,KAAK,GAAG,KAAKhC,IAAL,CAAUiC,MAAV,EAAZ;AACA,QAAI1B,cAAc,GAAG,KAAKP,IAAL,CAAUQ,iBAAV,EAArB;AACA,QAAIC,gBAAgB,GAAGxB,YAAY,CAACsB,cAAD,EAAiB,SAAjB,EAA4B,EAA5B,CAAnC;AAEA,QAAI2B,KAAK,GAAG,EAAZ;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1B,gBAAgB,CAACC,MAArC,EAA6CyB,CAAC,EAA9C,EACA;AACI,UAAIC,MAAM,GAAG3B,gBAAgB,CAAC0B,CAAD,CAA7B;AACA,UAAIE,EAAE,GAAGP,KAAK,GAAIM,MAAM,CAACjB,CAAP,GAAWM,EAA7B;AACA,UAAIa,EAAE,GAAGN,KAAK,GAAII,MAAM,CAACd,CAAP,GAAWM,EAA7B;AACA,UAAIW,EAAE,GAAGH,MAAM,CAAChB,KAAP,GAAeK,EAAxB;AACA,UAAIe,EAAE,GAAGJ,MAAM,CAACb,MAAP,GAAgBK,EAAzB;AACA,UAAIvB,IAAI,GAAG,IAAX;;AAEA,UAAI+B,MAAM,CAACZ,SAAX,EACA;AACInB,QAAAA,IAAI,GAAGzB,MAAM,CAAC4C,SAAP,CAAiBa,EAAE,GAAGE,EAAE,GAAG,CAA3B,EAA8BD,EAAE,GAAGE,EAAE,GAAG,CAAxC,EAA2CD,EAA3C,EAA+CC,EAA/C,EAAmDvC,OAAnD,CAAP;AACH,OAHD,MAIK,IAAImC,MAAM,CAACK,OAAX,EACL;AACIpC,QAAAA,IAAI,GAAGzB,MAAM,CAAC8D,MAAP,CAAcL,EAAE,GAAGE,EAAE,GAAG,CAAxB,EAA2BD,EAAE,GAAGE,EAAE,GAAG,CAArC,EAAwCD,EAAE,GAAG,CAA7C,EAAgDtC,OAAhD,CAAP;AACH,OAHI,MAIA,IAAImC,MAAM,CAACO,OAAP,IAAkBP,MAAM,CAACQ,QAA7B,EACL;AACI;AACA,YAAIC,cAAc,GAAGT,MAAM,CAACO,OAAP,GAAiBP,MAAM,CAACO,OAAxB,GAAkCP,MAAM,CAACQ,QAA9D;AAEA,YAAIE,MAAM,GAAGD,cAAc,CAACE,GAAf,CAAmB,UAAUC,CAAV,EAChC;AACI,iBAAO;AAAE7B,YAAAA,CAAC,EAAE6B,CAAC,CAAC7B,CAAF,GAAMM,EAAX;AAAeH,YAAAA,CAAC,EAAE0B,CAAC,CAAC1B,CAAF,GAAMM;AAAxB,WAAP;AACH,SAHY,CAAb;AAKA,YAAIqB,QAAQ,GAAG9D,QAAQ,CAAC+D,MAAT,CAAgBJ,MAAhB,CAAf,CATJ,CAWI;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAIK,MAAM,GAAGhE,QAAQ,CAACiE,MAAT,CAAgBH,QAAhB,CAAb;AAEAZ,QAAAA,EAAE,IAAIc,MAAM,CAAChC,CAAb;AACAmB,QAAAA,EAAE,IAAIa,MAAM,CAAC7B,CAAb;AAEAjB,QAAAA,IAAI,GAAGzB,MAAM,CAACyE,YAAP,CAAoBhB,EAApB,EAAwBC,EAAxB,EAA4BW,QAA5B,EAAsChD,OAAtC,CAAP;AACH;;AAED,UAAII,IAAJ,EACA;AACI6B,QAAAA,KAAK,CAACoB,IAAN,CAAWjD,IAAX;AACH;AACJ;;AAED,QAAI6B,KAAK,CAACxB,MAAN,KAAiB,CAArB,EACA;AACI,WAAKG,OAAL,CAAaqB,KAAK,CAAC,CAAD,CAAlB,EAAuBjC,OAAO,CAACK,UAA/B;AACH,KAHD,MAIK,IAAI4B,KAAK,CAACxB,MAAN,GAAe,CAAnB,EACL;AACIT,MAAAA,OAAO,CAACiC,KAAR,GAAgBA,KAAhB;AACA,WAAKrB,OAAL,CAAa/B,IAAI,CAACoE,MAAL,CAAYjD,OAAZ,CAAb,EAAmCA,OAAO,CAACK,UAA3C;AACH;;AAED,WAAO,IAAP;AACH,GA/L0B;;AAiM3B;;;;;;;;;;;;AAYAO,EAAAA,OAAO,EAAE,UAAUR,IAAV,EAAgBC,UAAhB,EACT;AACI,QAAIA,UAAU,KAAKQ,SAAnB,EAA8B;AAAER,MAAAA,UAAU,GAAG,IAAb;AAAoB;;AAEpD,QAAI,KAAKD,IAAT,EACA;AACI,WAAKkD,UAAL;AACH;;AAED,SAAKlD,IAAL,GAAYA,IAAZ;AACA,SAAKA,IAAL,CAAUmD,UAAV,GAAuB,IAAvB;;AAEA,QAAIlD,UAAJ,EACA;AACI,WAAKP,KAAL,CAAW0D,GAAX,CAAe,KAAKpD,IAApB;AACH;;AAED,WAAO,IAAP;AACH,GA/N0B;;AAiO3B;;;;;;;;AAQAkD,EAAAA,UAAU,EAAE,YACZ;AACI,QAAI,KAAKlD,IAAT,EACA;AACI,WAAKN,KAAL,CAAW2D,MAAX,CAAkB,KAAKrD,IAAvB;AACA,WAAKA,IAAL,CAAUmD,UAAV,GAAuB1C,SAAvB;AACA,WAAKT,IAAL,GAAYS,SAAZ;AACH;;AAED,WAAO,IAAP;AACH,GAnP0B;;AAqP3B;;;;;;;;AAQAV,EAAAA,OAAO,EAAE,YACT;AACI,SAAKmD,UAAL;AACA,SAAKvD,IAAL,CAAUE,OAAV,CAAkBC,UAAlB,GAA+BW,SAA/B;AACH;AAjQ0B,CAAV,CAArB;AAqQA6C,MAAM,CAACC,OAAP,GAAiBxE,cAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Bodies = require('./lib/factory/Bodies');\r\nvar Body = require('./lib/body/Body');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('./components');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar HasValue = require('../../utils/object/HasValue');\r\nvar Vertices = require('./lib/geometry/Vertices');\r\n\r\n/**\r\n * @classdesc\r\n * A wrapper around a Tile that provides access to a corresponding Matter body. A tile can only\r\n * have one Matter body associated with it. You can either pass in an existing Matter body for\r\n * the tile or allow the constructor to create the corresponding body for you. If the Tile has a\r\n * collision group (defined in Tiled), those shapes will be used to create the body. If not, the\r\n * tile's rectangle bounding box will be used.\r\n *\r\n * The corresponding body will be accessible on the Tile itself via Tile.physics.matterBody.\r\n *\r\n * Note: not all Tiled collision shapes are supported. See\r\n * Phaser.Physics.Matter.TileBody#setFromTileCollision for more information.\r\n *\r\n * @class TileBody\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Physics.Matter.Components.Bounce\r\n * @extends Phaser.Physics.Matter.Components.Collision\r\n * @extends Phaser.Physics.Matter.Components.Friction\r\n * @extends Phaser.Physics.Matter.Components.Gravity\r\n * @extends Phaser.Physics.Matter.Components.Mass\r\n * @extends Phaser.Physics.Matter.Components.Sensor\r\n * @extends Phaser.Physics.Matter.Components.Sleep\r\n * @extends Phaser.Physics.Matter.Components.Static\r\n *\r\n * @param {Phaser.Physics.Matter.World} world - The Matter world instance this body belongs to.\r\n * @param {Phaser.Tilemaps.Tile} tile - The target tile that should have a Matter body.\r\n * @param {Phaser.Types.Physics.Matter.MatterTileOptions} [options] - Options to be used when creating the Matter body.\r\n */\r\nvar MatterTileBody = new Class({\r\n\r\n    Mixins: [\r\n        Components.Bounce,\r\n        Components.Collision,\r\n        Components.Friction,\r\n        Components.Gravity,\r\n        Components.Mass,\r\n        Components.Sensor,\r\n        Components.Sleep,\r\n        Components.Static\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function MatterTileBody (world, tile, options)\r\n    {\r\n        /**\r\n         * The tile object the body is associated with.\r\n         *\r\n         * @name Phaser.Physics.Matter.TileBody#tile\r\n         * @type {Phaser.Tilemaps.Tile}\r\n         * @since 3.0.0\r\n         */\r\n        this.tile = tile;\r\n\r\n        /**\r\n         * The Matter world the body exists within.\r\n         *\r\n         * @name Phaser.Physics.Matter.TileBody#world\r\n         * @type {Phaser.Physics.Matter.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        // Install a reference to 'this' on the tile and ensure there can only be one matter body\r\n        // associated with the tile\r\n        if (tile.physics.matterBody)\r\n        {\r\n            tile.physics.matterBody.destroy();\r\n        }\r\n\r\n        tile.physics.matterBody = this;\r\n\r\n        // Set the body either from an existing body (if provided), the shapes in the tileset\r\n        // collision layer (if it exists) or a rectangle matching the tile.\r\n        var body = GetFastValue(options, 'body', null);\r\n\r\n        var addToWorld = GetFastValue(options, 'addToWorld', true);\r\n\r\n        if (!body)\r\n        {\r\n            var collisionGroup = tile.getCollisionGroup();\r\n            var collisionObjects = GetFastValue(collisionGroup, 'objects', []);\r\n\r\n            if (collisionObjects.length > 0)\r\n            {\r\n                this.setFromTileCollision(options);\r\n            }\r\n            else\r\n            {\r\n                this.setFromTileRectangle(options);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.setBody(body, addToWorld);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the current body to a rectangle that matches the bounds of the tile.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#setFromTileRectangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBodyTileOptions} [options] - Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.\r\n     * \r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    setFromTileRectangle: function (options)\r\n    {\r\n        if (options === undefined) { options = {}; }\r\n        if (!HasValue(options, 'isStatic')) { options.isStatic = true; }\r\n        if (!HasValue(options, 'addToWorld')) { options.addToWorld = true; }\r\n\r\n        var bounds = this.tile.getBounds();\r\n        var cx = bounds.x + (bounds.width / 2);\r\n        var cy = bounds.y + (bounds.height / 2);\r\n        var body = Bodies.rectangle(cx, cy, bounds.width, bounds.height, options);\r\n\r\n        this.setBody(body, options.addToWorld);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current body from the collision group associated with the Tile. This is typically\r\n     * set up in Tiled's collision editor.\r\n     *\r\n     * Note: Matter doesn't support all shapes from Tiled. Rectangles and polygons are directly\r\n     * supported. Ellipses are converted into circle bodies. Polylines are treated as if they are\r\n     * closed polygons. If a tile has multiple shapes, a multi-part body will be created. Concave\r\n     * shapes are supported if poly-decomp library is included. Decomposition is not guaranteed to\r\n     * work for complex shapes (e.g. holes), so it's often best to manually decompose a concave\r\n     * polygon into multiple convex polygons yourself.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#setFromTileCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBodyTileOptions} [options] - Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.\r\n     * \r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    setFromTileCollision: function (options)\r\n    {\r\n        if (options === undefined) { options = {}; }\r\n        if (!HasValue(options, 'isStatic')) { options.isStatic = true; }\r\n        if (!HasValue(options, 'addToWorld')) { options.addToWorld = true; }\r\n\r\n        var sx = this.tile.tilemapLayer.scaleX;\r\n        var sy = this.tile.tilemapLayer.scaleY;\r\n        var tileX = this.tile.getLeft();\r\n        var tileY = this.tile.getTop();\r\n        var collisionGroup = this.tile.getCollisionGroup();\r\n        var collisionObjects = GetFastValue(collisionGroup, 'objects', []);\r\n\r\n        var parts = [];\r\n\r\n        for (var i = 0; i < collisionObjects.length; i++)\r\n        {\r\n            var object = collisionObjects[i];\r\n            var ox = tileX + (object.x * sx);\r\n            var oy = tileY + (object.y * sy);\r\n            var ow = object.width * sx;\r\n            var oh = object.height * sy;\r\n            var body = null;\r\n\r\n            if (object.rectangle)\r\n            {\r\n                body = Bodies.rectangle(ox + ow / 2, oy + oh / 2, ow, oh, options);\r\n            }\r\n            else if (object.ellipse)\r\n            {\r\n                body = Bodies.circle(ox + ow / 2, oy + oh / 2, ow / 2, options);\r\n            }\r\n            else if (object.polygon || object.polyline)\r\n            {\r\n                // Polygons and polylines are both treated as closed polygons\r\n                var originalPoints = object.polygon ? object.polygon : object.polyline;\r\n\r\n                var points = originalPoints.map(function (p)\r\n                {\r\n                    return { x: p.x * sx, y: p.y * sy };\r\n                });\r\n\r\n                var vertices = Vertices.create(points);\r\n\r\n                // Points are relative to the object's origin (first point placed in Tiled), but\r\n                // matter expects points to be relative to the center of mass. This only applies to\r\n                // convex shapes. When a concave shape is decomposed, multiple parts are created and\r\n                // the individual parts are positioned relative to (ox, oy).\r\n                //\r\n                //  Update: 8th January 2019 - the latest version of Matter needs the Vertices adjusted,\r\n                //  regardless if convex or concave.\r\n\r\n                var center = Vertices.centre(vertices);\r\n\r\n                ox += center.x;\r\n                oy += center.y;\r\n\r\n                body = Bodies.fromVertices(ox, oy, vertices, options);\r\n            }\r\n\r\n            if (body)\r\n            {\r\n                parts.push(body);\r\n            }\r\n        }\r\n\r\n        if (parts.length === 1)\r\n        {\r\n            this.setBody(parts[0], options.addToWorld);\r\n        }\r\n        else if (parts.length > 1)\r\n        {\r\n            options.parts = parts;\r\n            this.setBody(Body.create(options), options.addToWorld);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current body to the given body. This will remove the previous body, if one already\r\n     * exists.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#setBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MatterJS.BodyType} body - The new Matter body to use.\r\n     * @param {boolean} [addToWorld=true] - Whether or not to add the body to the Matter world.\r\n     * \r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    setBody: function (body, addToWorld)\r\n    {\r\n        if (addToWorld === undefined) { addToWorld = true; }\r\n\r\n        if (this.body)\r\n        {\r\n            this.removeBody();\r\n        }\r\n\r\n        this.body = body;\r\n        this.body.gameObject = this;\r\n\r\n        if (addToWorld)\r\n        {\r\n            this.world.add(this.body);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the current body from the TileBody and from the Matter world\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#removeBody\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    removeBody: function ()\r\n    {\r\n        if (this.body)\r\n        {\r\n            this.world.remove(this.body);\r\n            this.body.gameObject = undefined;\r\n            this.body = undefined;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the current body from the tile and the world.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#destroy\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeBody();\r\n        this.tile.physics.matterBody = undefined;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MatterTileBody;\r\n"]},"metadata":{},"sourceType":"script"}