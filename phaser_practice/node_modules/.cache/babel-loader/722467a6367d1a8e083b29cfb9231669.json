{"ast":null,"code":"/**\r\n* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.\r\n*\r\n* @class Pairs\r\n*/\nvar Pairs = {};\nmodule.exports = Pairs;\n\nvar Pair = require('./Pair');\n\nvar Common = require('../core/Common');\n\n(function () {\n  Pairs._pairMaxIdleLife = 1000;\n  /**\r\n   * Creates a new pairs structure.\r\n   * @method create\r\n   * @param {object} options\r\n   * @return {pairs} A new pairs structure\r\n   */\n\n  Pairs.create = function (options) {\n    return Common.extend({\n      table: {},\n      list: [],\n      collisionStart: [],\n      collisionActive: [],\n      collisionEnd: []\n    }, options);\n  };\n  /**\r\n   * Updates pairs given a list of collisions.\r\n   * @method update\r\n   * @param {object} pairs\r\n   * @param {collision[]} collisions\r\n   * @param {number} timestamp\r\n   */\n\n\n  Pairs.update = function (pairs, collisions, timestamp) {\n    var pairsList = pairs.list,\n        pairsTable = pairs.table,\n        collisionStart = pairs.collisionStart,\n        collisionEnd = pairs.collisionEnd,\n        collisionActive = pairs.collisionActive,\n        collision,\n        pairId,\n        pair,\n        i; // clear collision state arrays, but maintain old reference\n\n    collisionStart.length = 0;\n    collisionEnd.length = 0;\n    collisionActive.length = 0;\n\n    for (i = 0; i < pairsList.length; i++) {\n      pairsList[i].confirmedActive = false;\n    }\n\n    for (i = 0; i < collisions.length; i++) {\n      collision = collisions[i];\n\n      if (collision.collided) {\n        pairId = Pair.id(collision.bodyA, collision.bodyB);\n        pair = pairsTable[pairId];\n\n        if (pair) {\n          // pair already exists (but may or may not be active)\n          if (pair.isActive) {\n            // pair exists and is active\n            collisionActive.push(pair);\n          } else {\n            // pair exists but was inactive, so a collision has just started again\n            collisionStart.push(pair);\n          } // update the pair\n\n\n          Pair.update(pair, collision, timestamp);\n          pair.confirmedActive = true;\n        } else {\n          // pair did not exist, create a new pair\n          pair = Pair.create(collision, timestamp);\n          pairsTable[pairId] = pair; // push the new pair\n\n          collisionStart.push(pair);\n          pairsList.push(pair);\n        }\n      }\n    } // deactivate previously active pairs that are now inactive\n\n\n    for (i = 0; i < pairsList.length; i++) {\n      pair = pairsList[i];\n\n      if (pair.isActive && !pair.confirmedActive) {\n        Pair.setActive(pair, false, timestamp);\n        collisionEnd.push(pair);\n      }\n    }\n  };\n  /**\r\n   * Finds and removes pairs that have been inactive for a set amount of time.\r\n   * @method removeOld\r\n   * @param {object} pairs\r\n   * @param {number} timestamp\r\n   */\n\n\n  Pairs.removeOld = function (pairs, timestamp) {\n    var pairsList = pairs.list,\n        pairsTable = pairs.table,\n        indexesToRemove = [],\n        pair,\n        collision,\n        pairIndex,\n        i;\n\n    for (i = 0; i < pairsList.length; i++) {\n      pair = pairsList[i];\n      collision = pair.collision; // never remove sleeping pairs\n\n      if (collision.bodyA.isSleeping || collision.bodyB.isSleeping) {\n        pair.timeUpdated = timestamp;\n        continue;\n      } // if pair is inactive for too long, mark it to be removed\n\n\n      if (timestamp - pair.timeUpdated > Pairs._pairMaxIdleLife) {\n        indexesToRemove.push(i);\n      }\n    } // remove marked pairs\n\n\n    for (i = 0; i < indexesToRemove.length; i++) {\n      pairIndex = indexesToRemove[i] - i;\n      pair = pairsList[pairIndex];\n      delete pairsTable[pair.id];\n      pairsList.splice(pairIndex, 1);\n    }\n  };\n  /**\r\n   * Clears the given pairs structure.\r\n   * @method clear\r\n   * @param {pairs} pairs\r\n   * @return {pairs} pairs\r\n   */\n\n\n  Pairs.clear = function (pairs) {\n    pairs.table = {};\n    pairs.list.length = 0;\n    pairs.collisionStart.length = 0;\n    pairs.collisionActive.length = 0;\n    pairs.collisionEnd.length = 0;\n    return pairs;\n  };\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/lib/collision/Pairs.js"],"names":["Pairs","module","exports","Pair","require","Common","_pairMaxIdleLife","create","options","extend","table","list","collisionStart","collisionActive","collisionEnd","update","pairs","collisions","timestamp","pairsList","pairsTable","collision","pairId","pair","i","length","confirmedActive","collided","id","bodyA","bodyB","isActive","push","setActive","removeOld","indexesToRemove","pairIndex","isSleeping","timeUpdated","splice","clear"],"mappings":"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","sourcesContent":["/**\r\n* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.\r\n*\r\n* @class Pairs\r\n*/\r\n\r\nvar Pairs = {};\r\n\r\nmodule.exports = Pairs;\r\n\r\nvar Pair = require('./Pair');\r\nvar Common = require('../core/Common');\r\n\r\n(function() {\r\n    \r\n    Pairs._pairMaxIdleLife = 1000;\r\n\r\n    /**\r\n     * Creates a new pairs structure.\r\n     * @method create\r\n     * @param {object} options\r\n     * @return {pairs} A new pairs structure\r\n     */\r\n    Pairs.create = function(options) {\r\n        return Common.extend({ \r\n            table: {},\r\n            list: [],\r\n            collisionStart: [],\r\n            collisionActive: [],\r\n            collisionEnd: []\r\n        }, options);\r\n    };\r\n\r\n    /**\r\n     * Updates pairs given a list of collisions.\r\n     * @method update\r\n     * @param {object} pairs\r\n     * @param {collision[]} collisions\r\n     * @param {number} timestamp\r\n     */\r\n    Pairs.update = function(pairs, collisions, timestamp) {\r\n        var pairsList = pairs.list,\r\n            pairsTable = pairs.table,\r\n            collisionStart = pairs.collisionStart,\r\n            collisionEnd = pairs.collisionEnd,\r\n            collisionActive = pairs.collisionActive,\r\n            collision,\r\n            pairId,\r\n            pair,\r\n            i;\r\n\r\n        // clear collision state arrays, but maintain old reference\r\n        collisionStart.length = 0;\r\n        collisionEnd.length = 0;\r\n        collisionActive.length = 0;\r\n\r\n        for (i = 0; i < pairsList.length; i++) {\r\n            pairsList[i].confirmedActive = false;\r\n        }\r\n\r\n        for (i = 0; i < collisions.length; i++) {\r\n            collision = collisions[i];\r\n\r\n            if (collision.collided) {\r\n                pairId = Pair.id(collision.bodyA, collision.bodyB);\r\n\r\n                pair = pairsTable[pairId];\r\n                \r\n                if (pair) {\r\n                    // pair already exists (but may or may not be active)\r\n                    if (pair.isActive) {\r\n                        // pair exists and is active\r\n                        collisionActive.push(pair);\r\n                    } else {\r\n                        // pair exists but was inactive, so a collision has just started again\r\n                        collisionStart.push(pair);\r\n                    }\r\n\r\n                    // update the pair\r\n                    Pair.update(pair, collision, timestamp);\r\n                    pair.confirmedActive = true;\r\n                } else {\r\n                    // pair did not exist, create a new pair\r\n                    pair = Pair.create(collision, timestamp);\r\n                    pairsTable[pairId] = pair;\r\n\r\n                    // push the new pair\r\n                    collisionStart.push(pair);\r\n                    pairsList.push(pair);\r\n                }\r\n            }\r\n        }\r\n\r\n        // deactivate previously active pairs that are now inactive\r\n        for (i = 0; i < pairsList.length; i++) {\r\n            pair = pairsList[i];\r\n            if (pair.isActive && !pair.confirmedActive) {\r\n                Pair.setActive(pair, false, timestamp);\r\n                collisionEnd.push(pair);\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Finds and removes pairs that have been inactive for a set amount of time.\r\n     * @method removeOld\r\n     * @param {object} pairs\r\n     * @param {number} timestamp\r\n     */\r\n    Pairs.removeOld = function(pairs, timestamp) {\r\n        var pairsList = pairs.list,\r\n            pairsTable = pairs.table,\r\n            indexesToRemove = [],\r\n            pair,\r\n            collision,\r\n            pairIndex,\r\n            i;\r\n\r\n        for (i = 0; i < pairsList.length; i++) {\r\n            pair = pairsList[i];\r\n            collision = pair.collision;\r\n            \r\n            // never remove sleeping pairs\r\n            if (collision.bodyA.isSleeping || collision.bodyB.isSleeping) {\r\n                pair.timeUpdated = timestamp;\r\n                continue;\r\n            }\r\n\r\n            // if pair is inactive for too long, mark it to be removed\r\n            if (timestamp - pair.timeUpdated > Pairs._pairMaxIdleLife) {\r\n                indexesToRemove.push(i);\r\n            }\r\n        }\r\n\r\n        // remove marked pairs\r\n        for (i = 0; i < indexesToRemove.length; i++) {\r\n            pairIndex = indexesToRemove[i] - i;\r\n            pair = pairsList[pairIndex];\r\n            delete pairsTable[pair.id];\r\n            pairsList.splice(pairIndex, 1);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Clears the given pairs structure.\r\n     * @method clear\r\n     * @param {pairs} pairs\r\n     * @return {pairs} pairs\r\n     */\r\n    Pairs.clear = function(pairs) {\r\n        pairs.table = {};\r\n        pairs.list.length = 0;\r\n        pairs.collisionStart.length = 0;\r\n        pairs.collisionActive.length = 0;\r\n        pairs.collisionEnd.length = 0;\r\n        return pairs;\r\n    };\r\n\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}