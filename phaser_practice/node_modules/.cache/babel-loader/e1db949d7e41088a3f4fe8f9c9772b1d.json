{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar CanvasSnapshot = require('../snapshot/CanvasSnapshot');\n\nvar CameraEvents = require('../../cameras/2d/events');\n\nvar Class = require('../../utils/Class');\n\nvar CONST = require('../../const');\n\nvar GetBlendModes = require('./utils/GetBlendModes');\n\nvar ScaleEvents = require('../../scale/events');\n\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\n/**\r\n * @classdesc\r\n * The Canvas Renderer is responsible for managing 2D canvas rendering contexts, including the one used by the Game's canvas. It tracks the internal state of a given context and can renderer textured Game Objects to it, taking into account alpha, blending, and scaling.\r\n *\r\n * @class CanvasRenderer\r\n * @memberof Phaser.Renderer.Canvas\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser Game instance that owns this renderer.\r\n */\n\n\nvar CanvasRenderer = new Class({\n  initialize: function CanvasRenderer(game) {\n    /**\r\n     * The Phaser Game instance that owns this renderer.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#game\r\n     * @type {Phaser.Game}\r\n     * @since 3.0.0\r\n     */\n    this.game = game;\n    /**\r\n     * A constant which allows the renderer to be easily identified as a Canvas Renderer.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#type\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.type = CONST.CANVAS;\n    /**\r\n     * The total number of Game Objects which were rendered in a frame.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#drawCount\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.drawCount = 0;\n    /**\r\n     * The width of the canvas being rendered to.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#width\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.width = 0;\n    /**\r\n     * The height of the canvas being rendered to.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#height\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.height = 0;\n    /**\r\n     * The local configuration settings of the CanvasRenderer.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#config\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.config = {\n      clearBeforeRender: game.config.clearBeforeRender,\n      backgroundColor: game.config.backgroundColor,\n      resolution: game.config.resolution,\n      antialias: game.config.antialias,\n      roundPixels: game.config.roundPixels\n    };\n    /**\r\n     * The canvas element which the Game uses.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#gameCanvas\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.0.0\r\n     */\n\n    this.gameCanvas = game.canvas;\n    var contextOptions = {\n      alpha: game.config.transparent,\n      desynchronized: game.config.desynchronized\n    };\n    /**\r\n     * The canvas context used to render all Cameras in all Scenes during the game loop.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#gameContext\r\n     * @type {CanvasRenderingContext2D}\r\n     * @since 3.0.0\r\n     */\n\n    this.gameContext = this.game.config.context ? this.game.config.context : this.gameCanvas.getContext('2d', contextOptions);\n    /**\r\n     * The canvas context currently used by the CanvasRenderer for all rendering operations.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#currentContext\r\n     * @type {CanvasRenderingContext2D}\r\n     * @since 3.0.0\r\n     */\n\n    this.currentContext = this.gameContext;\n    /**\r\n     * Should the Canvas use Image Smoothing or not when drawing Sprites?\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#antialias\r\n     * @type {boolean}\r\n     * @since 3.20.0\r\n     */\n\n    this.antialias = game.config.antialias;\n    /**\r\n     * The blend modes supported by the Canvas Renderer.\r\n     *\r\n     * This object maps the {@link Phaser.BlendModes} to canvas compositing operations.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#blendModes\r\n     * @type {array}\r\n     * @since 3.0.0\r\n     */\n\n    this.blendModes = GetBlendModes();\n    /**\r\n     * Details about the currently scheduled snapshot.\r\n     * \r\n     * If a non-null `callback` is set in this object, a snapshot of the canvas will be taken after the current frame is fully rendered.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#snapshotState\r\n     * @type {Phaser.Types.Renderer.Snapshot.SnapshotState}\r\n     * @since 3.16.0\r\n     */\n\n    this.snapshotState = {\n      x: 0,\n      y: 0,\n      width: 1,\n      height: 1,\n      getPixel: false,\n      callback: null,\n      type: 'image/png',\n      encoder: 0.92\n    };\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix1\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix1 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix2\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix2 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix3\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix3 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix4\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix4 = new TransformMatrix();\n    this.init();\n  },\n\n  /**\r\n   * Prepares the game canvas for rendering.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#init\r\n   * @since 3.0.0\r\n   */\n  init: function () {\n    this.game.scale.on(ScaleEvents.RESIZE, this.onResize, this);\n    var baseSize = this.game.scale.baseSize;\n    this.resize(baseSize.width, baseSize.height);\n  },\n\n  /**\r\n   * The event handler that manages the `resize` event dispatched by the Scale Manager.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#onResize\r\n   * @since 3.16.0\r\n   *\r\n   * @param {Phaser.Structs.Size} gameSize - The default Game Size object. This is the un-modified game dimensions.\r\n   * @param {Phaser.Structs.Size} baseSize - The base Size object. The game dimensions multiplied by the resolution. The canvas width / height values match this.\r\n   * @param {Phaser.Structs.Size} displaySize - The display Size object. The size of the canvas style width / height attributes.\r\n   * @param {number} [resolution] - The Scale Manager resolution setting.\r\n   */\n  onResize: function (gameSize, baseSize) {\n    //  Has the underlying canvas size changed?\n    if (baseSize.width !== this.width || baseSize.height !== this.height) {\n      this.resize(baseSize.width, baseSize.height);\n    }\n  },\n\n  /**\r\n   * Resize the main game canvas.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#resize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [width] - The new width of the renderer.\r\n   * @param {number} [height] - The new height of the renderer.\r\n   */\n  resize: function (width, height) {\n    this.width = width;\n    this.height = height;\n  },\n\n  /**\r\n   * Resets the transformation matrix of the current context to the identity matrix, thus resetting any transformation.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#resetTransform\r\n   * @since 3.0.0\r\n   */\n  resetTransform: function () {\n    this.currentContext.setTransform(1, 0, 0, 1, 0, 0);\n  },\n\n  /**\r\n   * Sets the blend mode (compositing operation) of the current context.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#setBlendMode\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} blendMode - The new blend mode which should be used.\r\n   *\r\n   * @return {this} This CanvasRenderer object.\r\n   */\n  setBlendMode: function (blendMode) {\n    this.currentContext.globalCompositeOperation = blendMode;\n    return this;\n  },\n\n  /**\r\n   * Changes the Canvas Rendering Context that all draw operations are performed against.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#setContext\r\n   * @since 3.12.0\r\n   *\r\n   * @param {?CanvasRenderingContext2D} [ctx] - The new Canvas Rendering Context to draw everything to. Leave empty to reset to the Game Canvas.\r\n   *\r\n   * @return {this} The Canvas Renderer instance.\r\n   */\n  setContext: function (ctx) {\n    this.currentContext = ctx ? ctx : this.gameContext;\n    return this;\n  },\n\n  /**\r\n   * Sets the global alpha of the current context.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#setAlpha\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} alpha - The new alpha to use, where 0 is fully transparent and 1 is fully opaque.\r\n   *\r\n   * @return {this} This CanvasRenderer object.\r\n   */\n  setAlpha: function (alpha) {\n    this.currentContext.globalAlpha = alpha;\n    return this;\n  },\n\n  /**\r\n   * Called at the start of the render loop.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#preRender\r\n   * @since 3.0.0\r\n   */\n  preRender: function () {\n    var ctx = this.gameContext;\n    var config = this.config;\n    var width = this.width;\n    var height = this.height;\n    ctx.globalAlpha = 1;\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n    if (config.clearBeforeRender) {\n      ctx.clearRect(0, 0, width, height);\n    }\n\n    if (!config.transparent) {\n      ctx.fillStyle = config.backgroundColor.rgba;\n      ctx.fillRect(0, 0, width, height);\n    }\n\n    ctx.save();\n    this.drawCount = 0;\n  },\n\n  /**\r\n   * Renders the Scene to the given Camera.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#render\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Scene} scene - The Scene to render.\r\n   * @param {Phaser.GameObjects.DisplayList} children - The Game Objects within the Scene to be rendered.\r\n   * @param {number} interpolationPercentage - The interpolation percentage to apply. Currently unused.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera to render with.\r\n   */\n  render: function (scene, children, interpolationPercentage, camera) {\n    var list = children.list;\n    var childCount = list.length;\n    var cx = camera._cx;\n    var cy = camera._cy;\n    var cw = camera._cw;\n    var ch = camera._ch;\n    var ctx = camera.renderToTexture ? camera.context : scene.sys.context; //  Save context pre-clip\n\n    ctx.save();\n\n    if (this.game.scene.customViewports) {\n      ctx.beginPath();\n      ctx.rect(cx, cy, cw, ch);\n      ctx.clip();\n    }\n\n    this.currentContext = ctx;\n    var mask = camera.mask;\n\n    if (mask) {\n      mask.preRenderCanvas(this, null, camera._maskCamera);\n    }\n\n    if (!camera.transparent) {\n      ctx.fillStyle = camera.backgroundColor.rgba;\n      ctx.fillRect(cx, cy, cw, ch);\n    }\n\n    ctx.globalAlpha = camera.alpha;\n    ctx.globalCompositeOperation = 'source-over';\n    this.drawCount += list.length;\n\n    if (camera.renderToTexture) {\n      camera.emit(CameraEvents.PRE_RENDER, camera);\n    }\n\n    camera.matrix.copyToContext(ctx);\n\n    for (var i = 0; i < childCount; i++) {\n      var child = list[i];\n\n      if (!child.willRender(camera)) {\n        continue;\n      }\n\n      if (child.mask) {\n        child.mask.preRenderCanvas(this, child, camera);\n      }\n\n      child.renderCanvas(this, child, interpolationPercentage, camera);\n\n      if (child.mask) {\n        child.mask.postRenderCanvas(this, child, camera);\n      }\n    }\n\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.globalAlpha = 1;\n    camera.flashEffect.postRenderCanvas(ctx);\n    camera.fadeEffect.postRenderCanvas(ctx);\n    camera.dirty = false;\n\n    if (mask) {\n      mask.postRenderCanvas(this);\n    } //  Restore pre-clip context\n\n\n    ctx.restore();\n\n    if (camera.renderToTexture) {\n      camera.emit(CameraEvents.POST_RENDER, camera);\n      scene.sys.context.drawImage(camera.canvas, cx, cy);\n    }\n  },\n\n  /**\r\n   * Restores the game context's global settings and takes a snapshot if one is scheduled.\r\n   *\r\n   * The post-render step happens after all Cameras in all Scenes have been rendered.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#postRender\r\n   * @since 3.0.0\r\n   */\n  postRender: function () {\n    var ctx = this.gameContext;\n    ctx.restore();\n    var state = this.snapshotState;\n\n    if (state.callback) {\n      CanvasSnapshot(this.gameCanvas, state);\n      state.callback = null;\n    }\n  },\n\n  /**\r\n   * Takes a snapshot of the given area of the given canvas.\r\n   * \r\n   * Unlike the other snapshot methods, this one is processed immediately and doesn't wait for the next render.\r\n   * \r\n   * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets\r\n   * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshotCanvas\r\n   * @since 3.19.0\r\n   *\r\n   * @param {HTMLCanvasElement} canvas - The canvas to grab from.\r\n   * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n   * @param {boolean} [getPixel=false] - Grab a single pixel as a Color object, or an area as an Image object?\r\n   * @param {integer} [x=0] - The x coordinate to grab from.\r\n   * @param {integer} [y=0] - The y coordinate to grab from.\r\n   * @param {integer} [width=canvas.width] - The width of the area to grab.\r\n   * @param {integer} [height=canvas.height] - The height of the area to grab.\r\n   * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n   * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n   *\r\n   * @return {this} This Canvas Renderer.\r\n   */\n  snapshotCanvas: function (canvas, callback, getPixel, x, y, width, height, type, encoderOptions) {\n    if (getPixel === undefined) {\n      getPixel = false;\n    }\n\n    this.snapshotArea(x, y, width, height, callback, type, encoderOptions);\n    var state = this.snapshotState;\n    state.getPixel = getPixel;\n    CanvasSnapshot(this.canvas, state);\n    state.callback = null;\n    return this;\n  },\n\n  /**\r\n   * Schedules a snapshot of the entire game viewport to be taken after the current frame is rendered.\r\n   * \r\n   * To capture a specific area see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.\r\n   * \r\n   * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n   * calling this method will override it.\r\n   * \r\n   * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets\r\n   * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshot\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n   * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n   * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n   *\r\n   * @return {this} This WebGL Renderer.\r\n   */\n  snapshot: function (callback, type, encoderOptions) {\n    return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, callback, type, encoderOptions);\n  },\n\n  /**\r\n   * Schedules a snapshot of the given area of the game viewport to be taken after the current frame is rendered.\r\n   * \r\n   * To capture the whole game viewport see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.\r\n   * \r\n   * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n   * calling this method will override it.\r\n   * \r\n   * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets\r\n   * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshotArea\r\n   * @since 3.16.0\r\n   *\r\n   * @param {integer} x - The x coordinate to grab from.\r\n   * @param {integer} y - The y coordinate to grab from.\r\n   * @param {integer} width - The width of the area to grab.\r\n   * @param {integer} height - The height of the area to grab.\r\n   * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n   * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n   * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n   *\r\n   * @return {this} This WebGL Renderer.\r\n   */\n  snapshotArea: function (x, y, width, height, callback, type, encoderOptions) {\n    var state = this.snapshotState;\n    state.callback = callback;\n    state.type = type;\n    state.encoder = encoderOptions;\n    state.getPixel = false;\n    state.x = x;\n    state.y = y;\n    state.width = Math.min(width, this.gameCanvas.width);\n    state.height = Math.min(height, this.gameCanvas.height);\n    return this;\n  },\n\n  /**\r\n   * Schedules a snapshot of the given pixel from the game viewport to be taken after the current frame is rendered.\r\n   * \r\n   * To capture the whole game viewport see the `snapshot` method. To capture a specific area, see `snapshotArea`.\r\n   * \r\n   * Only one snapshot can be active _per frame_. If you have already called `snapshotArea`, for example, then\r\n   * calling this method will override it.\r\n   * \r\n   * Unlike the other two snapshot methods, this one will return a `Color` object containing the color data for\r\n   * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,\r\n   * using less memory.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshotPixel\r\n   * @since 3.16.0\r\n   *\r\n   * @param {integer} x - The x coordinate of the pixel to get.\r\n   * @param {integer} y - The y coordinate of the pixel to get.\r\n   * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.\r\n   *\r\n   * @return {this} This WebGL Renderer.\r\n   */\n  snapshotPixel: function (x, y, callback) {\n    this.snapshotArea(x, y, 1, 1, callback);\n    this.snapshotState.getPixel = true;\n    return this;\n  },\n\n  /**\r\n   * Takes a Sprite Game Object, or any object that extends it, and draws it to the current context.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#batchSprite\r\n   * @since 3.12.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} sprite - The texture based Game Object to draw.\r\n   * @param {Phaser.Textures.Frame} frame - The frame to draw, doesn't have to be that owned by the Game Object.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use for the rendering transform.\r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} [parentTransformMatrix] - The transform matrix of the parent container, if set.\r\n   */\n  batchSprite: function (sprite, frame, camera, parentTransformMatrix) {\n    var alpha = camera.alpha * sprite.alpha;\n\n    if (alpha === 0) {\n      //  Nothing to see, so abort early\n      return;\n    }\n\n    var ctx = this.currentContext;\n    var camMatrix = this._tempMatrix1;\n    var spriteMatrix = this._tempMatrix2;\n    var calcMatrix = this._tempMatrix3;\n    var cd = frame.canvasData;\n    var frameX = cd.x;\n    var frameY = cd.y;\n    var frameWidth = frame.cutWidth;\n    var frameHeight = frame.cutHeight;\n    var customPivot = frame.customPivot;\n    var res = frame.source.resolution;\n    var displayOriginX = sprite.displayOriginX;\n    var displayOriginY = sprite.displayOriginY;\n    var x = -displayOriginX + frame.x;\n    var y = -displayOriginY + frame.y;\n\n    if (sprite.isCropped) {\n      var crop = sprite._crop;\n\n      if (crop.flipX !== sprite.flipX || crop.flipY !== sprite.flipY) {\n        frame.updateCropUVs(crop, sprite.flipX, sprite.flipY);\n      }\n\n      frameWidth = crop.cw;\n      frameHeight = crop.ch;\n      frameX = crop.cx;\n      frameY = crop.cy;\n      x = -displayOriginX + crop.x;\n      y = -displayOriginY + crop.y;\n\n      if (sprite.flipX) {\n        if (x >= 0) {\n          x = -(x + frameWidth);\n        } else if (x < 0) {\n          x = Math.abs(x) - frameWidth;\n        }\n      }\n\n      if (sprite.flipY) {\n        if (y >= 0) {\n          y = -(y + frameHeight);\n        } else if (y < 0) {\n          y = Math.abs(y) - frameHeight;\n        }\n      }\n    }\n\n    var flipX = 1;\n    var flipY = 1;\n\n    if (sprite.flipX) {\n      if (!customPivot) {\n        x += -frame.realWidth + displayOriginX * 2;\n      }\n\n      flipX = -1;\n    } //  Auto-invert the flipY if this is coming from a GLTexture\n\n\n    if (sprite.flipY) {\n      if (!customPivot) {\n        y += -frame.realHeight + displayOriginY * 2;\n      }\n\n      flipY = -1;\n    }\n\n    spriteMatrix.applyITRS(sprite.x, sprite.y, sprite.rotation, sprite.scaleX * flipX, sprite.scaleY * flipY);\n    camMatrix.copyFrom(camera.matrix);\n\n    if (parentTransformMatrix) {\n      //  Multiply the camera by the parent matrix\n      camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * sprite.scrollFactorX, -camera.scrollY * sprite.scrollFactorY); //  Undo the camera scroll\n\n      spriteMatrix.e = sprite.x;\n      spriteMatrix.f = sprite.y; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n      camMatrix.multiply(spriteMatrix, calcMatrix);\n    } else {\n      spriteMatrix.e -= camera.scrollX * sprite.scrollFactorX;\n      spriteMatrix.f -= camera.scrollY * sprite.scrollFactorY; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n      camMatrix.multiply(spriteMatrix, calcMatrix);\n    }\n\n    ctx.save();\n    calcMatrix.setToContext(ctx);\n    ctx.globalCompositeOperation = this.blendModes[sprite.blendMode];\n    ctx.globalAlpha = alpha;\n    ctx.imageSmoothingEnabled = !(!this.antialias || frame.source.scaleMode);\n    ctx.drawImage(frame.source.image, frameX, frameY, frameWidth, frameHeight, x, y, frameWidth / res, frameHeight / res);\n    ctx.restore();\n  },\n\n  /**\r\n   * Destroys all object references in the Canvas Renderer.\r\n   *\r\n   * @method Phaser.Renderer.Canvas.CanvasRenderer#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.gameCanvas = null;\n    this.gameContext = null;\n    this.game = null;\n  }\n});\nmodule.exports = CanvasRenderer;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/renderer/canvas/CanvasRenderer.js"],"names":["CanvasSnapshot","require","CameraEvents","Class","CONST","GetBlendModes","ScaleEvents","TransformMatrix","CanvasRenderer","initialize","game","type","CANVAS","drawCount","width","height","config","clearBeforeRender","backgroundColor","resolution","antialias","roundPixels","gameCanvas","canvas","contextOptions","alpha","transparent","desynchronized","gameContext","context","getContext","currentContext","blendModes","snapshotState","x","y","getPixel","callback","encoder","_tempMatrix1","_tempMatrix2","_tempMatrix3","_tempMatrix4","init","scale","on","RESIZE","onResize","baseSize","resize","gameSize","resetTransform","setTransform","setBlendMode","blendMode","globalCompositeOperation","setContext","ctx","setAlpha","globalAlpha","preRender","clearRect","fillStyle","rgba","fillRect","save","render","scene","children","interpolationPercentage","camera","list","childCount","length","cx","_cx","cy","_cy","cw","_cw","ch","_ch","renderToTexture","sys","customViewports","beginPath","rect","clip","mask","preRenderCanvas","_maskCamera","emit","PRE_RENDER","matrix","copyToContext","i","child","willRender","renderCanvas","postRenderCanvas","flashEffect","fadeEffect","dirty","restore","POST_RENDER","drawImage","postRender","state","snapshotCanvas","encoderOptions","undefined","snapshotArea","snapshot","Math","min","snapshotPixel","batchSprite","sprite","frame","parentTransformMatrix","camMatrix","spriteMatrix","calcMatrix","cd","canvasData","frameX","frameY","frameWidth","cutWidth","frameHeight","cutHeight","customPivot","res","source","displayOriginX","displayOriginY","isCropped","crop","_crop","flipX","flipY","updateCropUVs","abs","realWidth","realHeight","applyITRS","rotation","scaleX","scaleY","copyFrom","multiplyWithOffset","scrollX","scrollFactorX","scrollY","scrollFactorY","e","f","multiply","setToContext","imageSmoothingEnabled","scaleMode","image","destroy","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CanvasSnapshot = require('../snapshot/CanvasSnapshot');\r\nvar CameraEvents = require('../../cameras/2d/events');\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../../const');\r\nvar GetBlendModes = require('./utils/GetBlendModes');\r\nvar ScaleEvents = require('../../scale/events');\r\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\r\n\r\n/**\r\n * @classdesc\r\n * The Canvas Renderer is responsible for managing 2D canvas rendering contexts, including the one used by the Game's canvas. It tracks the internal state of a given context and can renderer textured Game Objects to it, taking into account alpha, blending, and scaling.\r\n *\r\n * @class CanvasRenderer\r\n * @memberof Phaser.Renderer.Canvas\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser Game instance that owns this renderer.\r\n */\r\nvar CanvasRenderer = new Class({\r\n\r\n    initialize:\r\n\r\n    function CanvasRenderer (game)\r\n    {\r\n        /**\r\n         * The Phaser Game instance that owns this renderer.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * A constant which allows the renderer to be easily identified as a Canvas Renderer.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#type\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = CONST.CANVAS;\r\n\r\n        /**\r\n         * The total number of Game Objects which were rendered in a frame.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#drawCount\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.drawCount = 0;\r\n\r\n        /**\r\n         * The width of the canvas being rendered to.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#width\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = 0;\r\n\r\n        /**\r\n         * The height of the canvas being rendered to.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#height\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = 0;\r\n\r\n        /**\r\n         * The local configuration settings of the CanvasRenderer.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#config\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = {\r\n            clearBeforeRender: game.config.clearBeforeRender,\r\n            backgroundColor: game.config.backgroundColor,\r\n            resolution: game.config.resolution,\r\n            antialias: game.config.antialias,\r\n            roundPixels: game.config.roundPixels\r\n        };\r\n\r\n        /**\r\n         * The canvas element which the Game uses.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#gameCanvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */\r\n        this.gameCanvas = game.canvas;\r\n\r\n        var contextOptions = {\r\n            alpha: game.config.transparent,\r\n            desynchronized: game.config.desynchronized\r\n        };\r\n\r\n        /**\r\n         * The canvas context used to render all Cameras in all Scenes during the game loop.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#gameContext\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */\r\n        this.gameContext = (this.game.config.context) ? this.game.config.context : this.gameCanvas.getContext('2d', contextOptions);\r\n\r\n        /**\r\n         * The canvas context currently used by the CanvasRenderer for all rendering operations.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#currentContext\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */\r\n        this.currentContext = this.gameContext;\r\n\r\n        /**\r\n         * Should the Canvas use Image Smoothing or not when drawing Sprites?\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#antialias\r\n         * @type {boolean}\r\n         * @since 3.20.0\r\n         */\r\n        this.antialias = game.config.antialias;\r\n\r\n        /**\r\n         * The blend modes supported by the Canvas Renderer.\r\n         *\r\n         * This object maps the {@link Phaser.BlendModes} to canvas compositing operations.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#blendModes\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.blendModes = GetBlendModes();\r\n\r\n        /**\r\n         * Details about the currently scheduled snapshot.\r\n         * \r\n         * If a non-null `callback` is set in this object, a snapshot of the canvas will be taken after the current frame is fully rendered.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#snapshotState\r\n         * @type {Phaser.Types.Renderer.Snapshot.SnapshotState}\r\n         * @since 3.16.0\r\n         */\r\n        this.snapshotState = {\r\n            x: 0,\r\n            y: 0,\r\n            width: 1,\r\n            height: 1,\r\n            getPixel: false,\r\n            callback: null,\r\n            type: 'image/png',\r\n            encoder: 0.92\r\n        };\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix1\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix1 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix2\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix2 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix3\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix3 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix4\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix4 = new TransformMatrix();\r\n\r\n        this.init();\r\n    },\r\n\r\n    /**\r\n     * Prepares the game canvas for rendering.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#init\r\n     * @since 3.0.0\r\n     */\r\n    init: function ()\r\n    {\r\n        this.game.scale.on(ScaleEvents.RESIZE, this.onResize, this);\r\n\r\n        var baseSize = this.game.scale.baseSize;\r\n\r\n        this.resize(baseSize.width, baseSize.height);\r\n    },\r\n\r\n    /**\r\n     * The event handler that manages the `resize` event dispatched by the Scale Manager.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#onResize\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Structs.Size} gameSize - The default Game Size object. This is the un-modified game dimensions.\r\n     * @param {Phaser.Structs.Size} baseSize - The base Size object. The game dimensions multiplied by the resolution. The canvas width / height values match this.\r\n     * @param {Phaser.Structs.Size} displaySize - The display Size object. The size of the canvas style width / height attributes.\r\n     * @param {number} [resolution] - The Scale Manager resolution setting.\r\n     */\r\n    onResize: function (gameSize, baseSize)\r\n    {\r\n        //  Has the underlying canvas size changed?\r\n        if (baseSize.width !== this.width || baseSize.height !== this.height)\r\n        {\r\n            this.resize(baseSize.width, baseSize.height);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Resize the main game canvas.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#resize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [width] - The new width of the renderer.\r\n     * @param {number} [height] - The new height of the renderer.\r\n     */\r\n    resize: function (width, height)\r\n    {\r\n        this.width = width;\r\n        this.height = height;\r\n    },\r\n\r\n    /**\r\n     * Resets the transformation matrix of the current context to the identity matrix, thus resetting any transformation.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#resetTransform\r\n     * @since 3.0.0\r\n     */\r\n    resetTransform: function ()\r\n    {\r\n        this.currentContext.setTransform(1, 0, 0, 1, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Sets the blend mode (compositing operation) of the current context.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#setBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} blendMode - The new blend mode which should be used.\r\n     *\r\n     * @return {this} This CanvasRenderer object.\r\n     */\r\n    setBlendMode: function (blendMode)\r\n    {\r\n        this.currentContext.globalCompositeOperation = blendMode;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Changes the Canvas Rendering Context that all draw operations are performed against.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#setContext\r\n     * @since 3.12.0\r\n     *\r\n     * @param {?CanvasRenderingContext2D} [ctx] - The new Canvas Rendering Context to draw everything to. Leave empty to reset to the Game Canvas.\r\n     *\r\n     * @return {this} The Canvas Renderer instance.\r\n     */\r\n    setContext: function (ctx)\r\n    {\r\n        this.currentContext = (ctx) ? ctx : this.gameContext;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the global alpha of the current context.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#setAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} alpha - The new alpha to use, where 0 is fully transparent and 1 is fully opaque.\r\n     *\r\n     * @return {this} This CanvasRenderer object.\r\n     */\r\n    setAlpha: function (alpha)\r\n    {\r\n        this.currentContext.globalAlpha = alpha;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Called at the start of the render loop.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#preRender\r\n     * @since 3.0.0\r\n     */\r\n    preRender: function ()\r\n    {\r\n        var ctx = this.gameContext;\r\n        var config = this.config;\r\n\r\n        var width = this.width;\r\n        var height = this.height;\r\n\r\n        ctx.globalAlpha = 1;\r\n        ctx.globalCompositeOperation = 'source-over';\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n\r\n        if (config.clearBeforeRender)\r\n        {\r\n            ctx.clearRect(0, 0, width, height);\r\n        }\r\n\r\n        if (!config.transparent)\r\n        {\r\n            ctx.fillStyle = config.backgroundColor.rgba;\r\n            ctx.fillRect(0, 0, width, height);\r\n        }\r\n\r\n        ctx.save();\r\n\r\n        this.drawCount = 0;\r\n    },\r\n\r\n    /**\r\n     * Renders the Scene to the given Camera.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#render\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene to render.\r\n     * @param {Phaser.GameObjects.DisplayList} children - The Game Objects within the Scene to be rendered.\r\n     * @param {number} interpolationPercentage - The interpolation percentage to apply. Currently unused.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera to render with.\r\n     */\r\n    render: function (scene, children, interpolationPercentage, camera)\r\n    {\r\n        var list = children.list;\r\n        var childCount = list.length;\r\n\r\n        var cx = camera._cx;\r\n        var cy = camera._cy;\r\n        var cw = camera._cw;\r\n        var ch = camera._ch;\r\n\r\n        var ctx = (camera.renderToTexture) ? camera.context : scene.sys.context;\r\n\r\n        //  Save context pre-clip\r\n        ctx.save();\r\n\r\n        if (this.game.scene.customViewports)\r\n        {\r\n            ctx.beginPath();\r\n            ctx.rect(cx, cy, cw, ch);\r\n            ctx.clip();\r\n        }\r\n\r\n        this.currentContext = ctx;\r\n\r\n        var mask = camera.mask;\r\n\r\n        if (mask)\r\n        {\r\n            mask.preRenderCanvas(this, null, camera._maskCamera);\r\n        }\r\n\r\n        if (!camera.transparent)\r\n        {\r\n            ctx.fillStyle = camera.backgroundColor.rgba;\r\n            ctx.fillRect(cx, cy, cw, ch);\r\n        }\r\n\r\n        ctx.globalAlpha = camera.alpha;\r\n\r\n        ctx.globalCompositeOperation = 'source-over';\r\n\r\n        this.drawCount += list.length;\r\n\r\n        if (camera.renderToTexture)\r\n        {\r\n            camera.emit(CameraEvents.PRE_RENDER, camera);\r\n        }\r\n\r\n        camera.matrix.copyToContext(ctx);\r\n\r\n        for (var i = 0; i < childCount; i++)\r\n        {\r\n            var child = list[i];\r\n\r\n            if (!child.willRender(camera))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (child.mask)\r\n            {\r\n                child.mask.preRenderCanvas(this, child, camera);\r\n            }\r\n\r\n            child.renderCanvas(this, child, interpolationPercentage, camera);\r\n\r\n            if (child.mask)\r\n            {\r\n                child.mask.postRenderCanvas(this, child, camera);\r\n            }\r\n        }\r\n\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        ctx.globalCompositeOperation = 'source-over';\r\n        ctx.globalAlpha = 1;\r\n\r\n        camera.flashEffect.postRenderCanvas(ctx);\r\n        camera.fadeEffect.postRenderCanvas(ctx);\r\n\r\n        camera.dirty = false;\r\n\r\n        if (mask)\r\n        {\r\n            mask.postRenderCanvas(this);\r\n        }\r\n\r\n        //  Restore pre-clip context\r\n        ctx.restore();\r\n\r\n        if (camera.renderToTexture)\r\n        {\r\n            camera.emit(CameraEvents.POST_RENDER, camera);\r\n\r\n            scene.sys.context.drawImage(camera.canvas, cx, cy);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Restores the game context's global settings and takes a snapshot if one is scheduled.\r\n     *\r\n     * The post-render step happens after all Cameras in all Scenes have been rendered.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#postRender\r\n     * @since 3.0.0\r\n     */\r\n    postRender: function ()\r\n    {\r\n        var ctx = this.gameContext;\r\n\r\n        ctx.restore();\r\n\r\n        var state = this.snapshotState;\r\n\r\n        if (state.callback)\r\n        {\r\n            CanvasSnapshot(this.gameCanvas, state);\r\n\r\n            state.callback = null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the given area of the given canvas.\r\n     * \r\n     * Unlike the other snapshot methods, this one is processed immediately and doesn't wait for the next render.\r\n     * \r\n     * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets\r\n     * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshotCanvas\r\n     * @since 3.19.0\r\n     *\r\n     * @param {HTMLCanvasElement} canvas - The canvas to grab from.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {boolean} [getPixel=false] - Grab a single pixel as a Color object, or an area as an Image object?\r\n     * @param {integer} [x=0] - The x coordinate to grab from.\r\n     * @param {integer} [y=0] - The y coordinate to grab from.\r\n     * @param {integer} [width=canvas.width] - The width of the area to grab.\r\n     * @param {integer} [height=canvas.height] - The height of the area to grab.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This Canvas Renderer.\r\n     */\r\n    snapshotCanvas: function (canvas, callback, getPixel, x, y, width, height, type, encoderOptions)\r\n    {\r\n        if (getPixel === undefined) { getPixel = false; }\r\n\r\n        this.snapshotArea(x, y, width, height, callback, type, encoderOptions);\r\n\r\n        var state = this.snapshotState;\r\n\r\n        state.getPixel = getPixel;\r\n\r\n        CanvasSnapshot(this.canvas, state);\r\n\r\n        state.callback = null;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the entire game viewport to be taken after the current frame is rendered.\r\n     * \r\n     * To capture a specific area see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.\r\n     * \r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n     * calling this method will override it.\r\n     * \r\n     * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets\r\n     * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshot: function (callback, type, encoderOptions)\r\n    {\r\n        return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, callback, type, encoderOptions);\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the given area of the game viewport to be taken after the current frame is rendered.\r\n     * \r\n     * To capture the whole game viewport see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.\r\n     * \r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n     * calling this method will override it.\r\n     * \r\n     * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets\r\n     * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshotArea\r\n     * @since 3.16.0\r\n     *\r\n     * @param {integer} x - The x coordinate to grab from.\r\n     * @param {integer} y - The y coordinate to grab from.\r\n     * @param {integer} width - The width of the area to grab.\r\n     * @param {integer} height - The height of the area to grab.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshotArea: function (x, y, width, height, callback, type, encoderOptions)\r\n    {\r\n        var state = this.snapshotState;\r\n\r\n        state.callback = callback;\r\n        state.type = type;\r\n        state.encoder = encoderOptions;\r\n        state.getPixel = false;\r\n        state.x = x;\r\n        state.y = y;\r\n        state.width = Math.min(width, this.gameCanvas.width);\r\n        state.height = Math.min(height, this.gameCanvas.height);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the given pixel from the game viewport to be taken after the current frame is rendered.\r\n     * \r\n     * To capture the whole game viewport see the `snapshot` method. To capture a specific area, see `snapshotArea`.\r\n     * \r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotArea`, for example, then\r\n     * calling this method will override it.\r\n     * \r\n     * Unlike the other two snapshot methods, this one will return a `Color` object containing the color data for\r\n     * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,\r\n     * using less memory.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshotPixel\r\n     * @since 3.16.0\r\n     *\r\n     * @param {integer} x - The x coordinate of the pixel to get.\r\n     * @param {integer} y - The y coordinate of the pixel to get.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshotPixel: function (x, y, callback)\r\n    {\r\n        this.snapshotArea(x, y, 1, 1, callback);\r\n\r\n        this.snapshotState.getPixel = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes a Sprite Game Object, or any object that extends it, and draws it to the current context.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#batchSprite\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The texture based Game Object to draw.\r\n     * @param {Phaser.Textures.Frame} frame - The frame to draw, doesn't have to be that owned by the Game Object.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use for the rendering transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentTransformMatrix] - The transform matrix of the parent container, if set.\r\n     */\r\n    batchSprite: function (sprite, frame, camera, parentTransformMatrix)\r\n    {\r\n        var alpha = camera.alpha * sprite.alpha;\r\n\r\n        if (alpha === 0)\r\n        {\r\n            //  Nothing to see, so abort early\r\n            return;\r\n        }\r\n    \r\n        var ctx = this.currentContext;\r\n\r\n        var camMatrix = this._tempMatrix1;\r\n        var spriteMatrix = this._tempMatrix2;\r\n        var calcMatrix = this._tempMatrix3;\r\n\r\n        var cd = frame.canvasData;\r\n\r\n        var frameX = cd.x;\r\n        var frameY = cd.y;\r\n        var frameWidth = frame.cutWidth;\r\n        var frameHeight = frame.cutHeight;\r\n        var customPivot = frame.customPivot;\r\n\r\n        var res = frame.source.resolution;\r\n\r\n        var displayOriginX = sprite.displayOriginX;\r\n        var displayOriginY = sprite.displayOriginY;\r\n\r\n        var x = -displayOriginX + frame.x;\r\n        var y = -displayOriginY + frame.y;\r\n\r\n        if (sprite.isCropped)\r\n        {\r\n            var crop = sprite._crop;\r\n\r\n            if (crop.flipX !== sprite.flipX || crop.flipY !== sprite.flipY)\r\n            {\r\n                frame.updateCropUVs(crop, sprite.flipX, sprite.flipY);\r\n            }\r\n\r\n            frameWidth = crop.cw;\r\n            frameHeight = crop.ch;\r\n    \r\n            frameX = crop.cx;\r\n            frameY = crop.cy;\r\n\r\n            x = -displayOriginX + crop.x;\r\n            y = -displayOriginY + crop.y;\r\n\r\n            if (sprite.flipX)\r\n            {\r\n                if (x >= 0)\r\n                {\r\n                    x = -(x + frameWidth);\r\n                }\r\n                else if (x < 0)\r\n                {\r\n                    x = (Math.abs(x) - frameWidth);\r\n                }\r\n            }\r\n        \r\n            if (sprite.flipY)\r\n            {\r\n                if (y >= 0)\r\n                {\r\n                    y = -(y + frameHeight);\r\n                }\r\n                else if (y < 0)\r\n                {\r\n                    y = (Math.abs(y) - frameHeight);\r\n                }\r\n            }\r\n        }\r\n\r\n        var flipX = 1;\r\n        var flipY = 1;\r\n\r\n        if (sprite.flipX)\r\n        {\r\n            if (!customPivot)\r\n            {\r\n                x += (-frame.realWidth + (displayOriginX * 2));\r\n            }\r\n\r\n            flipX = -1;\r\n        }\r\n\r\n        //  Auto-invert the flipY if this is coming from a GLTexture\r\n        if (sprite.flipY)\r\n        {\r\n            if (!customPivot)\r\n            {\r\n                y += (-frame.realHeight + (displayOriginY * 2));\r\n            }\r\n\r\n            flipY = -1;\r\n        }\r\n\r\n        spriteMatrix.applyITRS(sprite.x, sprite.y, sprite.rotation, sprite.scaleX * flipX, sprite.scaleY * flipY);\r\n\r\n        camMatrix.copyFrom(camera.matrix);\r\n\r\n        if (parentTransformMatrix)\r\n        {\r\n            //  Multiply the camera by the parent matrix\r\n            camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * sprite.scrollFactorX, -camera.scrollY * sprite.scrollFactorY);\r\n\r\n            //  Undo the camera scroll\r\n            spriteMatrix.e = sprite.x;\r\n            spriteMatrix.f = sprite.y;\r\n\r\n            //  Multiply by the Sprite matrix, store result in calcMatrix\r\n            camMatrix.multiply(spriteMatrix, calcMatrix);\r\n        }\r\n        else\r\n        {\r\n            spriteMatrix.e -= camera.scrollX * sprite.scrollFactorX;\r\n            spriteMatrix.f -= camera.scrollY * sprite.scrollFactorY;\r\n    \r\n            //  Multiply by the Sprite matrix, store result in calcMatrix\r\n            camMatrix.multiply(spriteMatrix, calcMatrix);\r\n        }\r\n\r\n        ctx.save();\r\n       \r\n        calcMatrix.setToContext(ctx);\r\n\r\n        ctx.globalCompositeOperation = this.blendModes[sprite.blendMode];\r\n\r\n        ctx.globalAlpha = alpha;\r\n\r\n        ctx.imageSmoothingEnabled = !(!this.antialias || frame.source.scaleMode);\r\n\r\n        ctx.drawImage(frame.source.image, frameX, frameY, frameWidth, frameHeight, x, y, frameWidth / res, frameHeight / res);\r\n\r\n        ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Destroys all object references in the Canvas Renderer.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.gameCanvas = null;\r\n        this.gameContext = null;\r\n\r\n        this.game = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = CanvasRenderer;\r\n"]},"metadata":{},"sourceType":"script"}