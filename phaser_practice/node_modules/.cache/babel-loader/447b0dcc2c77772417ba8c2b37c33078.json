{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar FromPoints = require('../geom/rectangle/FromPoints');\n\nvar Rectangle = require('../geom/rectangle/Rectangle');\n\nvar Vector2 = require('../math/Vector2');\n/**\r\n * @classdesc\r\n * A Base Curve class, which all other curve types extend.\r\n *\r\n * Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\r\n *\r\n * @class Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} type - The curve type.\r\n */\n\n\nvar Curve = new Class({\n  initialize: function Curve(type) {\n    /**\r\n     * String based identifier for the type of curve.\r\n     *\r\n     * @name Phaser.Curves.Curve#type\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\n    this.type = type;\n    /**\r\n     * The default number of divisions within the curve.\r\n     *\r\n     * @name Phaser.Curves.Curve#defaultDivisions\r\n     * @type {integer}\r\n     * @default 5\r\n     * @since 3.0.0\r\n     */\n\n    this.defaultDivisions = 5;\n    /**\r\n     * The quantity of arc length divisions within the curve.\r\n     *\r\n     * @name Phaser.Curves.Curve#arcLengthDivisions\r\n     * @type {integer}\r\n     * @default 100\r\n     * @since 3.0.0\r\n     */\n\n    this.arcLengthDivisions = 100;\n    /**\r\n     * An array of cached arc length values.\r\n     *\r\n     * @name Phaser.Curves.Curve#cacheArcLengths\r\n     * @type {number[]}\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this.cacheArcLengths = [];\n    /**\r\n     * Does the data of this curve need updating?\r\n     *\r\n     * @name Phaser.Curves.Curve#needsUpdate\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.needsUpdate = true;\n    /**\r\n     * For a curve on a Path, `false` means the Path will ignore this curve.\r\n     *\r\n     * @name Phaser.Curves.Curve#active\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.active = true;\n    /**\r\n     * A temporary calculation Vector.\r\n     *\r\n     * @name Phaser.Curves.Curve#_tmpVec2A\r\n     * @type {Phaser.Math.Vector2}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._tmpVec2A = new Vector2();\n    /**\r\n     * A temporary calculation Vector.\r\n     *\r\n     * @name Phaser.Curves.Curve#_tmpVec2B\r\n     * @type {Phaser.Math.Vector2}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._tmpVec2B = new Vector2();\n  },\n\n  /**\r\n   * Draws this curve on the given Graphics object.\r\n   *\r\n   * The curve is drawn using `Graphics.strokePoints` so will be drawn at whatever the present Graphics stroke color is.\r\n   * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.\r\n   *\r\n   * @method Phaser.Curves.Curve#draw\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]\r\n   *\r\n   * @param {Phaser.GameObjects.Graphics} graphics - The Graphics instance onto which this curve will be drawn.\r\n   * @param {integer} [pointsTotal=32] - The resolution of the curve. The higher the value the smoother it will render, at the cost of rendering performance.\r\n   *\r\n   * @return {Phaser.GameObjects.Graphics} The Graphics object to which the curve was drawn.\r\n   */\n  draw: function (graphics, pointsTotal) {\n    if (pointsTotal === undefined) {\n      pointsTotal = 32;\n    } //  So you can chain graphics calls\n\n\n    return graphics.strokePoints(this.getPoints(pointsTotal));\n  },\n\n  /**\r\n   * Returns a Rectangle where the position and dimensions match the bounds of this Curve.\r\n   *\r\n   * You can control the accuracy of the bounds. The value given is used to work out how many points\r\n   * to plot across the curve. Higher values are more accurate at the cost of calculation speed.\r\n   *\r\n   * @method Phaser.Curves.Curve#getBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Geom.Rectangle} [out] - The Rectangle to store the bounds in. If falsey a new object will be created.\r\n   * @param {integer} [accuracy=16] - The accuracy of the bounds calculations.\r\n   *\r\n   * @return {Phaser.Geom.Rectangle} A Rectangle object holding the bounds of this curve. If `out` was given it will be this object.\r\n   */\n  getBounds: function (out, accuracy) {\n    if (!out) {\n      out = new Rectangle();\n    }\n\n    if (accuracy === undefined) {\n      accuracy = 16;\n    }\n\n    var len = this.getLength();\n\n    if (accuracy > len) {\n      accuracy = len / 2;\n    } //  The length of the curve in pixels\n    //  So we'll have 1 spaced point per 'accuracy' pixels\n\n\n    var spaced = Math.max(1, Math.round(len / accuracy));\n    return FromPoints(this.getSpacedPoints(spaced), out);\n  },\n\n  /**\r\n   * Returns an array of points, spaced out X distance pixels apart.\r\n   * The smaller the distance, the larger the array will be.\r\n   *\r\n   * @method Phaser.Curves.Curve#getDistancePoints\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} distance - The distance, in pixels, between each point along the curve.\r\n   *\r\n   * @return {Phaser.Geom.Point[]} An Array of Point objects.\r\n   */\n  getDistancePoints: function (distance) {\n    var len = this.getLength();\n    var spaced = Math.max(1, len / distance);\n    return this.getSpacedPoints(spaced);\n  },\n\n  /**\r\n   * Get a point at the end of the curve.\r\n   *\r\n   * @method Phaser.Curves.Curve#getEndPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} [out] - Optional Vector object to store the result in.\r\n   *\r\n   * @return {Phaser.Math.Vector2} Vector2 containing the coordinates of the curves end point.\r\n   */\n  getEndPoint: function (out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    return this.getPointAt(1, out);\n  },\n\n  /**\r\n   * Get total curve arc length\r\n   *\r\n   * @method Phaser.Curves.Curve#getLength\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The total length of the curve.\r\n   */\n  getLength: function () {\n    var lengths = this.getLengths();\n    return lengths[lengths.length - 1];\n  },\n\n  /**\r\n   * Get a list of cumulative segment lengths.\r\n   *\r\n   * These lengths are\r\n   *\r\n   * - [0] 0\r\n   * - [1] The first segment\r\n   * - [2] The first and second segment\r\n   * - ...\r\n   * - [divisions] All segments\r\n   *\r\n   * @method Phaser.Curves.Curve#getLengths\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} [divisions] - The number of divisions or segments.\r\n   *\r\n   * @return {number[]} An array of cumulative lengths.\r\n   */\n  getLengths: function (divisions) {\n    if (divisions === undefined) {\n      divisions = this.arcLengthDivisions;\n    }\n\n    if (this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n      return this.cacheArcLengths;\n    }\n\n    this.needsUpdate = false;\n    var cache = [];\n    var current;\n    var last = this.getPoint(0, this._tmpVec2A);\n    var sum = 0;\n    cache.push(0);\n\n    for (var p = 1; p <= divisions; p++) {\n      current = this.getPoint(p / divisions, this._tmpVec2B);\n      sum += current.distance(last);\n      cache.push(sum);\n      last.copy(current);\n    }\n\n    this.cacheArcLengths = cache;\n    return cache; // { sums: cache, sum:sum }; Sum is in the last element.\n  },\n  // Get point at relative position in curve according to arc length\n  // - u [0 .. 1]\n\n  /**\r\n   * Get a point at a relative position on the curve, by arc length.\r\n   *\r\n   * @method Phaser.Curves.Curve#getPointAt\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {number} u - The relative position, [0..1].\r\n   * @param {Phaser.Math.Vector2} [out] - A point to store the result in.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The point.\r\n   */\n  getPointAt: function (u, out) {\n    var t = this.getUtoTmapping(u);\n    return this.getPoint(t, out);\n  },\n  // Get sequence of points using getPoint( t )\n\n  /**\r\n   * Get a sequence of evenly spaced points from the curve.\r\n   *\r\n   * You can pass `divisions`, `stepRate`, or neither.\r\n   *\r\n   * The number of divisions will be\r\n   *\r\n   * 1. `divisions`, if `divisions` > 0; or\r\n   * 2. `this.getLength / stepRate`, if `stepRate` > 0; or\r\n   * 3. `this.defaultDivisions`\r\n   *\r\n   * `1 + divisions` points will be returned.\r\n   *\r\n   * @method Phaser.Curves.Curve#getPoints\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2[]} O - [out,$return]\r\n   *\r\n   * @param {integer} [divisions] - The number of divisions to make.\r\n   * @param {number} [stepRate] - The curve distance between points, implying `divisions`.\r\n   * @param {(array|Phaser.Math.Vector2[])} [out] - An optional array to store the points in.\r\n   *\r\n   * @return {(array|Phaser.Math.Vector2[])} An array of Points from the curve.\r\n   */\n  getPoints: function (divisions, stepRate, out) {\n    if (out === undefined) {\n      out = [];\n    } //  If divisions is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\n\n\n    if (!divisions) {\n      if (!stepRate) {\n        divisions = this.defaultDivisions;\n      } else {\n        divisions = this.getLength() / stepRate;\n      }\n    }\n\n    for (var d = 0; d <= divisions; d++) {\n      out.push(this.getPoint(d / divisions));\n    }\n\n    return out;\n  },\n\n  /**\r\n   * Get a random point from the curve.\r\n   *\r\n   * @method Phaser.Curves.Curve#getRandomPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {Phaser.Math.Vector2} [out] - A point object to store the result in.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The point.\r\n   */\n  getRandomPoint: function (out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    return this.getPoint(Math.random(), out);\n  },\n  // Get sequence of points using getPointAt( u )\n\n  /**\r\n   * Get a sequence of equally spaced points (by arc distance) from the curve.\r\n   *\r\n   * `1 + divisions` points will be returned.\r\n   *\r\n   * @method Phaser.Curves.Curve#getSpacedPoints\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} [divisions=this.defaultDivisions] - The number of divisions to make.\r\n   * @param {number} [stepRate] - Step between points. Used to calculate the number of points to return when divisions is falsy. Ignored if divisions is positive.\r\n   * @param {(array|Phaser.Math.Vector2[])} [out] - An optional array to store the points in.\r\n   *\r\n   * @return {Phaser.Math.Vector2[]} An array of points.\r\n   */\n  getSpacedPoints: function (divisions, stepRate, out) {\n    if (out === undefined) {\n      out = [];\n    } //  If divisions is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\n\n\n    if (!divisions) {\n      if (!stepRate) {\n        divisions = this.defaultDivisions;\n      } else {\n        divisions = this.getLength() / stepRate;\n      }\n    }\n\n    for (var d = 0; d <= divisions; d++) {\n      var t = this.getUtoTmapping(d / divisions, null, divisions);\n      out.push(this.getPoint(t));\n    }\n\n    return out;\n  },\n\n  /**\r\n   * Get a point at the start of the curve.\r\n   *\r\n   * @method Phaser.Curves.Curve#getStartPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {Phaser.Math.Vector2} [out] - A point to store the result in.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The point.\r\n   */\n  getStartPoint: function (out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    return this.getPointAt(0, out);\n  },\n\n  /**\r\n   * Get a unit vector tangent at a relative position on the curve.\r\n   * In case any sub curve does not implement its tangent derivation,\r\n   * 2 points a small delta apart will be used to find its gradient\r\n   * which seems to give a reasonable approximation\r\n   *\r\n   * @method Phaser.Curves.Curve#getTangent\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {number} t - The relative position on the curve, [0..1].\r\n   * @param {Phaser.Math.Vector2} [out] - A vector to store the result in.\r\n   *\r\n   * @return {Phaser.Math.Vector2} Vector approximating the tangent line at the point t (delta +/- 0.0001)\r\n   */\n  getTangent: function (t, out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    var delta = 0.0001;\n    var t1 = t - delta;\n    var t2 = t + delta; // Capping in case of danger\n\n    if (t1 < 0) {\n      t1 = 0;\n    }\n\n    if (t2 > 1) {\n      t2 = 1;\n    }\n\n    this.getPoint(t1, this._tmpVec2A);\n    this.getPoint(t2, out);\n    return out.subtract(this._tmpVec2A).normalize();\n  },\n\n  /**\r\n   * Get a unit vector tangent at a relative position on the curve, by arc length.\r\n   *\r\n   * @method Phaser.Curves.Curve#getTangentAt\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {number} u - The relative position on the curve, [0..1].\r\n   * @param {Phaser.Math.Vector2} [out] - A vector to store the result in.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The tangent vector.\r\n   */\n  getTangentAt: function (u, out) {\n    var t = this.getUtoTmapping(u);\n    return this.getTangent(t, out);\n  },\n  //  Given a distance in pixels, get a t to find p.\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Curve#getTFromDistance\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} distance - [description]\r\n   * @param {integer} [divisions] - [description]\r\n   *\r\n   * @return {number} [description]\r\n   */\n  getTFromDistance: function (distance, divisions) {\n    if (distance <= 0) {\n      return 0;\n    }\n\n    return this.getUtoTmapping(0, distance, divisions);\n  },\n  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Curve#getUtoTmapping\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} u - [description]\r\n   * @param {integer} distance - [description]\r\n   * @param {integer} [divisions] - [description]\r\n   *\r\n   * @return {number} [description]\r\n   */\n  getUtoTmapping: function (u, distance, divisions) {\n    var arcLengths = this.getLengths(divisions);\n    var i = 0;\n    var il = arcLengths.length;\n    var targetArcLength; // The targeted u distance value to get\n\n    if (distance) {\n      //  Cannot overshoot the curve\n      targetArcLength = Math.min(distance, arcLengths[il - 1]);\n    } else {\n      targetArcLength = u * arcLengths[il - 1];\n    } // binary search for the index with largest value smaller than target u distance\n\n\n    var low = 0;\n    var high = il - 1;\n    var comparison;\n\n    while (low <= high) {\n      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n      comparison = arcLengths[i] - targetArcLength;\n\n      if (comparison < 0) {\n        low = i + 1;\n      } else if (comparison > 0) {\n        high = i - 1;\n      } else {\n        high = i;\n        break;\n      }\n    }\n\n    i = high;\n\n    if (arcLengths[i] === targetArcLength) {\n      return i / (il - 1);\n    } // we could get finer grain at lengths, or use simple interpolation between two points\n\n\n    var lengthBefore = arcLengths[i];\n    var lengthAfter = arcLengths[i + 1];\n    var segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points\n\n    var segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t\n\n    return (i + segmentFraction) / (il - 1);\n  },\n\n  /**\r\n   * Calculate and cache the arc lengths.\r\n   *\r\n   * @method Phaser.Curves.Curve#updateArcLengths\r\n   * @since 3.0.0\r\n   *\r\n   * @see Phaser.Curves.Curve#getLengths()\r\n   */\n  updateArcLengths: function () {\n    this.needsUpdate = true;\n    this.getLengths();\n  }\n});\nmodule.exports = Curve;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/curves/Curve.js"],"names":["Class","require","FromPoints","Rectangle","Vector2","Curve","initialize","type","defaultDivisions","arcLengthDivisions","cacheArcLengths","needsUpdate","active","_tmpVec2A","_tmpVec2B","draw","graphics","pointsTotal","undefined","strokePoints","getPoints","getBounds","out","accuracy","len","getLength","spaced","Math","max","round","getSpacedPoints","getDistancePoints","distance","getEndPoint","getPointAt","lengths","getLengths","length","divisions","cache","current","last","getPoint","sum","push","p","copy","u","t","getUtoTmapping","stepRate","d","getRandomPoint","random","getStartPoint","getTangent","delta","t1","t2","subtract","normalize","getTangentAt","getTFromDistance","arcLengths","i","il","targetArcLength","min","low","high","comparison","floor","lengthBefore","lengthAfter","segmentLength","segmentFraction","updateArcLengths","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar FromPoints = require('../geom/rectangle/FromPoints');\r\nvar Rectangle = require('../geom/rectangle/Rectangle');\r\nvar Vector2 = require('../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Base Curve class, which all other curve types extend.\r\n *\r\n * Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\r\n *\r\n * @class Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} type - The curve type.\r\n */\r\nvar Curve = new Class({\r\n\r\n    initialize:\r\n\r\n    function Curve (type)\r\n    {\r\n        /**\r\n         * String based identifier for the type of curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * The default number of divisions within the curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#defaultDivisions\r\n         * @type {integer}\r\n         * @default 5\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultDivisions = 5;\r\n\r\n        /**\r\n         * The quantity of arc length divisions within the curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#arcLengthDivisions\r\n         * @type {integer}\r\n         * @default 100\r\n         * @since 3.0.0\r\n         */\r\n        this.arcLengthDivisions = 100;\r\n\r\n        /**\r\n         * An array of cached arc length values.\r\n         *\r\n         * @name Phaser.Curves.Curve#cacheArcLengths\r\n         * @type {number[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.cacheArcLengths = [];\r\n\r\n        /**\r\n         * Does the data of this curve need updating?\r\n         *\r\n         * @name Phaser.Curves.Curve#needsUpdate\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.needsUpdate = true;\r\n\r\n        /**\r\n         * For a curve on a Path, `false` means the Path will ignore this curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * A temporary calculation Vector.\r\n         *\r\n         * @name Phaser.Curves.Curve#_tmpVec2A\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tmpVec2A = new Vector2();\r\n\r\n        /**\r\n         * A temporary calculation Vector.\r\n         *\r\n         * @name Phaser.Curves.Curve#_tmpVec2B\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tmpVec2B = new Vector2();\r\n    },\r\n\r\n    /**\r\n     * Draws this curve on the given Graphics object.\r\n     *\r\n     * The curve is drawn using `Graphics.strokePoints` so will be drawn at whatever the present Graphics stroke color is.\r\n     * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.\r\n     *\r\n     * @method Phaser.Curves.Curve#draw\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics instance onto which this curve will be drawn.\r\n     * @param {integer} [pointsTotal=32] - The resolution of the curve. The higher the value the smoother it will render, at the cost of rendering performance.\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The Graphics object to which the curve was drawn.\r\n     */\r\n    draw: function (graphics, pointsTotal)\r\n    {\r\n        if (pointsTotal === undefined) { pointsTotal = 32; }\r\n\r\n        //  So you can chain graphics calls\r\n        return graphics.strokePoints(this.getPoints(pointsTotal));\r\n    },\r\n\r\n    /**\r\n     * Returns a Rectangle where the position and dimensions match the bounds of this Curve.\r\n     *\r\n     * You can control the accuracy of the bounds. The value given is used to work out how many points\r\n     * to plot across the curve. Higher values are more accurate at the cost of calculation speed.\r\n     *\r\n     * @method Phaser.Curves.Curve#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} [out] - The Rectangle to store the bounds in. If falsey a new object will be created.\r\n     * @param {integer} [accuracy=16] - The accuracy of the bounds calculations.\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} A Rectangle object holding the bounds of this curve. If `out` was given it will be this object.\r\n     */\r\n    getBounds: function (out, accuracy)\r\n    {\r\n        if (!out) { out = new Rectangle(); }\r\n        if (accuracy === undefined) { accuracy = 16; }\r\n\r\n        var len = this.getLength();\r\n\r\n        if (accuracy > len)\r\n        {\r\n            accuracy = len / 2;\r\n        }\r\n\r\n        //  The length of the curve in pixels\r\n        //  So we'll have 1 spaced point per 'accuracy' pixels\r\n\r\n        var spaced = Math.max(1, Math.round(len / accuracy));\r\n\r\n        return FromPoints(this.getSpacedPoints(spaced), out);\r\n    },\r\n\r\n    /**\r\n     * Returns an array of points, spaced out X distance pixels apart.\r\n     * The smaller the distance, the larger the array will be.\r\n     *\r\n     * @method Phaser.Curves.Curve#getDistancePoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} distance - The distance, in pixels, between each point along the curve.\r\n     *\r\n     * @return {Phaser.Geom.Point[]} An Array of Point objects.\r\n     */\r\n    getDistancePoints: function (distance)\r\n    {\r\n        var len = this.getLength();\r\n\r\n        var spaced = Math.max(1, len / distance);\r\n\r\n        return this.getSpacedPoints(spaced);\r\n    },\r\n\r\n    /**\r\n     * Get a point at the end of the curve.\r\n     *\r\n     * @method Phaser.Curves.Curve#getEndPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - Optional Vector object to store the result in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} Vector2 containing the coordinates of the curves end point.\r\n     */\r\n    getEndPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return this.getPointAt(1, out);\r\n    },\r\n\r\n    /**\r\n     * Get total curve arc length\r\n     *\r\n     * @method Phaser.Curves.Curve#getLength\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The total length of the curve.\r\n     */\r\n    getLength: function ()\r\n    {\r\n        var lengths = this.getLengths();\r\n\r\n        return lengths[lengths.length - 1];\r\n    },\r\n\r\n\r\n    /**\r\n     * Get a list of cumulative segment lengths.\r\n     *\r\n     * These lengths are\r\n     *\r\n     * - [0] 0\r\n     * - [1] The first segment\r\n     * - [2] The first and second segment\r\n     * - ...\r\n     * - [divisions] All segments\r\n     *\r\n     * @method Phaser.Curves.Curve#getLengths\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [divisions] - The number of divisions or segments.\r\n     *\r\n     * @return {number[]} An array of cumulative lengths.\r\n     */\r\n    getLengths: function (divisions)\r\n    {\r\n        if (divisions === undefined) { divisions = this.arcLengthDivisions; }\r\n\r\n        if ((this.cacheArcLengths.length === divisions + 1) && !this.needsUpdate)\r\n        {\r\n            return this.cacheArcLengths;\r\n        }\r\n\r\n        this.needsUpdate = false;\r\n\r\n        var cache = [];\r\n        var current;\r\n        var last = this.getPoint(0, this._tmpVec2A);\r\n        var sum = 0;\r\n\r\n        cache.push(0);\r\n\r\n        for (var p = 1; p <= divisions; p++)\r\n        {\r\n            current = this.getPoint(p / divisions, this._tmpVec2B);\r\n\r\n            sum += current.distance(last);\r\n\r\n            cache.push(sum);\r\n\r\n            last.copy(current);\r\n        }\r\n\r\n        this.cacheArcLengths = cache;\r\n\r\n        return cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n    },\r\n\r\n    // Get point at relative position in curve according to arc length\r\n\r\n    // - u [0 .. 1]\r\n\r\n    /**\r\n     * Get a point at a relative position on the curve, by arc length.\r\n     *\r\n     * @method Phaser.Curves.Curve#getPointAt\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} u - The relative position, [0..1].\r\n     * @param {Phaser.Math.Vector2} [out] - A point to store the result in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The point.\r\n     */\r\n    getPointAt: function (u, out)\r\n    {\r\n        var t = this.getUtoTmapping(u);\r\n\r\n        return this.getPoint(t, out);\r\n    },\r\n\r\n    // Get sequence of points using getPoint( t )\r\n\r\n    /**\r\n     * Get a sequence of evenly spaced points from the curve.\r\n     *\r\n     * You can pass `divisions`, `stepRate`, or neither.\r\n     *\r\n     * The number of divisions will be\r\n     *\r\n     * 1. `divisions`, if `divisions` > 0; or\r\n     * 2. `this.getLength / stepRate`, if `stepRate` > 0; or\r\n     * 3. `this.defaultDivisions`\r\n     *\r\n     * `1 + divisions` points will be returned.\r\n     *\r\n     * @method Phaser.Curves.Curve#getPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2[]} O - [out,$return]\r\n     *\r\n     * @param {integer} [divisions] - The number of divisions to make.\r\n     * @param {number} [stepRate] - The curve distance between points, implying `divisions`.\r\n     * @param {(array|Phaser.Math.Vector2[])} [out] - An optional array to store the points in.\r\n     *\r\n     * @return {(array|Phaser.Math.Vector2[])} An array of Points from the curve.\r\n     */\r\n    getPoints: function (divisions, stepRate, out)\r\n    {\r\n        if (out === undefined) { out = []; }\r\n\r\n        //  If divisions is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\r\n        if (!divisions)\r\n        {\r\n            if (!stepRate)\r\n            {\r\n                divisions = this.defaultDivisions;\r\n            }\r\n            else\r\n            {\r\n                divisions = this.getLength() / stepRate;\r\n            }\r\n        }\r\n\r\n        for (var d = 0; d <= divisions; d++)\r\n        {\r\n            out.push(this.getPoint(d / divisions));\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Get a random point from the curve.\r\n     *\r\n     * @method Phaser.Curves.Curve#getRandomPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - A point object to store the result in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The point.\r\n     */\r\n    getRandomPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return this.getPoint(Math.random(), out);\r\n    },\r\n\r\n    // Get sequence of points using getPointAt( u )\r\n\r\n    /**\r\n     * Get a sequence of equally spaced points (by arc distance) from the curve.\r\n     *\r\n     * `1 + divisions` points will be returned.\r\n     *\r\n     * @method Phaser.Curves.Curve#getSpacedPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [divisions=this.defaultDivisions] - The number of divisions to make.\r\n     * @param {number} [stepRate] - Step between points. Used to calculate the number of points to return when divisions is falsy. Ignored if divisions is positive.\r\n     * @param {(array|Phaser.Math.Vector2[])} [out] - An optional array to store the points in.\r\n     *\r\n     * @return {Phaser.Math.Vector2[]} An array of points.\r\n     */\r\n    getSpacedPoints: function (divisions, stepRate, out)\r\n    {\r\n        if (out === undefined) { out = []; }\r\n\r\n        //  If divisions is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\r\n        if (!divisions)\r\n        {\r\n            if (!stepRate)\r\n            {\r\n                divisions = this.defaultDivisions;\r\n            }\r\n            else\r\n            {\r\n                divisions = this.getLength() / stepRate;\r\n            }\r\n        }\r\n\r\n        for (var d = 0; d <= divisions; d++)\r\n        {\r\n            var t = this.getUtoTmapping(d / divisions, null, divisions);\r\n\r\n            out.push(this.getPoint(t));\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Get a point at the start of the curve.\r\n     *\r\n     * @method Phaser.Curves.Curve#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - A point to store the result in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The point.\r\n     */\r\n    getStartPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return this.getPointAt(0, out);\r\n    },\r\n\r\n    /**\r\n     * Get a unit vector tangent at a relative position on the curve.\r\n     * In case any sub curve does not implement its tangent derivation,\r\n     * 2 points a small delta apart will be used to find its gradient\r\n     * which seems to give a reasonable approximation\r\n     *\r\n     * @method Phaser.Curves.Curve#getTangent\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - The relative position on the curve, [0..1].\r\n     * @param {Phaser.Math.Vector2} [out] - A vector to store the result in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} Vector approximating the tangent line at the point t (delta +/- 0.0001)\r\n     */\r\n    getTangent: function (t, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        var delta = 0.0001;\r\n        var t1 = t - delta;\r\n        var t2 = t + delta;\r\n\r\n        // Capping in case of danger\r\n\r\n        if (t1 < 0)\r\n        {\r\n            t1 = 0;\r\n        }\r\n\r\n        if (t2 > 1)\r\n        {\r\n            t2 = 1;\r\n        }\r\n\r\n        this.getPoint(t1, this._tmpVec2A);\r\n        this.getPoint(t2, out);\r\n\r\n        return out.subtract(this._tmpVec2A).normalize();\r\n    },\r\n\r\n    /**\r\n     * Get a unit vector tangent at a relative position on the curve, by arc length.\r\n     *\r\n     * @method Phaser.Curves.Curve#getTangentAt\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} u - The relative position on the curve, [0..1].\r\n     * @param {Phaser.Math.Vector2} [out] - A vector to store the result in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The tangent vector.\r\n     */\r\n    getTangentAt: function (u, out)\r\n    {\r\n        var t = this.getUtoTmapping(u);\r\n\r\n        return this.getTangent(t, out);\r\n    },\r\n\r\n    //  Given a distance in pixels, get a t to find p.\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getTFromDistance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} distance - [description]\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */\r\n    getTFromDistance: function (distance, divisions)\r\n    {\r\n        if (distance <= 0)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        return this.getUtoTmapping(0, distance, divisions);\r\n    },\r\n\r\n    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getUtoTmapping\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} u - [description]\r\n     * @param {integer} distance - [description]\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */\r\n    getUtoTmapping: function (u, distance, divisions)\r\n    {\r\n        var arcLengths = this.getLengths(divisions);\r\n\r\n        var i = 0;\r\n        var il = arcLengths.length;\r\n\r\n        var targetArcLength; // The targeted u distance value to get\r\n\r\n        if (distance)\r\n        {\r\n            //  Cannot overshoot the curve\r\n            targetArcLength = Math.min(distance, arcLengths[il - 1]);\r\n        }\r\n        else\r\n        {\r\n            targetArcLength = u * arcLengths[il - 1];\r\n        }\r\n\r\n        // binary search for the index with largest value smaller than target u distance\r\n\r\n        var low = 0;\r\n        var high = il - 1;\r\n        var comparison;\r\n\r\n        while (low <= high)\r\n        {\r\n            i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n            comparison = arcLengths[i] - targetArcLength;\r\n\r\n            if (comparison < 0)\r\n            {\r\n                low = i + 1;\r\n            }\r\n            else if (comparison > 0)\r\n            {\r\n                high = i - 1;\r\n            }\r\n            else\r\n            {\r\n                high = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        i = high;\r\n\r\n        if (arcLengths[i] === targetArcLength)\r\n        {\r\n            return i / (il - 1);\r\n        }\r\n\r\n        // we could get finer grain at lengths, or use simple interpolation between two points\r\n\r\n        var lengthBefore = arcLengths[i];\r\n        var lengthAfter = arcLengths[i + 1];\r\n\r\n        var segmentLength = lengthAfter - lengthBefore;\r\n\r\n        // determine where we are between the 'before' and 'after' points\r\n\r\n        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;\r\n\r\n        // add that fractional amount to t\r\n\r\n        return (i + segmentFraction) / (il - 1);\r\n    },\r\n\r\n    /**\r\n     * Calculate and cache the arc lengths.\r\n     *\r\n     * @method Phaser.Curves.Curve#updateArcLengths\r\n     * @since 3.0.0\r\n     *\r\n     * @see Phaser.Curves.Curve#getLengths()\r\n     */\r\n    updateArcLengths: function ()\r\n    {\r\n        this.needsUpdate = true;\r\n\r\n        this.getLengths();\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Curve;\r\n"]},"metadata":{},"sourceType":"script"}