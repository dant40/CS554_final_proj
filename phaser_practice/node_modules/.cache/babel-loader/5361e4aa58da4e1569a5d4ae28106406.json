{"ast":null,"code":"/**\r\n* The `Matter.Composite` module contains methods for creating and manipulating composite bodies.\r\n* A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.\r\n* It is important to use the functions in this module to modify composites, rather than directly modifying their properties.\r\n* Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Composite\r\n*/\nvar Composite = {};\nmodule.exports = Composite;\n\nvar Events = require('../core/Events');\n\nvar Common = require('../core/Common');\n\nvar Bounds = require('../geometry/Bounds');\n\nvar Body = require('./Body');\n\n(function () {\n  /**\r\n   * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n   * See the properites section below for detailed information on what you can pass via the `options` object.\r\n   * @method create\r\n   * @param {} [options]\r\n   * @return {composite} A new composite\r\n   */\n  Composite.create = function (options) {\n    return Common.extend({\n      id: Common.nextId(),\n      type: 'composite',\n      parent: null,\n      isModified: false,\n      bodies: [],\n      constraints: [],\n      composites: [],\n      label: 'Composite',\n      plugin: {}\n    }, options);\n  };\n  /**\r\n   * Sets the composite's `isModified` flag. \r\n   * If `updateParents` is true, all parents will be set (default: false).\r\n   * If `updateChildren` is true, all children will be set (default: false).\r\n   * @method setModified\r\n   * @param {composite} composite\r\n   * @param {boolean} isModified\r\n   * @param {boolean} [updateParents=false]\r\n   * @param {boolean} [updateChildren=false]\r\n   */\n\n\n  Composite.setModified = function (composite, isModified, updateParents, updateChildren) {\n    Events.trigger(composite, 'compositeModified', composite);\n    composite.isModified = isModified;\n\n    if (updateParents && composite.parent) {\n      Composite.setModified(composite.parent, isModified, updateParents, updateChildren);\n    }\n\n    if (updateChildren) {\n      for (var i = 0; i < composite.composites.length; i++) {\n        var childComposite = composite.composites[i];\n        Composite.setModified(childComposite, isModified, updateParents, updateChildren);\n      }\n    }\n  };\n  /**\r\n   * Generic add function. Adds one or many body(s), constraint(s) or a composite(s) to the given composite.\r\n   * Triggers `beforeAdd` and `afterAdd` events on the `composite`.\r\n   * @method add\r\n   * @param {composite} composite\r\n   * @param {} object\r\n   * @return {composite} The original composite with the objects added\r\n   */\n\n\n  Composite.add = function (composite, object) {\n    var objects = [].concat(object);\n    Events.trigger(composite, 'beforeAdd', {\n      object: object\n    });\n\n    for (var i = 0; i < objects.length; i++) {\n      var obj = objects[i];\n\n      switch (obj.type) {\n        case 'body':\n          // skip adding compound parts\n          if (obj.parent !== obj) {\n            Common.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)');\n            break;\n          }\n\n          Composite.addBody(composite, obj);\n          break;\n\n        case 'constraint':\n          Composite.addConstraint(composite, obj);\n          break;\n\n        case 'composite':\n          Composite.addComposite(composite, obj);\n          break;\n\n        case 'mouseConstraint':\n          Composite.addConstraint(composite, obj.constraint);\n          break;\n      }\n    }\n\n    Events.trigger(composite, 'afterAdd', {\n      object: object\n    });\n    return composite;\n  };\n  /**\r\n   * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.\r\n   * Optionally searching its children recursively.\r\n   * Triggers `beforeRemove` and `afterRemove` events on the `composite`.\r\n   * @method remove\r\n   * @param {composite} composite\r\n   * @param {} object\r\n   * @param {boolean} [deep=false]\r\n   * @return {composite} The original composite with the objects removed\r\n   */\n\n\n  Composite.remove = function (composite, object, deep) {\n    var objects = [].concat(object);\n    Events.trigger(composite, 'beforeRemove', {\n      object: object\n    });\n\n    for (var i = 0; i < objects.length; i++) {\n      var obj = objects[i];\n\n      switch (obj.type) {\n        case 'body':\n          Composite.removeBody(composite, obj, deep);\n          break;\n\n        case 'constraint':\n          Composite.removeConstraint(composite, obj, deep);\n          break;\n\n        case 'composite':\n          Composite.removeComposite(composite, obj, deep);\n          break;\n\n        case 'mouseConstraint':\n          Composite.removeConstraint(composite, obj.constraint);\n          break;\n      }\n    }\n\n    Events.trigger(composite, 'afterRemove', {\n      object: object\n    });\n    return composite;\n  };\n  /**\r\n   * Adds a composite to the given composite.\r\n   * @private\r\n   * @method addComposite\r\n   * @param {composite} compositeA\r\n   * @param {composite} compositeB\r\n   * @return {composite} The original compositeA with the objects from compositeB added\r\n   */\n\n\n  Composite.addComposite = function (compositeA, compositeB) {\n    compositeA.composites.push(compositeB);\n    compositeB.parent = compositeA;\n    Composite.setModified(compositeA, true, true, false);\n    return compositeA;\n  };\n  /**\r\n   * Removes a composite from the given composite, and optionally searching its children recursively.\r\n   * @private\r\n   * @method removeComposite\r\n   * @param {composite} compositeA\r\n   * @param {composite} compositeB\r\n   * @param {boolean} [deep=false]\r\n   * @return {composite} The original compositeA with the composite removed\r\n   */\n\n\n  Composite.removeComposite = function (compositeA, compositeB, deep) {\n    var position = compositeA.composites.indexOf(compositeB);\n\n    if (position !== -1) {\n      Composite.removeCompositeAt(compositeA, position);\n      Composite.setModified(compositeA, true, true, false);\n    }\n\n    if (deep) {\n      for (var i = 0; i < compositeA.composites.length; i++) {\n        Composite.removeComposite(compositeA.composites[i], compositeB, true);\n      }\n    }\n\n    return compositeA;\n  };\n  /**\r\n   * Removes a composite from the given composite.\r\n   * @private\r\n   * @method removeCompositeAt\r\n   * @param {composite} composite\r\n   * @param {number} position\r\n   * @return {composite} The original composite with the composite removed\r\n   */\n\n\n  Composite.removeCompositeAt = function (composite, position) {\n    composite.composites.splice(position, 1);\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Adds a body to the given composite.\r\n   * @private\r\n   * @method addBody\r\n   * @param {composite} composite\r\n   * @param {body} body\r\n   * @return {composite} The original composite with the body added\r\n   */\n\n\n  Composite.addBody = function (composite, body) {\n    composite.bodies.push(body);\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Removes a body from the given composite, and optionally searching its children recursively.\r\n   * @private\r\n   * @method removeBody\r\n   * @param {composite} composite\r\n   * @param {body} body\r\n   * @param {boolean} [deep=false]\r\n   * @return {composite} The original composite with the body removed\r\n   */\n\n\n  Composite.removeBody = function (composite, body, deep) {\n    var position = composite.bodies.indexOf(body);\n\n    if (position !== -1) {\n      Composite.removeBodyAt(composite, position);\n      Composite.setModified(composite, true, true, false);\n    }\n\n    if (deep) {\n      for (var i = 0; i < composite.composites.length; i++) {\n        Composite.removeBody(composite.composites[i], body, true);\n      }\n    }\n\n    return composite;\n  };\n  /**\r\n   * Removes a body from the given composite.\r\n   * @private\r\n   * @method removeBodyAt\r\n   * @param {composite} composite\r\n   * @param {number} position\r\n   * @return {composite} The original composite with the body removed\r\n   */\n\n\n  Composite.removeBodyAt = function (composite, position) {\n    composite.bodies.splice(position, 1);\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Adds a constraint to the given composite.\r\n   * @private\r\n   * @method addConstraint\r\n   * @param {composite} composite\r\n   * @param {constraint} constraint\r\n   * @return {composite} The original composite with the constraint added\r\n   */\n\n\n  Composite.addConstraint = function (composite, constraint) {\n    composite.constraints.push(constraint);\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Removes a constraint from the given composite, and optionally searching its children recursively.\r\n   * @private\r\n   * @method removeConstraint\r\n   * @param {composite} composite\r\n   * @param {constraint} constraint\r\n   * @param {boolean} [deep=false]\r\n   * @return {composite} The original composite with the constraint removed\r\n   */\n\n\n  Composite.removeConstraint = function (composite, constraint, deep) {\n    var position = composite.constraints.indexOf(constraint);\n\n    if (position !== -1) {\n      Composite.removeConstraintAt(composite, position);\n    }\n\n    if (deep) {\n      for (var i = 0; i < composite.composites.length; i++) {\n        Composite.removeConstraint(composite.composites[i], constraint, true);\n      }\n    }\n\n    return composite;\n  };\n  /**\r\n   * Removes a body from the given composite.\r\n   * @private\r\n   * @method removeConstraintAt\r\n   * @param {composite} composite\r\n   * @param {number} position\r\n   * @return {composite} The original composite with the constraint removed\r\n   */\n\n\n  Composite.removeConstraintAt = function (composite, position) {\n    composite.constraints.splice(position, 1);\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Removes all bodies, constraints and composites from the given composite.\r\n   * Optionally clearing its children recursively.\r\n   * @method clear\r\n   * @param {composite} composite\r\n   * @param {boolean} keepStatic\r\n   * @param {boolean} [deep=false]\r\n   */\n\n\n  Composite.clear = function (composite, keepStatic, deep) {\n    if (deep) {\n      for (var i = 0; i < composite.composites.length; i++) {\n        Composite.clear(composite.composites[i], keepStatic, true);\n      }\n    }\n\n    if (keepStatic) {\n      composite.bodies = composite.bodies.filter(function (body) {\n        return body.isStatic;\n      });\n    } else {\n      composite.bodies.length = 0;\n    }\n\n    composite.constraints.length = 0;\n    composite.composites.length = 0;\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Returns all bodies in the given composite, including all bodies in its children, recursively.\r\n   * @method allBodies\r\n   * @param {composite} composite\r\n   * @return {body[]} All the bodies\r\n   */\n\n\n  Composite.allBodies = function (composite) {\n    var bodies = [].concat(composite.bodies);\n\n    for (var i = 0; i < composite.composites.length; i++) bodies = bodies.concat(Composite.allBodies(composite.composites[i]));\n\n    return bodies;\n  };\n  /**\r\n   * Returns all constraints in the given composite, including all constraints in its children, recursively.\r\n   * @method allConstraints\r\n   * @param {composite} composite\r\n   * @return {constraint[]} All the constraints\r\n   */\n\n\n  Composite.allConstraints = function (composite) {\n    var constraints = [].concat(composite.constraints);\n\n    for (var i = 0; i < composite.composites.length; i++) constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));\n\n    return constraints;\n  };\n  /**\r\n   * Returns all composites in the given composite, including all composites in its children, recursively.\r\n   * @method allComposites\r\n   * @param {composite} composite\r\n   * @return {composite[]} All the composites\r\n   */\n\n\n  Composite.allComposites = function (composite) {\n    var composites = [].concat(composite.composites);\n\n    for (var i = 0; i < composite.composites.length; i++) composites = composites.concat(Composite.allComposites(composite.composites[i]));\n\n    return composites;\n  };\n  /**\r\n   * Searches the composite recursively for an object matching the type and id supplied, null if not found.\r\n   * @method get\r\n   * @param {composite} composite\r\n   * @param {number} id\r\n   * @param {string} type\r\n   * @return {object} The requested object, if found\r\n   */\n\n\n  Composite.get = function (composite, id, type) {\n    var objects, object;\n\n    switch (type) {\n      case 'body':\n        objects = Composite.allBodies(composite);\n        break;\n\n      case 'constraint':\n        objects = Composite.allConstraints(composite);\n        break;\n\n      case 'composite':\n        objects = Composite.allComposites(composite).concat(composite);\n        break;\n    }\n\n    if (!objects) return null;\n    object = objects.filter(function (object) {\n      return object.id.toString() === id.toString();\n    });\n    return object.length === 0 ? null : object[0];\n  };\n  /**\r\n   * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).\r\n   * @method move\r\n   * @param {compositeA} compositeA\r\n   * @param {object[]} objects\r\n   * @param {compositeB} compositeB\r\n   * @return {composite} Returns compositeA\r\n   */\n\n\n  Composite.move = function (compositeA, objects, compositeB) {\n    Composite.remove(compositeA, objects);\n    Composite.add(compositeB, objects);\n    return compositeA;\n  };\n  /**\r\n   * Assigns new ids for all objects in the composite, recursively.\r\n   * @method rebase\r\n   * @param {composite} composite\r\n   * @return {composite} Returns composite\r\n   */\n\n\n  Composite.rebase = function (composite) {\n    var objects = Composite.allBodies(composite).concat(Composite.allConstraints(composite)).concat(Composite.allComposites(composite));\n\n    for (var i = 0; i < objects.length; i++) {\n      objects[i].id = Common.nextId();\n    }\n\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Translates all children in the composite by a given vector relative to their current positions, \r\n   * without imparting any velocity.\r\n   * @method translate\r\n   * @param {composite} composite\r\n   * @param {vector} translation\r\n   * @param {bool} [recursive=true]\r\n   */\n\n\n  Composite.translate = function (composite, translation, recursive) {\n    var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n    for (var i = 0; i < bodies.length; i++) {\n      Body.translate(bodies[i], translation);\n    }\n\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.\r\n   * @method rotate\r\n   * @param {composite} composite\r\n   * @param {number} rotation\r\n   * @param {vector} point\r\n   * @param {bool} [recursive=true]\r\n   */\n\n\n  Composite.rotate = function (composite, rotation, point, recursive) {\n    var cos = Math.cos(rotation),\n        sin = Math.sin(rotation),\n        bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i],\n          dx = body.position.x - point.x,\n          dy = body.position.y - point.y;\n      Body.setPosition(body, {\n        x: point.x + (dx * cos - dy * sin),\n        y: point.y + (dx * sin + dy * cos)\n      });\n      Body.rotate(body, rotation);\n    }\n\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.\r\n   * @method scale\r\n   * @param {composite} composite\r\n   * @param {number} scaleX\r\n   * @param {number} scaleY\r\n   * @param {vector} point\r\n   * @param {bool} [recursive=true]\r\n   */\n\n\n  Composite.scale = function (composite, scaleX, scaleY, point, recursive) {\n    var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i],\n          dx = body.position.x - point.x,\n          dy = body.position.y - point.y;\n      Body.setPosition(body, {\n        x: point.x + dx * scaleX,\n        y: point.y + dy * scaleY\n      });\n      Body.scale(body, scaleX, scaleY);\n    }\n\n    Composite.setModified(composite, true, true, false);\n    return composite;\n  };\n  /**\r\n   * Returns the union of the bounds of all of the composite's bodies.\r\n   * @method bounds\r\n   * @param {composite} composite The composite.\r\n   * @returns {bounds} The composite bounds.\r\n   */\n\n\n  Composite.bounds = function (composite) {\n    var bodies = Composite.allBodies(composite),\n        vertices = [];\n\n    for (var i = 0; i < bodies.length; i += 1) {\n      var body = bodies[i];\n      vertices.push(body.bounds.min, body.bounds.max);\n    }\n\n    return Bounds.create(vertices);\n  };\n  /*\r\n  *\r\n  *  Events Documentation\r\n  *\r\n  */\n\n  /**\r\n  * Fired when a call to `Composite.add` is made, before objects have been added.\r\n  *\r\n  * @event beforeAdd\r\n  * @param {} event An event object\r\n  * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /**\r\n  * Fired when a call to `Composite.add` is made, after objects have been added.\r\n  *\r\n  * @event afterAdd\r\n  * @param {} event An event object\r\n  * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /**\r\n  * Fired when a call to `Composite.remove` is made, before objects have been removed.\r\n  *\r\n  * @event beforeRemove\r\n  * @param {} event An event object\r\n  * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /**\r\n  * Fired when a call to `Composite.remove` is made, after objects have been removed.\r\n  *\r\n  * @event afterRemove\r\n  * @param {} event An event object\r\n  * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /*\r\n  *\r\n  *  Properties Documentation\r\n  *\r\n  */\n\n  /**\r\n   * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\r\n   *\r\n   * @property id\r\n   * @type number\r\n   */\n\n  /**\r\n   * A `String` denoting the type of object.\r\n   *\r\n   * @property type\r\n   * @type string\r\n   * @default \"composite\"\r\n   * @readOnly\r\n   */\n\n  /**\r\n   * An arbitrary `String` name to help the user identify and manage composites.\r\n   *\r\n   * @property label\r\n   * @type string\r\n   * @default \"Composite\"\r\n   */\n\n  /**\r\n   * A flag that specifies whether the composite has been modified during the current step.\r\n   * Most `Matter.Composite` methods will automatically set this flag to `true` to inform the engine of changes to be handled.\r\n   * If you need to change it manually, you should use the `Composite.setModified` method.\r\n   *\r\n   * @property isModified\r\n   * @type boolean\r\n   * @default false\r\n   */\n\n  /**\r\n   * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.\r\n   *\r\n   * @property parent\r\n   * @type composite\r\n   * @default null\r\n   */\n\n  /**\r\n   * An array of `Body` that are _direct_ children of this composite.\r\n   * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\r\n   * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.\r\n   *\r\n   * @property bodies\r\n   * @type body[]\r\n   * @default []\r\n   */\n\n  /**\r\n   * An array of `Constraint` that are _direct_ children of this composite.\r\n   * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\r\n   * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.\r\n   *\r\n   * @property constraints\r\n   * @type constraint[]\r\n   * @default []\r\n   */\n\n  /**\r\n   * An array of `Composite` that are _direct_ children of this composite.\r\n   * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\r\n   * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.\r\n   *\r\n   * @property composites\r\n   * @type composite[]\r\n   * @default []\r\n   */\n\n  /**\r\n   * An object reserved for storing plugin-specific properties.\r\n   *\r\n   * @property plugin\r\n   * @type {}\r\n   */\n\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/lib/body/Composite.js"],"names":["Composite","module","exports","Events","require","Common","Bounds","Body","create","options","extend","id","nextId","type","parent","isModified","bodies","constraints","composites","label","plugin","setModified","composite","updateParents","updateChildren","trigger","i","length","childComposite","add","object","objects","concat","obj","warn","addBody","addConstraint","addComposite","constraint","remove","deep","removeBody","removeConstraint","removeComposite","compositeA","compositeB","push","position","indexOf","removeCompositeAt","splice","body","removeBodyAt","removeConstraintAt","clear","keepStatic","filter","isStatic","allBodies","allConstraints","allComposites","get","toString","move","rebase","translate","translation","recursive","rotate","rotation","point","cos","Math","sin","dx","x","dy","y","setPosition","scale","scaleX","scaleY","bounds","vertices","min","max"],"mappings":"AAAA;;;;;;;;;;AAWA,IAAIA,SAAS,GAAG,EAAhB;AAEAC,MAAM,CAACC,OAAP,GAAiBF,SAAjB;;AAEA,IAAIG,MAAM,GAAGC,OAAO,CAAC,gBAAD,CAApB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,gBAAD,CAApB;;AACA,IAAIE,MAAM,GAAGF,OAAO,CAAC,oBAAD,CAApB;;AACA,IAAIG,IAAI,GAAGH,OAAO,CAAC,QAAD,CAAlB;;AAEA,CAAC,YAAW;AAER;;;;;;;AAOAJ,EAAAA,SAAS,CAACQ,MAAV,GAAmB,UAASC,OAAT,EAAkB;AACjC,WAAOJ,MAAM,CAACK,MAAP,CAAc;AACjBC,MAAAA,EAAE,EAAEN,MAAM,CAACO,MAAP,EADa;AAEjBC,MAAAA,IAAI,EAAE,WAFW;AAGjBC,MAAAA,MAAM,EAAE,IAHS;AAIjBC,MAAAA,UAAU,EAAE,KAJK;AAKjBC,MAAAA,MAAM,EAAE,EALS;AAMjBC,MAAAA,WAAW,EAAE,EANI;AAOjBC,MAAAA,UAAU,EAAE,EAPK;AAQjBC,MAAAA,KAAK,EAAE,WARU;AASjBC,MAAAA,MAAM,EAAE;AATS,KAAd,EAUJX,OAVI,CAAP;AAWH,GAZD;AAcA;;;;;;;;;;;;AAUAT,EAAAA,SAAS,CAACqB,WAAV,GAAwB,UAASC,SAAT,EAAoBP,UAApB,EAAgCQ,aAAhC,EAA+CC,cAA/C,EAA+D;AAEnFrB,IAAAA,MAAM,CAACsB,OAAP,CAAeH,SAAf,EAA0B,mBAA1B,EAA+CA,SAA/C;AAEAA,IAAAA,SAAS,CAACP,UAAV,GAAuBA,UAAvB;;AAEA,QAAIQ,aAAa,IAAID,SAAS,CAACR,MAA/B,EAAuC;AACnCd,MAAAA,SAAS,CAACqB,WAAV,CAAsBC,SAAS,CAACR,MAAhC,EAAwCC,UAAxC,EAAoDQ,aAApD,EAAmEC,cAAnE;AACH;;AAED,QAAIA,cAAJ,EAAoB;AAChB,WAAI,IAAIE,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGJ,SAAS,CAACJ,UAAV,CAAqBS,MAAxC,EAAgDD,CAAC,EAAjD,EAAqD;AACjD,YAAIE,cAAc,GAAGN,SAAS,CAACJ,UAAV,CAAqBQ,CAArB,CAArB;AACA1B,QAAAA,SAAS,CAACqB,WAAV,CAAsBO,cAAtB,EAAsCb,UAAtC,EAAkDQ,aAAlD,EAAiEC,cAAjE;AACH;AACJ;AACJ,GAhBD;AAkBA;;;;;;;;;;AAQAxB,EAAAA,SAAS,CAAC6B,GAAV,GAAgB,UAASP,SAAT,EAAoBQ,MAApB,EAA4B;AACxC,QAAIC,OAAO,GAAG,GAAGC,MAAH,CAAUF,MAAV,CAAd;AAEA3B,IAAAA,MAAM,CAACsB,OAAP,CAAeH,SAAf,EAA0B,WAA1B,EAAuC;AAAEQ,MAAAA,MAAM,EAAEA;AAAV,KAAvC;;AAEA,SAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGK,OAAO,CAACJ,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACrC,UAAIO,GAAG,GAAGF,OAAO,CAACL,CAAD,CAAjB;;AAEA,cAAQO,GAAG,CAACpB,IAAZ;AAEA,aAAK,MAAL;AACI;AACA,cAAIoB,GAAG,CAACnB,MAAJ,KAAemB,GAAnB,EAAwB;AACpB5B,YAAAA,MAAM,CAAC6B,IAAP,CAAY,sFAAZ;AACA;AACH;;AAEDlC,UAAAA,SAAS,CAACmC,OAAV,CAAkBb,SAAlB,EAA6BW,GAA7B;AACA;;AACJ,aAAK,YAAL;AACIjC,UAAAA,SAAS,CAACoC,aAAV,CAAwBd,SAAxB,EAAmCW,GAAnC;AACA;;AACJ,aAAK,WAAL;AACIjC,UAAAA,SAAS,CAACqC,YAAV,CAAuBf,SAAvB,EAAkCW,GAAlC;AACA;;AACJ,aAAK,iBAAL;AACIjC,UAAAA,SAAS,CAACoC,aAAV,CAAwBd,SAAxB,EAAmCW,GAAG,CAACK,UAAvC;AACA;AAnBJ;AAsBH;;AAEDnC,IAAAA,MAAM,CAACsB,OAAP,CAAeH,SAAf,EAA0B,UAA1B,EAAsC;AAAEQ,MAAAA,MAAM,EAAEA;AAAV,KAAtC;AAEA,WAAOR,SAAP;AACH,GAnCD;AAqCA;;;;;;;;;;;;AAUAtB,EAAAA,SAAS,CAACuC,MAAV,GAAmB,UAASjB,SAAT,EAAoBQ,MAApB,EAA4BU,IAA5B,EAAkC;AACjD,QAAIT,OAAO,GAAG,GAAGC,MAAH,CAAUF,MAAV,CAAd;AAEA3B,IAAAA,MAAM,CAACsB,OAAP,CAAeH,SAAf,EAA0B,cAA1B,EAA0C;AAAEQ,MAAAA,MAAM,EAAEA;AAAV,KAA1C;;AAEA,SAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGK,OAAO,CAACJ,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACrC,UAAIO,GAAG,GAAGF,OAAO,CAACL,CAAD,CAAjB;;AAEA,cAAQO,GAAG,CAACpB,IAAZ;AAEA,aAAK,MAAL;AACIb,UAAAA,SAAS,CAACyC,UAAV,CAAqBnB,SAArB,EAAgCW,GAAhC,EAAqCO,IAArC;AACA;;AACJ,aAAK,YAAL;AACIxC,UAAAA,SAAS,CAAC0C,gBAAV,CAA2BpB,SAA3B,EAAsCW,GAAtC,EAA2CO,IAA3C;AACA;;AACJ,aAAK,WAAL;AACIxC,UAAAA,SAAS,CAAC2C,eAAV,CAA0BrB,SAA1B,EAAqCW,GAArC,EAA0CO,IAA1C;AACA;;AACJ,aAAK,iBAAL;AACIxC,UAAAA,SAAS,CAAC0C,gBAAV,CAA2BpB,SAA3B,EAAsCW,GAAG,CAACK,UAA1C;AACA;AAbJ;AAgBH;;AAEDnC,IAAAA,MAAM,CAACsB,OAAP,CAAeH,SAAf,EAA0B,aAA1B,EAAyC;AAAEQ,MAAAA,MAAM,EAAEA;AAAV,KAAzC;AAEA,WAAOR,SAAP;AACH,GA7BD;AA+BA;;;;;;;;;;AAQAtB,EAAAA,SAAS,CAACqC,YAAV,GAAyB,UAASO,UAAT,EAAqBC,UAArB,EAAiC;AACtDD,IAAAA,UAAU,CAAC1B,UAAX,CAAsB4B,IAAtB,CAA2BD,UAA3B;AACAA,IAAAA,UAAU,CAAC/B,MAAX,GAAoB8B,UAApB;AACA5C,IAAAA,SAAS,CAACqB,WAAV,CAAsBuB,UAAtB,EAAkC,IAAlC,EAAwC,IAAxC,EAA8C,KAA9C;AACA,WAAOA,UAAP;AACH,GALD;AAOA;;;;;;;;;;;AASA5C,EAAAA,SAAS,CAAC2C,eAAV,GAA4B,UAASC,UAAT,EAAqBC,UAArB,EAAiCL,IAAjC,EAAuC;AAC/D,QAAIO,QAAQ,GAAGH,UAAU,CAAC1B,UAAX,CAAsB8B,OAAtB,CAA8BH,UAA9B,CAAf;;AACA,QAAIE,QAAQ,KAAK,CAAC,CAAlB,EAAqB;AACjB/C,MAAAA,SAAS,CAACiD,iBAAV,CAA4BL,UAA5B,EAAwCG,QAAxC;AACA/C,MAAAA,SAAS,CAACqB,WAAV,CAAsBuB,UAAtB,EAAkC,IAAlC,EAAwC,IAAxC,EAA8C,KAA9C;AACH;;AAED,QAAIJ,IAAJ,EAAU;AACN,WAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkB,UAAU,CAAC1B,UAAX,CAAsBS,MAA1C,EAAkDD,CAAC,EAAnD,EAAsD;AAClD1B,QAAAA,SAAS,CAAC2C,eAAV,CAA0BC,UAAU,CAAC1B,UAAX,CAAsBQ,CAAtB,CAA1B,EAAoDmB,UAApD,EAAgE,IAAhE;AACH;AACJ;;AAED,WAAOD,UAAP;AACH,GAdD;AAgBA;;;;;;;;;;AAQA5C,EAAAA,SAAS,CAACiD,iBAAV,GAA8B,UAAS3B,SAAT,EAAoByB,QAApB,EAA8B;AACxDzB,IAAAA,SAAS,CAACJ,UAAV,CAAqBgC,MAArB,CAA4BH,QAA5B,EAAsC,CAAtC;AACA/C,IAAAA,SAAS,CAACqB,WAAV,CAAsBC,SAAtB,EAAiC,IAAjC,EAAuC,IAAvC,EAA6C,KAA7C;AACA,WAAOA,SAAP;AACH,GAJD;AAMA;;;;;;;;;;AAQAtB,EAAAA,SAAS,CAACmC,OAAV,GAAoB,UAASb,SAAT,EAAoB6B,IAApB,EAA0B;AAC1C7B,IAAAA,SAAS,CAACN,MAAV,CAAiB8B,IAAjB,CAAsBK,IAAtB;AACAnD,IAAAA,SAAS,CAACqB,WAAV,CAAsBC,SAAtB,EAAiC,IAAjC,EAAuC,IAAvC,EAA6C,KAA7C;AACA,WAAOA,SAAP;AACH,GAJD;AAMA;;;;;;;;;;;AASAtB,EAAAA,SAAS,CAACyC,UAAV,GAAuB,UAASnB,SAAT,EAAoB6B,IAApB,EAA0BX,IAA1B,EAAgC;AACnD,QAAIO,QAAQ,GAAGzB,SAAS,CAACN,MAAV,CAAiBgC,OAAjB,CAAyBG,IAAzB,CAAf;;AACA,QAAIJ,QAAQ,KAAK,CAAC,CAAlB,EAAqB;AACjB/C,MAAAA,SAAS,CAACoD,YAAV,CAAuB9B,SAAvB,EAAkCyB,QAAlC;AACA/C,MAAAA,SAAS,CAACqB,WAAV,CAAsBC,SAAtB,EAAiC,IAAjC,EAAuC,IAAvC,EAA6C,KAA7C;AACH;;AAED,QAAIkB,IAAJ,EAAU;AACN,WAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,SAAS,CAACJ,UAAV,CAAqBS,MAAzC,EAAiDD,CAAC,EAAlD,EAAqD;AACjD1B,QAAAA,SAAS,CAACyC,UAAV,CAAqBnB,SAAS,CAACJ,UAAV,CAAqBQ,CAArB,CAArB,EAA8CyB,IAA9C,EAAoD,IAApD;AACH;AACJ;;AAED,WAAO7B,SAAP;AACH,GAdD;AAgBA;;;;;;;;;;AAQAtB,EAAAA,SAAS,CAACoD,YAAV,GAAyB,UAAS9B,SAAT,EAAoByB,QAApB,EAA8B;AACnDzB,IAAAA,SAAS,CAACN,MAAV,CAAiBkC,MAAjB,CAAwBH,QAAxB,EAAkC,CAAlC;AACA/C,IAAAA,SAAS,CAACqB,WAAV,CAAsBC,SAAtB,EAAiC,IAAjC,EAAuC,IAAvC,EAA6C,KAA7C;AACA,WAAOA,SAAP;AACH,GAJD;AAMA;;;;;;;;;;AAQAtB,EAAAA,SAAS,CAACoC,aAAV,GAA0B,UAASd,SAAT,EAAoBgB,UAApB,EAAgC;AACtDhB,IAAAA,SAAS,CAACL,WAAV,CAAsB6B,IAAtB,CAA2BR,UAA3B;AACAtC,IAAAA,SAAS,CAACqB,WAAV,CAAsBC,SAAtB,EAAiC,IAAjC,EAAuC,IAAvC,EAA6C,KAA7C;AACA,WAAOA,SAAP;AACH,GAJD;AAMA;;;;;;;;;;;AASAtB,EAAAA,SAAS,CAAC0C,gBAAV,GAA6B,UAASpB,SAAT,EAAoBgB,UAApB,EAAgCE,IAAhC,EAAsC;AAC/D,QAAIO,QAAQ,GAAGzB,SAAS,CAACL,WAAV,CAAsB+B,OAAtB,CAA8BV,UAA9B,CAAf;;AACA,QAAIS,QAAQ,KAAK,CAAC,CAAlB,EAAqB;AACjB/C,MAAAA,SAAS,CAACqD,kBAAV,CAA6B/B,SAA7B,EAAwCyB,QAAxC;AACH;;AAED,QAAIP,IAAJ,EAAU;AACN,WAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,SAAS,CAACJ,UAAV,CAAqBS,MAAzC,EAAiDD,CAAC,EAAlD,EAAqD;AACjD1B,QAAAA,SAAS,CAAC0C,gBAAV,CAA2BpB,SAAS,CAACJ,UAAV,CAAqBQ,CAArB,CAA3B,EAAoDY,UAApD,EAAgE,IAAhE;AACH;AACJ;;AAED,WAAOhB,SAAP;AACH,GAbD;AAeA;;;;;;;;;;AAQAtB,EAAAA,SAAS,CAACqD,kBAAV,GAA+B,UAAS/B,SAAT,EAAoByB,QAApB,EAA8B;AACzDzB,IAAAA,SAAS,CAACL,WAAV,CAAsBiC,MAAtB,CAA6BH,QAA7B,EAAuC,CAAvC;AACA/C,IAAAA,SAAS,CAACqB,WAAV,CAAsBC,SAAtB,EAAiC,IAAjC,EAAuC,IAAvC,EAA6C,KAA7C;AACA,WAAOA,SAAP;AACH,GAJD;AAMA;;;;;;;;;;AAQAtB,EAAAA,SAAS,CAACsD,KAAV,GAAkB,UAAShC,SAAT,EAAoBiC,UAApB,EAAgCf,IAAhC,EAAsC;AACpD,QAAIA,IAAJ,EAAU;AACN,WAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,SAAS,CAACJ,UAAV,CAAqBS,MAAzC,EAAiDD,CAAC,EAAlD,EAAqD;AACjD1B,QAAAA,SAAS,CAACsD,KAAV,CAAgBhC,SAAS,CAACJ,UAAV,CAAqBQ,CAArB,CAAhB,EAAyC6B,UAAzC,EAAqD,IAArD;AACH;AACJ;;AAED,QAAIA,UAAJ,EAAgB;AACZjC,MAAAA,SAAS,CAACN,MAAV,GAAmBM,SAAS,CAACN,MAAV,CAAiBwC,MAAjB,CAAwB,UAASL,IAAT,EAAe;AAAE,eAAOA,IAAI,CAACM,QAAZ;AAAuB,OAAhE,CAAnB;AACH,KAFD,MAEO;AACHnC,MAAAA,SAAS,CAACN,MAAV,CAAiBW,MAAjB,GAA0B,CAA1B;AACH;;AAEDL,IAAAA,SAAS,CAACL,WAAV,CAAsBU,MAAtB,GAA+B,CAA/B;AACAL,IAAAA,SAAS,CAACJ,UAAV,CAAqBS,MAArB,GAA8B,CAA9B;AACA3B,IAAAA,SAAS,CAACqB,WAAV,CAAsBC,SAAtB,EAAiC,IAAjC,EAAuC,IAAvC,EAA6C,KAA7C;AAEA,WAAOA,SAAP;AACH,GAlBD;AAoBA;;;;;;;;AAMAtB,EAAAA,SAAS,CAAC0D,SAAV,GAAsB,UAASpC,SAAT,EAAoB;AACtC,QAAIN,MAAM,GAAG,GAAGgB,MAAH,CAAUV,SAAS,CAACN,MAApB,CAAb;;AAEA,SAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,SAAS,CAACJ,UAAV,CAAqBS,MAAzC,EAAiDD,CAAC,EAAlD,EACIV,MAAM,GAAGA,MAAM,CAACgB,MAAP,CAAchC,SAAS,CAAC0D,SAAV,CAAoBpC,SAAS,CAACJ,UAAV,CAAqBQ,CAArB,CAApB,CAAd,CAAT;;AAEJ,WAAOV,MAAP;AACH,GAPD;AASA;;;;;;;;AAMAhB,EAAAA,SAAS,CAAC2D,cAAV,GAA2B,UAASrC,SAAT,EAAoB;AAC3C,QAAIL,WAAW,GAAG,GAAGe,MAAH,CAAUV,SAAS,CAACL,WAApB,CAAlB;;AAEA,SAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,SAAS,CAACJ,UAAV,CAAqBS,MAAzC,EAAiDD,CAAC,EAAlD,EACIT,WAAW,GAAGA,WAAW,CAACe,MAAZ,CAAmBhC,SAAS,CAAC2D,cAAV,CAAyBrC,SAAS,CAACJ,UAAV,CAAqBQ,CAArB,CAAzB,CAAnB,CAAd;;AAEJ,WAAOT,WAAP;AACH,GAPD;AASA;;;;;;;;AAMAjB,EAAAA,SAAS,CAAC4D,aAAV,GAA0B,UAAStC,SAAT,EAAoB;AAC1C,QAAIJ,UAAU,GAAG,GAAGc,MAAH,CAAUV,SAAS,CAACJ,UAApB,CAAjB;;AAEA,SAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,SAAS,CAACJ,UAAV,CAAqBS,MAAzC,EAAiDD,CAAC,EAAlD,EACIR,UAAU,GAAGA,UAAU,CAACc,MAAX,CAAkBhC,SAAS,CAAC4D,aAAV,CAAwBtC,SAAS,CAACJ,UAAV,CAAqBQ,CAArB,CAAxB,CAAlB,CAAb;;AAEJ,WAAOR,UAAP;AACH,GAPD;AASA;;;;;;;;;;AAQAlB,EAAAA,SAAS,CAAC6D,GAAV,GAAgB,UAASvC,SAAT,EAAoBX,EAApB,EAAwBE,IAAxB,EAA8B;AAC1C,QAAIkB,OAAJ,EACID,MADJ;;AAGA,YAAQjB,IAAR;AACA,WAAK,MAAL;AACIkB,QAAAA,OAAO,GAAG/B,SAAS,CAAC0D,SAAV,CAAoBpC,SAApB,CAAV;AACA;;AACJ,WAAK,YAAL;AACIS,QAAAA,OAAO,GAAG/B,SAAS,CAAC2D,cAAV,CAAyBrC,SAAzB,CAAV;AACA;;AACJ,WAAK,WAAL;AACIS,QAAAA,OAAO,GAAG/B,SAAS,CAAC4D,aAAV,CAAwBtC,SAAxB,EAAmCU,MAAnC,CAA0CV,SAA1C,CAAV;AACA;AATJ;;AAYA,QAAI,CAACS,OAAL,EACI,OAAO,IAAP;AAEJD,IAAAA,MAAM,GAAGC,OAAO,CAACyB,MAAR,CAAe,UAAS1B,MAAT,EAAiB;AACrC,aAAOA,MAAM,CAACnB,EAAP,CAAUmD,QAAV,OAAyBnD,EAAE,CAACmD,QAAH,EAAhC;AACH,KAFQ,CAAT;AAIA,WAAOhC,MAAM,CAACH,MAAP,KAAkB,CAAlB,GAAsB,IAAtB,GAA6BG,MAAM,CAAC,CAAD,CAA1C;AACH,GAxBD;AA0BA;;;;;;;;;;AAQA9B,EAAAA,SAAS,CAAC+D,IAAV,GAAiB,UAASnB,UAAT,EAAqBb,OAArB,EAA8Bc,UAA9B,EAA0C;AACvD7C,IAAAA,SAAS,CAACuC,MAAV,CAAiBK,UAAjB,EAA6Bb,OAA7B;AACA/B,IAAAA,SAAS,CAAC6B,GAAV,CAAcgB,UAAd,EAA0Bd,OAA1B;AACA,WAAOa,UAAP;AACH,GAJD;AAMA;;;;;;;;AAMA5C,EAAAA,SAAS,CAACgE,MAAV,GAAmB,UAAS1C,SAAT,EAAoB;AACnC,QAAIS,OAAO,GAAG/B,SAAS,CAAC0D,SAAV,CAAoBpC,SAApB,EACTU,MADS,CACFhC,SAAS,CAAC2D,cAAV,CAAyBrC,SAAzB,CADE,EAETU,MAFS,CAEFhC,SAAS,CAAC4D,aAAV,CAAwBtC,SAAxB,CAFE,CAAd;;AAIA,SAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGK,OAAO,CAACJ,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACrCK,MAAAA,OAAO,CAACL,CAAD,CAAP,CAAWf,EAAX,GAAgBN,MAAM,CAACO,MAAP,EAAhB;AACH;;AAEDZ,IAAAA,SAAS,CAACqB,WAAV,CAAsBC,SAAtB,EAAiC,IAAjC,EAAuC,IAAvC,EAA6C,KAA7C;AAEA,WAAOA,SAAP;AACH,GAZD;AAcA;;;;;;;;;;AAQAtB,EAAAA,SAAS,CAACiE,SAAV,GAAsB,UAAS3C,SAAT,EAAoB4C,WAApB,EAAiCC,SAAjC,EAA4C;AAC9D,QAAInD,MAAM,GAAGmD,SAAS,GAAGnE,SAAS,CAAC0D,SAAV,CAAoBpC,SAApB,CAAH,GAAoCA,SAAS,CAACN,MAApE;;AAEA,SAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,MAAM,CAACW,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACpCnB,MAAAA,IAAI,CAAC0D,SAAL,CAAejD,MAAM,CAACU,CAAD,CAArB,EAA0BwC,WAA1B;AACH;;AAEDlE,IAAAA,SAAS,CAACqB,WAAV,CAAsBC,SAAtB,EAAiC,IAAjC,EAAuC,IAAvC,EAA6C,KAA7C;AAEA,WAAOA,SAAP;AACH,GAVD;AAYA;;;;;;;;;;AAQAtB,EAAAA,SAAS,CAACoE,MAAV,GAAmB,UAAS9C,SAAT,EAAoB+C,QAApB,EAA8BC,KAA9B,EAAqCH,SAArC,EAAgD;AAC/D,QAAII,GAAG,GAAGC,IAAI,CAACD,GAAL,CAASF,QAAT,CAAV;AAAA,QACII,GAAG,GAAGD,IAAI,CAACC,GAAL,CAASJ,QAAT,CADV;AAAA,QAEIrD,MAAM,GAAGmD,SAAS,GAAGnE,SAAS,CAAC0D,SAAV,CAAoBpC,SAApB,CAAH,GAAoCA,SAAS,CAACN,MAFpE;;AAIA,SAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,MAAM,CAACW,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACpC,UAAIyB,IAAI,GAAGnC,MAAM,CAACU,CAAD,CAAjB;AAAA,UACIgD,EAAE,GAAGvB,IAAI,CAACJ,QAAL,CAAc4B,CAAd,GAAkBL,KAAK,CAACK,CADjC;AAAA,UAEIC,EAAE,GAAGzB,IAAI,CAACJ,QAAL,CAAc8B,CAAd,GAAkBP,KAAK,CAACO,CAFjC;AAIAtE,MAAAA,IAAI,CAACuE,WAAL,CAAiB3B,IAAjB,EAAuB;AACnBwB,QAAAA,CAAC,EAAEL,KAAK,CAACK,CAAN,IAAWD,EAAE,GAAGH,GAAL,GAAWK,EAAE,GAAGH,GAA3B,CADgB;AAEnBI,QAAAA,CAAC,EAAEP,KAAK,CAACO,CAAN,IAAWH,EAAE,GAAGD,GAAL,GAAWG,EAAE,GAAGL,GAA3B;AAFgB,OAAvB;AAKAhE,MAAAA,IAAI,CAAC6D,MAAL,CAAYjB,IAAZ,EAAkBkB,QAAlB;AACH;;AAEDrE,IAAAA,SAAS,CAACqB,WAAV,CAAsBC,SAAtB,EAAiC,IAAjC,EAAuC,IAAvC,EAA6C,KAA7C;AAEA,WAAOA,SAAP;AACH,GArBD;AAuBA;;;;;;;;;;;AASAtB,EAAAA,SAAS,CAAC+E,KAAV,GAAkB,UAASzD,SAAT,EAAoB0D,MAApB,EAA4BC,MAA5B,EAAoCX,KAApC,EAA2CH,SAA3C,EAAsD;AACpE,QAAInD,MAAM,GAAGmD,SAAS,GAAGnE,SAAS,CAAC0D,SAAV,CAAoBpC,SAApB,CAAH,GAAoCA,SAAS,CAACN,MAApE;;AAEA,SAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,MAAM,CAACW,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACpC,UAAIyB,IAAI,GAAGnC,MAAM,CAACU,CAAD,CAAjB;AAAA,UACIgD,EAAE,GAAGvB,IAAI,CAACJ,QAAL,CAAc4B,CAAd,GAAkBL,KAAK,CAACK,CADjC;AAAA,UAEIC,EAAE,GAAGzB,IAAI,CAACJ,QAAL,CAAc8B,CAAd,GAAkBP,KAAK,CAACO,CAFjC;AAIAtE,MAAAA,IAAI,CAACuE,WAAL,CAAiB3B,IAAjB,EAAuB;AACnBwB,QAAAA,CAAC,EAAEL,KAAK,CAACK,CAAN,GAAUD,EAAE,GAAGM,MADC;AAEnBH,QAAAA,CAAC,EAAEP,KAAK,CAACO,CAAN,GAAUD,EAAE,GAAGK;AAFC,OAAvB;AAKA1E,MAAAA,IAAI,CAACwE,KAAL,CAAW5B,IAAX,EAAiB6B,MAAjB,EAAyBC,MAAzB;AACH;;AAEDjF,IAAAA,SAAS,CAACqB,WAAV,CAAsBC,SAAtB,EAAiC,IAAjC,EAAuC,IAAvC,EAA6C,KAA7C;AAEA,WAAOA,SAAP;AACH,GAnBD;AAqBA;;;;;;;;AAMAtB,EAAAA,SAAS,CAACkF,MAAV,GAAmB,UAAS5D,SAAT,EAAoB;AACnC,QAAIN,MAAM,GAAGhB,SAAS,CAAC0D,SAAV,CAAoBpC,SAApB,CAAb;AAAA,QACI6D,QAAQ,GAAG,EADf;;AAGA,SAAK,IAAIzD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,MAAM,CAACW,MAA3B,EAAmCD,CAAC,IAAI,CAAxC,EAA2C;AACvC,UAAIyB,IAAI,GAAGnC,MAAM,CAACU,CAAD,CAAjB;AACAyD,MAAAA,QAAQ,CAACrC,IAAT,CAAcK,IAAI,CAAC+B,MAAL,CAAYE,GAA1B,EAA+BjC,IAAI,CAAC+B,MAAL,CAAYG,GAA3C;AACH;;AAED,WAAO/E,MAAM,CAACE,MAAP,CAAc2E,QAAd,CAAP;AACH,GAVD;AAYA;;;;;;AAMA;;;;;;;;;;AAUA;;;;;;;;;;AAUA;;;;;;;;;;AAUA;;;;;;;;;;AAUA;;;;;;AAMA;;;;;;;AAOA;;;;;;;;;AASA;;;;;;;;AAQA;;;;;;;;;;AAUA;;;;;;;;AAQA;;;;;;;;;;AAUA;;;;;;;;;;AAUA;;;;;;;;;;AAUA;;;;;;;AAOH,CA3pBD","sourcesContent":["/**\r\n* The `Matter.Composite` module contains methods for creating and manipulating composite bodies.\r\n* A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.\r\n* It is important to use the functions in this module to modify composites, rather than directly modifying their properties.\r\n* Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Composite\r\n*/\r\n\r\nvar Composite = {};\r\n\r\nmodule.exports = Composite;\r\n\r\nvar Events = require('../core/Events');\r\nvar Common = require('../core/Common');\r\nvar Bounds = require('../geometry/Bounds');\r\nvar Body = require('./Body');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properites section below for detailed information on what you can pass via the `options` object.\r\n     * @method create\r\n     * @param {} [options]\r\n     * @return {composite} A new composite\r\n     */\r\n    Composite.create = function(options) {\r\n        return Common.extend({ \r\n            id: Common.nextId(),\r\n            type: 'composite',\r\n            parent: null,\r\n            isModified: false,\r\n            bodies: [], \r\n            constraints: [], \r\n            composites: [],\r\n            label: 'Composite',\r\n            plugin: {}\r\n        }, options);\r\n    };\r\n\r\n    /**\r\n     * Sets the composite's `isModified` flag. \r\n     * If `updateParents` is true, all parents will be set (default: false).\r\n     * If `updateChildren` is true, all children will be set (default: false).\r\n     * @method setModified\r\n     * @param {composite} composite\r\n     * @param {boolean} isModified\r\n     * @param {boolean} [updateParents=false]\r\n     * @param {boolean} [updateChildren=false]\r\n     */\r\n    Composite.setModified = function(composite, isModified, updateParents, updateChildren) {\r\n\r\n        Events.trigger(composite, 'compositeModified', composite);\r\n\r\n        composite.isModified = isModified;\r\n\r\n        if (updateParents && composite.parent) {\r\n            Composite.setModified(composite.parent, isModified, updateParents, updateChildren);\r\n        }\r\n\r\n        if (updateChildren) {\r\n            for(var i = 0; i < composite.composites.length; i++) {\r\n                var childComposite = composite.composites[i];\r\n                Composite.setModified(childComposite, isModified, updateParents, updateChildren);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Generic add function. Adds one or many body(s), constraint(s) or a composite(s) to the given composite.\r\n     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.\r\n     * @method add\r\n     * @param {composite} composite\r\n     * @param {} object\r\n     * @return {composite} The original composite with the objects added\r\n     */\r\n    Composite.add = function(composite, object) {\r\n        var objects = [].concat(object);\r\n\r\n        Events.trigger(composite, 'beforeAdd', { object: object });\r\n\r\n        for (var i = 0; i < objects.length; i++) {\r\n            var obj = objects[i];\r\n\r\n            switch (obj.type) {\r\n\r\n            case 'body':\r\n                // skip adding compound parts\r\n                if (obj.parent !== obj) {\r\n                    Common.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)');\r\n                    break;\r\n                }\r\n\r\n                Composite.addBody(composite, obj);\r\n                break;\r\n            case 'constraint':\r\n                Composite.addConstraint(composite, obj);\r\n                break;\r\n            case 'composite':\r\n                Composite.addComposite(composite, obj);\r\n                break;\r\n            case 'mouseConstraint':\r\n                Composite.addConstraint(composite, obj.constraint);\r\n                break;\r\n\r\n            }\r\n        }\r\n\r\n        Events.trigger(composite, 'afterAdd', { object: object });\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.\r\n     * Optionally searching its children recursively.\r\n     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.\r\n     * @method remove\r\n     * @param {composite} composite\r\n     * @param {} object\r\n     * @param {boolean} [deep=false]\r\n     * @return {composite} The original composite with the objects removed\r\n     */\r\n    Composite.remove = function(composite, object, deep) {\r\n        var objects = [].concat(object);\r\n\r\n        Events.trigger(composite, 'beforeRemove', { object: object });\r\n\r\n        for (var i = 0; i < objects.length; i++) {\r\n            var obj = objects[i];\r\n\r\n            switch (obj.type) {\r\n\r\n            case 'body':\r\n                Composite.removeBody(composite, obj, deep);\r\n                break;\r\n            case 'constraint':\r\n                Composite.removeConstraint(composite, obj, deep);\r\n                break;\r\n            case 'composite':\r\n                Composite.removeComposite(composite, obj, deep);\r\n                break;\r\n            case 'mouseConstraint':\r\n                Composite.removeConstraint(composite, obj.constraint);\r\n                break;\r\n\r\n            }\r\n        }\r\n\r\n        Events.trigger(composite, 'afterRemove', { object: object });\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Adds a composite to the given composite.\r\n     * @private\r\n     * @method addComposite\r\n     * @param {composite} compositeA\r\n     * @param {composite} compositeB\r\n     * @return {composite} The original compositeA with the objects from compositeB added\r\n     */\r\n    Composite.addComposite = function(compositeA, compositeB) {\r\n        compositeA.composites.push(compositeB);\r\n        compositeB.parent = compositeA;\r\n        Composite.setModified(compositeA, true, true, false);\r\n        return compositeA;\r\n    };\r\n\r\n    /**\r\n     * Removes a composite from the given composite, and optionally searching its children recursively.\r\n     * @private\r\n     * @method removeComposite\r\n     * @param {composite} compositeA\r\n     * @param {composite} compositeB\r\n     * @param {boolean} [deep=false]\r\n     * @return {composite} The original compositeA with the composite removed\r\n     */\r\n    Composite.removeComposite = function(compositeA, compositeB, deep) {\r\n        var position = compositeA.composites.indexOf(compositeB);\r\n        if (position !== -1) {\r\n            Composite.removeCompositeAt(compositeA, position);\r\n            Composite.setModified(compositeA, true, true, false);\r\n        }\r\n\r\n        if (deep) {\r\n            for (var i = 0; i < compositeA.composites.length; i++){\r\n                Composite.removeComposite(compositeA.composites[i], compositeB, true);\r\n            }\r\n        }\r\n\r\n        return compositeA;\r\n    };\r\n\r\n    /**\r\n     * Removes a composite from the given composite.\r\n     * @private\r\n     * @method removeCompositeAt\r\n     * @param {composite} composite\r\n     * @param {number} position\r\n     * @return {composite} The original composite with the composite removed\r\n     */\r\n    Composite.removeCompositeAt = function(composite, position) {\r\n        composite.composites.splice(position, 1);\r\n        Composite.setModified(composite, true, true, false);\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Adds a body to the given composite.\r\n     * @private\r\n     * @method addBody\r\n     * @param {composite} composite\r\n     * @param {body} body\r\n     * @return {composite} The original composite with the body added\r\n     */\r\n    Composite.addBody = function(composite, body) {\r\n        composite.bodies.push(body);\r\n        Composite.setModified(composite, true, true, false);\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Removes a body from the given composite, and optionally searching its children recursively.\r\n     * @private\r\n     * @method removeBody\r\n     * @param {composite} composite\r\n     * @param {body} body\r\n     * @param {boolean} [deep=false]\r\n     * @return {composite} The original composite with the body removed\r\n     */\r\n    Composite.removeBody = function(composite, body, deep) {\r\n        var position = composite.bodies.indexOf(body);\r\n        if (position !== -1) {\r\n            Composite.removeBodyAt(composite, position);\r\n            Composite.setModified(composite, true, true, false);\r\n        }\r\n\r\n        if (deep) {\r\n            for (var i = 0; i < composite.composites.length; i++){\r\n                Composite.removeBody(composite.composites[i], body, true);\r\n            }\r\n        }\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Removes a body from the given composite.\r\n     * @private\r\n     * @method removeBodyAt\r\n     * @param {composite} composite\r\n     * @param {number} position\r\n     * @return {composite} The original composite with the body removed\r\n     */\r\n    Composite.removeBodyAt = function(composite, position) {\r\n        composite.bodies.splice(position, 1);\r\n        Composite.setModified(composite, true, true, false);\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Adds a constraint to the given composite.\r\n     * @private\r\n     * @method addConstraint\r\n     * @param {composite} composite\r\n     * @param {constraint} constraint\r\n     * @return {composite} The original composite with the constraint added\r\n     */\r\n    Composite.addConstraint = function(composite, constraint) {\r\n        composite.constraints.push(constraint);\r\n        Composite.setModified(composite, true, true, false);\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Removes a constraint from the given composite, and optionally searching its children recursively.\r\n     * @private\r\n     * @method removeConstraint\r\n     * @param {composite} composite\r\n     * @param {constraint} constraint\r\n     * @param {boolean} [deep=false]\r\n     * @return {composite} The original composite with the constraint removed\r\n     */\r\n    Composite.removeConstraint = function(composite, constraint, deep) {\r\n        var position = composite.constraints.indexOf(constraint);\r\n        if (position !== -1) {\r\n            Composite.removeConstraintAt(composite, position);\r\n        }\r\n\r\n        if (deep) {\r\n            for (var i = 0; i < composite.composites.length; i++){\r\n                Composite.removeConstraint(composite.composites[i], constraint, true);\r\n            }\r\n        }\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Removes a body from the given composite.\r\n     * @private\r\n     * @method removeConstraintAt\r\n     * @param {composite} composite\r\n     * @param {number} position\r\n     * @return {composite} The original composite with the constraint removed\r\n     */\r\n    Composite.removeConstraintAt = function(composite, position) {\r\n        composite.constraints.splice(position, 1);\r\n        Composite.setModified(composite, true, true, false);\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Removes all bodies, constraints and composites from the given composite.\r\n     * Optionally clearing its children recursively.\r\n     * @method clear\r\n     * @param {composite} composite\r\n     * @param {boolean} keepStatic\r\n     * @param {boolean} [deep=false]\r\n     */\r\n    Composite.clear = function(composite, keepStatic, deep) {\r\n        if (deep) {\r\n            for (var i = 0; i < composite.composites.length; i++){\r\n                Composite.clear(composite.composites[i], keepStatic, true);\r\n            }\r\n        }\r\n        \r\n        if (keepStatic) {\r\n            composite.bodies = composite.bodies.filter(function(body) { return body.isStatic; });\r\n        } else {\r\n            composite.bodies.length = 0;\r\n        }\r\n\r\n        composite.constraints.length = 0;\r\n        composite.composites.length = 0;\r\n        Composite.setModified(composite, true, true, false);\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Returns all bodies in the given composite, including all bodies in its children, recursively.\r\n     * @method allBodies\r\n     * @param {composite} composite\r\n     * @return {body[]} All the bodies\r\n     */\r\n    Composite.allBodies = function(composite) {\r\n        var bodies = [].concat(composite.bodies);\r\n\r\n        for (var i = 0; i < composite.composites.length; i++)\r\n            bodies = bodies.concat(Composite.allBodies(composite.composites[i]));\r\n\r\n        return bodies;\r\n    };\r\n\r\n    /**\r\n     * Returns all constraints in the given composite, including all constraints in its children, recursively.\r\n     * @method allConstraints\r\n     * @param {composite} composite\r\n     * @return {constraint[]} All the constraints\r\n     */\r\n    Composite.allConstraints = function(composite) {\r\n        var constraints = [].concat(composite.constraints);\r\n\r\n        for (var i = 0; i < composite.composites.length; i++)\r\n            constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));\r\n\r\n        return constraints;\r\n    };\r\n\r\n    /**\r\n     * Returns all composites in the given composite, including all composites in its children, recursively.\r\n     * @method allComposites\r\n     * @param {composite} composite\r\n     * @return {composite[]} All the composites\r\n     */\r\n    Composite.allComposites = function(composite) {\r\n        var composites = [].concat(composite.composites);\r\n\r\n        for (var i = 0; i < composite.composites.length; i++)\r\n            composites = composites.concat(Composite.allComposites(composite.composites[i]));\r\n\r\n        return composites;\r\n    };\r\n\r\n    /**\r\n     * Searches the composite recursively for an object matching the type and id supplied, null if not found.\r\n     * @method get\r\n     * @param {composite} composite\r\n     * @param {number} id\r\n     * @param {string} type\r\n     * @return {object} The requested object, if found\r\n     */\r\n    Composite.get = function(composite, id, type) {\r\n        var objects,\r\n            object;\r\n\r\n        switch (type) {\r\n        case 'body':\r\n            objects = Composite.allBodies(composite);\r\n            break;\r\n        case 'constraint':\r\n            objects = Composite.allConstraints(composite);\r\n            break;\r\n        case 'composite':\r\n            objects = Composite.allComposites(composite).concat(composite);\r\n            break;\r\n        }\r\n\r\n        if (!objects)\r\n            return null;\r\n\r\n        object = objects.filter(function(object) { \r\n            return object.id.toString() === id.toString(); \r\n        });\r\n\r\n        return object.length === 0 ? null : object[0];\r\n    };\r\n\r\n    /**\r\n     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).\r\n     * @method move\r\n     * @param {compositeA} compositeA\r\n     * @param {object[]} objects\r\n     * @param {compositeB} compositeB\r\n     * @return {composite} Returns compositeA\r\n     */\r\n    Composite.move = function(compositeA, objects, compositeB) {\r\n        Composite.remove(compositeA, objects);\r\n        Composite.add(compositeB, objects);\r\n        return compositeA;\r\n    };\r\n\r\n    /**\r\n     * Assigns new ids for all objects in the composite, recursively.\r\n     * @method rebase\r\n     * @param {composite} composite\r\n     * @return {composite} Returns composite\r\n     */\r\n    Composite.rebase = function(composite) {\r\n        var objects = Composite.allBodies(composite)\r\n            .concat(Composite.allConstraints(composite))\r\n            .concat(Composite.allComposites(composite));\r\n\r\n        for (var i = 0; i < objects.length; i++) {\r\n            objects[i].id = Common.nextId();\r\n        }\r\n\r\n        Composite.setModified(composite, true, true, false);\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Translates all children in the composite by a given vector relative to their current positions, \r\n     * without imparting any velocity.\r\n     * @method translate\r\n     * @param {composite} composite\r\n     * @param {vector} translation\r\n     * @param {bool} [recursive=true]\r\n     */\r\n    Composite.translate = function(composite, translation, recursive) {\r\n        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\r\n\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            Body.translate(bodies[i], translation);\r\n        }\r\n\r\n        Composite.setModified(composite, true, true, false);\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.\r\n     * @method rotate\r\n     * @param {composite} composite\r\n     * @param {number} rotation\r\n     * @param {vector} point\r\n     * @param {bool} [recursive=true]\r\n     */\r\n    Composite.rotate = function(composite, rotation, point, recursive) {\r\n        var cos = Math.cos(rotation),\r\n            sin = Math.sin(rotation),\r\n            bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\r\n\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i],\r\n                dx = body.position.x - point.x,\r\n                dy = body.position.y - point.y;\r\n                \r\n            Body.setPosition(body, {\r\n                x: point.x + (dx * cos - dy * sin),\r\n                y: point.y + (dx * sin + dy * cos)\r\n            });\r\n\r\n            Body.rotate(body, rotation);\r\n        }\r\n\r\n        Composite.setModified(composite, true, true, false);\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.\r\n     * @method scale\r\n     * @param {composite} composite\r\n     * @param {number} scaleX\r\n     * @param {number} scaleY\r\n     * @param {vector} point\r\n     * @param {bool} [recursive=true]\r\n     */\r\n    Composite.scale = function(composite, scaleX, scaleY, point, recursive) {\r\n        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\r\n\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i],\r\n                dx = body.position.x - point.x,\r\n                dy = body.position.y - point.y;\r\n                \r\n            Body.setPosition(body, {\r\n                x: point.x + dx * scaleX,\r\n                y: point.y + dy * scaleY\r\n            });\r\n\r\n            Body.scale(body, scaleX, scaleY);\r\n        }\r\n\r\n        Composite.setModified(composite, true, true, false);\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Returns the union of the bounds of all of the composite's bodies.\r\n     * @method bounds\r\n     * @param {composite} composite The composite.\r\n     * @returns {bounds} The composite bounds.\r\n     */\r\n    Composite.bounds = function(composite) {\r\n        var bodies = Composite.allBodies(composite),\r\n            vertices = [];\r\n\r\n        for (var i = 0; i < bodies.length; i += 1) {\r\n            var body = bodies[i];\r\n            vertices.push(body.bounds.min, body.bounds.max);\r\n        }\r\n\r\n        return Bounds.create(vertices);\r\n    };\r\n\r\n    /*\r\n    *\r\n    *  Events Documentation\r\n    *\r\n    */\r\n\r\n    /**\r\n    * Fired when a call to `Composite.add` is made, before objects have been added.\r\n    *\r\n    * @event beforeAdd\r\n    * @param {} event An event object\r\n    * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /**\r\n    * Fired when a call to `Composite.add` is made, after objects have been added.\r\n    *\r\n    * @event afterAdd\r\n    * @param {} event An event object\r\n    * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /**\r\n    * Fired when a call to `Composite.remove` is made, before objects have been removed.\r\n    *\r\n    * @event beforeRemove\r\n    * @param {} event An event object\r\n    * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /**\r\n    * Fired when a call to `Composite.remove` is made, after objects have been removed.\r\n    *\r\n    * @event afterRemove\r\n    * @param {} event An event object\r\n    * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /*\r\n    *\r\n    *  Properties Documentation\r\n    *\r\n    */\r\n\r\n    /**\r\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\r\n     *\r\n     * @property id\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A `String` denoting the type of object.\r\n     *\r\n     * @property type\r\n     * @type string\r\n     * @default \"composite\"\r\n     * @readOnly\r\n     */\r\n\r\n    /**\r\n     * An arbitrary `String` name to help the user identify and manage composites.\r\n     *\r\n     * @property label\r\n     * @type string\r\n     * @default \"Composite\"\r\n     */\r\n\r\n    /**\r\n     * A flag that specifies whether the composite has been modified during the current step.\r\n     * Most `Matter.Composite` methods will automatically set this flag to `true` to inform the engine of changes to be handled.\r\n     * If you need to change it manually, you should use the `Composite.setModified` method.\r\n     *\r\n     * @property isModified\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n\r\n    /**\r\n     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.\r\n     *\r\n     * @property parent\r\n     * @type composite\r\n     * @default null\r\n     */\r\n\r\n    /**\r\n     * An array of `Body` that are _direct_ children of this composite.\r\n     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\r\n     * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.\r\n     *\r\n     * @property bodies\r\n     * @type body[]\r\n     * @default []\r\n     */\r\n\r\n    /**\r\n     * An array of `Constraint` that are _direct_ children of this composite.\r\n     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\r\n     * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.\r\n     *\r\n     * @property constraints\r\n     * @type constraint[]\r\n     * @default []\r\n     */\r\n\r\n    /**\r\n     * An array of `Composite` that are _direct_ children of this composite.\r\n     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\r\n     * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.\r\n     *\r\n     * @property composites\r\n     * @type composite[]\r\n     * @default []\r\n     */\r\n\r\n    /**\r\n     * An object reserved for storing plugin-specific properties.\r\n     *\r\n     * @property plugin\r\n     * @type {}\r\n     */\r\n\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}