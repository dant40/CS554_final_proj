{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar BaseCamera = require('../../cameras/2d/BaseCamera');\n\nvar CameraEvents = require('../../cameras/2d/events');\n\nvar Class = require('../../utils/Class');\n\nvar CONST = require('../../const');\n\nvar GameEvents = require('../../core/events');\n\nvar IsSizePowerOfTwo = require('../../math/pow2/IsSizePowerOfTwo');\n\nvar NOOP = require('../../utils/NOOP');\n\nvar ScaleEvents = require('../../scale/events');\n\nvar SpliceOne = require('../../utils/array/SpliceOne');\n\nvar TextureEvents = require('../../textures/events');\n\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\n\nvar Utils = require('./Utils');\n\nvar WebGLSnapshot = require('../snapshot/WebGLSnapshot'); //  Default Pipelines\n\n\nvar BitmapMaskPipeline = require('./pipelines/BitmapMaskPipeline');\n\nvar ForwardDiffuseLightPipeline = require('./pipelines/ForwardDiffuseLightPipeline');\n\nvar TextureTintPipeline = require('./pipelines/TextureTintPipeline');\n/**\r\n * @callback WebGLContextCallback\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer which owns the context.\r\n */\n\n/**\r\n * @classdesc\r\n * WebGLRenderer is a class that contains the needed functionality to keep the\r\n * WebGLRenderingContext state clean. The main idea of the WebGLRenderer is to keep track of\r\n * any context change that happens for WebGL rendering inside of Phaser. This means\r\n * if raw webgl functions are called outside the WebGLRenderer of the Phaser WebGL\r\n * rendering ecosystem they might pollute the current WebGLRenderingContext state producing\r\n * unexpected behavior. It's recommended that WebGL interaction is done through\r\n * WebGLRenderer and/or WebGLPipeline.\r\n *\r\n * @class WebGLRenderer\r\n * @memberof Phaser.Renderer.WebGL\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Game instance which owns this WebGL Renderer.\r\n */\n\n\nvar WebGLRenderer = new Class({\n  initialize: function WebGLRenderer(game) {\n    var gameConfig = game.config;\n    var contextCreationConfig = {\n      alpha: gameConfig.transparent,\n      desynchronized: gameConfig.desynchronized,\n      depth: false,\n      antialias: gameConfig.antialiasGL,\n      premultipliedAlpha: gameConfig.premultipliedAlpha,\n      stencil: true,\n      failIfMajorPerformanceCaveat: gameConfig.failIfMajorPerformanceCaveat,\n      powerPreference: gameConfig.powerPreference\n    };\n    /**\r\n     * The local configuration settings of this WebGL Renderer.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#config\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.config = {\n      clearBeforeRender: gameConfig.clearBeforeRender,\n      antialias: gameConfig.antialias,\n      backgroundColor: gameConfig.backgroundColor,\n      contextCreation: contextCreationConfig,\n      resolution: gameConfig.resolution,\n      roundPixels: gameConfig.roundPixels,\n      maxTextures: gameConfig.maxTextures,\n      maxTextureSize: gameConfig.maxTextureSize,\n      batchSize: gameConfig.batchSize,\n      maxLights: gameConfig.maxLights,\n      mipmapFilter: gameConfig.mipmapFilter\n    };\n    /**\r\n     * The Game instance which owns this WebGL Renderer.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#game\r\n     * @type {Phaser.Game}\r\n     * @since 3.0.0\r\n     */\n\n    this.game = game;\n    /**\r\n     * A constant which allows the renderer to be easily identified as a WebGL Renderer.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#type\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.type = CONST.WEBGL;\n    /**\r\n     * The width of the canvas being rendered to.\r\n     * This is populated in the onResize event handler.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#width\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.width = 0;\n    /**\r\n     * The height of the canvas being rendered to.\r\n     * This is populated in the onResize event handler.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#height\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.height = 0;\n    /**\r\n     * The canvas which this WebGL Renderer draws to.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#canvas\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.0.0\r\n     */\n\n    this.canvas = game.canvas;\n    /**\r\n     * An array of blend modes supported by the WebGL Renderer.\r\n     * \r\n     * This array includes the default blend modes as well as any custom blend modes added through {@link #addBlendMode}.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#blendModes\r\n     * @type {array}\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this.blendModes = [];\n    /**\r\n     * Keeps track of any WebGLTexture created with the current WebGLRenderingContext\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#nativeTextures\r\n     * @type {array}\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this.nativeTextures = [];\n    /**\r\n     * This property is set to `true` if the WebGL context of the renderer is lost.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#contextLost\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.contextLost = false;\n    /**\r\n     * This object will store all pipelines created through addPipeline\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#pipelines\r\n     * @type {object}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.pipelines = null;\n    /**\r\n     * Details about the currently scheduled snapshot.\r\n     * \r\n     * If a non-null `callback` is set in this object, a snapshot of the canvas will be taken after the current frame is fully rendered.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#snapshotState\r\n     * @type {Phaser.Types.Renderer.Snapshot.SnapshotState}\r\n     * @since 3.0.0\r\n     */\n\n    this.snapshotState = {\n      x: 0,\n      y: 0,\n      width: 1,\n      height: 1,\n      getPixel: false,\n      callback: null,\n      type: 'image/png',\n      encoder: 0.92,\n      isFramebuffer: false,\n      bufferWidth: 0,\n      bufferHeight: 0\n    }; // Internal Renderer State (Textures, Framebuffers, Pipelines, Buffers, etc)\n\n    /**\r\n     * Cached value for the last texture unit that was used\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentActiveTextureUnit\r\n     * @type {integer}\r\n     * @since 3.1.0\r\n     */\n\n    this.currentActiveTextureUnit = 0;\n    /**\r\n     * An array of the last texture handles that were bound to the WebGLRenderingContext\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentTextures\r\n     * @type {array}\r\n     * @since 3.0.0\r\n     */\n\n    this.currentTextures = new Array(16);\n    /**\r\n     * Current framebuffer in use\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentFramebuffer\r\n     * @type {WebGLFramebuffer}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.currentFramebuffer = null;\n    /**\r\n     * Current WebGLPipeline in use\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentPipeline\r\n     * @type {Phaser.Renderer.WebGL.WebGLPipeline}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.currentPipeline = null;\n    /**\r\n     * Current WebGLProgram in use\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentProgram\r\n     * @type {WebGLProgram}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.currentProgram = null;\n    /**\r\n     * Current WebGLBuffer (Vertex buffer) in use\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentVertexBuffer\r\n     * @type {WebGLBuffer}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.currentVertexBuffer = null;\n    /**\r\n     * Current WebGLBuffer (Index buffer) in use\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentIndexBuffer\r\n     * @type {WebGLBuffer}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.currentIndexBuffer = null;\n    /**\r\n     * Current blend mode in use\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentBlendMode\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.currentBlendMode = Infinity;\n    /**\r\n     * Indicates if the the scissor state is enabled in WebGLRenderingContext\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentScissorEnabled\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.currentScissorEnabled = false;\n    /**\r\n     * Stores the current scissor data\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentScissor\r\n     * @type {Uint32Array}\r\n     * @since 3.0.0\r\n     */\n\n    this.currentScissor = null;\n    /**\r\n     * Stack of scissor data\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#scissorStack\r\n     * @type {Uint32Array}\r\n     * @since 3.0.0\r\n     */\n\n    this.scissorStack = [];\n    /**\r\n     * The handler to invoke when the context is lost.\r\n     * This should not be changed and is set in the boot method.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#contextLostHandler\r\n     * @type {function}\r\n     * @since 3.19.0\r\n     */\n\n    this.contextLostHandler = NOOP;\n    /**\r\n     * The handler to invoke when the context is restored.\r\n     * This should not be changed and is set in the boot method.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#contextRestoredHandler\r\n     * @type {function}\r\n     * @since 3.19.0\r\n     */\n\n    this.contextRestoredHandler = NOOP;\n    /**\r\n     * The underlying WebGL context of the renderer.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#gl\r\n     * @type {WebGLRenderingContext}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.gl = null;\n    /**\r\n     * Array of strings that indicate which WebGL extensions are supported by the browser\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#supportedExtensions\r\n     * @type {object}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.supportedExtensions = null;\n    /**\r\n     * Extensions loaded into the current context\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#extensions\r\n     * @type {object}\r\n     * @default {}\r\n     * @since 3.0.0\r\n     */\n\n    this.extensions = {};\n    /**\r\n     * Stores the current WebGL component formats for further use\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#glFormats\r\n     * @type {array}\r\n     * @default []\r\n     * @since 3.2.0\r\n     */\n\n    this.glFormats = [];\n    /**\r\n     * Stores the supported WebGL texture compression formats.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#compression\r\n     * @type {array}\r\n     * @since 3.8.0\r\n     */\n\n    this.compression = {\n      ETC1: false,\n      PVRTC: false,\n      S3TC: false\n    };\n    /**\r\n     * Cached drawing buffer height to reduce gl calls.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#drawingBufferHeight\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.11.0\r\n     */\n\n    this.drawingBufferHeight = 0;\n    /**\r\n     * A blank 32x32 transparent texture, as used by the Graphics system where needed.\r\n     * This is set in the `boot` method.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#blankTexture\r\n     * @type {WebGLTexture}\r\n     * @readonly\r\n     * @since 3.12.0\r\n     */\n\n    this.blankTexture = null;\n    /**\r\n     * A default Camera used in calls when no other camera has been provided.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#defaultCamera\r\n     * @type {Phaser.Cameras.Scene2D.BaseCamera}\r\n     * @since 3.12.0\r\n     */\n\n    this.defaultCamera = new BaseCamera(0, 0, 0, 0);\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix1\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix1 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix2\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix2 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix3\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix3 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix4\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix4 = new TransformMatrix();\n    /**\r\n     * The total number of masks currently stacked.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#maskCount\r\n     * @type {integer}\r\n     * @since 3.17.0\r\n     */\n\n    this.maskCount = 0;\n    /**\r\n     * The mask stack.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#maskStack\r\n     * @type {Phaser.Display.Masks.GeometryMask[]}\r\n     * @since 3.17.0\r\n     */\n\n    this.maskStack = [];\n    /**\r\n     * Internal property that tracks the currently set mask.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentMask\r\n     * @type {any}\r\n     * @since 3.17.0\r\n     */\n\n    this.currentMask = {\n      mask: null,\n      camera: null\n    };\n    /**\r\n     * Internal property that tracks the currently set camera mask.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentCameraMask\r\n     * @type {any}\r\n     * @since 3.17.0\r\n     */\n\n    this.currentCameraMask = {\n      mask: null,\n      camera: null\n    };\n    /**\r\n     * Internal gl function mapping for uniform look-up.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/uniform\r\n     * \r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#glFuncMap\r\n     * @type {any}\r\n     * @since 3.17.0\r\n     */\n\n    this.glFuncMap = null;\n    /**\r\n     * The `type` of the Game Object being currently rendered.\r\n     * This can be used by advanced render functions for batching look-ahead.\r\n     * \r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#currentType\r\n     * @type {string}\r\n     * @since 3.19.0\r\n     */\n\n    this.currentType = '';\n    /**\r\n     * Is the `type` of the Game Object being currently rendered different than the\r\n     * type of the object before it in the display list? I.e. it's a 'new' type.\r\n     * \r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#newType\r\n     * @type {boolean}\r\n     * @since 3.19.0\r\n     */\n\n    this.newType = false;\n    /**\r\n     * Does the `type` of the next Game Object in the display list match that\r\n     * of the object being currently rendered?\r\n     * \r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#nextTypeMatch\r\n     * @type {boolean}\r\n     * @since 3.19.0\r\n     */\n\n    this.nextTypeMatch = false;\n    /**\r\n     * The mipmap magFilter to be used when creating textures.\r\n     * \r\n     * You can specify this as a string in the game config, i.e.:\r\n     * \r\n     * `renderer: { mipmapFilter: 'NEAREST_MIPMAP_LINEAR' }`\r\n     * \r\n     * The 6 options for WebGL1 are, in order from least to most computationally expensive:\r\n     * \r\n     * NEAREST (for pixel art)\r\n     * LINEAR (the default)\r\n     * NEAREST_MIPMAP_NEAREST\r\n     * LINEAR_MIPMAP_NEAREST\r\n     * NEAREST_MIPMAP_LINEAR\r\n     * LINEAR_MIPMAP_LINEAR\r\n     * \r\n     * Mipmaps only work with textures that are fully power-of-two in size.\r\n     * \r\n     * For more details see https://webglfundamentals.org/webgl/lessons/webgl-3d-textures.html\r\n     * \r\n     * @name Phaser.Renderer.WebGL.WebGLRenderer#mipmapFilter\r\n     * @type {GLenum}\r\n     * @since 3.21.0\r\n     */\n\n    this.mipmapFilter = null;\n    this.init(this.config);\n  },\n\n  /**\r\n   * Creates a new WebGLRenderingContext and initializes all internal state.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#init\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} config - The configuration object for the renderer.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  init: function (config) {\n    var gl;\n    var game = this.game;\n    var canvas = this.canvas;\n    var clearColor = config.backgroundColor; //  Did they provide their own context?\n\n    if (game.config.context) {\n      gl = game.config.context;\n    } else {\n      gl = canvas.getContext('webgl', config.contextCreation) || canvas.getContext('experimental-webgl', config.contextCreation);\n    }\n\n    if (!gl || gl.isContextLost()) {\n      this.contextLost = true;\n      throw new Error('WebGL unsupported');\n    }\n\n    this.gl = gl;\n\n    var _this = this;\n\n    this.contextLostHandler = function (event) {\n      _this.contextLost = true;\n\n      _this.game.events.emit(GameEvents.CONTEXT_LOST, _this);\n\n      event.preventDefault();\n    };\n\n    this.contextRestoredHandler = function () {\n      _this.contextLost = false;\n\n      _this.init(_this.config);\n\n      _this.game.events.emit(GameEvents.CONTEXT_RESTORED, _this);\n    };\n\n    canvas.addEventListener('webglcontextlost', this.contextLostHandler, false);\n    canvas.addEventListener('webglcontextrestored', this.contextRestoredHandler, false); //  Set it back into the Game, so developers can access it from there too\n\n    game.context = gl;\n\n    for (var i = 0; i <= 27; i++) {\n      this.blendModes.push({\n        func: [gl.ONE, gl.ONE_MINUS_SRC_ALPHA],\n        equation: gl.FUNC_ADD\n      });\n    } //  ADD\n\n\n    this.blendModes[1].func = [gl.ONE, gl.DST_ALPHA]; //  MULTIPLY\n\n    this.blendModes[2].func = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA]; //  SCREEN\n\n    this.blendModes[3].func = [gl.ONE, gl.ONE_MINUS_SRC_COLOR]; //  ERASE\n\n    this.blendModes[17] = {\n      func: [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA],\n      equation: gl.FUNC_REVERSE_SUBTRACT\n    };\n    this.glFormats[0] = gl.BYTE;\n    this.glFormats[1] = gl.SHORT;\n    this.glFormats[2] = gl.UNSIGNED_BYTE;\n    this.glFormats[3] = gl.UNSIGNED_SHORT;\n    this.glFormats[4] = gl.FLOAT; //  Set the gl function map\n\n    this.glFuncMap = {\n      mat2: {\n        func: gl.uniformMatrix2fv,\n        length: 1,\n        matrix: true\n      },\n      mat3: {\n        func: gl.uniformMatrix3fv,\n        length: 1,\n        matrix: true\n      },\n      mat4: {\n        func: gl.uniformMatrix4fv,\n        length: 1,\n        matrix: true\n      },\n      '1f': {\n        func: gl.uniform1f,\n        length: 1\n      },\n      '1fv': {\n        func: gl.uniform1fv,\n        length: 1\n      },\n      '1i': {\n        func: gl.uniform1i,\n        length: 1\n      },\n      '1iv': {\n        func: gl.uniform1iv,\n        length: 1\n      },\n      '2f': {\n        func: gl.uniform2f,\n        length: 2\n      },\n      '2fv': {\n        func: gl.uniform2fv,\n        length: 1\n      },\n      '2i': {\n        func: gl.uniform2i,\n        length: 2\n      },\n      '2iv': {\n        func: gl.uniform2iv,\n        length: 1\n      },\n      '3f': {\n        func: gl.uniform3f,\n        length: 3\n      },\n      '3fv': {\n        func: gl.uniform3fv,\n        length: 1\n      },\n      '3i': {\n        func: gl.uniform3i,\n        length: 3\n      },\n      '3iv': {\n        func: gl.uniform3iv,\n        length: 1\n      },\n      '4f': {\n        func: gl.uniform4f,\n        length: 4\n      },\n      '4fv': {\n        func: gl.uniform4fv,\n        length: 1\n      },\n      '4i': {\n        func: gl.uniform4i,\n        length: 4\n      },\n      '4iv': {\n        func: gl.uniform4iv,\n        length: 1\n      }\n    }; // Load supported extensions\n\n    var exts = gl.getSupportedExtensions();\n\n    if (!config.maxTextures) {\n      config.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    }\n\n    if (!config.maxTextureSize) {\n      config.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    }\n\n    var extString = 'WEBGL_compressed_texture_';\n    var wkExtString = 'WEBKIT_' + extString;\n    this.compression.ETC1 = gl.getExtension(extString + 'etc1') || gl.getExtension(wkExtString + 'etc1');\n    this.compression.PVRTC = gl.getExtension(extString + 'pvrtc') || gl.getExtension(wkExtString + 'pvrtc');\n    this.compression.S3TC = gl.getExtension(extString + 's3tc') || gl.getExtension(wkExtString + 's3tc');\n    this.supportedExtensions = exts; //  Setup initial WebGL state\n\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.CULL_FACE);\n    gl.enable(gl.BLEND);\n    gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL); //  Mipmaps\n\n    this.mipmapFilter = gl[config.mipmapFilter]; // Initialize all textures to null\n\n    for (var index = 0; index < this.currentTextures.length; ++index) {\n      this.currentTextures[index] = null;\n    } // Clear previous pipelines and reload default ones\n\n\n    this.pipelines = {};\n    this.addPipeline('TextureTintPipeline', new TextureTintPipeline({\n      game: game,\n      renderer: this\n    }));\n    this.addPipeline('BitmapMaskPipeline', new BitmapMaskPipeline({\n      game: game,\n      renderer: this\n    }));\n    this.addPipeline('Light2D', new ForwardDiffuseLightPipeline({\n      game: game,\n      renderer: this,\n      maxLights: config.maxLights\n    }));\n    this.setBlendMode(CONST.BlendModes.NORMAL);\n    game.textures.once(TextureEvents.READY, this.boot, this);\n    return this;\n  },\n\n  /**\r\n   * Internal boot handler. Calls 'boot' on each pipeline.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#boot\r\n   * @private\r\n   * @since 3.11.0\r\n   */\n  boot: function () {\n    for (var pipelineName in this.pipelines) {\n      this.pipelines[pipelineName].boot();\n    }\n\n    var blank = this.game.textures.getFrame('__DEFAULT');\n    this.pipelines.TextureTintPipeline.currentFrame = blank;\n    this.blankTexture = blank;\n    var gl = this.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.enable(gl.SCISSOR_TEST);\n    this.setPipeline(this.pipelines.TextureTintPipeline);\n    this.game.scale.on(ScaleEvents.RESIZE, this.onResize, this);\n    var baseSize = this.game.scale.baseSize;\n    this.resize(baseSize.width, baseSize.height, this.game.scale.resolution);\n  },\n\n  /**\r\n   * The event handler that manages the `resize` event dispatched by the Scale Manager.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#onResize\r\n   * @since 3.16.0\r\n   *\r\n   * @param {Phaser.Structs.Size} gameSize - The default Game Size object. This is the un-modified game dimensions.\r\n   * @param {Phaser.Structs.Size} baseSize - The base Size object. The game dimensions multiplied by the resolution. The canvas width / height values match this.\r\n   * @param {Phaser.Structs.Size} displaySize - The display Size object. The size of the canvas style width / height attributes.\r\n   * @param {number} [resolution] - The Scale Manager resolution setting.\r\n   */\n  onResize: function (gameSize, baseSize, displaySize, resolution) {\n    //  Has the underlying canvas size changed?\n    if (baseSize.width !== this.width || baseSize.height !== this.height || resolution !== this.resolution) {\n      this.resize(baseSize.width, baseSize.height, resolution);\n    }\n  },\n\n  /**\r\n   * Resizes the drawing buffer to match that required by the Scale Manager.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#resize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [width] - The new width of the renderer.\r\n   * @param {number} [height] - The new height of the renderer.\r\n   * @param {number} [resolution] - The new resolution of the renderer.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  resize: function (width, height, resolution) {\n    var gl = this.gl;\n    var pipelines = this.pipelines;\n    this.width = width;\n    this.height = height;\n    this.resolution = resolution;\n    gl.viewport(0, 0, width, height); //  Update all registered pipelines\n\n    for (var pipelineName in pipelines) {\n      pipelines[pipelineName].resize(width, height, resolution);\n    }\n\n    this.drawingBufferHeight = gl.drawingBufferHeight;\n    gl.scissor(0, gl.drawingBufferHeight - height, width, height);\n    this.defaultCamera.setSize(width, height);\n    return this;\n  },\n\n  /**\r\n   * Checks if a WebGL extension is supported\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#hasExtension\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} extensionName - Name of the WebGL extension\r\n   *\r\n   * @return {boolean} `true` if the extension is supported, otherwise `false`.\r\n   */\n  hasExtension: function (extensionName) {\n    return this.supportedExtensions ? this.supportedExtensions.indexOf(extensionName) : false;\n  },\n\n  /**\r\n   * Loads a WebGL extension\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#getExtension\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} extensionName - The name of the extension to load.\r\n   *\r\n   * @return {object} WebGL extension if the extension is supported\r\n   */\n  getExtension: function (extensionName) {\n    if (!this.hasExtension(extensionName)) {\n      return null;\n    }\n\n    if (!(extensionName in this.extensions)) {\n      this.extensions[extensionName] = this.gl.getExtension(extensionName);\n    }\n\n    return this.extensions[extensionName];\n  },\n\n  /**\r\n   * Flushes the current pipeline if the pipeline is bound\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#flush\r\n   * @since 3.0.0\r\n   */\n  flush: function () {\n    if (this.currentPipeline) {\n      this.currentPipeline.flush();\n    }\n  },\n\n  /**\r\n   * Checks if a pipeline is present in the current WebGLRenderer\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#hasPipeline\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} pipelineName - The name of the pipeline.\r\n   *\r\n   * @return {boolean} `true` if the given pipeline is loaded, otherwise `false`.\r\n   */\n  hasPipeline: function (pipelineName) {\n    return pipelineName in this.pipelines;\n  },\n\n  /**\r\n   * Returns the pipeline by name if the pipeline exists\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#getPipeline\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} pipelineName - The name of the pipeline.\r\n   *\r\n   * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline instance, or `null` if not found.\r\n   */\n  getPipeline: function (pipelineName) {\n    return this.hasPipeline(pipelineName) ? this.pipelines[pipelineName] : null;\n  },\n\n  /**\r\n   * Removes a pipeline by name.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#removePipeline\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} pipelineName - The name of the pipeline to be removed.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  removePipeline: function (pipelineName) {\n    delete this.pipelines[pipelineName];\n    return this;\n  },\n\n  /**\r\n   * Adds a pipeline instance into the collection of pipelines\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#addPipeline\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} pipelineName - A unique string-based key for the pipeline.\r\n   * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - A pipeline instance which must extend WebGLPipeline.\r\n   *\r\n   * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline instance that was passed.\r\n   */\n  addPipeline: function (pipelineName, pipelineInstance) {\n    if (!this.hasPipeline(pipelineName)) {\n      this.pipelines[pipelineName] = pipelineInstance;\n    } else {\n      console.warn('Pipeline exists: ' + pipelineName);\n    }\n\n    pipelineInstance.name = pipelineName;\n    this.pipelines[pipelineName].resize(this.width, this.height, this.config.resolution);\n    return pipelineInstance;\n  },\n\n  /**\r\n   * Pushes a new scissor state. This is used to set nested scissor states.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#pushScissor\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} x - The x position of the scissor.\r\n   * @param {integer} y - The y position of the scissor.\r\n   * @param {integer} width - The width of the scissor.\r\n   * @param {integer} height - The height of the scissor.\r\n   * @param {integer} [drawingBufferHeight] - Optional drawingBufferHeight override value.\r\n   *\r\n   * @return {integer[]} An array containing the scissor values.\r\n   */\n  pushScissor: function (x, y, width, height, drawingBufferHeight) {\n    if (drawingBufferHeight === undefined) {\n      drawingBufferHeight = this.drawingBufferHeight;\n    }\n\n    var scissorStack = this.scissorStack;\n    var scissor = [x, y, width, height];\n    scissorStack.push(scissor);\n    this.setScissor(x, y, width, height, drawingBufferHeight);\n    this.currentScissor = scissor;\n    return scissor;\n  },\n\n  /**\r\n   * Sets the current scissor state.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setScissor\r\n   * @since 3.0.0\r\n   * \r\n   * @param {integer} x - The x position of the scissor.\r\n   * @param {integer} y - The y position of the scissor.\r\n   * @param {integer} width - The width of the scissor.\r\n   * @param {integer} height - The height of the scissor.\r\n   * @param {integer} [drawingBufferHeight] - Optional drawingBufferHeight override value.\r\n   */\n  setScissor: function (x, y, width, height, drawingBufferHeight) {\n    if (drawingBufferHeight === undefined) {\n      drawingBufferHeight = this.drawingBufferHeight;\n    }\n\n    var gl = this.gl;\n    var current = this.currentScissor;\n    var setScissor = width > 0 && height > 0;\n\n    if (current && setScissor) {\n      var cx = current[0];\n      var cy = current[1];\n      var cw = current[2];\n      var ch = current[3];\n      setScissor = cx !== x || cy !== y || cw !== width || ch !== height;\n    }\n\n    if (setScissor) {\n      this.flush(); // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/scissor\n\n      gl.scissor(x, drawingBufferHeight - y - height, width, height);\n    }\n  },\n\n  /**\r\n   * Pops the last scissor state and sets it.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#popScissor\r\n   * @since 3.0.0\r\n   */\n  popScissor: function () {\n    var scissorStack = this.scissorStack; //  Remove the current scissor\n\n    scissorStack.pop(); //  Reset the previous scissor\n\n    var scissor = scissorStack[scissorStack.length - 1];\n\n    if (scissor) {\n      this.setScissor(scissor[0], scissor[1], scissor[2], scissor[3]);\n    }\n\n    this.currentScissor = scissor;\n  },\n\n  /**\r\n   * Binds a WebGLPipeline and sets it as the current pipeline to be used.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setPipeline\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - The pipeline instance to be activated.\r\n   * @param {Phaser.GameObjects.GameObject} [gameObject] - The Game Object that invoked this pipeline, if any.\r\n   *\r\n   * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline that was activated.\r\n   */\n  setPipeline: function (pipelineInstance, gameObject) {\n    if (this.currentPipeline !== pipelineInstance || this.currentPipeline.vertexBuffer !== this.currentVertexBuffer || this.currentPipeline.program !== this.currentProgram) {\n      this.flush();\n      this.currentPipeline = pipelineInstance;\n      this.currentPipeline.bind();\n    }\n\n    this.currentPipeline.onBind(gameObject);\n    return this.currentPipeline;\n  },\n\n  /**\r\n   * Is there an active stencil mask?\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#hasActiveStencilMask\r\n   * @since 3.17.0\r\n   * \r\n   * @return {boolean} `true` if there is an active stencil mask, otherwise `false`.\r\n   */\n  hasActiveStencilMask: function () {\n    var mask = this.currentMask.mask;\n    var camMask = this.currentCameraMask.mask;\n    return mask && mask.isStencil || camMask && camMask.isStencil;\n  },\n\n  /**\r\n   * Use this to reset the gl context to the state that Phaser requires to continue rendering.\r\n   * Calling this will:\r\n   * \r\n   * * Disable `DEPTH_TEST`, `CULL_FACE` and `STENCIL_TEST`.\r\n   * * Clear the depth buffer and stencil buffers.\r\n   * * Reset the viewport size.\r\n   * * Reset the blend mode.\r\n   * * Bind a blank texture as the active texture on texture unit zero.\r\n   * * Rebinds the given pipeline instance.\r\n   * \r\n   * You should call this having previously called `clearPipeline` and then wishing to return\r\n   * control to Phaser again.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#rebindPipeline\r\n   * @since 3.16.0\r\n   * \r\n   * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - The pipeline instance to be activated.\r\n   */\n  rebindPipeline: function (pipelineInstance) {\n    var gl = this.gl;\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.CULL_FACE);\n\n    if (this.hasActiveStencilMask()) {\n      gl.clear(gl.DEPTH_BUFFER_BIT);\n    } else {\n      //  If there wasn't a stencil mask set before this call, we can disable it safely\n      gl.disable(gl.STENCIL_TEST);\n      gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n    }\n\n    gl.viewport(0, 0, this.width, this.height);\n    this.setBlendMode(0, true);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this.blankTexture.glTexture);\n    this.currentActiveTextureUnit = 0;\n    this.currentTextures[0] = this.blankTexture.glTexture;\n    this.currentPipeline = pipelineInstance;\n    this.currentPipeline.bind();\n    this.currentPipeline.onBind();\n  },\n\n  /**\r\n   * Flushes the current WebGLPipeline being used and then clears it, along with the\r\n   * the current shader program and vertex buffer. Then resets the blend mode to NORMAL.\r\n   * Call this before jumping to your own gl context handler, and then call `rebindPipeline` when\r\n   * you wish to return control to Phaser again.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#clearPipeline\r\n   * @since 3.16.0\r\n   */\n  clearPipeline: function () {\n    this.flush();\n    this.currentPipeline = null;\n    this.currentProgram = null;\n    this.currentVertexBuffer = null;\n    this.currentIndexBuffer = null;\n    this.setBlendMode(0, true);\n  },\n\n  /**\r\n   * Sets the blend mode to the value given.\r\n   *\r\n   * If the current blend mode is different from the one given, the pipeline is flushed and the new\r\n   * blend mode is enabled.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setBlendMode\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} blendModeId - The blend mode to be set. Can be a `BlendModes` const or an integer value.\r\n   * @param {boolean} [force=false] - Force the blend mode to be set, regardless of the currently set blend mode.\r\n   *\r\n   * @return {boolean} `true` if the blend mode was changed as a result of this call, forcing a flush, otherwise `false`.\r\n   */\n  setBlendMode: function (blendModeId, force) {\n    if (force === undefined) {\n      force = false;\n    }\n\n    var gl = this.gl;\n    var blendMode = this.blendModes[blendModeId];\n\n    if (force || blendModeId !== CONST.BlendModes.SKIP_CHECK && this.currentBlendMode !== blendModeId) {\n      this.flush();\n      gl.enable(gl.BLEND);\n      gl.blendEquation(blendMode.equation);\n\n      if (blendMode.func.length > 2) {\n        gl.blendFuncSeparate(blendMode.func[0], blendMode.func[1], blendMode.func[2], blendMode.func[3]);\n      } else {\n        gl.blendFunc(blendMode.func[0], blendMode.func[1]);\n      }\n\n      this.currentBlendMode = blendModeId;\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Creates a new custom blend mode for the renderer.\r\n   * \r\n   * See https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants#Blending_modes\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#addBlendMode\r\n   * @since 3.0.0\r\n   *\r\n   * @param {GLenum[]} func - An array containing the WebGL functions to use for the source and the destination blending factors, respectively. See the possible constants for {@link WebGLRenderingContext#blendFunc()}.\r\n   * @param {GLenum} equation - The equation to use for combining the RGB and alpha components of a new pixel with a rendered one. See the possible constants for {@link WebGLRenderingContext#blendEquation()}.\r\n   *\r\n   * @return {integer} The index of the new blend mode, used for referencing it in the future.\r\n   */\n  addBlendMode: function (func, equation) {\n    var index = this.blendModes.push({\n      func: func,\n      equation: equation\n    });\n    return index - 1;\n  },\n\n  /**\r\n   * Updates the function bound to a given custom blend mode.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#updateBlendMode\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} index - The index of the custom blend mode.\r\n   * @param {function} func - The function to use for the blend mode.\r\n   * @param {function} equation - The equation to use for the blend mode.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  updateBlendMode: function (index, func, equation) {\n    if (this.blendModes[index]) {\n      this.blendModes[index].func = func;\n\n      if (equation) {\n        this.blendModes[index].equation = equation;\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes a custom blend mode from the renderer.\r\n   * Any Game Objects still using this blend mode will error, so be sure to clear them first.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#removeBlendMode\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} index - The index of the custom blend mode to be removed.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  removeBlendMode: function (index) {\n    if (index > 17 && this.blendModes[index]) {\n      this.blendModes.splice(index, 1);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the current active texture for texture unit zero to be a blank texture.\r\n   * This only happens if there isn't a texture already in use by texture unit zero.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setBlankTexture\r\n   * @private\r\n   * @since 3.12.0\r\n   *\r\n   * @param {boolean} [force=false] - Force a blank texture set, regardless of what's already bound?\r\n   */\n  setBlankTexture: function (force) {\n    if (force === undefined) {\n      force = false;\n    }\n\n    if (force || this.currentActiveTextureUnit !== 0 || !this.currentTextures[0]) {\n      this.setTexture2D(this.blankTexture.glTexture, 0);\n    }\n  },\n\n  /**\r\n   * Binds a texture at a texture unit. If a texture is already\r\n   * bound to that unit it will force a flush on the current pipeline.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setTexture2D\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLTexture} texture - The WebGL texture that needs to be bound.\r\n   * @param {integer} textureUnit - The texture unit to which the texture will be bound.\r\n   * @param {boolean} [flush=true] - Will the current pipeline be flushed if this is a new texture, or not?\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  setTexture2D: function (texture, textureUnit, flush) {\n    if (flush === undefined) {\n      flush = true;\n    }\n\n    var gl = this.gl;\n\n    if (texture !== this.currentTextures[textureUnit]) {\n      if (flush) {\n        this.flush();\n      }\n\n      if (this.currentActiveTextureUnit !== textureUnit) {\n        gl.activeTexture(gl.TEXTURE0 + textureUnit);\n        this.currentActiveTextureUnit = textureUnit;\n      }\n\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      this.currentTextures[textureUnit] = texture;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Binds a framebuffer. If there was another framebuffer already bound it will force a pipeline flush.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFramebuffer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLFramebuffer} framebuffer - The framebuffer that needs to be bound.\r\n   * @param {boolean} [updateScissor=false] - If a framebuffer is given, set the gl scissor to match the frame buffer size? Or, if `null` given, pop the scissor from the stack.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  setFramebuffer: function (framebuffer, updateScissor) {\n    if (updateScissor === undefined) {\n      updateScissor = false;\n    }\n\n    var gl = this.gl;\n    var width = this.width;\n    var height = this.height;\n\n    if (framebuffer !== this.currentFramebuffer) {\n      if (framebuffer && framebuffer.renderTexture) {\n        width = framebuffer.renderTexture.width;\n        height = framebuffer.renderTexture.height;\n      } else {\n        this.flush();\n      }\n\n      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n      gl.viewport(0, 0, width, height);\n\n      if (updateScissor) {\n        if (framebuffer) {\n          this.drawingBufferHeight = height;\n          this.pushScissor(0, 0, width, height);\n        } else {\n          this.drawingBufferHeight = this.height;\n          this.popScissor();\n        }\n      }\n\n      this.currentFramebuffer = framebuffer;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Binds a program. If there was another program already bound it will force a pipeline flush.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setProgram\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The program that needs to be bound.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  setProgram: function (program) {\n    var gl = this.gl;\n\n    if (program !== this.currentProgram) {\n      this.flush();\n      gl.useProgram(program);\n      this.currentProgram = program;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Bounds a vertex buffer. If there is a vertex buffer already bound it'll force a pipeline flush.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setVertexBuffer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLBuffer} vertexBuffer - The buffer that needs to be bound.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  setVertexBuffer: function (vertexBuffer) {\n    var gl = this.gl;\n\n    if (vertexBuffer !== this.currentVertexBuffer) {\n      this.flush();\n      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n      this.currentVertexBuffer = vertexBuffer;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Bounds a index buffer. If there is a index buffer already bound it'll force a pipeline flush.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setIndexBuffer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLBuffer} indexBuffer - The buffer the needs to be bound.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  setIndexBuffer: function (indexBuffer) {\n    var gl = this.gl;\n\n    if (indexBuffer !== this.currentIndexBuffer) {\n      this.flush();\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\n      this.currentIndexBuffer = indexBuffer;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Creates a texture from an image source. If the source is not valid it creates an empty texture.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#createTextureFromSource\r\n   * @since 3.0.0\r\n   *\r\n   * @param {object} source - The source of the texture.\r\n   * @param {integer} width - The width of the texture.\r\n   * @param {integer} height - The height of the texture.\r\n   * @param {integer} scaleMode - The scale mode to be used by the texture.\r\n   *\r\n   * @return {?WebGLTexture} The WebGL Texture that was created, or `null` if it couldn't be created.\r\n   */\n  createTextureFromSource: function (source, width, height, scaleMode) {\n    var gl = this.gl;\n    var minFilter = gl.NEAREST;\n    var magFilter = gl.NEAREST;\n    var wrap = gl.CLAMP_TO_EDGE;\n    var texture = null;\n    width = source ? source.width : width;\n    height = source ? source.height : height;\n    var pow = IsSizePowerOfTwo(width, height);\n\n    if (pow) {\n      wrap = gl.REPEAT;\n    }\n\n    if (scaleMode === CONST.ScaleModes.LINEAR && this.config.antialias) {\n      minFilter = pow ? this.mipmapFilter : gl.LINEAR;\n      magFilter = gl.LINEAR;\n    }\n\n    if (!source && typeof width === 'number' && typeof height === 'number') {\n      texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, null, width, height);\n    } else {\n      texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, source);\n    }\n\n    return texture;\n  },\n\n  /**\r\n   * A wrapper for creating a WebGLTexture. If no pixel data is passed it will create an empty texture.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#createTexture2D\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} mipLevel - Mip level of the texture.\r\n   * @param {integer} minFilter - Filtering of the texture.\r\n   * @param {integer} magFilter - Filtering of the texture.\r\n   * @param {integer} wrapT - Wrapping mode of the texture.\r\n   * @param {integer} wrapS - Wrapping mode of the texture.\r\n   * @param {integer} format - Which format does the texture use.\r\n   * @param {?object} pixels - pixel data.\r\n   * @param {integer} width - Width of the texture in pixels.\r\n   * @param {integer} height - Height of the texture in pixels.\r\n   * @param {boolean} [pma=true] - Does the texture have premultiplied alpha?\r\n   * @param {boolean} [forceSize=false] - If `true` it will use the width and height passed to this method, regardless of the pixels dimension.\r\n   * @param {boolean} [flipY=false] - Sets the `UNPACK_FLIP_Y_WEBGL` flag the WebGL Texture uses during upload.\r\n   *\r\n   * @return {WebGLTexture} The WebGLTexture that was created.\r\n   */\n  createTexture2D: function (mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height, pma, forceSize, flipY) {\n    pma = pma === undefined || pma === null ? true : pma;\n\n    if (forceSize === undefined) {\n      forceSize = false;\n    }\n\n    if (flipY === undefined) {\n      flipY = false;\n    }\n\n    var gl = this.gl;\n    var texture = gl.createTexture();\n    this.setTexture2D(texture, 0);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, pma);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n\n    if (pixels === null || pixels === undefined) {\n      gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, width, height, 0, format, gl.UNSIGNED_BYTE, null);\n    } else {\n      if (!forceSize) {\n        width = pixels.width;\n        height = pixels.height;\n      }\n\n      gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, format, gl.UNSIGNED_BYTE, pixels);\n    }\n\n    if (IsSizePowerOfTwo(width, height)) {\n      gl.generateMipmap(gl.TEXTURE_2D);\n    }\n\n    this.setTexture2D(null, 0);\n    texture.isAlphaPremultiplied = pma;\n    texture.isRenderTexture = false;\n    texture.width = width;\n    texture.height = height;\n    this.nativeTextures.push(texture);\n    return texture;\n  },\n\n  /**\r\n   * Wrapper for creating WebGLFramebuffer.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#createFramebuffer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} width - Width in pixels of the framebuffer\r\n   * @param {integer} height - Height in pixels of the framebuffer\r\n   * @param {WebGLTexture} renderTexture - The color texture to where the color pixels are written\r\n   * @param {boolean} addDepthStencilBuffer - Indicates if the current framebuffer support depth and stencil buffers\r\n   *\r\n   * @return {WebGLFramebuffer} Raw WebGLFramebuffer\r\n   */\n  createFramebuffer: function (width, height, renderTexture, addDepthStencilBuffer) {\n    var gl = this.gl;\n    var framebuffer = gl.createFramebuffer();\n    var complete = 0;\n    this.setFramebuffer(framebuffer);\n\n    if (addDepthStencilBuffer) {\n      var depthStencilBuffer = gl.createRenderbuffer();\n      gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);\n      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilBuffer);\n    }\n\n    renderTexture.isRenderTexture = true;\n    renderTexture.isAlphaPremultiplied = false;\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);\n    complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\n    if (complete !== gl.FRAMEBUFFER_COMPLETE) {\n      var errors = {\n        36054: 'Incomplete Attachment',\n        36055: 'Missing Attachment',\n        36057: 'Incomplete Dimensions',\n        36061: 'Framebuffer Unsupported'\n      };\n      throw new Error('Framebuffer incomplete. Framebuffer status: ' + errors[complete]);\n    }\n\n    framebuffer.renderTexture = renderTexture;\n    this.setFramebuffer(null);\n    return framebuffer;\n  },\n\n  /**\r\n   * Wrapper for creating a WebGLProgram\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#createProgram\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} vertexShader - Source to the vertex shader\r\n   * @param {string} fragmentShader - Source to the fragment shader\r\n   *\r\n   * @return {WebGLProgram} Raw WebGLProgram\r\n   */\n  createProgram: function (vertexShader, fragmentShader) {\n    var gl = this.gl;\n    var program = gl.createProgram();\n    var vs = gl.createShader(gl.VERTEX_SHADER);\n    var fs = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(vs, vertexShader);\n    gl.shaderSource(fs, fragmentShader);\n    gl.compileShader(vs);\n    gl.compileShader(fs);\n\n    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n      throw new Error('Failed to compile Vertex Shader:\\n' + gl.getShaderInfoLog(vs));\n    }\n\n    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n      throw new Error('Failed to compile Fragment Shader:\\n' + gl.getShaderInfoLog(fs));\n    }\n\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      throw new Error('Failed to link program:\\n' + gl.getProgramInfoLog(program));\n    }\n\n    return program;\n  },\n\n  /**\r\n   * Wrapper for creating a vertex buffer.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#createVertexBuffer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {ArrayBuffer} initialDataOrSize - It's either ArrayBuffer or an integer indicating the size of the vbo\r\n   * @param {integer} bufferUsage - How the buffer is used. gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW\r\n   *\r\n   * @return {WebGLBuffer} Raw vertex buffer\r\n   */\n  createVertexBuffer: function (initialDataOrSize, bufferUsage) {\n    var gl = this.gl;\n    var vertexBuffer = gl.createBuffer();\n    this.setVertexBuffer(vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, initialDataOrSize, bufferUsage);\n    this.setVertexBuffer(null);\n    return vertexBuffer;\n  },\n\n  /**\r\n   * Wrapper for creating a vertex buffer.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#createIndexBuffer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {ArrayBuffer} initialDataOrSize - Either ArrayBuffer or an integer indicating the size of the vbo.\r\n   * @param {integer} bufferUsage - How the buffer is used. gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW.\r\n   *\r\n   * @return {WebGLBuffer} Raw index buffer\r\n   */\n  createIndexBuffer: function (initialDataOrSize, bufferUsage) {\n    var gl = this.gl;\n    var indexBuffer = gl.createBuffer();\n    this.setIndexBuffer(indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, initialDataOrSize, bufferUsage);\n    this.setIndexBuffer(null);\n    return indexBuffer;\n  },\n\n  /**\r\n   * Removes the given texture from the nativeTextures array and then deletes it from the GPU.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteTexture\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLTexture} texture - The WebGL Texture to be deleted.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  deleteTexture: function (texture) {\n    var index = this.nativeTextures.indexOf(texture);\n\n    if (index !== -1) {\n      SpliceOne(this.nativeTextures, index);\n    }\n\n    this.gl.deleteTexture(texture);\n\n    if (this.currentTextures[0] === texture && !this.game.pendingDestroy) {\n      //  texture we just deleted is in use, so bind a blank texture\n      this.setBlankTexture(true);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Deletes a WebGLFramebuffer from the GL instance.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteFramebuffer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLFramebuffer} framebuffer - The Framebuffer to be deleted.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  deleteFramebuffer: function (framebuffer) {\n    this.gl.deleteFramebuffer(framebuffer);\n    return this;\n  },\n\n  /**\r\n   * Deletes a WebGLProgram from the GL instance.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteProgram\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The shader program to be deleted.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  deleteProgram: function (program) {\n    this.gl.deleteProgram(program);\n    return this;\n  },\n\n  /**\r\n   * Deletes a WebGLBuffer from the GL instance.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteBuffer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLBuffer} vertexBuffer - The WebGLBuffer to be deleted.\r\n   *\r\n   * @return {this} This WebGLRenderer instance.\r\n   */\n  deleteBuffer: function (buffer) {\n    this.gl.deleteBuffer(buffer);\n    return this;\n  },\n\n  /**\r\n   * Controls the pre-render operations for the given camera.\r\n   * Handles any clipping needed by the camera and renders the background color if a color is visible.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#preRenderCamera\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to pre-render.\r\n   */\n  preRenderCamera: function (camera) {\n    var cx = camera._cx;\n    var cy = camera._cy;\n    var cw = camera._cw;\n    var ch = camera._ch;\n    var TextureTintPipeline = this.pipelines.TextureTintPipeline;\n    var color = camera.backgroundColor;\n\n    if (camera.renderToTexture) {\n      this.flush();\n      this.pushScissor(cx, cy, cw, -ch);\n      this.setFramebuffer(camera.framebuffer);\n      var gl = this.gl;\n      gl.clearColor(0, 0, 0, 0);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      TextureTintPipeline.projOrtho(cx, cw + cx, cy, ch + cy, -1000, 1000);\n\n      if (camera.mask) {\n        this.currentCameraMask.mask = camera.mask;\n        this.currentCameraMask.camera = camera._maskCamera;\n        camera.mask.preRenderWebGL(this, camera, camera._maskCamera);\n      }\n\n      if (color.alphaGL > 0) {\n        TextureTintPipeline.drawFillRect(cx, cy, cw + cx, ch + cy, Utils.getTintFromFloats(color.redGL, color.greenGL, color.blueGL, 1), color.alphaGL);\n      }\n\n      camera.emit(CameraEvents.PRE_RENDER, camera);\n    } else {\n      this.pushScissor(cx, cy, cw, ch);\n\n      if (camera.mask) {\n        this.currentCameraMask.mask = camera.mask;\n        this.currentCameraMask.camera = camera._maskCamera;\n        camera.mask.preRenderWebGL(this, camera, camera._maskCamera);\n      }\n\n      if (color.alphaGL > 0) {\n        TextureTintPipeline.drawFillRect(cx, cy, cw, ch, Utils.getTintFromFloats(color.redGL, color.greenGL, color.blueGL, 1), color.alphaGL);\n      }\n    }\n  },\n  getCurrentStencilMask: function () {\n    var prev = null;\n    var stack = this.maskStack;\n    var cameraMask = this.currentCameraMask;\n\n    if (stack.length > 0) {\n      prev = stack[stack.length - 1];\n    } else if (cameraMask.mask && cameraMask.mask.isStencil) {\n      prev = cameraMask;\n    }\n\n    return prev;\n  },\n\n  /**\r\n   * Controls the post-render operations for the given camera.\r\n   * Renders the foreground camera effects like flash and fading. It resets the current scissor state.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#postRenderCamera\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to post-render.\r\n   */\n  postRenderCamera: function (camera) {\n    var TextureTintPipeline = this.pipelines.TextureTintPipeline;\n    camera.flashEffect.postRenderWebGL(TextureTintPipeline, Utils.getTintFromFloats);\n    camera.fadeEffect.postRenderWebGL(TextureTintPipeline, Utils.getTintFromFloats);\n    camera.dirty = false;\n    this.popScissor();\n\n    if (camera.renderToTexture) {\n      TextureTintPipeline.flush();\n      this.setFramebuffer(null);\n      camera.emit(CameraEvents.POST_RENDER, camera);\n      TextureTintPipeline.projOrtho(0, TextureTintPipeline.width, TextureTintPipeline.height, 0, -1000.0, 1000.0);\n      var getTint = Utils.getTintAppendFloatAlpha;\n      var pipeline = camera.pipeline ? camera.pipeline : TextureTintPipeline;\n      pipeline.batchTexture(camera, camera.glTexture, camera.width, camera.height, camera.x, camera.y, camera.width, camera.height, camera.zoom, camera.zoom, camera.rotation, camera.flipX, !camera.flipY, 1, 1, 0, 0, 0, 0, camera.width, camera.height, getTint(camera._tintTL, camera._alphaTL), getTint(camera._tintTR, camera._alphaTR), getTint(camera._tintBL, camera._alphaBL), getTint(camera._tintBR, camera._alphaBR), camera._isTinted && camera.tintFill, 0, 0, this.defaultCamera, null); //  Force clear the current texture so that items next in the batch (like Graphics) don't try and use it\n\n      this.setBlankTexture(true);\n    }\n\n    if (camera.mask) {\n      this.currentCameraMask.mask = null;\n      camera.mask.postRenderWebGL(this, camera._maskCamera);\n    }\n  },\n\n  /**\r\n   * Clears the current vertex buffer and updates pipelines.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#preRender\r\n   * @since 3.0.0\r\n   */\n  preRender: function () {\n    if (this.contextLost) {\n      return;\n    }\n\n    var gl = this.gl;\n    var pipelines = this.pipelines; //  Make sure we are bound to the main frame buffer\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n    if (this.config.clearBeforeRender) {\n      var clearColor = this.config.backgroundColor;\n      gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n    }\n\n    gl.enable(gl.SCISSOR_TEST);\n\n    for (var key in pipelines) {\n      pipelines[key].onPreRender();\n    } //  TODO - Find a way to stop needing to create these arrays every frame\n    //  and equally not need a huge array buffer created to hold them\n\n\n    this.currentScissor = [0, 0, this.width, this.height];\n    this.scissorStack = [this.currentScissor];\n\n    if (this.game.scene.customViewports) {\n      gl.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height);\n    }\n\n    this.currentMask.mask = null;\n    this.currentCameraMask.mask = null;\n    this.maskStack.length = 0;\n    this.setPipeline(this.pipelines.TextureTintPipeline);\n  },\n\n  /**\r\n   * The core render step for a Scene Camera.\r\n   * \r\n   * Iterates through the given Game Object's array and renders them with the given Camera.\r\n   * \r\n   * This is called by the `CameraManager.render` method. The Camera Manager instance belongs to a Scene, and is invoked\r\n   * by the Scene Systems.render method.\r\n   * \r\n   * This method is not called if `Camera.visible` is `false`, or `Camera.alpha` is zero.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#render\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Scene} scene - The Scene to render.\r\n   * @param {Phaser.GameObjects.GameObject} children - The Game Object's within the Scene to be rendered.\r\n   * @param {number} interpolationPercentage - The interpolation percentage to apply. Currently un-used.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera to render with.\r\n   */\n  render: function (scene, children, interpolationPercentage, camera) {\n    if (this.contextLost) {\n      return;\n    }\n\n    var list = children.list;\n    var childCount = list.length;\n    var pipelines = this.pipelines;\n\n    for (var key in pipelines) {\n      pipelines[key].onRender(scene, camera);\n    } //   Apply scissor for cam region + render background color, if not transparent\n\n\n    this.preRenderCamera(camera); //  Nothing to render, so bail out\n\n    if (childCount === 0) {\n      this.setBlendMode(CONST.BlendModes.NORMAL); //  Applies camera effects and pops the scissor, if set\n\n      this.postRenderCamera(camera);\n      return;\n    } //  Reset the current type\n\n\n    this.currentType = '';\n    var current = this.currentMask;\n\n    for (var i = 0; i < childCount; i++) {\n      var child = list[i];\n\n      if (!child.willRender(camera)) {\n        continue;\n      }\n\n      if (child.blendMode !== this.currentBlendMode) {\n        this.setBlendMode(child.blendMode);\n      }\n\n      var mask = child.mask;\n      current = this.currentMask;\n\n      if (current.mask && current.mask !== mask) {\n        //  Render out the previously set mask\n        current.mask.postRenderWebGL(this, current.camera);\n      }\n\n      if (mask && current.mask !== mask) {\n        mask.preRenderWebGL(this, child, camera);\n      }\n\n      var type = child.type;\n\n      if (type !== this.currentType) {\n        this.newType = true;\n        this.currentType = type;\n      }\n\n      this.nextTypeMatch = i < childCount - 1 ? list[i + 1].type === this.currentType : false;\n      child.renderWebGL(this, child, interpolationPercentage, camera);\n      this.newType = false;\n    }\n\n    current = this.currentMask;\n\n    if (current.mask) {\n      //  Render out the previously set mask, if it was the last item in the display list\n      current.mask.postRenderWebGL(this, current.camera);\n    }\n\n    this.setBlendMode(CONST.BlendModes.NORMAL); //  Applies camera effects and pops the scissor, if set\n\n    this.postRenderCamera(camera);\n  },\n\n  /**\r\n   * The post-render step happens after all Cameras in all Scenes have been rendered.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#postRender\r\n   * @since 3.0.0\r\n   */\n  postRender: function () {\n    if (this.contextLost) {\n      return;\n    }\n\n    this.flush(); // Unbind custom framebuffer here\n\n    var state = this.snapshotState;\n\n    if (state.callback) {\n      WebGLSnapshot(this.canvas, state);\n      state.callback = null;\n    }\n\n    var pipelines = this.pipelines;\n\n    for (var key in pipelines) {\n      pipelines[key].onPostRender();\n    }\n  },\n\n  /**\r\n   * Schedules a snapshot of the entire game viewport to be taken after the current frame is rendered.\r\n   * \r\n   * To capture a specific area see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.\r\n   * \r\n   * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n   * calling this method will override it.\r\n   * \r\n   * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n   * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n   * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n   * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshot\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n   * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n   * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n   *\r\n   * @return {this} This WebGL Renderer.\r\n   */\n  snapshot: function (callback, type, encoderOptions) {\n    return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, callback, type, encoderOptions);\n  },\n\n  /**\r\n   * Schedules a snapshot of the given area of the game viewport to be taken after the current frame is rendered.\r\n   * \r\n   * To capture the whole game viewport see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.\r\n   * \r\n   * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n   * calling this method will override it.\r\n   * \r\n   * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n   * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n   * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n   * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshotArea\r\n   * @since 3.16.0\r\n   *\r\n   * @param {integer} x - The x coordinate to grab from.\r\n   * @param {integer} y - The y coordinate to grab from.\r\n   * @param {integer} width - The width of the area to grab.\r\n   * @param {integer} height - The height of the area to grab.\r\n   * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n   * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n   * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n   *\r\n   * @return {this} This WebGL Renderer.\r\n   */\n  snapshotArea: function (x, y, width, height, callback, type, encoderOptions) {\n    var state = this.snapshotState;\n    state.callback = callback;\n    state.type = type;\n    state.encoder = encoderOptions;\n    state.getPixel = false;\n    state.x = x;\n    state.y = y;\n    state.width = Math.min(width, this.gl.drawingBufferWidth);\n    state.height = Math.min(height, this.gl.drawingBufferHeight);\n    return this;\n  },\n\n  /**\r\n   * Schedules a snapshot of the given pixel from the game viewport to be taken after the current frame is rendered.\r\n   * \r\n   * To capture the whole game viewport see the `snapshot` method. To capture a specific area, see `snapshotArea`.\r\n   * \r\n   * Only one snapshot can be active _per frame_. If you have already called `snapshotArea`, for example, then\r\n   * calling this method will override it.\r\n   * \r\n   * Unlike the other two snapshot methods, this one will return a `Color` object containing the color data for\r\n   * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,\r\n   * using less memory.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshotPixel\r\n   * @since 3.16.0\r\n   *\r\n   * @param {integer} x - The x coordinate of the pixel to get.\r\n   * @param {integer} y - The y coordinate of the pixel to get.\r\n   * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.\r\n   *\r\n   * @return {this} This WebGL Renderer.\r\n   */\n  snapshotPixel: function (x, y, callback) {\n    this.snapshotArea(x, y, 1, 1, callback);\n    this.snapshotState.getPixel = true;\n    return this;\n  },\n\n  /**\r\n   * Takes a snapshot of the given area of the given frame buffer.\r\n   * \r\n   * Unlike the other snapshot methods, this one is processed immediately and doesn't wait for the next render.\r\n   * \r\n   * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n   * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n   * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n   * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshotFramebuffer\r\n   * @since 3.19.0\r\n   *\r\n   * @param {WebGLFramebuffer} framebuffer - The framebuffer to grab from.\r\n   * @param {integer} bufferWidth - The width of the framebuffer.\r\n   * @param {integer} bufferHeight - The height of the framebuffer.\r\n   * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n   * @param {boolean} [getPixel=false] - Grab a single pixel as a Color object, or an area as an Image object?\r\n   * @param {integer} [x=0] - The x coordinate to grab from.\r\n   * @param {integer} [y=0] - The y coordinate to grab from.\r\n   * @param {integer} [width=bufferWidth] - The width of the area to grab.\r\n   * @param {integer} [height=bufferHeight] - The height of the area to grab.\r\n   * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n   * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n   *\r\n   * @return {this} This WebGL Renderer.\r\n   */\n  snapshotFramebuffer: function (framebuffer, bufferWidth, bufferHeight, callback, getPixel, x, y, width, height, type, encoderOptions) {\n    if (getPixel === undefined) {\n      getPixel = false;\n    }\n\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = bufferWidth;\n    }\n\n    if (height === undefined) {\n      height = bufferHeight;\n    }\n\n    var currentFramebuffer = this.currentFramebuffer;\n    this.snapshotArea(x, y, width, height, callback, type, encoderOptions);\n    var state = this.snapshotState;\n    state.getPixel = getPixel;\n    state.isFramebuffer = true;\n    state.bufferWidth = bufferWidth;\n    state.bufferHeight = bufferHeight;\n    this.setFramebuffer(framebuffer);\n    WebGLSnapshot(this.canvas, state);\n    this.setFramebuffer(currentFramebuffer);\n    state.callback = null;\n    state.isFramebuffer = false;\n    return this;\n  },\n\n  /**\r\n   * Creates a new WebGL Texture based on the given Canvas Element.\r\n   * \r\n   * If the `dstTexture` parameter is given, the WebGL Texture is updated, rather than created fresh.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#canvasToTexture\r\n   * @since 3.0.0\r\n   * \r\n   * @param {HTMLCanvasElement} srcCanvas - The Canvas to create the WebGL Texture from\r\n   * @param {WebGLTexture} [dstTexture] - The destination WebGL Texture to set.\r\n   * @param {boolean} [noRepeat=false] - Should this canvas be allowed to set `REPEAT` (such as for Text objects?)\r\n   * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?\r\n   * \r\n   * @return {WebGLTexture} The newly created, or updated, WebGL Texture.\r\n   */\n  canvasToTexture: function (srcCanvas, dstTexture, noRepeat, flipY) {\n    if (noRepeat === undefined) {\n      noRepeat = false;\n    }\n\n    if (flipY === undefined) {\n      flipY = false;\n    }\n\n    if (!dstTexture) {\n      return this.createCanvasTexture(srcCanvas, noRepeat, flipY);\n    } else {\n      return this.updateCanvasTexture(srcCanvas, dstTexture, flipY);\n    }\n  },\n\n  /**\r\n   * Creates a new WebGL Texture based on the given Canvas Element.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#createCanvasTexture\r\n   * @since 3.20.0\r\n   * \r\n   * @param {HTMLCanvasElement} srcCanvas - The Canvas to create the WebGL Texture from\r\n   * @param {boolean} [noRepeat=false] - Should this canvas be allowed to set `REPEAT` (such as for Text objects?)\r\n   * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?\r\n   * \r\n   * @return {WebGLTexture} The newly created WebGL Texture.\r\n   */\n  createCanvasTexture: function (srcCanvas, noRepeat, flipY) {\n    if (noRepeat === undefined) {\n      noRepeat = false;\n    }\n\n    if (flipY === undefined) {\n      flipY = false;\n    }\n\n    var gl = this.gl;\n    var minFilter = gl.NEAREST;\n    var magFilter = gl.NEAREST;\n    var width = srcCanvas.width;\n    var height = srcCanvas.height;\n    var wrapping = gl.CLAMP_TO_EDGE;\n    var pow = IsSizePowerOfTwo(width, height);\n\n    if (!noRepeat && pow) {\n      wrapping = gl.REPEAT;\n    }\n\n    if (this.config.antialias) {\n      minFilter = pow ? this.mipmapFilter : gl.LINEAR;\n      magFilter = gl.LINEAR;\n    }\n\n    return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcCanvas, width, height, true, false, flipY);\n  },\n\n  /**\r\n   * Updates a WebGL Texture based on the given Canvas Element.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#updateCanvasTexture\r\n   * @since 3.20.0\r\n   * \r\n   * @param {HTMLCanvasElement} srcCanvas - The Canvas to update the WebGL Texture from.\r\n   * @param {WebGLTexture} dstTexture - The destination WebGL Texture to update.\r\n   * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?\r\n   * \r\n   * @return {WebGLTexture} The updated WebGL Texture.\r\n   */\n  updateCanvasTexture: function (srcCanvas, dstTexture, flipY) {\n    if (flipY === undefined) {\n      flipY = false;\n    }\n\n    var gl = this.gl;\n    var width = srcCanvas.width;\n    var height = srcCanvas.height;\n\n    if (width > 0 && height > 0) {\n      this.setTexture2D(dstTexture, 0);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);\n      dstTexture.width = width;\n      dstTexture.height = height;\n      this.setTexture2D(null, 0);\n    }\n\n    return dstTexture;\n  },\n\n  /**\r\n   * Creates a new WebGL Texture based on the given HTML Video Element.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#createVideoTexture\r\n   * @since 3.20.0\r\n   * \r\n   * @param {HTMLVideoElement} srcVideo - The Video to create the WebGL Texture from\r\n   * @param {boolean} [noRepeat=false] - Should this canvas be allowed to set `REPEAT`?\r\n   * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?\r\n   * \r\n   * @return {WebGLTexture} The newly created WebGL Texture.\r\n   */\n  createVideoTexture: function (srcVideo, noRepeat, flipY) {\n    if (noRepeat === undefined) {\n      noRepeat = false;\n    }\n\n    if (flipY === undefined) {\n      flipY = false;\n    }\n\n    var gl = this.gl;\n    var minFilter = gl.NEAREST;\n    var magFilter = gl.NEAREST;\n    var width = srcVideo.videoWidth;\n    var height = srcVideo.videoHeight;\n    var wrapping = gl.CLAMP_TO_EDGE;\n    var pow = IsSizePowerOfTwo(width, height);\n\n    if (!noRepeat && pow) {\n      wrapping = gl.REPEAT;\n    }\n\n    if (this.config.antialias) {\n      minFilter = pow ? this.mipmapFilter : gl.LINEAR;\n      magFilter = gl.LINEAR;\n    }\n\n    return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcVideo, width, height, true, true, flipY);\n  },\n\n  /**\r\n   * Updates a WebGL Texture based on the given HTML Video Element.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#updateVideoTexture\r\n   * @since 3.20.0\r\n   * \r\n   * @param {HTMLVideoElement} srcVideo - The Video to update the WebGL Texture with.\r\n   * @param {WebGLTexture} dstTexture - The destination WebGL Texture to update.\r\n   * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?\r\n   * \r\n   * @return {WebGLTexture} The updated WebGL Texture.\r\n   */\n  updateVideoTexture: function (srcVideo, dstTexture, flipY) {\n    if (flipY === undefined) {\n      flipY = false;\n    }\n\n    var gl = this.gl;\n    var width = srcVideo.videoWidth;\n    var height = srcVideo.videoHeight;\n\n    if (width > 0 && height > 0) {\n      this.setTexture2D(dstTexture, 0);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcVideo);\n      dstTexture.width = width;\n      dstTexture.height = height;\n      this.setTexture2D(null, 0);\n    }\n\n    return dstTexture;\n  },\n\n  /**\r\n   * Sets the minification and magnification filter for a texture.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setTextureFilter\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} texture - The texture to set the filter for.\r\n   * @param {integer} filter - The filter to set. 0 for linear filtering, 1 for nearest neighbor (blocky) filtering.\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setTextureFilter: function (texture, filter) {\n    var gl = this.gl;\n    var glFilter = [gl.LINEAR, gl.NEAREST][filter];\n    this.setTexture2D(texture, 0);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter);\n    this.setTexture2D(null, 0);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat1\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {number} x - [description]\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setFloat1: function (program, name, x) {\n    this.setProgram(program);\n    this.gl.uniform1f(this.gl.getUniformLocation(program, name), x);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat2\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {number} x - [description]\r\n   * @param {number} y - [description]\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setFloat2: function (program, name, x, y) {\n    this.setProgram(program);\n    this.gl.uniform2f(this.gl.getUniformLocation(program, name), x, y);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat3\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {number} x - [description]\r\n   * @param {number} y - [description]\r\n   * @param {number} z - [description]\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setFloat3: function (program, name, x, y, z) {\n    this.setProgram(program);\n    this.gl.uniform3f(this.gl.getUniformLocation(program, name), x, y, z);\n    return this;\n  },\n\n  /**\r\n   * Sets uniform of a WebGLProgram\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat4\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {number} x - X component\r\n   * @param {number} y - Y component\r\n   * @param {number} z - Z component\r\n   * @param {number} w - W component\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setFloat4: function (program, name, x, y, z, w) {\n    this.setProgram(program);\n    this.gl.uniform4f(this.gl.getUniformLocation(program, name), x, y, z, w);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat1v\r\n   * @since 3.13.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {Float32Array} arr - The new value to be used for the uniform variable.\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setFloat1v: function (program, name, arr) {\n    this.setProgram(program);\n    this.gl.uniform1fv(this.gl.getUniformLocation(program, name), arr);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat2v\r\n   * @since 3.13.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {Float32Array} arr - The new value to be used for the uniform variable.\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setFloat2v: function (program, name, arr) {\n    this.setProgram(program);\n    this.gl.uniform2fv(this.gl.getUniformLocation(program, name), arr);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat3v\r\n   * @since 3.13.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {Float32Array} arr - The new value to be used for the uniform variable.\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setFloat3v: function (program, name, arr) {\n    this.setProgram(program);\n    this.gl.uniform3fv(this.gl.getUniformLocation(program, name), arr);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat4v\r\n   * @since 3.13.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {Float32Array} arr - The new value to be used for the uniform variable.\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setFloat4v: function (program, name, arr) {\n    this.setProgram(program);\n    this.gl.uniform4fv(this.gl.getUniformLocation(program, name), arr);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt1\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {integer} x - [description]\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setInt1: function (program, name, x) {\n    this.setProgram(program);\n    this.gl.uniform1i(this.gl.getUniformLocation(program, name), x);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt2\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {integer} x - The new X component\r\n   * @param {integer} y - The new Y component\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setInt2: function (program, name, x, y) {\n    this.setProgram(program);\n    this.gl.uniform2i(this.gl.getUniformLocation(program, name), x, y);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt3\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {integer} x - The new X component\r\n   * @param {integer} y - The new Y component\r\n   * @param {integer} z - The new Z component\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setInt3: function (program, name, x, y, z) {\n    this.setProgram(program);\n    this.gl.uniform3i(this.gl.getUniformLocation(program, name), x, y, z);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt4\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {integer} x - X component\r\n   * @param {integer} y - Y component\r\n   * @param {integer} z - Z component\r\n   * @param {integer} w - W component\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setInt4: function (program, name, x, y, z, w) {\n    this.setProgram(program);\n    this.gl.uniform4i(this.gl.getUniformLocation(program, name), x, y, z, w);\n    return this;\n  },\n\n  /**\r\n   * Sets the value of a 2x2 matrix uniform variable in the given WebGLProgram.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix2\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {boolean} transpose - The value indicating whether to transpose the matrix. Must be false.\r\n   * @param {Float32Array} matrix - The new matrix value.\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setMatrix2: function (program, name, transpose, matrix) {\n    this.setProgram(program);\n    this.gl.uniformMatrix2fv(this.gl.getUniformLocation(program, name), transpose, matrix);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix3\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {boolean} transpose - [description]\r\n   * @param {Float32Array} matrix - [description]\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setMatrix3: function (program, name, transpose, matrix) {\n    this.setProgram(program);\n    this.gl.uniformMatrix3fv(this.gl.getUniformLocation(program, name), transpose, matrix);\n    return this;\n  },\n\n  /**\r\n   * Sets uniform of a WebGLProgram\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix4\r\n   * @since 3.0.0\r\n   *\r\n   * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n   * @param {string} name - The name of the uniform to look-up and modify.\r\n   * @param {boolean} transpose - Is the matrix transposed\r\n   * @param {Float32Array} matrix - Matrix data\r\n   *\r\n   * @return {this} This WebGL Renderer instance.\r\n   */\n  setMatrix4: function (program, name, transpose, matrix) {\n    this.setProgram(program);\n    this.gl.uniformMatrix4fv(this.gl.getUniformLocation(program, name), transpose, matrix);\n    return this;\n  },\n\n  /**\r\n   * Returns the maximum number of texture units that can be used in a fragment shader.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#getMaxTextures\r\n   * @since 3.8.0\r\n   *\r\n   * @return {integer} The maximum number of textures WebGL supports.\r\n   */\n  getMaxTextures: function () {\n    return this.config.maxTextures;\n  },\n\n  /**\r\n   * Returns the largest texture size (either width or height) that can be created.\r\n   * Note that VRAM may not allow a texture of any given size, it just expresses\r\n   * hardware / driver support for a given size.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#getMaxTextureSize\r\n   * @since 3.8.0\r\n   *\r\n   * @return {integer} The maximum supported texture size.\r\n   */\n  getMaxTextureSize: function () {\n    return this.config.maxTextureSize;\n  },\n\n  /**\r\n   * Destroy this WebGLRenderer, cleaning up all related resources such as pipelines, native textures, etc.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.WebGLRenderer#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    //  Clear-up anything that should be cleared :)\n    for (var i = 0; i < this.nativeTextures.length; i++) {\n      this.gl.deleteTexture(this.nativeTextures[i]);\n    }\n\n    this.nativeTextures = [];\n\n    for (var key in this.pipelines) {\n      this.pipelines[key].destroy();\n      delete this.pipelines[key];\n    }\n\n    this.defaultCamera.destroy();\n    this.currentMask = null;\n    this.currentCameraMask = null;\n    this.canvas.removeEventListener('webglcontextlost', this.contextLostHandler, false);\n    this.canvas.removeEventListener('webglcontextrestored', this.contextRestoredHandler, false);\n    this.game = null;\n    this.gl = null;\n    this.canvas = null;\n    this.maskStack = [];\n    this.contextLost = true;\n    this.extensions = {};\n  }\n});\nmodule.exports = WebGLRenderer;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/renderer/webgl/WebGLRenderer.js"],"names":["BaseCamera","require","CameraEvents","Class","CONST","GameEvents","IsSizePowerOfTwo","NOOP","ScaleEvents","SpliceOne","TextureEvents","TransformMatrix","Utils","WebGLSnapshot","BitmapMaskPipeline","ForwardDiffuseLightPipeline","TextureTintPipeline","WebGLRenderer","initialize","game","gameConfig","config","contextCreationConfig","alpha","transparent","desynchronized","depth","antialias","antialiasGL","premultipliedAlpha","stencil","failIfMajorPerformanceCaveat","powerPreference","clearBeforeRender","backgroundColor","contextCreation","resolution","roundPixels","maxTextures","maxTextureSize","batchSize","maxLights","mipmapFilter","type","WEBGL","width","height","canvas","blendModes","nativeTextures","contextLost","pipelines","snapshotState","x","y","getPixel","callback","encoder","isFramebuffer","bufferWidth","bufferHeight","currentActiveTextureUnit","currentTextures","Array","currentFramebuffer","currentPipeline","currentProgram","currentVertexBuffer","currentIndexBuffer","currentBlendMode","Infinity","currentScissorEnabled","currentScissor","scissorStack","contextLostHandler","contextRestoredHandler","gl","supportedExtensions","extensions","glFormats","compression","ETC1","PVRTC","S3TC","drawingBufferHeight","blankTexture","defaultCamera","_tempMatrix1","_tempMatrix2","_tempMatrix3","_tempMatrix4","maskCount","maskStack","currentMask","mask","camera","currentCameraMask","glFuncMap","currentType","newType","nextTypeMatch","init","clearColor","context","getContext","isContextLost","Error","_this","event","events","emit","CONTEXT_LOST","preventDefault","CONTEXT_RESTORED","addEventListener","i","push","func","ONE","ONE_MINUS_SRC_ALPHA","equation","FUNC_ADD","DST_ALPHA","DST_COLOR","ONE_MINUS_SRC_COLOR","ZERO","FUNC_REVERSE_SUBTRACT","BYTE","SHORT","UNSIGNED_BYTE","UNSIGNED_SHORT","FLOAT","mat2","uniformMatrix2fv","length","matrix","mat3","uniformMatrix3fv","mat4","uniformMatrix4fv","uniform1f","uniform1fv","uniform1i","uniform1iv","uniform2f","uniform2fv","uniform2i","uniform2iv","uniform3f","uniform3fv","uniform3i","uniform3iv","uniform4f","uniform4fv","uniform4i","uniform4iv","exts","getSupportedExtensions","getParameter","MAX_TEXTURE_IMAGE_UNITS","MAX_TEXTURE_SIZE","extString","wkExtString","getExtension","disable","DEPTH_TEST","CULL_FACE","enable","BLEND","redGL","greenGL","blueGL","alphaGL","index","addPipeline","renderer","setBlendMode","BlendModes","NORMAL","textures","once","READY","boot","pipelineName","blank","getFrame","currentFrame","bindFramebuffer","FRAMEBUFFER","SCISSOR_TEST","setPipeline","scale","on","RESIZE","onResize","baseSize","resize","gameSize","displaySize","viewport","scissor","setSize","hasExtension","extensionName","indexOf","flush","hasPipeline","getPipeline","removePipeline","pipelineInstance","console","warn","name","pushScissor","undefined","setScissor","current","cx","cy","cw","ch","popScissor","pop","gameObject","vertexBuffer","program","bind","onBind","hasActiveStencilMask","camMask","isStencil","rebindPipeline","clear","DEPTH_BUFFER_BIT","STENCIL_TEST","STENCIL_BUFFER_BIT","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","glTexture","clearPipeline","blendModeId","force","blendMode","SKIP_CHECK","blendEquation","blendFuncSeparate","blendFunc","addBlendMode","updateBlendMode","removeBlendMode","splice","setBlankTexture","setTexture2D","texture","textureUnit","setFramebuffer","framebuffer","updateScissor","renderTexture","setProgram","useProgram","setVertexBuffer","bindBuffer","ARRAY_BUFFER","setIndexBuffer","indexBuffer","ELEMENT_ARRAY_BUFFER","createTextureFromSource","source","scaleMode","minFilter","NEAREST","magFilter","wrap","CLAMP_TO_EDGE","pow","REPEAT","ScaleModes","LINEAR","createTexture2D","RGBA","mipLevel","wrapT","wrapS","format","pixels","pma","forceSize","flipY","createTexture","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_FLIP_Y_WEBGL","texImage2D","generateMipmap","isAlphaPremultiplied","isRenderTexture","createFramebuffer","addDepthStencilBuffer","complete","depthStencilBuffer","createRenderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","DEPTH_STENCIL","framebufferRenderbuffer","DEPTH_STENCIL_ATTACHMENT","framebufferTexture2D","COLOR_ATTACHMENT0","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","errors","createProgram","vertexShader","fragmentShader","vs","createShader","VERTEX_SHADER","fs","FRAGMENT_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","createVertexBuffer","initialDataOrSize","bufferUsage","createBuffer","bufferData","createIndexBuffer","deleteTexture","pendingDestroy","deleteFramebuffer","deleteProgram","deleteBuffer","buffer","preRenderCamera","_cx","_cy","_cw","_ch","color","renderToTexture","COLOR_BUFFER_BIT","projOrtho","_maskCamera","preRenderWebGL","drawFillRect","getTintFromFloats","PRE_RENDER","getCurrentStencilMask","prev","stack","cameraMask","postRenderCamera","flashEffect","postRenderWebGL","fadeEffect","dirty","POST_RENDER","getTint","getTintAppendFloatAlpha","pipeline","batchTexture","zoom","rotation","flipX","_tintTL","_alphaTL","_tintTR","_alphaTR","_tintBL","_alphaBL","_tintBR","_alphaBR","_isTinted","tintFill","preRender","key","onPreRender","scene","customViewports","render","children","interpolationPercentage","list","childCount","onRender","child","willRender","renderWebGL","postRender","state","onPostRender","snapshot","encoderOptions","snapshotArea","drawingBufferWidth","Math","min","snapshotPixel","snapshotFramebuffer","canvasToTexture","srcCanvas","dstTexture","noRepeat","createCanvasTexture","updateCanvasTexture","wrapping","createVideoTexture","srcVideo","videoWidth","videoHeight","updateVideoTexture","setTextureFilter","filter","glFilter","setFloat1","getUniformLocation","setFloat2","setFloat3","z","setFloat4","w","setFloat1v","arr","setFloat2v","setFloat3v","setFloat4v","setInt1","setInt2","setInt3","setInt4","setMatrix2","transpose","setMatrix3","setMatrix4","getMaxTextures","getMaxTextureSize","destroy","removeEventListener","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BaseCamera = require('../../cameras/2d/BaseCamera');\r\nvar CameraEvents = require('../../cameras/2d/events');\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../../const');\r\nvar GameEvents = require('../../core/events');\r\nvar IsSizePowerOfTwo = require('../../math/pow2/IsSizePowerOfTwo');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar ScaleEvents = require('../../scale/events');\r\nvar SpliceOne = require('../../utils/array/SpliceOne');\r\nvar TextureEvents = require('../../textures/events');\r\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\r\nvar Utils = require('./Utils');\r\nvar WebGLSnapshot = require('../snapshot/WebGLSnapshot');\r\n\r\n//  Default Pipelines\r\nvar BitmapMaskPipeline = require('./pipelines/BitmapMaskPipeline');\r\nvar ForwardDiffuseLightPipeline = require('./pipelines/ForwardDiffuseLightPipeline');\r\nvar TextureTintPipeline = require('./pipelines/TextureTintPipeline');\r\n\r\n/**\r\n * @callback WebGLContextCallback\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer which owns the context.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * WebGLRenderer is a class that contains the needed functionality to keep the\r\n * WebGLRenderingContext state clean. The main idea of the WebGLRenderer is to keep track of\r\n * any context change that happens for WebGL rendering inside of Phaser. This means\r\n * if raw webgl functions are called outside the WebGLRenderer of the Phaser WebGL\r\n * rendering ecosystem they might pollute the current WebGLRenderingContext state producing\r\n * unexpected behavior. It's recommended that WebGL interaction is done through\r\n * WebGLRenderer and/or WebGLPipeline.\r\n *\r\n * @class WebGLRenderer\r\n * @memberof Phaser.Renderer.WebGL\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Game instance which owns this WebGL Renderer.\r\n */\r\nvar WebGLRenderer = new Class({\r\n\r\n    initialize:\r\n\r\n    function WebGLRenderer (game)\r\n    {\r\n        var gameConfig = game.config;\r\n\r\n        var contextCreationConfig = {\r\n            alpha: gameConfig.transparent,\r\n            desynchronized: gameConfig.desynchronized,\r\n            depth: false,\r\n            antialias: gameConfig.antialiasGL,\r\n            premultipliedAlpha: gameConfig.premultipliedAlpha,\r\n            stencil: true,\r\n            failIfMajorPerformanceCaveat: gameConfig.failIfMajorPerformanceCaveat,\r\n            powerPreference: gameConfig.powerPreference\r\n        };\r\n\r\n        /**\r\n         * The local configuration settings of this WebGL Renderer.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#config\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = {\r\n            clearBeforeRender: gameConfig.clearBeforeRender,\r\n            antialias: gameConfig.antialias,\r\n            backgroundColor: gameConfig.backgroundColor,\r\n            contextCreation: contextCreationConfig,\r\n            resolution: gameConfig.resolution,\r\n            roundPixels: gameConfig.roundPixels,\r\n            maxTextures: gameConfig.maxTextures,\r\n            maxTextureSize: gameConfig.maxTextureSize,\r\n            batchSize: gameConfig.batchSize,\r\n            maxLights: gameConfig.maxLights,\r\n            mipmapFilter: gameConfig.mipmapFilter\r\n        };\r\n\r\n        /**\r\n         * The Game instance which owns this WebGL Renderer.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * A constant which allows the renderer to be easily identified as a WebGL Renderer.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#type\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = CONST.WEBGL;\r\n\r\n        /**\r\n         * The width of the canvas being rendered to.\r\n         * This is populated in the onResize event handler.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#width\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = 0;\r\n\r\n        /**\r\n         * The height of the canvas being rendered to.\r\n         * This is populated in the onResize event handler.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#height\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = 0;\r\n\r\n        /**\r\n         * The canvas which this WebGL Renderer draws to.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */\r\n        this.canvas = game.canvas;\r\n\r\n        /**\r\n         * An array of blend modes supported by the WebGL Renderer.\r\n         * \r\n         * This array includes the default blend modes as well as any custom blend modes added through {@link #addBlendMode}.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#blendModes\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.blendModes = [];\r\n\r\n        /**\r\n         * Keeps track of any WebGLTexture created with the current WebGLRenderingContext\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#nativeTextures\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.nativeTextures = [];\r\n\r\n        /**\r\n         * This property is set to `true` if the WebGL context of the renderer is lost.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#contextLost\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.contextLost = false;\r\n\r\n        /**\r\n         * This object will store all pipelines created through addPipeline\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#pipelines\r\n         * @type {object}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.pipelines = null;\r\n\r\n        /**\r\n         * Details about the currently scheduled snapshot.\r\n         * \r\n         * If a non-null `callback` is set in this object, a snapshot of the canvas will be taken after the current frame is fully rendered.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#snapshotState\r\n         * @type {Phaser.Types.Renderer.Snapshot.SnapshotState}\r\n         * @since 3.0.0\r\n         */\r\n        this.snapshotState = {\r\n            x: 0,\r\n            y: 0,\r\n            width: 1,\r\n            height: 1,\r\n            getPixel: false,\r\n            callback: null,\r\n            type: 'image/png',\r\n            encoder: 0.92,\r\n            isFramebuffer: false,\r\n            bufferWidth: 0,\r\n            bufferHeight: 0\r\n        };\r\n\r\n        // Internal Renderer State (Textures, Framebuffers, Pipelines, Buffers, etc)\r\n\r\n        /**\r\n         * Cached value for the last texture unit that was used\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentActiveTextureUnit\r\n         * @type {integer}\r\n         * @since 3.1.0\r\n         */\r\n        this.currentActiveTextureUnit = 0;\r\n\r\n        /**\r\n         * An array of the last texture handles that were bound to the WebGLRenderingContext\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentTextures\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.currentTextures = new Array(16);\r\n\r\n        /**\r\n         * Current framebuffer in use\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentFramebuffer\r\n         * @type {WebGLFramebuffer}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.currentFramebuffer = null;\r\n\r\n        /**\r\n         * Current WebGLPipeline in use\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentPipeline\r\n         * @type {Phaser.Renderer.WebGL.WebGLPipeline}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.currentPipeline = null;\r\n\r\n        /**\r\n         * Current WebGLProgram in use\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentProgram\r\n         * @type {WebGLProgram}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.currentProgram = null;\r\n\r\n        /**\r\n         * Current WebGLBuffer (Vertex buffer) in use\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentVertexBuffer\r\n         * @type {WebGLBuffer}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.currentVertexBuffer = null;\r\n\r\n        /**\r\n         * Current WebGLBuffer (Index buffer) in use\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentIndexBuffer\r\n         * @type {WebGLBuffer}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.currentIndexBuffer = null;\r\n\r\n        /**\r\n         * Current blend mode in use\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentBlendMode\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.currentBlendMode = Infinity;\r\n\r\n        /**\r\n         * Indicates if the the scissor state is enabled in WebGLRenderingContext\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentScissorEnabled\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.currentScissorEnabled = false;\r\n\r\n        /**\r\n         * Stores the current scissor data\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentScissor\r\n         * @type {Uint32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.currentScissor = null;\r\n\r\n        /**\r\n         * Stack of scissor data\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#scissorStack\r\n         * @type {Uint32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.scissorStack = [];\r\n\r\n        /**\r\n         * The handler to invoke when the context is lost.\r\n         * This should not be changed and is set in the boot method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#contextLostHandler\r\n         * @type {function}\r\n         * @since 3.19.0\r\n         */\r\n        this.contextLostHandler = NOOP;\r\n\r\n        /**\r\n         * The handler to invoke when the context is restored.\r\n         * This should not be changed and is set in the boot method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#contextRestoredHandler\r\n         * @type {function}\r\n         * @since 3.19.0\r\n         */\r\n        this.contextRestoredHandler = NOOP;\r\n\r\n        /**\r\n         * The underlying WebGL context of the renderer.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#gl\r\n         * @type {WebGLRenderingContext}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.gl = null;\r\n\r\n        /**\r\n         * Array of strings that indicate which WebGL extensions are supported by the browser\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#supportedExtensions\r\n         * @type {object}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.supportedExtensions = null;\r\n\r\n        /**\r\n         * Extensions loaded into the current context\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#extensions\r\n         * @type {object}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */\r\n        this.extensions = {};\r\n\r\n        /**\r\n         * Stores the current WebGL component formats for further use\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#glFormats\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.2.0\r\n         */\r\n        this.glFormats = [];\r\n\r\n        /**\r\n         * Stores the supported WebGL texture compression formats.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#compression\r\n         * @type {array}\r\n         * @since 3.8.0\r\n         */\r\n        this.compression = {\r\n            ETC1: false,\r\n            PVRTC: false,\r\n            S3TC: false\r\n        };\r\n\r\n        /**\r\n         * Cached drawing buffer height to reduce gl calls.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#drawingBufferHeight\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.11.0\r\n         */\r\n        this.drawingBufferHeight = 0;\r\n\r\n        /**\r\n         * A blank 32x32 transparent texture, as used by the Graphics system where needed.\r\n         * This is set in the `boot` method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#blankTexture\r\n         * @type {WebGLTexture}\r\n         * @readonly\r\n         * @since 3.12.0\r\n         */\r\n        this.blankTexture = null;\r\n\r\n        /**\r\n         * A default Camera used in calls when no other camera has been provided.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#defaultCamera\r\n         * @type {Phaser.Cameras.Scene2D.BaseCamera}\r\n         * @since 3.12.0\r\n         */\r\n        this.defaultCamera = new BaseCamera(0, 0, 0, 0);\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix1\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix1 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix2\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix2 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix3\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix3 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix4\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix4 = new TransformMatrix();\r\n\r\n        /**\r\n         * The total number of masks currently stacked.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#maskCount\r\n         * @type {integer}\r\n         * @since 3.17.0\r\n         */\r\n        this.maskCount = 0;\r\n\r\n        /**\r\n         * The mask stack.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#maskStack\r\n         * @type {Phaser.Display.Masks.GeometryMask[]}\r\n         * @since 3.17.0\r\n         */\r\n        this.maskStack = [];\r\n\r\n        /**\r\n         * Internal property that tracks the currently set mask.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentMask\r\n         * @type {any}\r\n         * @since 3.17.0\r\n         */\r\n        this.currentMask = { mask: null, camera: null };\r\n\r\n        /**\r\n         * Internal property that tracks the currently set camera mask.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentCameraMask\r\n         * @type {any}\r\n         * @since 3.17.0\r\n         */\r\n        this.currentCameraMask = { mask: null, camera: null };\r\n\r\n        /**\r\n         * Internal gl function mapping for uniform look-up.\r\n         * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/uniform\r\n         * \r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#glFuncMap\r\n         * @type {any}\r\n         * @since 3.17.0\r\n         */\r\n        this.glFuncMap = null;\r\n\r\n        /**\r\n         * The `type` of the Game Object being currently rendered.\r\n         * This can be used by advanced render functions for batching look-ahead.\r\n         * \r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentType\r\n         * @type {string}\r\n         * @since 3.19.0\r\n         */\r\n        this.currentType = '';\r\n\r\n        /**\r\n         * Is the `type` of the Game Object being currently rendered different than the\r\n         * type of the object before it in the display list? I.e. it's a 'new' type.\r\n         * \r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#newType\r\n         * @type {boolean}\r\n         * @since 3.19.0\r\n         */\r\n        this.newType = false;\r\n\r\n        /**\r\n         * Does the `type` of the next Game Object in the display list match that\r\n         * of the object being currently rendered?\r\n         * \r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#nextTypeMatch\r\n         * @type {boolean}\r\n         * @since 3.19.0\r\n         */\r\n        this.nextTypeMatch = false;\r\n\r\n        /**\r\n         * The mipmap magFilter to be used when creating textures.\r\n         * \r\n         * You can specify this as a string in the game config, i.e.:\r\n         * \r\n         * `renderer: { mipmapFilter: 'NEAREST_MIPMAP_LINEAR' }`\r\n         * \r\n         * The 6 options for WebGL1 are, in order from least to most computationally expensive:\r\n         * \r\n         * NEAREST (for pixel art)\r\n         * LINEAR (the default)\r\n         * NEAREST_MIPMAP_NEAREST\r\n         * LINEAR_MIPMAP_NEAREST\r\n         * NEAREST_MIPMAP_LINEAR\r\n         * LINEAR_MIPMAP_LINEAR\r\n         * \r\n         * Mipmaps only work with textures that are fully power-of-two in size.\r\n         * \r\n         * For more details see https://webglfundamentals.org/webgl/lessons/webgl-3d-textures.html\r\n         * \r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#mipmapFilter\r\n         * @type {GLenum}\r\n         * @since 3.21.0\r\n         */\r\n        this.mipmapFilter = null;\r\n\r\n        this.init(this.config);\r\n    },\r\n\r\n    /**\r\n     * Creates a new WebGLRenderingContext and initializes all internal state.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#init\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} config - The configuration object for the renderer.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    init: function (config)\r\n    {\r\n        var gl;\r\n        var game = this.game;\r\n        var canvas = this.canvas;\r\n        var clearColor = config.backgroundColor;\r\n\r\n        //  Did they provide their own context?\r\n        if (game.config.context)\r\n        {\r\n            gl = game.config.context;\r\n        }\r\n        else\r\n        {\r\n            gl = canvas.getContext('webgl', config.contextCreation) || canvas.getContext('experimental-webgl', config.contextCreation);\r\n        }\r\n\r\n        if (!gl || gl.isContextLost())\r\n        {\r\n            this.contextLost = true;\r\n\r\n            throw new Error('WebGL unsupported');\r\n        }\r\n\r\n        this.gl = gl;\r\n\r\n        var _this = this;\r\n\r\n        this.contextLostHandler = function (event)\r\n        {\r\n            _this.contextLost = true;\r\n\r\n            _this.game.events.emit(GameEvents.CONTEXT_LOST, _this);\r\n\r\n            event.preventDefault();\r\n        };\r\n\r\n        this.contextRestoredHandler = function ()\r\n        {\r\n            _this.contextLost = false;\r\n\r\n            _this.init(_this.config);\r\n\r\n            _this.game.events.emit(GameEvents.CONTEXT_RESTORED, _this);\r\n        };\r\n\r\n        canvas.addEventListener('webglcontextlost', this.contextLostHandler, false);\r\n        canvas.addEventListener('webglcontextrestored', this.contextRestoredHandler, false);\r\n\r\n        //  Set it back into the Game, so developers can access it from there too\r\n        game.context = gl;\r\n\r\n        for (var i = 0; i <= 27; i++)\r\n        {\r\n            this.blendModes.push({ func: [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], equation: gl.FUNC_ADD });\r\n        }\r\n\r\n        //  ADD\r\n        this.blendModes[1].func = [ gl.ONE, gl.DST_ALPHA ];\r\n\r\n        //  MULTIPLY\r\n        this.blendModes[2].func = [ gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA ];\r\n\r\n        //  SCREEN\r\n        this.blendModes[3].func = [ gl.ONE, gl.ONE_MINUS_SRC_COLOR ];\r\n\r\n        //  ERASE\r\n        this.blendModes[17] = { func: [ gl.ZERO, gl.ONE_MINUS_SRC_ALPHA ], equation: gl.FUNC_REVERSE_SUBTRACT };\r\n\r\n        this.glFormats[0] = gl.BYTE;\r\n        this.glFormats[1] = gl.SHORT;\r\n        this.glFormats[2] = gl.UNSIGNED_BYTE;\r\n        this.glFormats[3] = gl.UNSIGNED_SHORT;\r\n        this.glFormats[4] = gl.FLOAT;\r\n\r\n        //  Set the gl function map\r\n        this.glFuncMap = {\r\n\r\n            mat2: { func: gl.uniformMatrix2fv, length: 1, matrix: true },\r\n            mat3: { func: gl.uniformMatrix3fv, length: 1, matrix: true },\r\n            mat4: { func: gl.uniformMatrix4fv, length: 1, matrix: true },\r\n\r\n            '1f': { func: gl.uniform1f, length: 1 },\r\n            '1fv': { func: gl.uniform1fv, length: 1 },\r\n            '1i': { func: gl.uniform1i, length: 1 },\r\n            '1iv': { func: gl.uniform1iv, length: 1 },\r\n\r\n            '2f': { func: gl.uniform2f, length: 2 },\r\n            '2fv': { func: gl.uniform2fv, length: 1 },\r\n            '2i': { func: gl.uniform2i, length: 2 },\r\n            '2iv': { func: gl.uniform2iv, length: 1 },\r\n\r\n            '3f': { func: gl.uniform3f, length: 3 },\r\n            '3fv': { func: gl.uniform3fv, length: 1 },\r\n            '3i': { func: gl.uniform3i, length: 3 },\r\n            '3iv': { func: gl.uniform3iv, length: 1 },\r\n\r\n            '4f': { func: gl.uniform4f, length: 4 },\r\n            '4fv': { func: gl.uniform4fv, length: 1 },\r\n            '4i': { func: gl.uniform4i, length: 4 },\r\n            '4iv': { func: gl.uniform4iv, length: 1 }\r\n\r\n        };\r\n\r\n        // Load supported extensions\r\n        var exts = gl.getSupportedExtensions();\r\n\r\n        if (!config.maxTextures)\r\n        {\r\n            config.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\r\n        }\r\n\r\n        if (!config.maxTextureSize)\r\n        {\r\n            config.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\r\n        }\r\n\r\n        var extString = 'WEBGL_compressed_texture_';\r\n        var wkExtString = 'WEBKIT_' + extString;\r\n\r\n        this.compression.ETC1 = gl.getExtension(extString + 'etc1') || gl.getExtension(wkExtString + 'etc1');\r\n        this.compression.PVRTC = gl.getExtension(extString + 'pvrtc') || gl.getExtension(wkExtString + 'pvrtc');\r\n        this.compression.S3TC = gl.getExtension(extString + 's3tc') || gl.getExtension(wkExtString + 's3tc');\r\n\r\n        this.supportedExtensions = exts;\r\n\r\n        //  Setup initial WebGL state\r\n        gl.disable(gl.DEPTH_TEST);\r\n        gl.disable(gl.CULL_FACE);\r\n\r\n        gl.enable(gl.BLEND);\r\n\r\n        gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);\r\n\r\n        //  Mipmaps\r\n        this.mipmapFilter = gl[config.mipmapFilter];\r\n\r\n        // Initialize all textures to null\r\n        for (var index = 0; index < this.currentTextures.length; ++index)\r\n        {\r\n            this.currentTextures[index] = null;\r\n        }\r\n\r\n        // Clear previous pipelines and reload default ones\r\n        this.pipelines = {};\r\n\r\n        this.addPipeline('TextureTintPipeline', new TextureTintPipeline({ game: game, renderer: this }));\r\n        this.addPipeline('BitmapMaskPipeline', new BitmapMaskPipeline({ game: game, renderer: this }));\r\n        this.addPipeline('Light2D', new ForwardDiffuseLightPipeline({ game: game, renderer: this, maxLights: config.maxLights }));\r\n\r\n        this.setBlendMode(CONST.BlendModes.NORMAL);\r\n\r\n        game.textures.once(TextureEvents.READY, this.boot, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal boot handler. Calls 'boot' on each pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#boot\r\n     * @private\r\n     * @since 3.11.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        for (var pipelineName in this.pipelines)\r\n        {\r\n            this.pipelines[pipelineName].boot();\r\n        }\r\n\r\n        var blank = this.game.textures.getFrame('__DEFAULT');\r\n\r\n        this.pipelines.TextureTintPipeline.currentFrame = blank;\r\n\r\n        this.blankTexture = blank;\r\n\r\n        var gl = this.gl;\r\n\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n\r\n        gl.enable(gl.SCISSOR_TEST);\r\n\r\n        this.setPipeline(this.pipelines.TextureTintPipeline);\r\n\r\n        this.game.scale.on(ScaleEvents.RESIZE, this.onResize, this);\r\n\r\n        var baseSize = this.game.scale.baseSize;\r\n\r\n        this.resize(baseSize.width, baseSize.height, this.game.scale.resolution);\r\n    },\r\n\r\n    /**\r\n     * The event handler that manages the `resize` event dispatched by the Scale Manager.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#onResize\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Structs.Size} gameSize - The default Game Size object. This is the un-modified game dimensions.\r\n     * @param {Phaser.Structs.Size} baseSize - The base Size object. The game dimensions multiplied by the resolution. The canvas width / height values match this.\r\n     * @param {Phaser.Structs.Size} displaySize - The display Size object. The size of the canvas style width / height attributes.\r\n     * @param {number} [resolution] - The Scale Manager resolution setting.\r\n     */\r\n    onResize: function (gameSize, baseSize, displaySize, resolution)\r\n    {\r\n        //  Has the underlying canvas size changed?\r\n        if (baseSize.width !== this.width || baseSize.height !== this.height || resolution !== this.resolution)\r\n        {\r\n            this.resize(baseSize.width, baseSize.height, resolution);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Resizes the drawing buffer to match that required by the Scale Manager.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#resize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [width] - The new width of the renderer.\r\n     * @param {number} [height] - The new height of the renderer.\r\n     * @param {number} [resolution] - The new resolution of the renderer.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    resize: function (width, height, resolution)\r\n    {\r\n        var gl = this.gl;\r\n        var pipelines = this.pipelines;\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n        this.resolution = resolution;\r\n\r\n        gl.viewport(0, 0, width, height);\r\n\r\n        //  Update all registered pipelines\r\n        for (var pipelineName in pipelines)\r\n        {\r\n            pipelines[pipelineName].resize(width, height, resolution);\r\n        }\r\n\r\n        this.drawingBufferHeight = gl.drawingBufferHeight;\r\n\r\n        gl.scissor(0, (gl.drawingBufferHeight - height), width, height);\r\n\r\n        this.defaultCamera.setSize(width, height);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Checks if a WebGL extension is supported\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#hasExtension\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} extensionName - Name of the WebGL extension\r\n     *\r\n     * @return {boolean} `true` if the extension is supported, otherwise `false`.\r\n     */\r\n    hasExtension: function (extensionName)\r\n    {\r\n        return this.supportedExtensions ? this.supportedExtensions.indexOf(extensionName) : false;\r\n    },\r\n\r\n    /**\r\n     * Loads a WebGL extension\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#getExtension\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} extensionName - The name of the extension to load.\r\n     *\r\n     * @return {object} WebGL extension if the extension is supported\r\n     */\r\n    getExtension: function (extensionName)\r\n    {\r\n        if (!this.hasExtension(extensionName)) { return null; }\r\n\r\n        if (!(extensionName in this.extensions))\r\n        {\r\n            this.extensions[extensionName] = this.gl.getExtension(extensionName);\r\n        }\r\n\r\n        return this.extensions[extensionName];\r\n    },\r\n\r\n    /**\r\n     * Flushes the current pipeline if the pipeline is bound\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#flush\r\n     * @since 3.0.0\r\n     */\r\n    flush: function ()\r\n    {\r\n        if (this.currentPipeline)\r\n        {\r\n            this.currentPipeline.flush();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks if a pipeline is present in the current WebGLRenderer\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#hasPipeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} pipelineName - The name of the pipeline.\r\n     *\r\n     * @return {boolean} `true` if the given pipeline is loaded, otherwise `false`.\r\n     */\r\n    hasPipeline: function (pipelineName)\r\n    {\r\n        return (pipelineName in this.pipelines);\r\n    },\r\n\r\n    /**\r\n     * Returns the pipeline by name if the pipeline exists\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#getPipeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} pipelineName - The name of the pipeline.\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline instance, or `null` if not found.\r\n     */\r\n    getPipeline: function (pipelineName)\r\n    {\r\n        return (this.hasPipeline(pipelineName)) ? this.pipelines[pipelineName] : null;\r\n    },\r\n\r\n    /**\r\n     * Removes a pipeline by name.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#removePipeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} pipelineName - The name of the pipeline to be removed.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    removePipeline: function (pipelineName)\r\n    {\r\n        delete this.pipelines[pipelineName];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a pipeline instance into the collection of pipelines\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#addPipeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} pipelineName - A unique string-based key for the pipeline.\r\n     * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - A pipeline instance which must extend WebGLPipeline.\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline instance that was passed.\r\n     */\r\n    addPipeline: function (pipelineName, pipelineInstance)\r\n    {\r\n        if (!this.hasPipeline(pipelineName))\r\n        {\r\n            this.pipelines[pipelineName] = pipelineInstance;\r\n        }\r\n        else\r\n        {\r\n            console.warn('Pipeline exists: ' + pipelineName);\r\n        }\r\n\r\n        pipelineInstance.name = pipelineName;\r\n\r\n        this.pipelines[pipelineName].resize(this.width, this.height, this.config.resolution);\r\n\r\n        return pipelineInstance;\r\n    },\r\n\r\n    /**\r\n     * Pushes a new scissor state. This is used to set nested scissor states.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#pushScissor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} x - The x position of the scissor.\r\n     * @param {integer} y - The y position of the scissor.\r\n     * @param {integer} width - The width of the scissor.\r\n     * @param {integer} height - The height of the scissor.\r\n     * @param {integer} [drawingBufferHeight] - Optional drawingBufferHeight override value.\r\n     *\r\n     * @return {integer[]} An array containing the scissor values.\r\n     */\r\n    pushScissor: function (x, y, width, height, drawingBufferHeight)\r\n    {\r\n        if (drawingBufferHeight === undefined) { drawingBufferHeight = this.drawingBufferHeight; }\r\n\r\n        var scissorStack = this.scissorStack;\r\n\r\n        var scissor = [ x, y, width, height ];\r\n\r\n        scissorStack.push(scissor);\r\n\r\n        this.setScissor(x, y, width, height, drawingBufferHeight);\r\n\r\n        this.currentScissor = scissor;\r\n\r\n        return scissor;\r\n    },\r\n\r\n    /**\r\n     * Sets the current scissor state.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setScissor\r\n     * @since 3.0.0\r\n     * \r\n     * @param {integer} x - The x position of the scissor.\r\n     * @param {integer} y - The y position of the scissor.\r\n     * @param {integer} width - The width of the scissor.\r\n     * @param {integer} height - The height of the scissor.\r\n     * @param {integer} [drawingBufferHeight] - Optional drawingBufferHeight override value.\r\n     */\r\n    setScissor: function (x, y, width, height, drawingBufferHeight)\r\n    {\r\n        if (drawingBufferHeight === undefined) { drawingBufferHeight = this.drawingBufferHeight; }\r\n\r\n        var gl = this.gl;\r\n\r\n        var current = this.currentScissor;\r\n\r\n        var setScissor = (width > 0 && height > 0);\r\n\r\n        if (current && setScissor)\r\n        {\r\n            var cx = current[0];\r\n            var cy = current[1];\r\n            var cw = current[2];\r\n            var ch = current[3];\r\n\r\n            setScissor = (cx !== x || cy !== y || cw !== width || ch !== height);\r\n        }\r\n\r\n        if (setScissor)\r\n        {\r\n            this.flush();\r\n\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/scissor\r\n            gl.scissor(x, (drawingBufferHeight - y - height), width, height);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Pops the last scissor state and sets it.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#popScissor\r\n     * @since 3.0.0\r\n     */\r\n    popScissor: function ()\r\n    {\r\n        var scissorStack = this.scissorStack;\r\n\r\n        //  Remove the current scissor\r\n        scissorStack.pop();\r\n\r\n        //  Reset the previous scissor\r\n        var scissor = scissorStack[scissorStack.length - 1];\r\n\r\n        if (scissor)\r\n        {\r\n            this.setScissor(scissor[0], scissor[1], scissor[2], scissor[3]);\r\n        }\r\n\r\n        this.currentScissor = scissor;\r\n    },\r\n\r\n    /**\r\n     * Binds a WebGLPipeline and sets it as the current pipeline to be used.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setPipeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - The pipeline instance to be activated.\r\n     * @param {Phaser.GameObjects.GameObject} [gameObject] - The Game Object that invoked this pipeline, if any.\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline that was activated.\r\n     */\r\n    setPipeline: function (pipelineInstance, gameObject)\r\n    {\r\n        if (this.currentPipeline !== pipelineInstance ||\r\n            this.currentPipeline.vertexBuffer !== this.currentVertexBuffer ||\r\n            this.currentPipeline.program !== this.currentProgram)\r\n        {\r\n            this.flush();\r\n            this.currentPipeline = pipelineInstance;\r\n            this.currentPipeline.bind();\r\n        }\r\n\r\n        this.currentPipeline.onBind(gameObject);\r\n\r\n        return this.currentPipeline;\r\n    },\r\n\r\n    /**\r\n     * Is there an active stencil mask?\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#hasActiveStencilMask\r\n     * @since 3.17.0\r\n     * \r\n     * @return {boolean} `true` if there is an active stencil mask, otherwise `false`.\r\n     */\r\n    hasActiveStencilMask: function ()\r\n    {\r\n        var mask = this.currentMask.mask;\r\n        var camMask = this.currentCameraMask.mask;\r\n\r\n        return ((mask && mask.isStencil) || (camMask && camMask.isStencil));\r\n    },\r\n\r\n    /**\r\n     * Use this to reset the gl context to the state that Phaser requires to continue rendering.\r\n     * Calling this will:\r\n     * \r\n     * * Disable `DEPTH_TEST`, `CULL_FACE` and `STENCIL_TEST`.\r\n     * * Clear the depth buffer and stencil buffers.\r\n     * * Reset the viewport size.\r\n     * * Reset the blend mode.\r\n     * * Bind a blank texture as the active texture on texture unit zero.\r\n     * * Rebinds the given pipeline instance.\r\n     * \r\n     * You should call this having previously called `clearPipeline` and then wishing to return\r\n     * control to Phaser again.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#rebindPipeline\r\n     * @since 3.16.0\r\n     * \r\n     * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - The pipeline instance to be activated.\r\n     */\r\n    rebindPipeline: function (pipelineInstance)\r\n    {\r\n        var gl = this.gl;\r\n\r\n        gl.disable(gl.DEPTH_TEST);\r\n        gl.disable(gl.CULL_FACE);\r\n\r\n        if (this.hasActiveStencilMask())\r\n        {\r\n            gl.clear(gl.DEPTH_BUFFER_BIT);\r\n        }\r\n        else\r\n        {\r\n            //  If there wasn't a stencil mask set before this call, we can disable it safely\r\n            gl.disable(gl.STENCIL_TEST);\r\n            gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\r\n        }\r\n\r\n        gl.viewport(0, 0, this.width, this.height);\r\n\r\n        this.setBlendMode(0, true);\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, this.blankTexture.glTexture);\r\n\r\n        this.currentActiveTextureUnit = 0;\r\n        this.currentTextures[0] = this.blankTexture.glTexture;\r\n\r\n        this.currentPipeline = pipelineInstance;\r\n        this.currentPipeline.bind();\r\n        this.currentPipeline.onBind();\r\n    },\r\n\r\n    /**\r\n     * Flushes the current WebGLPipeline being used and then clears it, along with the\r\n     * the current shader program and vertex buffer. Then resets the blend mode to NORMAL.\r\n     * Call this before jumping to your own gl context handler, and then call `rebindPipeline` when\r\n     * you wish to return control to Phaser again.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#clearPipeline\r\n     * @since 3.16.0\r\n     */\r\n    clearPipeline: function ()\r\n    {\r\n        this.flush();\r\n\r\n        this.currentPipeline = null;\r\n        this.currentProgram = null;\r\n        this.currentVertexBuffer = null;\r\n        this.currentIndexBuffer = null;\r\n\r\n        this.setBlendMode(0, true);\r\n    },\r\n\r\n    /**\r\n     * Sets the blend mode to the value given.\r\n     *\r\n     * If the current blend mode is different from the one given, the pipeline is flushed and the new\r\n     * blend mode is enabled.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} blendModeId - The blend mode to be set. Can be a `BlendModes` const or an integer value.\r\n     * @param {boolean} [force=false] - Force the blend mode to be set, regardless of the currently set blend mode.\r\n     *\r\n     * @return {boolean} `true` if the blend mode was changed as a result of this call, forcing a flush, otherwise `false`.\r\n     */\r\n    setBlendMode: function (blendModeId, force)\r\n    {\r\n        if (force === undefined) { force = false; }\r\n\r\n        var gl = this.gl;\r\n        var blendMode = this.blendModes[blendModeId];\r\n\r\n        if (force || (blendModeId !== CONST.BlendModes.SKIP_CHECK && this.currentBlendMode !== blendModeId))\r\n        {\r\n            this.flush();\r\n\r\n            gl.enable(gl.BLEND);\r\n            gl.blendEquation(blendMode.equation);\r\n\r\n            if (blendMode.func.length > 2)\r\n            {\r\n                gl.blendFuncSeparate(blendMode.func[0], blendMode.func[1], blendMode.func[2], blendMode.func[3]);\r\n            }\r\n            else\r\n            {\r\n                gl.blendFunc(blendMode.func[0], blendMode.func[1]);\r\n            }\r\n\r\n            this.currentBlendMode = blendModeId;\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Creates a new custom blend mode for the renderer.\r\n     * \r\n     * See https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants#Blending_modes\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#addBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {GLenum[]} func - An array containing the WebGL functions to use for the source and the destination blending factors, respectively. See the possible constants for {@link WebGLRenderingContext#blendFunc()}.\r\n     * @param {GLenum} equation - The equation to use for combining the RGB and alpha components of a new pixel with a rendered one. See the possible constants for {@link WebGLRenderingContext#blendEquation()}.\r\n     *\r\n     * @return {integer} The index of the new blend mode, used for referencing it in the future.\r\n     */\r\n    addBlendMode: function (func, equation)\r\n    {\r\n        var index = this.blendModes.push({ func: func, equation: equation });\r\n\r\n        return index - 1;\r\n    },\r\n\r\n    /**\r\n     * Updates the function bound to a given custom blend mode.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#updateBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The index of the custom blend mode.\r\n     * @param {function} func - The function to use for the blend mode.\r\n     * @param {function} equation - The equation to use for the blend mode.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    updateBlendMode: function (index, func, equation)\r\n    {\r\n        if (this.blendModes[index])\r\n        {\r\n            this.blendModes[index].func = func;\r\n\r\n            if (equation)\r\n            {\r\n                this.blendModes[index].equation = equation;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a custom blend mode from the renderer.\r\n     * Any Game Objects still using this blend mode will error, so be sure to clear them first.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#removeBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The index of the custom blend mode to be removed.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    removeBlendMode: function (index)\r\n    {\r\n        if (index > 17 && this.blendModes[index])\r\n        {\r\n            this.blendModes.splice(index, 1);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current active texture for texture unit zero to be a blank texture.\r\n     * This only happens if there isn't a texture already in use by texture unit zero.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setBlankTexture\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {boolean} [force=false] - Force a blank texture set, regardless of what's already bound?\r\n     */\r\n    setBlankTexture: function (force)\r\n    {\r\n        if (force === undefined) { force = false; }\r\n\r\n        if (force || this.currentActiveTextureUnit !== 0 || !this.currentTextures[0])\r\n        {\r\n            this.setTexture2D(this.blankTexture.glTexture, 0);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Binds a texture at a texture unit. If a texture is already\r\n     * bound to that unit it will force a flush on the current pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setTexture2D\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLTexture} texture - The WebGL texture that needs to be bound.\r\n     * @param {integer} textureUnit - The texture unit to which the texture will be bound.\r\n     * @param {boolean} [flush=true] - Will the current pipeline be flushed if this is a new texture, or not?\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    setTexture2D: function (texture, textureUnit, flush)\r\n    {\r\n        if (flush === undefined) { flush = true; }\r\n\r\n        var gl = this.gl;\r\n\r\n        if (texture !== this.currentTextures[textureUnit])\r\n        {\r\n            if (flush)\r\n            {\r\n                this.flush();\r\n            }\r\n\r\n            if (this.currentActiveTextureUnit !== textureUnit)\r\n            {\r\n                gl.activeTexture(gl.TEXTURE0 + textureUnit);\r\n\r\n                this.currentActiveTextureUnit = textureUnit;\r\n            }\r\n\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n            this.currentTextures[textureUnit] = texture;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Binds a framebuffer. If there was another framebuffer already bound it will force a pipeline flush.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFramebuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLFramebuffer} framebuffer - The framebuffer that needs to be bound.\r\n     * @param {boolean} [updateScissor=false] - If a framebuffer is given, set the gl scissor to match the frame buffer size? Or, if `null` given, pop the scissor from the stack.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    setFramebuffer: function (framebuffer, updateScissor)\r\n    {\r\n        if (updateScissor === undefined) { updateScissor = false; }\r\n\r\n        var gl = this.gl;\r\n\r\n        var width = this.width;\r\n        var height = this.height;\r\n\r\n        if (framebuffer !== this.currentFramebuffer)\r\n        {\r\n            if (framebuffer && framebuffer.renderTexture)\r\n            {\r\n                width = framebuffer.renderTexture.width;\r\n                height = framebuffer.renderTexture.height;\r\n            }\r\n            else\r\n            {\r\n                this.flush();\r\n            }\r\n\r\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n\r\n            gl.viewport(0, 0, width, height);\r\n\r\n            if (updateScissor)\r\n            {\r\n                if (framebuffer)\r\n                {\r\n                    this.drawingBufferHeight = height;\r\n\r\n                    this.pushScissor(0, 0, width, height);\r\n                }\r\n                else\r\n                {\r\n                    this.drawingBufferHeight = this.height;\r\n\r\n                    this.popScissor();\r\n                }\r\n            }\r\n\r\n            this.currentFramebuffer = framebuffer;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Binds a program. If there was another program already bound it will force a pipeline flush.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setProgram\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The program that needs to be bound.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    setProgram: function (program)\r\n    {\r\n        var gl = this.gl;\r\n\r\n        if (program !== this.currentProgram)\r\n        {\r\n            this.flush();\r\n\r\n            gl.useProgram(program);\r\n\r\n            this.currentProgram = program;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Bounds a vertex buffer. If there is a vertex buffer already bound it'll force a pipeline flush.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setVertexBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLBuffer} vertexBuffer - The buffer that needs to be bound.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    setVertexBuffer: function (vertexBuffer)\r\n    {\r\n        var gl = this.gl;\r\n\r\n        if (vertexBuffer !== this.currentVertexBuffer)\r\n        {\r\n            this.flush();\r\n\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n\r\n            this.currentVertexBuffer = vertexBuffer;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Bounds a index buffer. If there is a index buffer already bound it'll force a pipeline flush.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setIndexBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLBuffer} indexBuffer - The buffer the needs to be bound.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    setIndexBuffer: function (indexBuffer)\r\n    {\r\n        var gl = this.gl;\r\n\r\n        if (indexBuffer !== this.currentIndexBuffer)\r\n        {\r\n            this.flush();\r\n\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n\r\n            this.currentIndexBuffer = indexBuffer;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a texture from an image source. If the source is not valid it creates an empty texture.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createTextureFromSource\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} source - The source of the texture.\r\n     * @param {integer} width - The width of the texture.\r\n     * @param {integer} height - The height of the texture.\r\n     * @param {integer} scaleMode - The scale mode to be used by the texture.\r\n     *\r\n     * @return {?WebGLTexture} The WebGL Texture that was created, or `null` if it couldn't be created.\r\n     */\r\n    createTextureFromSource: function (source, width, height, scaleMode)\r\n    {\r\n        var gl = this.gl;\r\n        var minFilter = gl.NEAREST;\r\n        var magFilter = gl.NEAREST;\r\n        var wrap = gl.CLAMP_TO_EDGE;\r\n        var texture = null;\r\n\r\n        width = source ? source.width : width;\r\n        height = source ? source.height : height;\r\n\r\n        var pow = IsSizePowerOfTwo(width, height);\r\n\r\n        if (pow)\r\n        {\r\n            wrap = gl.REPEAT;\r\n        }\r\n\r\n        if (scaleMode === CONST.ScaleModes.LINEAR && this.config.antialias)\r\n        {\r\n            minFilter = (pow) ? this.mipmapFilter : gl.LINEAR;\r\n            magFilter = gl.LINEAR;\r\n        }\r\n\r\n        if (!source && typeof width === 'number' && typeof height === 'number')\r\n        {\r\n            texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, null, width, height);\r\n        }\r\n        else\r\n        {\r\n            texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, source);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * A wrapper for creating a WebGLTexture. If no pixel data is passed it will create an empty texture.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createTexture2D\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} mipLevel - Mip level of the texture.\r\n     * @param {integer} minFilter - Filtering of the texture.\r\n     * @param {integer} magFilter - Filtering of the texture.\r\n     * @param {integer} wrapT - Wrapping mode of the texture.\r\n     * @param {integer} wrapS - Wrapping mode of the texture.\r\n     * @param {integer} format - Which format does the texture use.\r\n     * @param {?object} pixels - pixel data.\r\n     * @param {integer} width - Width of the texture in pixels.\r\n     * @param {integer} height - Height of the texture in pixels.\r\n     * @param {boolean} [pma=true] - Does the texture have premultiplied alpha?\r\n     * @param {boolean} [forceSize=false] - If `true` it will use the width and height passed to this method, regardless of the pixels dimension.\r\n     * @param {boolean} [flipY=false] - Sets the `UNPACK_FLIP_Y_WEBGL` flag the WebGL Texture uses during upload.\r\n     *\r\n     * @return {WebGLTexture} The WebGLTexture that was created.\r\n     */\r\n    createTexture2D: function (mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height, pma, forceSize, flipY)\r\n    {\r\n        pma = (pma === undefined || pma === null) ? true : pma;\r\n        if (forceSize === undefined) { forceSize = false; }\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        var gl = this.gl;\r\n        var texture = gl.createTexture();\r\n\r\n        this.setTexture2D(texture, 0);\r\n\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\r\n\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, pma);\r\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\r\n\r\n        if (pixels === null || pixels === undefined)\r\n        {\r\n            gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, width, height, 0, format, gl.UNSIGNED_BYTE, null);\r\n        }\r\n        else\r\n        {\r\n            if (!forceSize)\r\n            {\r\n                width = pixels.width;\r\n                height = pixels.height;\r\n            }\r\n\r\n            gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, format, gl.UNSIGNED_BYTE, pixels);\r\n        }\r\n\r\n        if (IsSizePowerOfTwo(width, height))\r\n        {\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n        }\r\n\r\n        this.setTexture2D(null, 0);\r\n\r\n        texture.isAlphaPremultiplied = pma;\r\n        texture.isRenderTexture = false;\r\n        texture.width = width;\r\n        texture.height = height;\r\n\r\n        this.nativeTextures.push(texture);\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Wrapper for creating WebGLFramebuffer.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createFramebuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} width - Width in pixels of the framebuffer\r\n     * @param {integer} height - Height in pixels of the framebuffer\r\n     * @param {WebGLTexture} renderTexture - The color texture to where the color pixels are written\r\n     * @param {boolean} addDepthStencilBuffer - Indicates if the current framebuffer support depth and stencil buffers\r\n     *\r\n     * @return {WebGLFramebuffer} Raw WebGLFramebuffer\r\n     */\r\n    createFramebuffer: function (width, height, renderTexture, addDepthStencilBuffer)\r\n    {\r\n        var gl = this.gl;\r\n        var framebuffer = gl.createFramebuffer();\r\n        var complete = 0;\r\n\r\n        this.setFramebuffer(framebuffer);\r\n\r\n        if (addDepthStencilBuffer)\r\n        {\r\n            var depthStencilBuffer = gl.createRenderbuffer();\r\n            gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);\r\n            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);\r\n            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilBuffer);\r\n        }\r\n\r\n        renderTexture.isRenderTexture = true;\r\n        renderTexture.isAlphaPremultiplied = false;\r\n\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);\r\n\r\n        complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\r\n\r\n        if (complete !== gl.FRAMEBUFFER_COMPLETE)\r\n        {\r\n            var errors = {\r\n                36054: 'Incomplete Attachment',\r\n                36055: 'Missing Attachment',\r\n                36057: 'Incomplete Dimensions',\r\n                36061: 'Framebuffer Unsupported'\r\n            };\r\n\r\n            throw new Error('Framebuffer incomplete. Framebuffer status: ' + errors[complete]);\r\n        }\r\n\r\n        framebuffer.renderTexture = renderTexture;\r\n\r\n        this.setFramebuffer(null);\r\n\r\n        return framebuffer;\r\n    },\r\n\r\n    /**\r\n     * Wrapper for creating a WebGLProgram\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createProgram\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} vertexShader - Source to the vertex shader\r\n     * @param {string} fragmentShader - Source to the fragment shader\r\n     *\r\n     * @return {WebGLProgram} Raw WebGLProgram\r\n     */\r\n    createProgram: function (vertexShader, fragmentShader)\r\n    {\r\n        var gl = this.gl;\r\n        var program = gl.createProgram();\r\n        var vs = gl.createShader(gl.VERTEX_SHADER);\r\n        var fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n\r\n        gl.shaderSource(vs, vertexShader);\r\n        gl.shaderSource(fs, fragmentShader);\r\n        gl.compileShader(vs);\r\n        gl.compileShader(fs);\r\n\r\n        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))\r\n        {\r\n            throw new Error('Failed to compile Vertex Shader:\\n' + gl.getShaderInfoLog(vs));\r\n        }\r\n        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))\r\n        {\r\n            throw new Error('Failed to compile Fragment Shader:\\n' + gl.getShaderInfoLog(fs));\r\n        }\r\n\r\n        gl.attachShader(program, vs);\r\n        gl.attachShader(program, fs);\r\n        gl.linkProgram(program);\r\n\r\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS))\r\n        {\r\n            throw new Error('Failed to link program:\\n' + gl.getProgramInfoLog(program));\r\n        }\r\n\r\n        return program;\r\n    },\r\n\r\n    /**\r\n     * Wrapper for creating a vertex buffer.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createVertexBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArrayBuffer} initialDataOrSize - It's either ArrayBuffer or an integer indicating the size of the vbo\r\n     * @param {integer} bufferUsage - How the buffer is used. gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW\r\n     *\r\n     * @return {WebGLBuffer} Raw vertex buffer\r\n     */\r\n    createVertexBuffer: function (initialDataOrSize, bufferUsage)\r\n    {\r\n        var gl = this.gl;\r\n        var vertexBuffer = gl.createBuffer();\r\n\r\n        this.setVertexBuffer(vertexBuffer);\r\n\r\n        gl.bufferData(gl.ARRAY_BUFFER, initialDataOrSize, bufferUsage);\r\n\r\n        this.setVertexBuffer(null);\r\n\r\n        return vertexBuffer;\r\n    },\r\n\r\n    /**\r\n     * Wrapper for creating a vertex buffer.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createIndexBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArrayBuffer} initialDataOrSize - Either ArrayBuffer or an integer indicating the size of the vbo.\r\n     * @param {integer} bufferUsage - How the buffer is used. gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW.\r\n     *\r\n     * @return {WebGLBuffer} Raw index buffer\r\n     */\r\n    createIndexBuffer: function (initialDataOrSize, bufferUsage)\r\n    {\r\n        var gl = this.gl;\r\n        var indexBuffer = gl.createBuffer();\r\n\r\n        this.setIndexBuffer(indexBuffer);\r\n\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, initialDataOrSize, bufferUsage);\r\n\r\n        this.setIndexBuffer(null);\r\n\r\n        return indexBuffer;\r\n    },\r\n\r\n    /**\r\n     * Removes the given texture from the nativeTextures array and then deletes it from the GPU.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLTexture} texture - The WebGL Texture to be deleted.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    deleteTexture: function (texture)\r\n    {\r\n        var index = this.nativeTextures.indexOf(texture);\r\n\r\n        if (index !== -1)\r\n        {\r\n            SpliceOne(this.nativeTextures, index);\r\n        }\r\n\r\n        this.gl.deleteTexture(texture);\r\n\r\n        if (this.currentTextures[0] === texture && !this.game.pendingDestroy)\r\n        {\r\n            //  texture we just deleted is in use, so bind a blank texture\r\n            this.setBlankTexture(true);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Deletes a WebGLFramebuffer from the GL instance.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteFramebuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLFramebuffer} framebuffer - The Framebuffer to be deleted.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    deleteFramebuffer: function (framebuffer)\r\n    {\r\n        this.gl.deleteFramebuffer(framebuffer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Deletes a WebGLProgram from the GL instance.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteProgram\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The shader program to be deleted.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    deleteProgram: function (program)\r\n    {\r\n        this.gl.deleteProgram(program);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Deletes a WebGLBuffer from the GL instance.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLBuffer} vertexBuffer - The WebGLBuffer to be deleted.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    deleteBuffer: function (buffer)\r\n    {\r\n        this.gl.deleteBuffer(buffer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Controls the pre-render operations for the given camera.\r\n     * Handles any clipping needed by the camera and renders the background color if a color is visible.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#preRenderCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to pre-render.\r\n     */\r\n    preRenderCamera: function (camera)\r\n    {\r\n        var cx = camera._cx;\r\n        var cy = camera._cy;\r\n        var cw = camera._cw;\r\n        var ch = camera._ch;\r\n\r\n        var TextureTintPipeline = this.pipelines.TextureTintPipeline;\r\n\r\n        var color = camera.backgroundColor;\r\n\r\n        if (camera.renderToTexture)\r\n        {\r\n            this.flush();\r\n\r\n            this.pushScissor(cx, cy, cw, -ch);\r\n\r\n            this.setFramebuffer(camera.framebuffer);\r\n\r\n            var gl = this.gl;\r\n\r\n            gl.clearColor(0, 0, 0, 0);\r\n\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n            TextureTintPipeline.projOrtho(cx, cw + cx, cy, ch + cy, -1000, 1000);\r\n\r\n            if (camera.mask)\r\n            {\r\n                this.currentCameraMask.mask = camera.mask;\r\n                this.currentCameraMask.camera = camera._maskCamera;\r\n\r\n                camera.mask.preRenderWebGL(this, camera, camera._maskCamera);\r\n            }\r\n\r\n            if (color.alphaGL > 0)\r\n            {\r\n                TextureTintPipeline.drawFillRect(\r\n                    cx, cy, cw + cx, ch + cy,\r\n                    Utils.getTintFromFloats(color.redGL, color.greenGL, color.blueGL, 1),\r\n                    color.alphaGL\r\n                );\r\n            }\r\n            \r\n            camera.emit(CameraEvents.PRE_RENDER, camera);\r\n        }\r\n        else\r\n        {\r\n            this.pushScissor(cx, cy, cw, ch);\r\n\r\n            if (camera.mask)\r\n            {\r\n                this.currentCameraMask.mask = camera.mask;\r\n                this.currentCameraMask.camera = camera._maskCamera;\r\n\r\n                camera.mask.preRenderWebGL(this, camera, camera._maskCamera);\r\n            }\r\n\r\n            if (color.alphaGL > 0)\r\n            {\r\n                TextureTintPipeline.drawFillRect(\r\n                    cx, cy, cw , ch,\r\n                    Utils.getTintFromFloats(color.redGL, color.greenGL, color.blueGL, 1),\r\n                    color.alphaGL\r\n                );\r\n            }\r\n        }\r\n    },\r\n\r\n    getCurrentStencilMask: function ()\r\n    {\r\n        var prev = null;\r\n        var stack = this.maskStack;\r\n        var cameraMask = this.currentCameraMask;\r\n\r\n        if (stack.length > 0)\r\n        {\r\n            prev = stack[stack.length - 1];\r\n        }\r\n        else if (cameraMask.mask && cameraMask.mask.isStencil)\r\n        {\r\n            prev = cameraMask;\r\n        }\r\n\r\n        return prev;\r\n    },\r\n\r\n    /**\r\n     * Controls the post-render operations for the given camera.\r\n     * Renders the foreground camera effects like flash and fading. It resets the current scissor state.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#postRenderCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to post-render.\r\n     */\r\n    postRenderCamera: function (camera)\r\n    {\r\n        var TextureTintPipeline = this.pipelines.TextureTintPipeline;\r\n\r\n        camera.flashEffect.postRenderWebGL(TextureTintPipeline, Utils.getTintFromFloats);\r\n        camera.fadeEffect.postRenderWebGL(TextureTintPipeline, Utils.getTintFromFloats);\r\n\r\n        camera.dirty = false;\r\n\r\n        this.popScissor();\r\n\r\n        if (camera.renderToTexture)\r\n        {\r\n            TextureTintPipeline.flush();\r\n\r\n            this.setFramebuffer(null);\r\n\r\n            camera.emit(CameraEvents.POST_RENDER, camera);\r\n\r\n            TextureTintPipeline.projOrtho(0, TextureTintPipeline.width, TextureTintPipeline.height, 0, -1000.0, 1000.0);\r\n\r\n            var getTint = Utils.getTintAppendFloatAlpha;\r\n\r\n            var pipeline = (camera.pipeline) ? camera.pipeline : TextureTintPipeline;\r\n\r\n            pipeline.batchTexture(\r\n                camera,\r\n                camera.glTexture,\r\n                camera.width, camera.height,\r\n                camera.x, camera.y,\r\n                camera.width, camera.height,\r\n                camera.zoom, camera.zoom,\r\n                camera.rotation,\r\n                camera.flipX, !camera.flipY,\r\n                1, 1,\r\n                0, 0,\r\n                0, 0, camera.width, camera.height,\r\n                getTint(camera._tintTL, camera._alphaTL),\r\n                getTint(camera._tintTR, camera._alphaTR),\r\n                getTint(camera._tintBL, camera._alphaBL),\r\n                getTint(camera._tintBR, camera._alphaBR),\r\n                (camera._isTinted && camera.tintFill),\r\n                0, 0,\r\n                this.defaultCamera,\r\n                null\r\n            );\r\n\r\n            //  Force clear the current texture so that items next in the batch (like Graphics) don't try and use it\r\n            this.setBlankTexture(true);\r\n        }\r\n\r\n        if (camera.mask)\r\n        {\r\n            this.currentCameraMask.mask = null;\r\n\r\n            camera.mask.postRenderWebGL(this, camera._maskCamera);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Clears the current vertex buffer and updates pipelines.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#preRender\r\n     * @since 3.0.0\r\n     */\r\n    preRender: function ()\r\n    {\r\n        if (this.contextLost) { return; }\r\n\r\n        var gl = this.gl;\r\n        var pipelines = this.pipelines;\r\n\r\n        //  Make sure we are bound to the main frame buffer\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n\r\n        if (this.config.clearBeforeRender)\r\n        {\r\n            var clearColor = this.config.backgroundColor;\r\n\r\n            gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);\r\n\r\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\r\n        }\r\n\r\n        gl.enable(gl.SCISSOR_TEST);\r\n\r\n        for (var key in pipelines)\r\n        {\r\n            pipelines[key].onPreRender();\r\n        }\r\n\r\n        //  TODO - Find a way to stop needing to create these arrays every frame\r\n        //  and equally not need a huge array buffer created to hold them\r\n\r\n        this.currentScissor = [ 0, 0, this.width, this.height ];\r\n        this.scissorStack = [ this.currentScissor ];\r\n\r\n        if (this.game.scene.customViewports)\r\n        {\r\n            gl.scissor(0, (this.drawingBufferHeight - this.height), this.width, this.height);\r\n        }\r\n\r\n        this.currentMask.mask = null;\r\n        this.currentCameraMask.mask = null;\r\n        this.maskStack.length = 0;\r\n\r\n        this.setPipeline(this.pipelines.TextureTintPipeline);\r\n    },\r\n\r\n    /**\r\n     * The core render step for a Scene Camera.\r\n     * \r\n     * Iterates through the given Game Object's array and renders them with the given Camera.\r\n     * \r\n     * This is called by the `CameraManager.render` method. The Camera Manager instance belongs to a Scene, and is invoked\r\n     * by the Scene Systems.render method.\r\n     * \r\n     * This method is not called if `Camera.visible` is `false`, or `Camera.alpha` is zero.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#render\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene to render.\r\n     * @param {Phaser.GameObjects.GameObject} children - The Game Object's within the Scene to be rendered.\r\n     * @param {number} interpolationPercentage - The interpolation percentage to apply. Currently un-used.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera to render with.\r\n     */\r\n    render: function (scene, children, interpolationPercentage, camera)\r\n    {\r\n        if (this.contextLost) { return; }\r\n\r\n        var list = children.list;\r\n        var childCount = list.length;\r\n        var pipelines = this.pipelines;\r\n\r\n        for (var key in pipelines)\r\n        {\r\n            pipelines[key].onRender(scene, camera);\r\n        }\r\n\r\n        //   Apply scissor for cam region + render background color, if not transparent\r\n        this.preRenderCamera(camera);\r\n\r\n        //  Nothing to render, so bail out\r\n        if (childCount === 0)\r\n        {\r\n            this.setBlendMode(CONST.BlendModes.NORMAL);\r\n\r\n            //  Applies camera effects and pops the scissor, if set\r\n            this.postRenderCamera(camera);\r\n\r\n            return;\r\n        }\r\n\r\n        //  Reset the current type\r\n        this.currentType = '';\r\n            \r\n        var current = this.currentMask;\r\n\r\n        for (var i = 0; i < childCount; i++)\r\n        {\r\n            var child = list[i];\r\n\r\n            if (!child.willRender(camera))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (child.blendMode !== this.currentBlendMode)\r\n            {\r\n                this.setBlendMode(child.blendMode);\r\n            }\r\n\r\n            var mask = child.mask;\r\n\r\n            current = this.currentMask;\r\n\r\n            if (current.mask && current.mask !== mask)\r\n            {\r\n                //  Render out the previously set mask\r\n                current.mask.postRenderWebGL(this, current.camera);\r\n            }\r\n\r\n            if (mask && current.mask !== mask)\r\n            {\r\n                mask.preRenderWebGL(this, child, camera);\r\n            }\r\n\r\n            var type = child.type;\r\n\r\n            if (type !== this.currentType)\r\n            {\r\n                this.newType = true;\r\n                this.currentType = type;\r\n            }\r\n\r\n            this.nextTypeMatch = (i < childCount - 1) ? (list[i + 1].type === this.currentType) : false;\r\n\r\n            child.renderWebGL(this, child, interpolationPercentage, camera);\r\n\r\n            this.newType = false;\r\n        }\r\n\r\n        current = this.currentMask;\r\n\r\n        if (current.mask)\r\n        {\r\n            //  Render out the previously set mask, if it was the last item in the display list\r\n            current.mask.postRenderWebGL(this, current.camera);\r\n        }\r\n\r\n        this.setBlendMode(CONST.BlendModes.NORMAL);\r\n\r\n        //  Applies camera effects and pops the scissor, if set\r\n        this.postRenderCamera(camera);\r\n    },\r\n\r\n    /**\r\n     * The post-render step happens after all Cameras in all Scenes have been rendered.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#postRender\r\n     * @since 3.0.0\r\n     */\r\n    postRender: function ()\r\n    {\r\n        if (this.contextLost) { return; }\r\n\r\n        this.flush();\r\n\r\n        // Unbind custom framebuffer here\r\n\r\n        var state = this.snapshotState;\r\n\r\n        if (state.callback)\r\n        {\r\n            WebGLSnapshot(this.canvas, state);\r\n\r\n            state.callback = null;\r\n        }\r\n\r\n        var pipelines = this.pipelines;\r\n\r\n        for (var key in pipelines)\r\n        {\r\n            pipelines[key].onPostRender();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the entire game viewport to be taken after the current frame is rendered.\r\n     * \r\n     * To capture a specific area see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.\r\n     * \r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n     * calling this method will override it.\r\n     * \r\n     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshot: function (callback, type, encoderOptions)\r\n    {\r\n        return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, callback, type, encoderOptions);\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the given area of the game viewport to be taken after the current frame is rendered.\r\n     * \r\n     * To capture the whole game viewport see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.\r\n     * \r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n     * calling this method will override it.\r\n     * \r\n     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshotArea\r\n     * @since 3.16.0\r\n     *\r\n     * @param {integer} x - The x coordinate to grab from.\r\n     * @param {integer} y - The y coordinate to grab from.\r\n     * @param {integer} width - The width of the area to grab.\r\n     * @param {integer} height - The height of the area to grab.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshotArea: function (x, y, width, height, callback, type, encoderOptions)\r\n    {\r\n        var state = this.snapshotState;\r\n\r\n        state.callback = callback;\r\n        state.type = type;\r\n        state.encoder = encoderOptions;\r\n        state.getPixel = false;\r\n        state.x = x;\r\n        state.y = y;\r\n        state.width = Math.min(width, this.gl.drawingBufferWidth);\r\n        state.height = Math.min(height, this.gl.drawingBufferHeight);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the given pixel from the game viewport to be taken after the current frame is rendered.\r\n     * \r\n     * To capture the whole game viewport see the `snapshot` method. To capture a specific area, see `snapshotArea`.\r\n     * \r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotArea`, for example, then\r\n     * calling this method will override it.\r\n     * \r\n     * Unlike the other two snapshot methods, this one will return a `Color` object containing the color data for\r\n     * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,\r\n     * using less memory.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshotPixel\r\n     * @since 3.16.0\r\n     *\r\n     * @param {integer} x - The x coordinate of the pixel to get.\r\n     * @param {integer} y - The y coordinate of the pixel to get.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshotPixel: function (x, y, callback)\r\n    {\r\n        this.snapshotArea(x, y, 1, 1, callback);\r\n\r\n        this.snapshotState.getPixel = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the given area of the given frame buffer.\r\n     * \r\n     * Unlike the other snapshot methods, this one is processed immediately and doesn't wait for the next render.\r\n     * \r\n     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshotFramebuffer\r\n     * @since 3.19.0\r\n     *\r\n     * @param {WebGLFramebuffer} framebuffer - The framebuffer to grab from.\r\n     * @param {integer} bufferWidth - The width of the framebuffer.\r\n     * @param {integer} bufferHeight - The height of the framebuffer.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {boolean} [getPixel=false] - Grab a single pixel as a Color object, or an area as an Image object?\r\n     * @param {integer} [x=0] - The x coordinate to grab from.\r\n     * @param {integer} [y=0] - The y coordinate to grab from.\r\n     * @param {integer} [width=bufferWidth] - The width of the area to grab.\r\n     * @param {integer} [height=bufferHeight] - The height of the area to grab.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshotFramebuffer: function (framebuffer, bufferWidth, bufferHeight, callback, getPixel, x, y, width, height, type, encoderOptions)\r\n    {\r\n        if (getPixel === undefined) { getPixel = false; }\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = bufferWidth; }\r\n        if (height === undefined) { height = bufferHeight; }\r\n\r\n        var currentFramebuffer = this.currentFramebuffer;\r\n\r\n        this.snapshotArea(x, y, width, height, callback, type, encoderOptions);\r\n\r\n        var state = this.snapshotState;\r\n\r\n        state.getPixel = getPixel;\r\n\r\n        state.isFramebuffer = true;\r\n        state.bufferWidth = bufferWidth;\r\n        state.bufferHeight = bufferHeight;\r\n\r\n        this.setFramebuffer(framebuffer);\r\n\r\n        WebGLSnapshot(this.canvas, state);\r\n\r\n        this.setFramebuffer(currentFramebuffer);\r\n\r\n        state.callback = null;\r\n        state.isFramebuffer = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a new WebGL Texture based on the given Canvas Element.\r\n     * \r\n     * If the `dstTexture` parameter is given, the WebGL Texture is updated, rather than created fresh.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#canvasToTexture\r\n     * @since 3.0.0\r\n     * \r\n     * @param {HTMLCanvasElement} srcCanvas - The Canvas to create the WebGL Texture from\r\n     * @param {WebGLTexture} [dstTexture] - The destination WebGL Texture to set.\r\n     * @param {boolean} [noRepeat=false] - Should this canvas be allowed to set `REPEAT` (such as for Text objects?)\r\n     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?\r\n     * \r\n     * @return {WebGLTexture} The newly created, or updated, WebGL Texture.\r\n     */\r\n    canvasToTexture: function (srcCanvas, dstTexture, noRepeat, flipY)\r\n    {\r\n        if (noRepeat === undefined) { noRepeat = false; }\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        if (!dstTexture)\r\n        {\r\n            return this.createCanvasTexture(srcCanvas, noRepeat, flipY);\r\n        }\r\n        else\r\n        {\r\n            return this.updateCanvasTexture(srcCanvas, dstTexture, flipY);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a new WebGL Texture based on the given Canvas Element.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createCanvasTexture\r\n     * @since 3.20.0\r\n     * \r\n     * @param {HTMLCanvasElement} srcCanvas - The Canvas to create the WebGL Texture from\r\n     * @param {boolean} [noRepeat=false] - Should this canvas be allowed to set `REPEAT` (such as for Text objects?)\r\n     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?\r\n     * \r\n     * @return {WebGLTexture} The newly created WebGL Texture.\r\n     */\r\n    createCanvasTexture: function (srcCanvas, noRepeat, flipY)\r\n    {\r\n        if (noRepeat === undefined) { noRepeat = false; }\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        var gl = this.gl;\r\n        var minFilter = gl.NEAREST;\r\n        var magFilter = gl.NEAREST;\r\n\r\n        var width = srcCanvas.width;\r\n        var height = srcCanvas.height;\r\n\r\n        var wrapping = gl.CLAMP_TO_EDGE;\r\n\r\n        var pow = IsSizePowerOfTwo(width, height);\r\n\r\n        if (!noRepeat && pow)\r\n        {\r\n            wrapping = gl.REPEAT;\r\n        }\r\n\r\n        if (this.config.antialias)\r\n        {\r\n            minFilter = (pow) ? this.mipmapFilter : gl.LINEAR;\r\n            magFilter = gl.LINEAR;\r\n        }\r\n\r\n        return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcCanvas, width, height, true, false, flipY);\r\n    },\r\n\r\n    /**\r\n     * Updates a WebGL Texture based on the given Canvas Element.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#updateCanvasTexture\r\n     * @since 3.20.0\r\n     * \r\n     * @param {HTMLCanvasElement} srcCanvas - The Canvas to update the WebGL Texture from.\r\n     * @param {WebGLTexture} dstTexture - The destination WebGL Texture to update.\r\n     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?\r\n     * \r\n     * @return {WebGLTexture} The updated WebGL Texture.\r\n     */\r\n    updateCanvasTexture: function (srcCanvas, dstTexture, flipY)\r\n    {\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        var gl = this.gl;\r\n\r\n        var width = srcCanvas.width;\r\n        var height = srcCanvas.height;\r\n\r\n        if (width > 0 && height > 0)\r\n        {\r\n            this.setTexture2D(dstTexture, 0);\r\n\r\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\r\n\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);\r\n    \r\n            dstTexture.width = width;\r\n            dstTexture.height = height;\r\n    \r\n            this.setTexture2D(null, 0);\r\n        }\r\n\r\n        return dstTexture;\r\n    },\r\n\r\n    /**\r\n     * Creates a new WebGL Texture based on the given HTML Video Element.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createVideoTexture\r\n     * @since 3.20.0\r\n     * \r\n     * @param {HTMLVideoElement} srcVideo - The Video to create the WebGL Texture from\r\n     * @param {boolean} [noRepeat=false] - Should this canvas be allowed to set `REPEAT`?\r\n     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?\r\n     * \r\n     * @return {WebGLTexture} The newly created WebGL Texture.\r\n     */\r\n    createVideoTexture: function (srcVideo, noRepeat, flipY)\r\n    {\r\n        if (noRepeat === undefined) { noRepeat = false; }\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        var gl = this.gl;\r\n        var minFilter = gl.NEAREST;\r\n        var magFilter = gl.NEAREST;\r\n\r\n        var width = srcVideo.videoWidth;\r\n        var height = srcVideo.videoHeight;\r\n\r\n        var wrapping = gl.CLAMP_TO_EDGE;\r\n\r\n        var pow = IsSizePowerOfTwo(width, height);\r\n\r\n        if (!noRepeat && pow)\r\n        {\r\n            wrapping = gl.REPEAT;\r\n        }\r\n\r\n        if (this.config.antialias)\r\n        {\r\n            minFilter = (pow) ? this.mipmapFilter : gl.LINEAR;\r\n            magFilter = gl.LINEAR;\r\n        }\r\n\r\n        return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcVideo, width, height, true, true, flipY);\r\n    },\r\n\r\n    /**\r\n     * Updates a WebGL Texture based on the given HTML Video Element.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#updateVideoTexture\r\n     * @since 3.20.0\r\n     * \r\n     * @param {HTMLVideoElement} srcVideo - The Video to update the WebGL Texture with.\r\n     * @param {WebGLTexture} dstTexture - The destination WebGL Texture to update.\r\n     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?\r\n     * \r\n     * @return {WebGLTexture} The updated WebGL Texture.\r\n     */\r\n    updateVideoTexture: function (srcVideo, dstTexture, flipY)\r\n    {\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        var gl = this.gl;\r\n\r\n        var width = srcVideo.videoWidth;\r\n        var height = srcVideo.videoHeight;\r\n\r\n        if (width > 0 && height > 0)\r\n        {\r\n            this.setTexture2D(dstTexture, 0);\r\n\r\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\r\n\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcVideo);\r\n\r\n            dstTexture.width = width;\r\n            dstTexture.height = height;\r\n\r\n            this.setTexture2D(null, 0);\r\n        }\r\n\r\n        return dstTexture;\r\n    },\r\n\r\n    /**\r\n     * Sets the minification and magnification filter for a texture.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setTextureFilter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} texture - The texture to set the filter for.\r\n     * @param {integer} filter - The filter to set. 0 for linear filtering, 1 for nearest neighbor (blocky) filtering.\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setTextureFilter: function (texture, filter)\r\n    {\r\n        var gl = this.gl;\r\n        var glFilter = [ gl.LINEAR, gl.NEAREST ][filter];\r\n\r\n        this.setTexture2D(texture, 0);\r\n\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter);\r\n\r\n        this.setTexture2D(null, 0);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat1\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {number} x - [description]\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setFloat1: function (program, name, x)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform1f(this.gl.getUniformLocation(program, name), x);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat2\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setFloat2: function (program, name, x, y)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform2f(this.gl.getUniformLocation(program, name), x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} z - [description]\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setFloat3: function (program, name, x, y, z)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform3f(this.gl.getUniformLocation(program, name), x, y, z);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets uniform of a WebGLProgram\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {number} x - X component\r\n     * @param {number} y - Y component\r\n     * @param {number} z - Z component\r\n     * @param {number} w - W component\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setFloat4: function (program, name, x, y, z, w)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform4f(this.gl.getUniformLocation(program, name), x, y, z, w);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat1v\r\n     * @since 3.13.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {Float32Array} arr - The new value to be used for the uniform variable.\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setFloat1v: function (program, name, arr)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform1fv(this.gl.getUniformLocation(program, name), arr);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat2v\r\n     * @since 3.13.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {Float32Array} arr - The new value to be used for the uniform variable.\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setFloat2v: function (program, name, arr)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform2fv(this.gl.getUniformLocation(program, name), arr);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat3v\r\n     * @since 3.13.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {Float32Array} arr - The new value to be used for the uniform variable.\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setFloat3v: function (program, name, arr)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform3fv(this.gl.getUniformLocation(program, name), arr);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat4v\r\n     * @since 3.13.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {Float32Array} arr - The new value to be used for the uniform variable.\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n\r\n    setFloat4v: function (program, name, arr)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform4fv(this.gl.getUniformLocation(program, name), arr);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt1\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {integer} x - [description]\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setInt1: function (program, name, x)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform1i(this.gl.getUniformLocation(program, name), x);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt2\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {integer} x - The new X component\r\n     * @param {integer} y - The new Y component\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setInt2: function (program, name, x, y)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform2i(this.gl.getUniformLocation(program, name), x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {integer} x - The new X component\r\n     * @param {integer} y - The new Y component\r\n     * @param {integer} z - The new Z component\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setInt3: function (program, name, x, y, z)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform3i(this.gl.getUniformLocation(program, name), x, y, z);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {integer} x - X component\r\n     * @param {integer} y - Y component\r\n     * @param {integer} z - Z component\r\n     * @param {integer} w - W component\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setInt4: function (program, name, x, y, z, w)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform4i(this.gl.getUniformLocation(program, name), x, y, z, w);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a 2x2 matrix uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix2\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {boolean} transpose - The value indicating whether to transpose the matrix. Must be false.\r\n     * @param {Float32Array} matrix - The new matrix value.\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setMatrix2: function (program, name, transpose, matrix)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniformMatrix2fv(this.gl.getUniformLocation(program, name), transpose, matrix);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {boolean} transpose - [description]\r\n     * @param {Float32Array} matrix - [description]\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setMatrix3: function (program, name, transpose, matrix)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniformMatrix3fv(this.gl.getUniformLocation(program, name), transpose, matrix);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets uniform of a WebGLProgram\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {boolean} transpose - Is the matrix transposed\r\n     * @param {Float32Array} matrix - Matrix data\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setMatrix4: function (program, name, transpose, matrix)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniformMatrix4fv(this.gl.getUniformLocation(program, name), transpose, matrix);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the maximum number of texture units that can be used in a fragment shader.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#getMaxTextures\r\n     * @since 3.8.0\r\n     *\r\n     * @return {integer} The maximum number of textures WebGL supports.\r\n     */\r\n    getMaxTextures: function ()\r\n    {\r\n        return this.config.maxTextures;\r\n    },\r\n\r\n    /**\r\n     * Returns the largest texture size (either width or height) that can be created.\r\n     * Note that VRAM may not allow a texture of any given size, it just expresses\r\n     * hardware / driver support for a given size.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#getMaxTextureSize\r\n     * @since 3.8.0\r\n     *\r\n     * @return {integer} The maximum supported texture size.\r\n     */\r\n    getMaxTextureSize: function ()\r\n    {\r\n        return this.config.maxTextureSize;\r\n    },\r\n\r\n    /**\r\n     * Destroy this WebGLRenderer, cleaning up all related resources such as pipelines, native textures, etc.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        //  Clear-up anything that should be cleared :)\r\n\r\n        for (var i = 0; i < this.nativeTextures.length; i++)\r\n        {\r\n            this.gl.deleteTexture(this.nativeTextures[i]);\r\n        }\r\n\r\n        this.nativeTextures = [];\r\n\r\n        for (var key in this.pipelines)\r\n        {\r\n            this.pipelines[key].destroy();\r\n\r\n            delete this.pipelines[key];\r\n        }\r\n\r\n        this.defaultCamera.destroy();\r\n\r\n        this.currentMask = null;\r\n        this.currentCameraMask = null;\r\n\r\n        this.canvas.removeEventListener('webglcontextlost', this.contextLostHandler, false);\r\n        this.canvas.removeEventListener('webglcontextrestored', this.contextRestoredHandler, false);\r\n\r\n        this.game = null;\r\n        this.gl = null;\r\n        this.canvas = null;\r\n\r\n        this.maskStack = [];\r\n\r\n        this.contextLost = true;\r\n\r\n        this.extensions = {};\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = WebGLRenderer;\r\n"]},"metadata":{},"sourceType":"script"}