{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Body = require('./Body');\n\nvar Class = require('../../utils/Class');\n\nvar COLLIDES = require('./COLLIDES');\n\nvar CollisionMap = require('./CollisionMap');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar GetFastValue = require('../../utils/object/GetFastValue');\n\nvar HasValue = require('../../utils/object/HasValue');\n\nvar Set = require('../../structs/Set');\n\nvar Solver = require('./Solver');\n\nvar TILEMAP_FORMATS = require('../../tilemaps/Formats');\n\nvar TYPE = require('./TYPE');\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class World\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Physics.Impact\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Impact World instance belongs.\r\n * @param {Phaser.Types.Physics.Impact.WorldConfig} config - [description]\r\n */\n\n\nvar World = new Class({\n  Extends: EventEmitter,\n  initialize: function World(scene, config) {\n    EventEmitter.call(this);\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n\n    this.scene = scene;\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#bodies\r\n     * @type {Phaser.Structs.Set.<Phaser.Physics.Impact.Body>}\r\n     * @since 3.0.0\r\n     */\n\n    this.bodies = new Set();\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#gravity\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.gravity = GetFastValue(config, 'gravity', 0);\n    /**\r\n     * Spatial hash cell dimensions\r\n     *\r\n     * @name Phaser.Physics.Impact.World#cellSize\r\n     * @type {integer}\r\n     * @default 64\r\n     * @since 3.0.0\r\n     */\n\n    this.cellSize = GetFastValue(config, 'cellSize', 64);\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#collisionMap\r\n     * @type {Phaser.Physics.Impact.CollisionMap}\r\n     * @since 3.0.0\r\n     */\n\n    this.collisionMap = new CollisionMap();\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#timeScale\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\n\n    this.timeScale = GetFastValue(config, 'timeScale', 1);\n    /**\r\n     * Impacts maximum time step is 20 fps.\r\n     *\r\n     * @name Phaser.Physics.Impact.World#maxStep\r\n     * @type {number}\r\n     * @default 0.05\r\n     * @since 3.0.0\r\n     */\n\n    this.maxStep = GetFastValue(config, 'maxStep', 0.05);\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#enabled\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.enabled = true;\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#drawDebug\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.drawDebug = GetFastValue(config, 'debug', false);\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#debugGraphic\r\n     * @type {Phaser.GameObjects.Graphics}\r\n     * @since 3.0.0\r\n     */\n\n    this.debugGraphic;\n\n    var _maxVelocity = GetFastValue(config, 'maxVelocity', 100);\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#defaults\r\n     * @type {Phaser.Types.Physics.Impact.WorldDefaults}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.defaults = {\n      debugShowBody: GetFastValue(config, 'debugShowBody', true),\n      debugShowVelocity: GetFastValue(config, 'debugShowVelocity', true),\n      bodyDebugColor: GetFastValue(config, 'debugBodyColor', 0xff00ff),\n      velocityDebugColor: GetFastValue(config, 'debugVelocityColor', 0x00ff00),\n      maxVelocityX: GetFastValue(config, 'maxVelocityX', _maxVelocity),\n      maxVelocityY: GetFastValue(config, 'maxVelocityY', _maxVelocity),\n      minBounceVelocity: GetFastValue(config, 'minBounceVelocity', 40),\n      gravityFactor: GetFastValue(config, 'gravityFactor', 1),\n      bounciness: GetFastValue(config, 'bounciness', 0)\n    };\n    /**\r\n     * An object containing the 4 wall bodies that bound the physics world.\r\n     *\r\n     * @name Phaser.Physics.Impact.World#walls\r\n     * @type {Phaser.Types.Physics.Impact.WorldWalls}\r\n     * @since 3.0.0\r\n     */\n\n    this.walls = {\n      left: null,\n      right: null,\n      top: null,\n      bottom: null\n    };\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#delta\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.delta = 0;\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Physics.Impact.World#_lastId\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this._lastId = 0;\n\n    if (GetFastValue(config, 'setBounds', false)) {\n      var boundsConfig = config['setBounds'];\n\n      if (typeof boundsConfig === 'boolean') {\n        this.setBounds();\n      } else {\n        var x = GetFastValue(boundsConfig, 'x', 0);\n        var y = GetFastValue(boundsConfig, 'y', 0);\n        var width = GetFastValue(boundsConfig, 'width', scene.sys.scale.width);\n        var height = GetFastValue(boundsConfig, 'height', scene.sys.scale.height);\n        var thickness = GetFastValue(boundsConfig, 'thickness', 64);\n        var left = GetFastValue(boundsConfig, 'left', true);\n        var right = GetFastValue(boundsConfig, 'right', true);\n        var top = GetFastValue(boundsConfig, 'top', true);\n        var bottom = GetFastValue(boundsConfig, 'bottom', true);\n        this.setBounds(x, y, width, height, thickness, left, right, top, bottom);\n      }\n    }\n\n    if (this.drawDebug) {\n      this.createDebugGraphic();\n    }\n  },\n\n  /**\r\n   * Sets the collision map for the world either from a Weltmeister JSON level in the cache or from\r\n   * a 2D array. If loading from a Weltmeister level, the map must have a layer called \"collision\".\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setCollisionMap\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|integer[][])} key - Either a string key that corresponds to a Weltmeister level\r\n   * in the cache, or a 2D array of collision IDs.\r\n   * @param {integer} tileSize - The size of a tile. This is optional if loading from a Weltmeister\r\n   * level in the cache.\r\n   *\r\n   * @return {?Phaser.Physics.Impact.CollisionMap} The newly created CollisionMap, or null if the method failed to\r\n   * create the CollisionMap.\r\n   */\n  setCollisionMap: function (key, tileSize) {\n    if (typeof key === 'string') {\n      var tilemapData = this.scene.cache.tilemap.get(key);\n\n      if (!tilemapData || tilemapData.format !== TILEMAP_FORMATS.WELTMEISTER) {\n        console.warn('The specified key does not correspond to a Weltmeister tilemap: ' + key);\n        return null;\n      }\n\n      var layers = tilemapData.data.layer;\n      var collisionLayer;\n\n      for (var i = 0; i < layers.length; i++) {\n        if (layers[i].name === 'collision') {\n          collisionLayer = layers[i];\n          break;\n        }\n      }\n\n      if (tileSize === undefined) {\n        tileSize = collisionLayer.tilesize;\n      }\n\n      this.collisionMap = new CollisionMap(tileSize, collisionLayer.data);\n    } else if (Array.isArray(key)) {\n      this.collisionMap = new CollisionMap(tileSize, key);\n    } else {\n      console.warn('Invalid Weltmeister collision map data: ' + key);\n    }\n\n    return this.collisionMap;\n  },\n\n  /**\r\n   * Sets the collision map for the world from a tilemap layer. Only tiles that are marked as\r\n   * colliding will be used. You can specify the mapping from tiles to slope IDs in a couple of\r\n   * ways. The easiest is to use Tiled and the slopeTileProperty option. Alternatively, you can\r\n   * manually create a slopeMap that stores the mapping between tile indices and slope IDs.\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setCollisionMapFromTilemapLayer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The tilemap layer to use.\r\n   * @param {Phaser.Types.Physics.Impact.CollisionOptions} [options] - Options for controlling the mapping from tiles to slope IDs.\r\n   *\r\n   * @return {Phaser.Physics.Impact.CollisionMap} The newly created CollisionMap.\r\n   */\n  setCollisionMapFromTilemapLayer: function (tilemapLayer, options) {\n    if (options === undefined) {\n      options = {};\n    }\n\n    var slopeProperty = GetFastValue(options, 'slopeProperty', null);\n    var slopeMap = GetFastValue(options, 'slopeMap', null);\n    var collidingSlope = GetFastValue(options, 'defaultCollidingSlope', null);\n    var nonCollidingSlope = GetFastValue(options, 'defaultNonCollidingSlope', 0);\n    var layerData = tilemapLayer.layer;\n    var tileSize = layerData.baseTileWidth;\n    var collisionData = [];\n\n    for (var ty = 0; ty < layerData.height; ty++) {\n      collisionData[ty] = [];\n\n      for (var tx = 0; tx < layerData.width; tx++) {\n        var tile = layerData.data[ty][tx];\n\n        if (tile && tile.collides) {\n          if (slopeProperty !== null && HasValue(tile.properties, slopeProperty)) {\n            collisionData[ty][tx] = parseInt(tile.properties[slopeProperty], 10);\n          } else if (slopeMap !== null && HasValue(slopeMap, tile.index)) {\n            collisionData[ty][tx] = slopeMap[tile.index];\n          } else if (collidingSlope !== null) {\n            collisionData[ty][tx] = collidingSlope;\n          } else {\n            collisionData[ty][tx] = tile.index;\n          }\n        } else {\n          collisionData[ty][tx] = nonCollidingSlope;\n        }\n      }\n    }\n\n    this.collisionMap = new CollisionMap(tileSize, collisionData);\n    return this.collisionMap;\n  },\n\n  /**\r\n   * Sets the bounds of the Physics world to match the given world pixel dimensions.\r\n   * You can optionally set which 'walls' to create: left, right, top or bottom.\r\n   * If none of the walls are given it will default to use the walls settings it had previously.\r\n   * I.e. if you previously told it to not have the left or right walls, and you then adjust the world size\r\n   * the newly created bounds will also not have the left and right walls.\r\n   * Explicitly state them in the parameters to override this.\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [x] - The x coordinate of the top-left corner of the bounds.\r\n   * @param {number} [y] - The y coordinate of the top-left corner of the bounds.\r\n   * @param {number} [width] - The width of the bounds.\r\n   * @param {number} [height] - The height of the bounds.\r\n   * @param {number} [thickness=64] - [description]\r\n   * @param {boolean} [left=true] - If true will create the left bounds wall.\r\n   * @param {boolean} [right=true] - If true will create the right bounds wall.\r\n   * @param {boolean} [top=true] - If true will create the top bounds wall.\r\n   * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setBounds: function (x, y, width, height, thickness, left, right, top, bottom) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = this.scene.sys.scale.width;\n    }\n\n    if (height === undefined) {\n      height = this.scene.sys.scale.height;\n    }\n\n    if (thickness === undefined) {\n      thickness = 64;\n    }\n\n    if (left === undefined) {\n      left = true;\n    }\n\n    if (right === undefined) {\n      right = true;\n    }\n\n    if (top === undefined) {\n      top = true;\n    }\n\n    if (bottom === undefined) {\n      bottom = true;\n    }\n\n    this.updateWall(left, 'left', x - thickness, y, thickness, height);\n    this.updateWall(right, 'right', x + width, y, thickness, height);\n    this.updateWall(top, 'top', x, y - thickness, width, thickness);\n    this.updateWall(bottom, 'bottom', x, y + height, width, thickness);\n    return this;\n  },\n\n  /**\r\n   * position = 'left', 'right', 'top' or 'bottom'\r\n   *\r\n   * @method Phaser.Physics.Impact.World#updateWall\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} add - [description]\r\n   * @param {string} position - [description]\r\n   * @param {number} x - [description]\r\n   * @param {number} y - [description]\r\n   * @param {number} width - [description]\r\n   * @param {number} height - [description]\r\n   */\n  updateWall: function (add, position, x, y, width, height) {\n    var wall = this.walls[position];\n\n    if (add) {\n      if (wall) {\n        wall.resetSize(x, y, width, height);\n      } else {\n        this.walls[position] = this.create(x, y, width, height);\n        this.walls[position].name = position;\n        this.walls[position].gravityFactor = 0;\n        this.walls[position].collides = COLLIDES.FIXED;\n      }\n    } else {\n      if (wall) {\n        this.bodies.remove(wall);\n      }\n\n      this.walls[position] = null;\n    }\n  },\n\n  /**\r\n   * Creates a Graphics Game Object used for debug display and enables the world for debug drawing.\r\n   *\r\n   * @method Phaser.Physics.Impact.World#createDebugGraphic\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.GameObjects.Graphics} The Graphics object created that will have the debug visuals drawn to it.\r\n   */\n  createDebugGraphic: function () {\n    var graphic = this.scene.sys.add.graphics({\n      x: 0,\n      y: 0\n    });\n    graphic.setDepth(Number.MAX_VALUE);\n    this.debugGraphic = graphic;\n    this.drawDebug = true;\n    return graphic;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#getNextID\r\n   * @since 3.0.0\r\n   *\r\n   * @return {integer} [description]\r\n   */\n  getNextID: function () {\n    return this._lastId++;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#create\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - [description]\r\n   * @param {number} y - [description]\r\n   * @param {number} sizeX - [description]\r\n   * @param {number} sizeY - [description]\r\n   *\r\n   * @return {Phaser.Physics.Impact.Body} The Body that was added to this World.\r\n   */\n  create: function (x, y, sizeX, sizeY) {\n    var body = new Body(this, x, y, sizeX, sizeY);\n    this.bodies.set(body);\n    return body;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#remove\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body} object - The Body to remove from this World.\r\n   */\n  remove: function (object) {\n    this.bodies.delete(object);\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#pause\r\n   * @fires Phaser.Physics.Impact.Events#PAUSE\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  pause: function () {\n    this.enabled = false;\n    this.emit(Events.PAUSE);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#resume\r\n   * @fires Phaser.Physics.Impact.Events#RESUME\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  resume: function () {\n    this.enabled = true;\n    this.emit(Events.RESUME);\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#update\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n   * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n   */\n  update: function (time, delta) {\n    if (!this.enabled || this.bodies.size === 0) {\n      return;\n    } //  Impact uses a divided delta value that is clamped to the maxStep (20fps) maximum\n\n\n    var clampedDelta = Math.min(delta / 1000, this.maxStep) * this.timeScale;\n    this.delta = clampedDelta; //  Update all active bodies\n\n    var i;\n    var body;\n    var bodies = this.bodies.entries;\n    var len = bodies.length;\n    var hash = {};\n    var size = this.cellSize;\n\n    for (i = 0; i < len; i++) {\n      body = bodies[i];\n\n      if (body.enabled) {\n        body.update(clampedDelta);\n      }\n    } //  Run collision against them all now they're in the new positions from the update\n\n\n    for (i = 0; i < len; i++) {\n      body = bodies[i];\n\n      if (body && !body.skipHash()) {\n        this.checkHash(body, hash, size);\n      }\n    }\n\n    if (this.drawDebug) {\n      var graphics = this.debugGraphic;\n      graphics.clear();\n\n      for (i = 0; i < len; i++) {\n        body = bodies[i];\n\n        if (body && body.willDrawDebug()) {\n          body.drawDebug(graphics);\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Check the body against the spatial hash.\r\n   *\r\n   * @method Phaser.Physics.Impact.World#checkHash\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body} body - [description]\r\n   * @param {object} hash - [description]\r\n   * @param {number} size - [description]\r\n   */\n  checkHash: function (body, hash, size) {\n    var checked = {};\n    var xmin = Math.floor(body.pos.x / size);\n    var ymin = Math.floor(body.pos.y / size);\n    var xmax = Math.floor((body.pos.x + body.size.x) / size) + 1;\n    var ymax = Math.floor((body.pos.y + body.size.y) / size) + 1;\n\n    for (var x = xmin; x < xmax; x++) {\n      for (var y = ymin; y < ymax; y++) {\n        if (!hash[x]) {\n          hash[x] = {};\n          hash[x][y] = [body];\n        } else if (!hash[x][y]) {\n          hash[x][y] = [body];\n        } else {\n          var cell = hash[x][y];\n\n          for (var c = 0; c < cell.length; c++) {\n            if (body.touches(cell[c]) && !checked[cell[c].id]) {\n              checked[cell[c].id] = true;\n              this.checkBodies(body, cell[c]);\n            }\n          }\n\n          cell.push(body);\n        }\n      }\n    }\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#checkBodies\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body} bodyA - [description]\r\n   * @param {Phaser.Physics.Impact.Body} bodyB - [description]\r\n   */\n  checkBodies: function (bodyA, bodyB) {\n    //  2 fixed bodies won't do anything\n    if (bodyA.collides === COLLIDES.FIXED && bodyB.collides === COLLIDES.FIXED) {\n      return;\n    } //  bitwise checks\n\n\n    if (bodyA.checkAgainst & bodyB.type) {\n      bodyA.check(bodyB);\n    }\n\n    if (bodyB.checkAgainst & bodyA.type) {\n      bodyB.check(bodyA);\n    }\n\n    if (bodyA.collides && bodyB.collides && bodyA.collides + bodyB.collides > COLLIDES.ACTIVE) {\n      Solver(this, bodyA, bodyB);\n    }\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setCollidesNever\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setCollidesNever: function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].collides = COLLIDES.NEVER;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setLite\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setLite: function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].collides = COLLIDES.LITE;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setPassive\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setPassive: function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].collides = COLLIDES.PASSIVE;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setActive\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setActive: function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].collides = COLLIDES.ACTIVE;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setFixed\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setFixed: function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].collides = COLLIDES.FIXED;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setTypeNone\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setTypeNone: function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].type = TYPE.NONE;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setTypeA\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setTypeA: function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].type = TYPE.A;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setTypeB\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setTypeB: function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].type = TYPE.B;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setAvsB\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setAvsB: function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].type = TYPE.A;\n      bodies[i].checkAgainst = TYPE.B;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setBvsA\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setBvsA: function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].type = TYPE.B;\n      bodies[i].checkAgainst = TYPE.A;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setCheckAgainstNone\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setCheckAgainstNone: function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].checkAgainst = TYPE.NONE;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setCheckAgainstA\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setCheckAgainstA: function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].checkAgainst = TYPE.A;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#setCheckAgainstB\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n   *\r\n   * @return {Phaser.Physics.Impact.World} This World object.\r\n   */\n  setCheckAgainstB: function (bodies) {\n    for (var i = 0; i < bodies.length; i++) {\n      bodies[i].checkAgainst = TYPE.B;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#shutdown\r\n   * @since 3.0.0\r\n   */\n  shutdown: function () {\n    this.removeAllListeners();\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Physics.Impact.World#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.removeAllListeners();\n    this.scene = null;\n    this.bodies.clear();\n    this.bodies = null;\n    this.collisionMap = null;\n  }\n});\nmodule.exports = World;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/impact/World.js"],"names":["Body","require","Class","COLLIDES","CollisionMap","EventEmitter","Events","GetFastValue","HasValue","Set","Solver","TILEMAP_FORMATS","TYPE","World","Extends","initialize","scene","config","call","bodies","gravity","cellSize","collisionMap","timeScale","maxStep","enabled","drawDebug","debugGraphic","_maxVelocity","defaults","debugShowBody","debugShowVelocity","bodyDebugColor","velocityDebugColor","maxVelocityX","maxVelocityY","minBounceVelocity","gravityFactor","bounciness","walls","left","right","top","bottom","delta","_lastId","boundsConfig","setBounds","x","y","width","sys","scale","height","thickness","createDebugGraphic","setCollisionMap","key","tileSize","tilemapData","cache","tilemap","get","format","WELTMEISTER","console","warn","layers","data","layer","collisionLayer","i","length","name","undefined","tilesize","Array","isArray","setCollisionMapFromTilemapLayer","tilemapLayer","options","slopeProperty","slopeMap","collidingSlope","nonCollidingSlope","layerData","baseTileWidth","collisionData","ty","tx","tile","collides","properties","parseInt","index","updateWall","add","position","wall","resetSize","create","FIXED","remove","graphic","graphics","setDepth","Number","MAX_VALUE","getNextID","sizeX","sizeY","body","set","object","delete","pause","emit","PAUSE","resume","RESUME","update","time","size","clampedDelta","Math","min","entries","len","hash","skipHash","checkHash","clear","willDrawDebug","checked","xmin","floor","pos","ymin","xmax","ymax","cell","c","touches","id","checkBodies","push","bodyA","bodyB","checkAgainst","type","check","ACTIVE","setCollidesNever","NEVER","setLite","LITE","setPassive","PASSIVE","setActive","setFixed","setTypeNone","NONE","setTypeA","A","setTypeB","B","setAvsB","setBvsA","setCheckAgainstNone","setCheckAgainstA","setCheckAgainstB","shutdown","removeAllListeners","destroy","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Body = require('./Body');\r\nvar Class = require('../../utils/Class');\r\nvar COLLIDES = require('./COLLIDES');\r\nvar CollisionMap = require('./CollisionMap');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar HasValue = require('../../utils/object/HasValue');\r\nvar Set = require('../../structs/Set');\r\nvar Solver = require('./Solver');\r\nvar TILEMAP_FORMATS = require('../../tilemaps/Formats');\r\nvar TYPE = require('./TYPE');\r\n\r\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class World\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Physics.Impact\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Impact World instance belongs.\r\n * @param {Phaser.Types.Physics.Impact.WorldConfig} config - [description]\r\n */\r\nvar World = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function World (scene, config)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#bodies\r\n         * @type {Phaser.Structs.Set.<Phaser.Physics.Impact.Body>}\r\n         * @since 3.0.0\r\n         */\r\n        this.bodies = new Set();\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#gravity\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.gravity = GetFastValue(config, 'gravity', 0);\r\n\r\n        /**\r\n         * Spatial hash cell dimensions\r\n         *\r\n         * @name Phaser.Physics.Impact.World#cellSize\r\n         * @type {integer}\r\n         * @default 64\r\n         * @since 3.0.0\r\n         */\r\n        this.cellSize = GetFastValue(config, 'cellSize', 64);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#collisionMap\r\n         * @type {Phaser.Physics.Impact.CollisionMap}\r\n         * @since 3.0.0\r\n         */\r\n        this.collisionMap = new CollisionMap();\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.timeScale = GetFastValue(config, 'timeScale', 1);\r\n\r\n        /**\r\n         * Impacts maximum time step is 20 fps.\r\n         *\r\n         * @name Phaser.Physics.Impact.World#maxStep\r\n         * @type {number}\r\n         * @default 0.05\r\n         * @since 3.0.0\r\n         */\r\n        this.maxStep = GetFastValue(config, 'maxStep', 0.05);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#drawDebug\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.drawDebug = GetFastValue(config, 'debug', false);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#debugGraphic\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugGraphic;\r\n\r\n        var _maxVelocity = GetFastValue(config, 'maxVelocity', 100);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#defaults\r\n         * @type {Phaser.Types.Physics.Impact.WorldDefaults}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaults = {\r\n            debugShowBody: GetFastValue(config, 'debugShowBody', true),\r\n            debugShowVelocity: GetFastValue(config, 'debugShowVelocity', true),\r\n            bodyDebugColor: GetFastValue(config, 'debugBodyColor', 0xff00ff),\r\n            velocityDebugColor: GetFastValue(config, 'debugVelocityColor', 0x00ff00),\r\n            maxVelocityX: GetFastValue(config, 'maxVelocityX', _maxVelocity),\r\n            maxVelocityY: GetFastValue(config, 'maxVelocityY', _maxVelocity),\r\n            minBounceVelocity: GetFastValue(config, 'minBounceVelocity', 40),\r\n            gravityFactor: GetFastValue(config, 'gravityFactor', 1),\r\n            bounciness: GetFastValue(config, 'bounciness', 0)\r\n        };\r\n\r\n        /**\r\n         * An object containing the 4 wall bodies that bound the physics world.\r\n         *\r\n         * @name Phaser.Physics.Impact.World#walls\r\n         * @type {Phaser.Types.Physics.Impact.WorldWalls}\r\n         * @since 3.0.0\r\n         */\r\n        this.walls = { left: null, right: null, top: null, bottom: null };\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#delta\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.delta = 0;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#_lastId\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._lastId = 0;\r\n\r\n        if (GetFastValue(config, 'setBounds', false))\r\n        {\r\n            var boundsConfig = config['setBounds'];\r\n\r\n            if (typeof boundsConfig === 'boolean')\r\n            {\r\n                this.setBounds();\r\n            }\r\n            else\r\n            {\r\n                var x = GetFastValue(boundsConfig, 'x', 0);\r\n                var y = GetFastValue(boundsConfig, 'y', 0);\r\n                var width = GetFastValue(boundsConfig, 'width', scene.sys.scale.width);\r\n                var height = GetFastValue(boundsConfig, 'height', scene.sys.scale.height);\r\n                var thickness = GetFastValue(boundsConfig, 'thickness', 64);\r\n                var left = GetFastValue(boundsConfig, 'left', true);\r\n                var right = GetFastValue(boundsConfig, 'right', true);\r\n                var top = GetFastValue(boundsConfig, 'top', true);\r\n                var bottom = GetFastValue(boundsConfig, 'bottom', true);\r\n\r\n                this.setBounds(x, y, width, height, thickness, left, right, top, bottom);\r\n            }\r\n        }\r\n\r\n        if (this.drawDebug)\r\n        {\r\n            this.createDebugGraphic();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the collision map for the world either from a Weltmeister JSON level in the cache or from\r\n     * a 2D array. If loading from a Weltmeister level, the map must have a layer called \"collision\".\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCollisionMap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer[][])} key - Either a string key that corresponds to a Weltmeister level\r\n     * in the cache, or a 2D array of collision IDs.\r\n     * @param {integer} tileSize - The size of a tile. This is optional if loading from a Weltmeister\r\n     * level in the cache.\r\n     *\r\n     * @return {?Phaser.Physics.Impact.CollisionMap} The newly created CollisionMap, or null if the method failed to\r\n     * create the CollisionMap.\r\n     */\r\n    setCollisionMap: function (key, tileSize)\r\n    {\r\n        if (typeof key === 'string')\r\n        {\r\n            var tilemapData = this.scene.cache.tilemap.get(key);\r\n\r\n            if (!tilemapData || tilemapData.format !== TILEMAP_FORMATS.WELTMEISTER)\r\n            {\r\n                console.warn('The specified key does not correspond to a Weltmeister tilemap: ' + key);\r\n                return null;\r\n            }\r\n\r\n            var layers = tilemapData.data.layer;\r\n            var collisionLayer;\r\n            for (var i = 0; i < layers.length; i++)\r\n            {\r\n                if (layers[i].name === 'collision')\r\n                {\r\n                    collisionLayer = layers[i];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (tileSize === undefined) { tileSize = collisionLayer.tilesize; }\r\n\r\n            this.collisionMap = new CollisionMap(tileSize, collisionLayer.data);\r\n        }\r\n        else if (Array.isArray(key))\r\n        {\r\n            this.collisionMap = new CollisionMap(tileSize, key);\r\n        }\r\n        else\r\n        {\r\n            console.warn('Invalid Weltmeister collision map data: ' + key);\r\n        }\r\n\r\n        return this.collisionMap;\r\n    },\r\n\r\n    /**\r\n     * Sets the collision map for the world from a tilemap layer. Only tiles that are marked as\r\n     * colliding will be used. You can specify the mapping from tiles to slope IDs in a couple of\r\n     * ways. The easiest is to use Tiled and the slopeTileProperty option. Alternatively, you can\r\n     * manually create a slopeMap that stores the mapping between tile indices and slope IDs.\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCollisionMapFromTilemapLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The tilemap layer to use.\r\n     * @param {Phaser.Types.Physics.Impact.CollisionOptions} [options] - Options for controlling the mapping from tiles to slope IDs.\r\n     *\r\n     * @return {Phaser.Physics.Impact.CollisionMap} The newly created CollisionMap.\r\n     */\r\n    setCollisionMapFromTilemapLayer: function (tilemapLayer, options)\r\n    {\r\n        if (options === undefined) { options = {}; }\r\n        var slopeProperty = GetFastValue(options, 'slopeProperty', null);\r\n        var slopeMap = GetFastValue(options, 'slopeMap', null);\r\n        var collidingSlope = GetFastValue(options, 'defaultCollidingSlope', null);\r\n        var nonCollidingSlope = GetFastValue(options, 'defaultNonCollidingSlope', 0);\r\n\r\n        var layerData = tilemapLayer.layer;\r\n        var tileSize = layerData.baseTileWidth;\r\n        var collisionData = [];\r\n\r\n        for (var ty = 0; ty < layerData.height; ty++)\r\n        {\r\n            collisionData[ty] = [];\r\n\r\n            for (var tx = 0; tx < layerData.width; tx++)\r\n            {\r\n                var tile = layerData.data[ty][tx];\r\n\r\n                if (tile && tile.collides)\r\n                {\r\n                    if (slopeProperty !== null && HasValue(tile.properties, slopeProperty))\r\n                    {\r\n                        collisionData[ty][tx] = parseInt(tile.properties[slopeProperty], 10);\r\n                    }\r\n                    else if (slopeMap !== null && HasValue(slopeMap, tile.index))\r\n                    {\r\n                        collisionData[ty][tx] = slopeMap[tile.index];\r\n                    }\r\n                    else if (collidingSlope !== null)\r\n                    {\r\n                        collisionData[ty][tx] = collidingSlope;\r\n                    }\r\n                    else\r\n                    {\r\n                        collisionData[ty][tx] = tile.index;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    collisionData[ty][tx] = nonCollidingSlope;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.collisionMap = new CollisionMap(tileSize, collisionData);\r\n\r\n        return this.collisionMap;\r\n    },\r\n\r\n    /**\r\n     * Sets the bounds of the Physics world to match the given world pixel dimensions.\r\n     * You can optionally set which 'walls' to create: left, right, top or bottom.\r\n     * If none of the walls are given it will default to use the walls settings it had previously.\r\n     * I.e. if you previously told it to not have the left or right walls, and you then adjust the world size\r\n     * the newly created bounds will also not have the left and right walls.\r\n     * Explicitly state them in the parameters to override this.\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x] - The x coordinate of the top-left corner of the bounds.\r\n     * @param {number} [y] - The y coordinate of the top-left corner of the bounds.\r\n     * @param {number} [width] - The width of the bounds.\r\n     * @param {number} [height] - The height of the bounds.\r\n     * @param {number} [thickness=64] - [description]\r\n     * @param {boolean} [left=true] - If true will create the left bounds wall.\r\n     * @param {boolean} [right=true] - If true will create the right bounds wall.\r\n     * @param {boolean} [top=true] - If true will create the top bounds wall.\r\n     * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setBounds: function (x, y, width, height, thickness, left, right, top, bottom)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.scene.sys.scale.width; }\r\n        if (height === undefined) { height = this.scene.sys.scale.height; }\r\n        if (thickness === undefined) { thickness = 64; }\r\n        if (left === undefined) { left = true; }\r\n        if (right === undefined) { right = true; }\r\n        if (top === undefined) { top = true; }\r\n        if (bottom === undefined) { bottom = true; }\r\n\r\n        this.updateWall(left, 'left', x - thickness, y, thickness, height);\r\n        this.updateWall(right, 'right', x + width, y, thickness, height);\r\n        this.updateWall(top, 'top', x, y - thickness, width, thickness);\r\n        this.updateWall(bottom, 'bottom', x, y + height, width, thickness);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * position = 'left', 'right', 'top' or 'bottom'\r\n     *\r\n     * @method Phaser.Physics.Impact.World#updateWall\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} add - [description]\r\n     * @param {string} position - [description]\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     */\r\n    updateWall: function (add, position, x, y, width, height)\r\n    {\r\n        var wall = this.walls[position];\r\n\r\n        if (add)\r\n        {\r\n            if (wall)\r\n            {\r\n                wall.resetSize(x, y, width, height);\r\n            }\r\n            else\r\n            {\r\n                this.walls[position] = this.create(x, y, width, height);\r\n                this.walls[position].name = position;\r\n                this.walls[position].gravityFactor = 0;\r\n                this.walls[position].collides = COLLIDES.FIXED;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if (wall)\r\n            {\r\n                this.bodies.remove(wall);\r\n            }\r\n\r\n            this.walls[position] = null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a Graphics Game Object used for debug display and enables the world for debug drawing.\r\n     *\r\n     * @method Phaser.Physics.Impact.World#createDebugGraphic\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The Graphics object created that will have the debug visuals drawn to it.\r\n     */\r\n    createDebugGraphic: function ()\r\n    {\r\n        var graphic = this.scene.sys.add.graphics({ x: 0, y: 0 });\r\n\r\n        graphic.setDepth(Number.MAX_VALUE);\r\n\r\n        this.debugGraphic = graphic;\r\n\r\n        this.drawDebug = true;\r\n\r\n        return graphic;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#getNextID\r\n     * @since 3.0.0\r\n     *\r\n     * @return {integer} [description]\r\n     */\r\n    getNextID: function ()\r\n    {\r\n        return this._lastId++;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} sizeX - [description]\r\n     * @param {number} sizeY - [description]\r\n     *\r\n     * @return {Phaser.Physics.Impact.Body} The Body that was added to this World.\r\n     */\r\n    create: function (x, y, sizeX, sizeY)\r\n    {\r\n        var body = new Body(this, x, y, sizeX, sizeY);\r\n\r\n        this.bodies.set(body);\r\n\r\n        return body;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body} object - The Body to remove from this World.\r\n     */\r\n    remove: function (object)\r\n    {\r\n        this.bodies.delete(object);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#pause\r\n     * @fires Phaser.Physics.Impact.Events#PAUSE\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    pause: function ()\r\n    {\r\n        this.enabled = false;\r\n\r\n        this.emit(Events.PAUSE);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#resume\r\n     * @fires Phaser.Physics.Impact.Events#RESUME\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    resume: function ()\r\n    {\r\n        this.enabled = true;\r\n\r\n        this.emit(Events.RESUME);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        if (!this.enabled || this.bodies.size === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  Impact uses a divided delta value that is clamped to the maxStep (20fps) maximum\r\n\r\n        var clampedDelta = Math.min(delta / 1000, this.maxStep) * this.timeScale;\r\n\r\n        this.delta = clampedDelta;\r\n\r\n        //  Update all active bodies\r\n\r\n        var i;\r\n        var body;\r\n        var bodies = this.bodies.entries;\r\n        var len = bodies.length;\r\n        var hash = {};\r\n        var size = this.cellSize;\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            body = bodies[i];\r\n\r\n            if (body.enabled)\r\n            {\r\n                body.update(clampedDelta);\r\n            }\r\n        }\r\n\r\n        //  Run collision against them all now they're in the new positions from the update\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            body = bodies[i];\r\n\r\n            if (body && !body.skipHash())\r\n            {\r\n                this.checkHash(body, hash, size);\r\n            }\r\n        }\r\n\r\n        if (this.drawDebug)\r\n        {\r\n            var graphics = this.debugGraphic;\r\n\r\n            graphics.clear();\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                body = bodies[i];\r\n\r\n                if (body && body.willDrawDebug())\r\n                {\r\n                    body.drawDebug(graphics);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Check the body against the spatial hash.\r\n     *\r\n     * @method Phaser.Physics.Impact.World#checkHash\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body} body - [description]\r\n     * @param {object} hash - [description]\r\n     * @param {number} size - [description]\r\n     */\r\n    checkHash: function (body, hash, size)\r\n    {\r\n        var checked = {};\r\n\r\n        var xmin = Math.floor(body.pos.x / size);\r\n        var ymin = Math.floor(body.pos.y / size);\r\n        var xmax = Math.floor((body.pos.x + body.size.x) / size) + 1;\r\n        var ymax = Math.floor((body.pos.y + body.size.y) / size) + 1;\r\n\r\n        for (var x = xmin; x < xmax; x++)\r\n        {\r\n            for (var y = ymin; y < ymax; y++)\r\n            {\r\n                if (!hash[x])\r\n                {\r\n                    hash[x] = {};\r\n                    hash[x][y] = [ body ];\r\n                }\r\n                else if (!hash[x][y])\r\n                {\r\n                    hash[x][y] = [ body ];\r\n                }\r\n                else\r\n                {\r\n                    var cell = hash[x][y];\r\n\r\n                    for (var c = 0; c < cell.length; c++)\r\n                    {\r\n                        if (body.touches(cell[c]) && !checked[cell[c].id])\r\n                        {\r\n                            checked[cell[c].id] = true;\r\n\r\n                            this.checkBodies(body, cell[c]);\r\n                        }\r\n                    }\r\n\r\n                    cell.push(body);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#checkBodies\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body} bodyA - [description]\r\n     * @param {Phaser.Physics.Impact.Body} bodyB - [description]\r\n     */\r\n    checkBodies: function (bodyA, bodyB)\r\n    {\r\n        //  2 fixed bodies won't do anything\r\n        if (bodyA.collides === COLLIDES.FIXED && bodyB.collides === COLLIDES.FIXED)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  bitwise checks\r\n        if (bodyA.checkAgainst & bodyB.type)\r\n        {\r\n            bodyA.check(bodyB);\r\n        }\r\n\r\n        if (bodyB.checkAgainst & bodyA.type)\r\n        {\r\n            bodyB.check(bodyA);\r\n        }\r\n\r\n        if (bodyA.collides && bodyB.collides && bodyA.collides + bodyB.collides > COLLIDES.ACTIVE)\r\n        {\r\n            Solver(this, bodyA, bodyB);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCollidesNever\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setCollidesNever: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].collides = COLLIDES.NEVER;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setLite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setLite: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].collides = COLLIDES.LITE;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setPassive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setPassive: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].collides = COLLIDES.PASSIVE;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setActive: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].collides = COLLIDES.ACTIVE;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setFixed\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setFixed: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].collides = COLLIDES.FIXED;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setTypeNone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setTypeNone: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].type = TYPE.NONE;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setTypeA\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setTypeA: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].type = TYPE.A;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setTypeB\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setTypeB: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].type = TYPE.B;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setAvsB\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setAvsB: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].type = TYPE.A;\r\n            bodies[i].checkAgainst = TYPE.B;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setBvsA\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setBvsA: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].type = TYPE.B;\r\n            bodies[i].checkAgainst = TYPE.A;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCheckAgainstNone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setCheckAgainstNone: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].checkAgainst = TYPE.NONE;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCheckAgainstA\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setCheckAgainstA: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].checkAgainst = TYPE.A;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCheckAgainstB\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setCheckAgainstB: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].checkAgainst = TYPE.B;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#shutdown\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.removeAllListeners();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAllListeners();\r\n\r\n        this.scene = null;\r\n\r\n        this.bodies.clear();\r\n\r\n        this.bodies = null;\r\n\r\n        this.collisionMap = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = World;\r\n"]},"metadata":{},"sourceType":"script"}