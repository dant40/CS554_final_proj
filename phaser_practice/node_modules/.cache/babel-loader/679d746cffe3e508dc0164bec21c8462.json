{"ast":null,"code":"/**\r\n* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.\r\n*\r\n* @class SAT\r\n*/\n// TODO: true circles and curves\nvar SAT = {};\nmodule.exports = SAT;\n\nvar Vertices = require('../geometry/Vertices');\n\nvar Vector = require('../geometry/Vector');\n\n(function () {\n  /**\r\n   * Detect collision between two bodies using the Separating Axis Theorem.\r\n   * @method collides\r\n   * @param {body} bodyA\r\n   * @param {body} bodyB\r\n   * @param {collision} previousCollision\r\n   * @return {collision} collision\r\n   */\n  SAT.collides = function (bodyA, bodyB, previousCollision) {\n    var overlapAB,\n        overlapBA,\n        minOverlap,\n        collision,\n        canReusePrevCol = false;\n\n    if (previousCollision) {\n      // estimate total motion\n      var parentA = bodyA.parent,\n          parentB = bodyB.parent,\n          motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed; // we may be able to (partially) reuse collision result \n      // but only safe if collision was resting\n\n      canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2; // reuse collision object\n\n      collision = previousCollision;\n    } else {\n      collision = {\n        collided: false,\n        bodyA: bodyA,\n        bodyB: bodyB\n      };\n    }\n\n    if (previousCollision && canReusePrevCol) {\n      // if we can reuse the collision result\n      // we only need to test the previously found axis\n      var axisBodyA = collision.axisBody,\n          axisBodyB = axisBodyA === bodyA ? bodyB : bodyA,\n          axes = [axisBodyA.axes[previousCollision.axisNumber]];\n      minOverlap = SAT._overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);\n      collision.reused = true;\n\n      if (minOverlap.overlap <= 0) {\n        collision.collided = false;\n        return collision;\n      }\n    } else {\n      // if we can't reuse a result, perform a full SAT test\n      overlapAB = SAT._overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);\n\n      if (overlapAB.overlap <= 0) {\n        collision.collided = false;\n        return collision;\n      }\n\n      overlapBA = SAT._overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);\n\n      if (overlapBA.overlap <= 0) {\n        collision.collided = false;\n        return collision;\n      }\n\n      if (overlapAB.overlap < overlapBA.overlap) {\n        minOverlap = overlapAB;\n        collision.axisBody = bodyA;\n      } else {\n        minOverlap = overlapBA;\n        collision.axisBody = bodyB;\n      } // important for reuse later\n\n\n      collision.axisNumber = minOverlap.axisNumber;\n    }\n\n    collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;\n    collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;\n    collision.collided = true;\n    collision.depth = minOverlap.overlap;\n    collision.parentA = collision.bodyA.parent;\n    collision.parentB = collision.bodyB.parent;\n    bodyA = collision.bodyA;\n    bodyB = collision.bodyB; // ensure normal is facing away from bodyA\n\n    if (Vector.dot(minOverlap.axis, Vector.sub(bodyB.position, bodyA.position)) < 0) {\n      collision.normal = {\n        x: minOverlap.axis.x,\n        y: minOverlap.axis.y\n      };\n    } else {\n      collision.normal = {\n        x: -minOverlap.axis.x,\n        y: -minOverlap.axis.y\n      };\n    }\n\n    collision.tangent = Vector.perp(collision.normal);\n    collision.penetration = collision.penetration || {};\n    collision.penetration.x = collision.normal.x * collision.depth;\n    collision.penetration.y = collision.normal.y * collision.depth; // find support points, there is always either exactly one or two\n\n    var verticesB = SAT._findSupports(bodyA, bodyB, collision.normal),\n        supports = []; // find the supports from bodyB that are inside bodyA\n\n\n    if (Vertices.contains(bodyA.vertices, verticesB[0])) supports.push(verticesB[0]);\n    if (Vertices.contains(bodyA.vertices, verticesB[1])) supports.push(verticesB[1]); // find the supports from bodyA that are inside bodyB\n\n    if (supports.length < 2) {\n      var verticesA = SAT._findSupports(bodyB, bodyA, Vector.neg(collision.normal));\n\n      if (Vertices.contains(bodyB.vertices, verticesA[0])) supports.push(verticesA[0]);\n      if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1])) supports.push(verticesA[1]);\n    } // account for the edge case of overlapping but no vertex containment\n\n\n    if (supports.length < 1) supports = [verticesB[0]];\n    collision.supports = supports;\n    return collision;\n  };\n  /**\r\n   * Find the overlap between two sets of vertices.\r\n   * @method _overlapAxes\r\n   * @private\r\n   * @param {} verticesA\r\n   * @param {} verticesB\r\n   * @param {} axes\r\n   * @return result\r\n   */\n\n\n  SAT._overlapAxes = function (verticesA, verticesB, axes) {\n    var projectionA = Vector._temp[0],\n        projectionB = Vector._temp[1],\n        result = {\n      overlap: Number.MAX_VALUE\n    },\n        overlap,\n        axis;\n\n    for (var i = 0; i < axes.length; i++) {\n      axis = axes[i];\n\n      SAT._projectToAxis(projectionA, verticesA, axis);\n\n      SAT._projectToAxis(projectionB, verticesB, axis);\n\n      overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);\n\n      if (overlap <= 0) {\n        result.overlap = overlap;\n        return result;\n      }\n\n      if (overlap < result.overlap) {\n        result.overlap = overlap;\n        result.axis = axis;\n        result.axisNumber = i;\n      }\n    }\n\n    return result;\n  };\n  /**\r\n   * Projects vertices on an axis and returns an interval.\r\n   * @method _projectToAxis\r\n   * @private\r\n   * @param {} projection\r\n   * @param {} vertices\r\n   * @param {} axis\r\n   */\n\n\n  SAT._projectToAxis = function (projection, vertices, axis) {\n    var min = Vector.dot(vertices[0], axis),\n        max = min;\n\n    for (var i = 1; i < vertices.length; i += 1) {\n      var dot = Vector.dot(vertices[i], axis);\n\n      if (dot > max) {\n        max = dot;\n      } else if (dot < min) {\n        min = dot;\n      }\n    }\n\n    projection.min = min;\n    projection.max = max;\n  };\n  /**\r\n   * Finds supporting vertices given two bodies along a given direction using hill-climbing.\r\n   * @method _findSupports\r\n   * @private\r\n   * @param {} bodyA\r\n   * @param {} bodyB\r\n   * @param {} normal\r\n   * @return [vector]\r\n   */\n\n\n  SAT._findSupports = function (bodyA, bodyB, normal) {\n    var nearestDistance = Number.MAX_VALUE,\n        vertexToBody = Vector._temp[0],\n        vertices = bodyB.vertices,\n        bodyAPosition = bodyA.position,\n        distance,\n        vertex,\n        vertexA,\n        vertexB; // find closest vertex on bodyB\n\n    for (var i = 0; i < vertices.length; i++) {\n      vertex = vertices[i];\n      vertexToBody.x = vertex.x - bodyAPosition.x;\n      vertexToBody.y = vertex.y - bodyAPosition.y;\n      distance = -Vector.dot(normal, vertexToBody);\n\n      if (distance < nearestDistance) {\n        nearestDistance = distance;\n        vertexA = vertex;\n      }\n    } // find next closest vertex using the two connected to it\n\n\n    var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;\n    vertex = vertices[prevIndex];\n    vertexToBody.x = vertex.x - bodyAPosition.x;\n    vertexToBody.y = vertex.y - bodyAPosition.y;\n    nearestDistance = -Vector.dot(normal, vertexToBody);\n    vertexB = vertex;\n    var nextIndex = (vertexA.index + 1) % vertices.length;\n    vertex = vertices[nextIndex];\n    vertexToBody.x = vertex.x - bodyAPosition.x;\n    vertexToBody.y = vertex.y - bodyAPosition.y;\n    distance = -Vector.dot(normal, vertexToBody);\n\n    if (distance < nearestDistance) {\n      vertexB = vertex;\n    }\n\n    return [vertexA, vertexB];\n  };\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/lib/collision/SAT.js"],"names":["SAT","module","exports","Vertices","require","Vector","collides","bodyA","bodyB","previousCollision","overlapAB","overlapBA","minOverlap","collision","canReusePrevCol","parentA","parent","parentB","motion","speed","angularSpeed","collided","axisBodyA","axisBody","axisBodyB","axes","axisNumber","_overlapAxes","vertices","reused","overlap","id","depth","dot","axis","sub","position","normal","x","y","tangent","perp","penetration","verticesB","_findSupports","supports","contains","push","length","verticesA","neg","projectionA","_temp","projectionB","result","Number","MAX_VALUE","i","_projectToAxis","Math","min","max","projection","nearestDistance","vertexToBody","bodyAPosition","distance","vertex","vertexA","vertexB","prevIndex","index","nextIndex"],"mappings":"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","sourcesContent":["/**\r\n* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.\r\n*\r\n* @class SAT\r\n*/\r\n\r\n// TODO: true circles and curves\r\n\r\nvar SAT = {};\r\n\r\nmodule.exports = SAT;\r\n\r\nvar Vertices = require('../geometry/Vertices');\r\nvar Vector = require('../geometry/Vector');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Detect collision between two bodies using the Separating Axis Theorem.\r\n     * @method collides\r\n     * @param {body} bodyA\r\n     * @param {body} bodyB\r\n     * @param {collision} previousCollision\r\n     * @return {collision} collision\r\n     */\r\n    SAT.collides = function(bodyA, bodyB, previousCollision) {\r\n        var overlapAB,\r\n            overlapBA, \r\n            minOverlap,\r\n            collision,\r\n            canReusePrevCol = false;\r\n\r\n        if (previousCollision) {\r\n            // estimate total motion\r\n            var parentA = bodyA.parent,\r\n                parentB = bodyB.parent,\r\n                motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed\r\n                       + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed;\r\n\r\n            // we may be able to (partially) reuse collision result \r\n            // but only safe if collision was resting\r\n            canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2;\r\n\r\n            // reuse collision object\r\n            collision = previousCollision;\r\n        } else {\r\n            collision = { collided: false, bodyA: bodyA, bodyB: bodyB };\r\n        }\r\n\r\n        if (previousCollision && canReusePrevCol) {\r\n            // if we can reuse the collision result\r\n            // we only need to test the previously found axis\r\n            var axisBodyA = collision.axisBody,\r\n                axisBodyB = axisBodyA === bodyA ? bodyB : bodyA,\r\n                axes = [axisBodyA.axes[previousCollision.axisNumber]];\r\n\r\n            minOverlap = SAT._overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);\r\n            collision.reused = true;\r\n\r\n            if (minOverlap.overlap <= 0) {\r\n                collision.collided = false;\r\n                return collision;\r\n            }\r\n        } else {\r\n            // if we can't reuse a result, perform a full SAT test\r\n\r\n            overlapAB = SAT._overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);\r\n\r\n            if (overlapAB.overlap <= 0) {\r\n                collision.collided = false;\r\n                return collision;\r\n            }\r\n\r\n            overlapBA = SAT._overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);\r\n\r\n            if (overlapBA.overlap <= 0) {\r\n                collision.collided = false;\r\n                return collision;\r\n            }\r\n\r\n            if (overlapAB.overlap < overlapBA.overlap) {\r\n                minOverlap = overlapAB;\r\n                collision.axisBody = bodyA;\r\n            } else {\r\n                minOverlap = overlapBA;\r\n                collision.axisBody = bodyB;\r\n            }\r\n\r\n            // important for reuse later\r\n            collision.axisNumber = minOverlap.axisNumber;\r\n        }\r\n\r\n        collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;\r\n        collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;\r\n        collision.collided = true;\r\n        collision.depth = minOverlap.overlap;\r\n        collision.parentA = collision.bodyA.parent;\r\n        collision.parentB = collision.bodyB.parent;\r\n        \r\n        bodyA = collision.bodyA;\r\n        bodyB = collision.bodyB;\r\n\r\n        // ensure normal is facing away from bodyA\r\n        if (Vector.dot(minOverlap.axis, Vector.sub(bodyB.position, bodyA.position)) < 0) {\r\n            collision.normal = {\r\n                x: minOverlap.axis.x,\r\n                y: minOverlap.axis.y\r\n            };\r\n        } else {\r\n            collision.normal = {\r\n                x: -minOverlap.axis.x,\r\n                y: -minOverlap.axis.y\r\n            };\r\n        }\r\n\r\n        collision.tangent = Vector.perp(collision.normal);\r\n\r\n        collision.penetration = collision.penetration || {};\r\n        collision.penetration.x = collision.normal.x * collision.depth;\r\n        collision.penetration.y = collision.normal.y * collision.depth; \r\n\r\n        // find support points, there is always either exactly one or two\r\n        var verticesB = SAT._findSupports(bodyA, bodyB, collision.normal),\r\n            supports = [];\r\n\r\n        // find the supports from bodyB that are inside bodyA\r\n        if (Vertices.contains(bodyA.vertices, verticesB[0]))\r\n            supports.push(verticesB[0]);\r\n\r\n        if (Vertices.contains(bodyA.vertices, verticesB[1]))\r\n            supports.push(verticesB[1]);\r\n\r\n        // find the supports from bodyA that are inside bodyB\r\n        if (supports.length < 2) {\r\n            var verticesA = SAT._findSupports(bodyB, bodyA, Vector.neg(collision.normal));\r\n                \r\n            if (Vertices.contains(bodyB.vertices, verticesA[0]))\r\n                supports.push(verticesA[0]);\r\n\r\n            if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1]))\r\n                supports.push(verticesA[1]);\r\n        }\r\n\r\n        // account for the edge case of overlapping but no vertex containment\r\n        if (supports.length < 1)\r\n            supports = [verticesB[0]];\r\n        \r\n        collision.supports = supports;\r\n\r\n        return collision;\r\n    };\r\n\r\n    /**\r\n     * Find the overlap between two sets of vertices.\r\n     * @method _overlapAxes\r\n     * @private\r\n     * @param {} verticesA\r\n     * @param {} verticesB\r\n     * @param {} axes\r\n     * @return result\r\n     */\r\n    SAT._overlapAxes = function(verticesA, verticesB, axes) {\r\n        var projectionA = Vector._temp[0], \r\n            projectionB = Vector._temp[1],\r\n            result = { overlap: Number.MAX_VALUE },\r\n            overlap,\r\n            axis;\r\n\r\n        for (var i = 0; i < axes.length; i++) {\r\n            axis = axes[i];\r\n\r\n            SAT._projectToAxis(projectionA, verticesA, axis);\r\n            SAT._projectToAxis(projectionB, verticesB, axis);\r\n\r\n            overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);\r\n\r\n            if (overlap <= 0) {\r\n                result.overlap = overlap;\r\n                return result;\r\n            }\r\n\r\n            if (overlap < result.overlap) {\r\n                result.overlap = overlap;\r\n                result.axis = axis;\r\n                result.axisNumber = i;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Projects vertices on an axis and returns an interval.\r\n     * @method _projectToAxis\r\n     * @private\r\n     * @param {} projection\r\n     * @param {} vertices\r\n     * @param {} axis\r\n     */\r\n    SAT._projectToAxis = function(projection, vertices, axis) {\r\n        var min = Vector.dot(vertices[0], axis),\r\n            max = min;\r\n\r\n        for (var i = 1; i < vertices.length; i += 1) {\r\n            var dot = Vector.dot(vertices[i], axis);\r\n\r\n            if (dot > max) { \r\n                max = dot; \r\n            } else if (dot < min) { \r\n                min = dot; \r\n            }\r\n        }\r\n\r\n        projection.min = min;\r\n        projection.max = max;\r\n    };\r\n    \r\n    /**\r\n     * Finds supporting vertices given two bodies along a given direction using hill-climbing.\r\n     * @method _findSupports\r\n     * @private\r\n     * @param {} bodyA\r\n     * @param {} bodyB\r\n     * @param {} normal\r\n     * @return [vector]\r\n     */\r\n    SAT._findSupports = function(bodyA, bodyB, normal) {\r\n        var nearestDistance = Number.MAX_VALUE,\r\n            vertexToBody = Vector._temp[0],\r\n            vertices = bodyB.vertices,\r\n            bodyAPosition = bodyA.position,\r\n            distance,\r\n            vertex,\r\n            vertexA,\r\n            vertexB;\r\n\r\n        // find closest vertex on bodyB\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            vertex = vertices[i];\r\n            vertexToBody.x = vertex.x - bodyAPosition.x;\r\n            vertexToBody.y = vertex.y - bodyAPosition.y;\r\n            distance = -Vector.dot(normal, vertexToBody);\r\n\r\n            if (distance < nearestDistance) {\r\n                nearestDistance = distance;\r\n                vertexA = vertex;\r\n            }\r\n        }\r\n\r\n        // find next closest vertex using the two connected to it\r\n        var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;\r\n        vertex = vertices[prevIndex];\r\n        vertexToBody.x = vertex.x - bodyAPosition.x;\r\n        vertexToBody.y = vertex.y - bodyAPosition.y;\r\n        nearestDistance = -Vector.dot(normal, vertexToBody);\r\n        vertexB = vertex;\r\n\r\n        var nextIndex = (vertexA.index + 1) % vertices.length;\r\n        vertex = vertices[nextIndex];\r\n        vertexToBody.x = vertex.x - bodyAPosition.x;\r\n        vertexToBody.y = vertex.y - bodyAPosition.y;\r\n        distance = -Vector.dot(normal, vertexToBody);\r\n        if (distance < nearestDistance) {\r\n            vertexB = vertex;\r\n        }\r\n\r\n        return [vertexA, vertexB];\r\n    };\r\n\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}