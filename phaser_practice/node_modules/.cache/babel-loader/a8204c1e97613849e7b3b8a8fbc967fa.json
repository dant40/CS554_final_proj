{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\n//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\nvar Class = require('../utils/Class');\n\nvar Curve = require('./Curve');\n\nvar DegToRad = require('../math/DegToRad');\n\nvar GetValue = require('../utils/object/GetValue');\n\nvar RadToDeg = require('../math/RadToDeg');\n\nvar Vector2 = require('../math/Vector2');\n/**\r\n * @classdesc\r\n * An Elliptical Curve derived from the Base Curve class.\r\n * \r\n * See https://en.wikipedia.org/wiki/Elliptic_curve for more details.\r\n *\r\n * @class Ellipse\r\n * @extends Phaser.Curves.Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(number|Phaser.Types.Curves.EllipseCurveConfig)} [x=0] - The x coordinate of the ellipse, or an Ellipse Curve configuration object.\r\n * @param {number} [y=0] - The y coordinate of the ellipse.\r\n * @param {number} [xRadius=0] - The horizontal radius of ellipse.\r\n * @param {number} [yRadius=0] - The vertical radius of ellipse.\r\n * @param {integer} [startAngle=0] - The start angle of the ellipse, in degrees.\r\n * @param {integer} [endAngle=360] - The end angle of the ellipse, in degrees.\r\n * @param {boolean} [clockwise=false] - Whether the ellipse angles are given as clockwise (`true`) or counter-clockwise (`false`).\r\n * @param {integer} [rotation=0] - The rotation of the ellipse, in degrees.\r\n */\n\n\nvar EllipseCurve = new Class({\n  Extends: Curve,\n  initialize: function EllipseCurve(x, y, xRadius, yRadius, startAngle, endAngle, clockwise, rotation) {\n    if (typeof x === 'object') {\n      var config = x;\n      x = GetValue(config, 'x', 0);\n      y = GetValue(config, 'y', 0);\n      xRadius = GetValue(config, 'xRadius', 0);\n      yRadius = GetValue(config, 'yRadius', xRadius);\n      startAngle = GetValue(config, 'startAngle', 0);\n      endAngle = GetValue(config, 'endAngle', 360);\n      clockwise = GetValue(config, 'clockwise', false);\n      rotation = GetValue(config, 'rotation', 0);\n    } else {\n      if (yRadius === undefined) {\n        yRadius = xRadius;\n      }\n\n      if (startAngle === undefined) {\n        startAngle = 0;\n      }\n\n      if (endAngle === undefined) {\n        endAngle = 360;\n      }\n\n      if (clockwise === undefined) {\n        clockwise = false;\n      }\n\n      if (rotation === undefined) {\n        rotation = 0;\n      }\n    }\n\n    Curve.call(this, 'EllipseCurve'); //  Center point\n\n    /**\r\n     * The center point of the ellipse. Used for calculating rotation.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#p0\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.p0 = new Vector2(x, y);\n    /**\r\n     * The horizontal radius of the ellipse.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#_xRadius\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._xRadius = xRadius;\n    /**\r\n     * The vertical radius of the ellipse.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#_yRadius\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._yRadius = yRadius; //  Radians\n\n    /**\r\n     * The starting angle of the ellipse in radians.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#_startAngle\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._startAngle = DegToRad(startAngle);\n    /**\r\n     * The end angle of the ellipse in radians.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#_endAngle\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._endAngle = DegToRad(endAngle);\n    /**\r\n     * Anti-clockwise direction.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#_clockwise\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._clockwise = clockwise;\n    /**\r\n     * The rotation of the arc.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#_rotation\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._rotation = DegToRad(rotation);\n  },\n\n  /**\r\n   * Gets the starting point on the curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#getStartPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n   */\n  getStartPoint: function (out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    return this.getPoint(0, out);\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Curves.Ellipse#getResolution\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} divisions - [description]\r\n   *\r\n   * @return {number} [description]\r\n   */\n  getResolution: function (divisions) {\n    return divisions * 2;\n  },\n\n  /**\r\n   * Get point at relative position in curve according to length.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#getPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n   *\r\n   * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n   * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n   */\n  getPoint: function (t, out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    var twoPi = Math.PI * 2;\n    var deltaAngle = this._endAngle - this._startAngle;\n    var samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI\n\n    while (deltaAngle < 0) {\n      deltaAngle += twoPi;\n    }\n\n    while (deltaAngle > twoPi) {\n      deltaAngle -= twoPi;\n    }\n\n    if (deltaAngle < Number.EPSILON) {\n      if (samePoints) {\n        deltaAngle = 0;\n      } else {\n        deltaAngle = twoPi;\n      }\n    }\n\n    if (this._clockwise && !samePoints) {\n      if (deltaAngle === twoPi) {\n        deltaAngle = -twoPi;\n      } else {\n        deltaAngle = deltaAngle - twoPi;\n      }\n    }\n\n    var angle = this._startAngle + t * deltaAngle;\n    var x = this.p0.x + this._xRadius * Math.cos(angle);\n    var y = this.p0.y + this._yRadius * Math.sin(angle);\n\n    if (this._rotation !== 0) {\n      var cos = Math.cos(this._rotation);\n      var sin = Math.sin(this._rotation);\n      var tx = x - this.p0.x;\n      var ty = y - this.p0.y; // Rotate the point about the center of the ellipse.\n\n      x = tx * cos - ty * sin + this.p0.x;\n      y = tx * sin + ty * cos + this.p0.y;\n    }\n\n    return out.set(x, y);\n  },\n\n  /**\r\n   * Sets the horizontal radius of this curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#setXRadius\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The horizontal radius of this curve.\r\n   *\r\n   * @return {Phaser.Curves.Ellipse} This curve object.\r\n   */\n  setXRadius: function (value) {\n    this.xRadius = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the vertical radius of this curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#setYRadius\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The vertical radius of this curve.\r\n   *\r\n   * @return {Phaser.Curves.Ellipse} This curve object.\r\n   */\n  setYRadius: function (value) {\n    this.yRadius = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the width of this curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#setWidth\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The width of this curve.\r\n   *\r\n   * @return {Phaser.Curves.Ellipse} This curve object.\r\n   */\n  setWidth: function (value) {\n    this.xRadius = value * 2;\n    return this;\n  },\n\n  /**\r\n   * Sets the height of this curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#setHeight\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The height of this curve.\r\n   *\r\n   * @return {Phaser.Curves.Ellipse} This curve object.\r\n   */\n  setHeight: function (value) {\n    this.yRadius = value * 2;\n    return this;\n  },\n\n  /**\r\n   * Sets the start angle of this curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#setStartAngle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The start angle of this curve, in radians.\r\n   *\r\n   * @return {Phaser.Curves.Ellipse} This curve object.\r\n   */\n  setStartAngle: function (value) {\n    this.startAngle = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the end angle of this curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#setEndAngle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The end angle of this curve, in radians.\r\n   *\r\n   * @return {Phaser.Curves.Ellipse} This curve object.\r\n   */\n  setEndAngle: function (value) {\n    this.endAngle = value;\n    return this;\n  },\n\n  /**\r\n   * Sets if this curve extends clockwise or anti-clockwise.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#setClockwise\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - The clockwise state of this curve.\r\n   *\r\n   * @return {Phaser.Curves.Ellipse} This curve object.\r\n   */\n  setClockwise: function (value) {\n    this.clockwise = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the rotation of this curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#setRotation\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The rotation of this curve, in radians.\r\n   *\r\n   * @return {Phaser.Curves.Ellipse} This curve object.\r\n   */\n  setRotation: function (value) {\n    this.rotation = value;\n    return this;\n  },\n\n  /**\r\n   * The x coordinate of the center of the ellipse.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#x\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  x: {\n    get: function () {\n      return this.p0.x;\n    },\n    set: function (value) {\n      this.p0.x = value;\n    }\n  },\n\n  /**\r\n   * The y coordinate of the center of the ellipse.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#y\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  y: {\n    get: function () {\n      return this.p0.y;\n    },\n    set: function (value) {\n      this.p0.y = value;\n    }\n  },\n\n  /**\r\n   * The horizontal radius of the ellipse.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#xRadius\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  xRadius: {\n    get: function () {\n      return this._xRadius;\n    },\n    set: function (value) {\n      this._xRadius = value;\n    }\n  },\n\n  /**\r\n   * The vertical radius of the ellipse.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#yRadius\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  yRadius: {\n    get: function () {\n      return this._yRadius;\n    },\n    set: function (value) {\n      this._yRadius = value;\n    }\n  },\n\n  /**\r\n   * The start angle of the ellipse in degrees.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#startAngle\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  startAngle: {\n    get: function () {\n      return RadToDeg(this._startAngle);\n    },\n    set: function (value) {\n      this._startAngle = DegToRad(value);\n    }\n  },\n\n  /**\r\n   * The end angle of the ellipse in degrees.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#endAngle\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  endAngle: {\n    get: function () {\n      return RadToDeg(this._endAngle);\n    },\n    set: function (value) {\n      this._endAngle = DegToRad(value);\n    }\n  },\n\n  /**\r\n   * `true` if the ellipse rotation is clockwise or `false` if anti-clockwise.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#clockwise\r\n   * @type {boolean}\r\n   * @since 3.0.0\r\n   */\n  clockwise: {\n    get: function () {\n      return this._clockwise;\n    },\n    set: function (value) {\n      this._clockwise = value;\n    }\n  },\n\n  /**\r\n   * The rotation of the ellipse, relative to the center, in degrees.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#angle\r\n   * @type {number}\r\n   * @since 3.14.0\r\n   */\n  angle: {\n    get: function () {\n      return RadToDeg(this._rotation);\n    },\n    set: function (value) {\n      this._rotation = DegToRad(value);\n    }\n  },\n\n  /**\r\n   * The rotation of the ellipse, relative to the center, in radians.\r\n   *\r\n   * @name Phaser.Curves.Ellipse#rotation\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  rotation: {\n    get: function () {\n      return this._rotation;\n    },\n    set: function (value) {\n      this._rotation = value;\n    }\n  },\n\n  /**\r\n   * JSON serialization of the curve.\r\n   *\r\n   * @method Phaser.Curves.Ellipse#toJSON\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Types.Curves.JSONEllipseCurve} The JSON object containing this curve data.\r\n   */\n  toJSON: function () {\n    return {\n      type: this.type,\n      x: this.p0.x,\n      y: this.p0.y,\n      xRadius: this._xRadius,\n      yRadius: this._yRadius,\n      startAngle: RadToDeg(this._startAngle),\n      endAngle: RadToDeg(this._endAngle),\n      clockwise: this._clockwise,\n      rotation: RadToDeg(this._rotation)\n    };\n  }\n});\n/**\r\n * Creates a curve from the provided Ellipse Curve Configuration object.\r\n *\r\n * @function Phaser.Curves.Ellipse.fromJSON\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Curves.JSONEllipseCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.Ellipse} The ellipse curve constructed from the configuration object.\r\n */\n\nEllipseCurve.fromJSON = function (data) {\n  return new EllipseCurve(data);\n};\n\nmodule.exports = EllipseCurve;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/curves/EllipseCurve.js"],"names":["Class","require","Curve","DegToRad","GetValue","RadToDeg","Vector2","EllipseCurve","Extends","initialize","x","y","xRadius","yRadius","startAngle","endAngle","clockwise","rotation","config","undefined","call","p0","_xRadius","_yRadius","_startAngle","_endAngle","_clockwise","_rotation","getStartPoint","out","getPoint","getResolution","divisions","t","twoPi","Math","PI","deltaAngle","samePoints","abs","Number","EPSILON","angle","cos","sin","tx","ty","set","setXRadius","value","setYRadius","setWidth","setHeight","setStartAngle","setEndAngle","setClockwise","setRotation","get","toJSON","type","fromJSON","data","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\r\n\r\nvar Class = require('../utils/Class');\r\nvar Curve = require('./Curve');\r\nvar DegToRad = require('../math/DegToRad');\r\nvar GetValue = require('../utils/object/GetValue');\r\nvar RadToDeg = require('../math/RadToDeg');\r\nvar Vector2 = require('../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * An Elliptical Curve derived from the Base Curve class.\r\n * \r\n * See https://en.wikipedia.org/wiki/Elliptic_curve for more details.\r\n *\r\n * @class Ellipse\r\n * @extends Phaser.Curves.Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(number|Phaser.Types.Curves.EllipseCurveConfig)} [x=0] - The x coordinate of the ellipse, or an Ellipse Curve configuration object.\r\n * @param {number} [y=0] - The y coordinate of the ellipse.\r\n * @param {number} [xRadius=0] - The horizontal radius of ellipse.\r\n * @param {number} [yRadius=0] - The vertical radius of ellipse.\r\n * @param {integer} [startAngle=0] - The start angle of the ellipse, in degrees.\r\n * @param {integer} [endAngle=360] - The end angle of the ellipse, in degrees.\r\n * @param {boolean} [clockwise=false] - Whether the ellipse angles are given as clockwise (`true`) or counter-clockwise (`false`).\r\n * @param {integer} [rotation=0] - The rotation of the ellipse, in degrees.\r\n */\r\nvar EllipseCurve = new Class({\r\n\r\n    Extends: Curve,\r\n\r\n    initialize:\r\n\r\n    function EllipseCurve (x, y, xRadius, yRadius, startAngle, endAngle, clockwise, rotation)\r\n    {\r\n        if (typeof x === 'object')\r\n        {\r\n            var config = x;\r\n\r\n            x = GetValue(config, 'x', 0);\r\n            y = GetValue(config, 'y', 0);\r\n            xRadius = GetValue(config, 'xRadius', 0);\r\n            yRadius = GetValue(config, 'yRadius', xRadius);\r\n            startAngle = GetValue(config, 'startAngle', 0);\r\n            endAngle = GetValue(config, 'endAngle', 360);\r\n            clockwise = GetValue(config, 'clockwise', false);\r\n            rotation = GetValue(config, 'rotation', 0);\r\n        }\r\n        else\r\n        {\r\n            if (yRadius === undefined) { yRadius = xRadius; }\r\n            if (startAngle === undefined) { startAngle = 0; }\r\n            if (endAngle === undefined) { endAngle = 360; }\r\n            if (clockwise === undefined) { clockwise = false; }\r\n            if (rotation === undefined) { rotation = 0; }\r\n        }\r\n\r\n        Curve.call(this, 'EllipseCurve');\r\n\r\n        //  Center point\r\n\r\n        /**\r\n         * The center point of the ellipse. Used for calculating rotation.\r\n         *\r\n         * @name Phaser.Curves.Ellipse#p0\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.p0 = new Vector2(x, y);\r\n\r\n        /**\r\n         * The horizontal radius of the ellipse.\r\n         *\r\n         * @name Phaser.Curves.Ellipse#_xRadius\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._xRadius = xRadius;\r\n\r\n        /**\r\n         * The vertical radius of the ellipse.\r\n         *\r\n         * @name Phaser.Curves.Ellipse#_yRadius\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._yRadius = yRadius;\r\n\r\n        //  Radians\r\n\r\n        /**\r\n         * The starting angle of the ellipse in radians.\r\n         *\r\n         * @name Phaser.Curves.Ellipse#_startAngle\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._startAngle = DegToRad(startAngle);\r\n\r\n        /**\r\n         * The end angle of the ellipse in radians.\r\n         *\r\n         * @name Phaser.Curves.Ellipse#_endAngle\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._endAngle = DegToRad(endAngle);\r\n\r\n        /**\r\n         * Anti-clockwise direction.\r\n         *\r\n         * @name Phaser.Curves.Ellipse#_clockwise\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._clockwise = clockwise;\r\n\r\n        /**\r\n         * The rotation of the arc.\r\n         *\r\n         * @name Phaser.Curves.Ellipse#_rotation\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._rotation = DegToRad(rotation);\r\n    },\r\n\r\n    /**\r\n     * Gets the starting point on the curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getStartPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return this.getPoint(0, out);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Ellipse#getResolution\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} divisions - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */\r\n    getResolution: function (divisions)\r\n    {\r\n        return divisions * 2;\r\n    },\r\n\r\n    /**\r\n     * Get point at relative position in curve according to length.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getPoint: function (t, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        var twoPi = Math.PI * 2;\r\n        var deltaAngle = this._endAngle - this._startAngle;\r\n        var samePoints = Math.abs(deltaAngle) < Number.EPSILON;\r\n\r\n        // ensures that deltaAngle is 0 .. 2 PI\r\n        while (deltaAngle < 0)\r\n        {\r\n            deltaAngle += twoPi;\r\n        }\r\n\r\n        while (deltaAngle > twoPi)\r\n        {\r\n            deltaAngle -= twoPi;\r\n        }\r\n\r\n        if (deltaAngle < Number.EPSILON)\r\n        {\r\n            if (samePoints)\r\n            {\r\n                deltaAngle = 0;\r\n            }\r\n            else\r\n            {\r\n                deltaAngle = twoPi;\r\n            }\r\n        }\r\n\r\n        if (this._clockwise && !samePoints)\r\n        {\r\n            if (deltaAngle === twoPi)\r\n            {\r\n                deltaAngle = - twoPi;\r\n            }\r\n            else\r\n            {\r\n                deltaAngle = deltaAngle - twoPi;\r\n            }\r\n        }\r\n\r\n        var angle = this._startAngle + t * deltaAngle;\r\n        var x = this.p0.x + this._xRadius * Math.cos(angle);\r\n        var y = this.p0.y + this._yRadius * Math.sin(angle);\r\n\r\n        if (this._rotation !== 0)\r\n        {\r\n            var cos = Math.cos(this._rotation);\r\n            var sin = Math.sin(this._rotation);\r\n\r\n            var tx = x - this.p0.x;\r\n            var ty = y - this.p0.y;\r\n\r\n            // Rotate the point about the center of the ellipse.\r\n            x = tx * cos - ty * sin + this.p0.x;\r\n            y = tx * sin + ty * cos + this.p0.y;\r\n        }\r\n\r\n        return out.set(x, y);\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal radius of this curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#setXRadius\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The horizontal radius of this curve.\r\n     *\r\n     * @return {Phaser.Curves.Ellipse} This curve object.\r\n     */\r\n    setXRadius: function (value)\r\n    {\r\n        this.xRadius = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical radius of this curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#setYRadius\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The vertical radius of this curve.\r\n     *\r\n     * @return {Phaser.Curves.Ellipse} This curve object.\r\n     */\r\n    setYRadius: function (value)\r\n    {\r\n        this.yRadius = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the width of this curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#setWidth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The width of this curve.\r\n     *\r\n     * @return {Phaser.Curves.Ellipse} This curve object.\r\n     */\r\n    setWidth: function (value)\r\n    {\r\n        this.xRadius = value * 2;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the height of this curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#setHeight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The height of this curve.\r\n     *\r\n     * @return {Phaser.Curves.Ellipse} This curve object.\r\n     */\r\n    setHeight: function (value)\r\n    {\r\n        this.yRadius = value * 2;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the start angle of this curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#setStartAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The start angle of this curve, in radians.\r\n     *\r\n     * @return {Phaser.Curves.Ellipse} This curve object.\r\n     */\r\n    setStartAngle: function (value)\r\n    {\r\n        this.startAngle = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the end angle of this curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#setEndAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The end angle of this curve, in radians.\r\n     *\r\n     * @return {Phaser.Curves.Ellipse} This curve object.\r\n     */\r\n    setEndAngle: function (value)\r\n    {\r\n        this.endAngle = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets if this curve extends clockwise or anti-clockwise.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#setClockwise\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The clockwise state of this curve.\r\n     *\r\n     * @return {Phaser.Curves.Ellipse} This curve object.\r\n     */\r\n    setClockwise: function (value)\r\n    {\r\n        this.clockwise = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the rotation of this curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#setRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The rotation of this curve, in radians.\r\n     *\r\n     * @return {Phaser.Curves.Ellipse} This curve object.\r\n     */\r\n    setRotation: function (value)\r\n    {\r\n        this.rotation = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The x coordinate of the center of the ellipse.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.p0.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.p0.x = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The y coordinate of the center of the ellipse.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.p0.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.p0.y = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The horizontal radius of the ellipse.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#xRadius\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    xRadius: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._xRadius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._xRadius = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical radius of the ellipse.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#yRadius\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    yRadius: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._yRadius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._yRadius = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The start angle of the ellipse in degrees.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#startAngle\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    startAngle: {\r\n\r\n        get: function ()\r\n        {\r\n            return RadToDeg(this._startAngle);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._startAngle = DegToRad(value);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The end angle of the ellipse in degrees.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#endAngle\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    endAngle: {\r\n\r\n        get: function ()\r\n        {\r\n            return RadToDeg(this._endAngle);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._endAngle = DegToRad(value);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * `true` if the ellipse rotation is clockwise or `false` if anti-clockwise.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#clockwise\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\r\n    clockwise: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._clockwise;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._clockwise = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The rotation of the ellipse, relative to the center, in degrees.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#angle\r\n     * @type {number}\r\n     * @since 3.14.0\r\n     */\r\n    angle: {\r\n\r\n        get: function ()\r\n        {\r\n            return RadToDeg(this._rotation);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._rotation = DegToRad(value);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The rotation of the ellipse, relative to the center, in radians.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#rotation\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    rotation: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._rotation;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._rotation = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * JSON serialization of the curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.Curves.JSONEllipseCurve} The JSON object containing this curve data.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return {\r\n            type: this.type,\r\n            x: this.p0.x,\r\n            y: this.p0.y,\r\n            xRadius: this._xRadius,\r\n            yRadius: this._yRadius,\r\n            startAngle: RadToDeg(this._startAngle),\r\n            endAngle: RadToDeg(this._endAngle),\r\n            clockwise: this._clockwise,\r\n            rotation: RadToDeg(this._rotation)\r\n        };\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Creates a curve from the provided Ellipse Curve Configuration object.\r\n *\r\n * @function Phaser.Curves.Ellipse.fromJSON\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Curves.JSONEllipseCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.Ellipse} The ellipse curve constructed from the configuration object.\r\n */\r\nEllipseCurve.fromJSON = function (data)\r\n{\r\n    return new EllipseCurve(data);\r\n};\r\n\r\nmodule.exports = EllipseCurve;\r\n"]},"metadata":{},"sourceType":"script"}