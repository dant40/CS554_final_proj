{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Body = require('./Body');\n\nvar Clamp = require('../../math/Clamp');\n\nvar Class = require('../../utils/Class');\n\nvar Collider = require('./Collider');\n\nvar CONST = require('./const');\n\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar FuzzyEqual = require('../../math/fuzzy/Equal');\n\nvar FuzzyGreaterThan = require('../../math/fuzzy/GreaterThan');\n\nvar FuzzyLessThan = require('../../math/fuzzy/LessThan');\n\nvar GetOverlapX = require('./GetOverlapX');\n\nvar GetOverlapY = require('./GetOverlapY');\n\nvar GetValue = require('../../utils/object/GetValue');\n\nvar ProcessQueue = require('../../structs/ProcessQueue');\n\nvar ProcessTileCallbacks = require('./tilemap/ProcessTileCallbacks');\n\nvar Rectangle = require('../../geom/rectangle/Rectangle');\n\nvar RTree = require('../../structs/RTree');\n\nvar SeparateTile = require('./tilemap/SeparateTile');\n\nvar SeparateX = require('./SeparateX');\n\nvar SeparateY = require('./SeparateY');\n\nvar Set = require('../../structs/Set');\n\nvar StaticBody = require('./StaticBody');\n\nvar TileIntersectsBody = require('./tilemap/TileIntersectsBody');\n\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\n\nvar Vector2 = require('../../math/Vector2');\n\nvar Wrap = require('../../math/Wrap');\n/**\r\n * @classdesc\r\n * The Arcade Physics World.\r\n *\r\n * The World is responsible for creating, managing, colliding and updating all of the bodies within it.\r\n *\r\n * An instance of the World belongs to a Phaser.Scene and is accessed via the property `physics.world`.\r\n *\r\n * @class World\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this World instance belongs.\r\n * @param {Phaser.Types.Physics.Arcade.ArcadeWorldConfig} config - An Arcade Physics Configuration object.\r\n */\n\n\nvar World = new Class({\n  Extends: EventEmitter,\n  initialize: function World(scene, config) {\n    EventEmitter.call(this);\n    /**\r\n     * The Scene this simulation belongs to.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n\n    this.scene = scene;\n    /**\r\n     * Dynamic Bodies in this simulation.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#bodies\r\n     * @type {Phaser.Structs.Set.<Phaser.Physics.Arcade.Body>}\r\n     * @since 3.0.0\r\n     */\n\n    this.bodies = new Set();\n    /**\r\n     * Static Bodies in this simulation.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#staticBodies\r\n     * @type {Phaser.Structs.Set.<Phaser.Physics.Arcade.StaticBody>}\r\n     * @since 3.0.0\r\n     */\n\n    this.staticBodies = new Set();\n    /**\r\n     * Static Bodies marked for deletion.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#pendingDestroy\r\n     * @type {Phaser.Structs.Set.<(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)>}\r\n     * @since 3.1.0\r\n     */\n\n    this.pendingDestroy = new Set();\n    /**\r\n     * This simulation's collision processors.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#colliders\r\n     * @type {Phaser.Structs.ProcessQueue.<Phaser.Physics.Arcade.Collider>}\r\n     * @since 3.0.0\r\n     */\n\n    this.colliders = new ProcessQueue();\n    /**\r\n     * Acceleration of Bodies due to gravity, in pixels per second.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#gravity\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\n\n    this.gravity = new Vector2(GetValue(config, 'gravity.x', 0), GetValue(config, 'gravity.y', 0));\n    /**\r\n     * A boundary constraining Bodies.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#bounds\r\n     * @type {Phaser.Geom.Rectangle}\r\n     * @since 3.0.0\r\n     */\n\n    this.bounds = new Rectangle(GetValue(config, 'x', 0), GetValue(config, 'y', 0), GetValue(config, 'width', scene.sys.scale.width), GetValue(config, 'height', scene.sys.scale.height));\n    /**\r\n     * The boundary edges that Bodies can collide with.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#checkCollision\r\n     * @type {Phaser.Types.Physics.Arcade.CheckCollisionObject}\r\n     * @since 3.0.0\r\n     */\n\n    this.checkCollision = {\n      up: GetValue(config, 'checkCollision.up', true),\n      down: GetValue(config, 'checkCollision.down', true),\n      left: GetValue(config, 'checkCollision.left', true),\n      right: GetValue(config, 'checkCollision.right', true)\n    };\n    /**\r\n     * The number of physics steps to be taken per second.\r\n     *\r\n     * This property is read-only. Use the `setFPS` method to modify it at run-time.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#fps\r\n     * @readonly\r\n     * @type {number}\r\n     * @default 60\r\n     * @since 3.10.0\r\n     */\n\n    this.fps = GetValue(config, 'fps', 60);\n    /**\r\n     * The amount of elapsed ms since the last frame.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#_elapsed\r\n     * @private\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\n\n    this._elapsed = 0;\n    /**\r\n     * Internal frame time value.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#_frameTime\r\n     * @private\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\n\n    this._frameTime = 1 / this.fps;\n    /**\r\n     * Internal frame time ms value.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#_frameTimeMS\r\n     * @private\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\n\n    this._frameTimeMS = 1000 * this._frameTime;\n    /**\r\n     * The number of steps that took place in the last frame.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#stepsLastFrame\r\n     * @readonly\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\n\n    this.stepsLastFrame = 0;\n    /**\r\n     * Scaling factor applied to the frame rate.\r\n     *\r\n     * - 1.0 = normal speed\r\n     * - 2.0 = half speed\r\n     * - 0.5 = double speed\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#timeScale\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.10.0\r\n     */\n\n    this.timeScale = GetValue(config, 'timeScale', 1);\n    /**\r\n     * The maximum absolute difference of a Body's per-step velocity and its overlap with another Body that will result in separation on *each axis*.\r\n     * Larger values favor separation.\r\n     * Smaller values favor no separation.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#OVERLAP_BIAS\r\n     * @type {number}\r\n     * @default 4\r\n     * @since 3.0.0\r\n     */\n\n    this.OVERLAP_BIAS = GetValue(config, 'overlapBias', 4);\n    /**\r\n     * The maximum absolute value of a Body's overlap with a tile that will result in separation on *each axis*.\r\n     * Larger values favor separation.\r\n     * Smaller values favor no separation.\r\n     * The optimum value may be similar to the tile size.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#TILE_BIAS\r\n     * @type {number}\r\n     * @default 16\r\n     * @since 3.0.0\r\n     */\n\n    this.TILE_BIAS = GetValue(config, 'tileBias', 16);\n    /**\r\n     * Always separate overlapping Bodies horizontally before vertically.\r\n     * False (the default) means Bodies are first separated on the axis of greater gravity, or the vertical axis if neither is greater.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#forceX\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.forceX = GetValue(config, 'forceX', false);\n    /**\r\n     * Whether the simulation advances with the game loop.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#isPaused\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.isPaused = GetValue(config, 'isPaused', false);\n    /**\r\n     * Temporary total of colliding Bodies.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#_total\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this._total = 0;\n    /**\r\n     * Enables the debug display.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#drawDebug\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.drawDebug = GetValue(config, 'debug', false);\n    /**\r\n     * The graphics object drawing the debug display.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#debugGraphic\r\n     * @type {Phaser.GameObjects.Graphics}\r\n     * @since 3.0.0\r\n     */\n\n    this.debugGraphic;\n    /**\r\n     * Default debug display settings for new Bodies.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#defaults\r\n     * @type {Phaser.Types.Physics.Arcade.ArcadeWorldDefaults}\r\n     * @since 3.0.0\r\n     */\n\n    this.defaults = {\n      debugShowBody: GetValue(config, 'debugShowBody', true),\n      debugShowStaticBody: GetValue(config, 'debugShowStaticBody', true),\n      debugShowVelocity: GetValue(config, 'debugShowVelocity', true),\n      bodyDebugColor: GetValue(config, 'debugBodyColor', 0xff00ff),\n      staticBodyDebugColor: GetValue(config, 'debugStaticBodyColor', 0x0000ff),\n      velocityDebugColor: GetValue(config, 'debugVelocityColor', 0x00ff00)\n    };\n    /**\r\n     * The maximum number of items per node on the RTree.\r\n     *\r\n     * This is ignored if `useTree` is `false`. If you have a large number of bodies in\r\n     * your world then you may find search performance improves by increasing this value,\r\n     * to allow more items per node and less node division.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#maxEntries\r\n     * @type {integer}\r\n     * @default 16\r\n     * @since 3.0.0\r\n     */\n\n    this.maxEntries = GetValue(config, 'maxEntries', 16);\n    /**\r\n     * Should this Arcade Physics World use an RTree for Dynamic and Static Physics bodies?\r\n     *\r\n     * An RTree is a fast way of spatially sorting of all the bodies in the world.\r\n     * However, at certain limits, the cost of clearing and inserting the bodies into the\r\n     * tree every frame becomes more expensive than the search speed gains it provides.\r\n     *\r\n     * If you have a large number of dynamic bodies in your world then it may be best to\r\n     * disable the use of the RTree by setting this property to `false` in the physics config.\r\n     *\r\n     * The number it can cope with depends on browser and device, but a conservative estimate\r\n     * of around 5,000 bodies should be considered the max before disabling it.\r\n     *\r\n     * This only applies to dynamic bodies. Static bodies are always kept in an RTree,\r\n     * because they don't have to be cleared every frame, so you benefit from the\r\n     * massive search speeds all the time.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#useTree\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.10.0\r\n     */\n\n    this.useTree = GetValue(config, 'useTree', true);\n    /**\r\n     * The spatial index of Dynamic Bodies.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#tree\r\n     * @type {Phaser.Structs.RTree}\r\n     * @since 3.0.0\r\n     */\n\n    this.tree = new RTree(this.maxEntries);\n    /**\r\n     * The spatial index of Static Bodies.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#staticTree\r\n     * @type {Phaser.Structs.RTree}\r\n     * @since 3.0.0\r\n     */\n\n    this.staticTree = new RTree(this.maxEntries);\n    /**\r\n     * Recycled input for tree searches.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#treeMinMax\r\n     * @type {Phaser.Types.Physics.Arcade.ArcadeWorldTreeMinMax}\r\n     * @since 3.0.0\r\n     */\n\n    this.treeMinMax = {\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0\n    };\n    /**\r\n     * A temporary Transform Matrix used by bodies for calculations without them needing their own local copy.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#_tempMatrix\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix used by bodies for calculations without them needing their own local copy.\r\n     *\r\n     * @name Phaser.Physics.Arcade.World#_tempMatrix2\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._tempMatrix2 = new TransformMatrix();\n\n    if (this.drawDebug) {\n      this.createDebugGraphic();\n    }\n  },\n\n  /**\r\n   * Adds an Arcade Physics Body to a Game Object, an array of Game Objects, or the children of a Group.\r\n   *\r\n   * The difference between this and the `enableBody` method is that you can pass arrays or Groups\r\n   * to this method.\r\n   *\r\n   * You can specify if the bodies are to be Dynamic or Static. A dynamic body can move via velocity and\r\n   * acceleration. A static body remains fixed in place and as such is able to use an optimized search\r\n   * tree, making it ideal for static elements such as level objects. You can still collide and overlap\r\n   * with static bodies.\r\n   *\r\n   * Normally, rather than calling this method directly, you'd use the helper methods available in the\r\n   * Arcade Physics Factory, such as:\r\n   *\r\n   * ```javascript\r\n   * this.physics.add.image(x, y, textureKey);\r\n   * this.physics.add.sprite(x, y, textureKey);\r\n   * ```\r\n   *\r\n   * Calling factory methods encapsulates the creation of a Game Object and the creation of its\r\n   * body at the same time. If you are creating custom classes then you can pass them to this\r\n   * method to have their bodies created.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#enable\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object - The object, or objects, on which to create the bodies.\r\n   * @param {integer} [bodyType] - The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.\r\n   */\n  enable: function (object, bodyType) {\n    if (bodyType === undefined) {\n      bodyType = CONST.DYNAMIC_BODY;\n    }\n\n    if (!Array.isArray(object)) {\n      object = [object];\n    }\n\n    for (var i = 0; i < object.length; i++) {\n      var entry = object[i];\n\n      if (entry.isParent) {\n        var children = entry.getChildren();\n\n        for (var c = 0; c < children.length; c++) {\n          var child = children[c];\n\n          if (child.isParent) {\n            //  Handle Groups nested inside of Groups\n            this.enable(child, bodyType);\n          } else {\n            this.enableBody(child, bodyType);\n          }\n        }\n      } else {\n        this.enableBody(entry, bodyType);\n      }\n    }\n  },\n\n  /**\r\n   * Creates an Arcade Physics Body on a single Game Object.\r\n   *\r\n   * If the Game Object already has a body, this method will simply add it back into the simulation.\r\n   *\r\n   * You can specify if the body is Dynamic or Static. A dynamic body can move via velocity and\r\n   * acceleration. A static body remains fixed in place and as such is able to use an optimized search\r\n   * tree, making it ideal for static elements such as level objects. You can still collide and overlap\r\n   * with static bodies.\r\n   *\r\n   * Normally, rather than calling this method directly, you'd use the helper methods available in the\r\n   * Arcade Physics Factory, such as:\r\n   *\r\n   * ```javascript\r\n   * this.physics.add.image(x, y, textureKey);\r\n   * this.physics.add.sprite(x, y, textureKey);\r\n   * ```\r\n   *\r\n   * Calling factory methods encapsulates the creation of a Game Object and the creation of its\r\n   * body at the same time. If you are creating custom classes then you can pass them to this\r\n   * method to have their bodies created.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#enableBody\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} object - The Game Object on which to create the body.\r\n   * @param {integer} [bodyType] - The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject} The Game Object on which the body was created.\r\n   */\n  enableBody: function (object, bodyType) {\n    if (bodyType === undefined) {\n      bodyType = CONST.DYNAMIC_BODY;\n    }\n\n    if (!object.body) {\n      if (bodyType === CONST.DYNAMIC_BODY) {\n        object.body = new Body(this, object);\n      } else if (bodyType === CONST.STATIC_BODY) {\n        object.body = new StaticBody(this, object);\n      }\n    }\n\n    this.add(object.body);\n    return object;\n  },\n\n  /**\r\n   * Adds an existing Arcade Physics Body or StaticBody to the simulation.\r\n   *\r\n   * The body is enabled and added to the local search trees.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#add\r\n   * @since 3.10.0\r\n   *\r\n   * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The Body to be added to the simulation.\r\n   *\r\n   * @return {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} The Body that was added to the simulation.\r\n   */\n  add: function (body) {\n    if (body.physicsType === CONST.DYNAMIC_BODY) {\n      this.bodies.set(body);\n    } else if (body.physicsType === CONST.STATIC_BODY) {\n      this.staticBodies.set(body);\n      this.staticTree.insert(body);\n    }\n\n    body.enable = true;\n    return body;\n  },\n\n  /**\r\n   * Disables the Arcade Physics Body of a Game Object, an array of Game Objects, or the children of a Group.\r\n   *\r\n   * The difference between this and the `disableBody` method is that you can pass arrays or Groups\r\n   * to this method.\r\n   *\r\n   * The body itself is not deleted, it just has its `enable` property set to false, which\r\n   * means you can re-enable it again at any point by passing it to enable `World.enable` or `World.add`.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#disable\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object - The object, or objects, on which to disable the bodies.\r\n   */\n  disable: function (object) {\n    if (!Array.isArray(object)) {\n      object = [object];\n    }\n\n    for (var i = 0; i < object.length; i++) {\n      var entry = object[i];\n\n      if (entry.isParent) {\n        var children = entry.getChildren();\n\n        for (var c = 0; c < children.length; c++) {\n          var child = children[c];\n\n          if (child.isParent) {\n            //  Handle Groups nested inside of Groups\n            this.disable(child);\n          } else {\n            this.disableBody(child.body);\n          }\n        }\n      } else {\n        this.disableBody(entry.body);\n      }\n    }\n  },\n\n  /**\r\n   * Disables an existing Arcade Physics Body or StaticBody and removes it from the simulation.\r\n   *\r\n   * The body is disabled and removed from the local search trees.\r\n   *\r\n   * The body itself is not deleted, it just has its `enable` property set to false, which\r\n   * means you can re-enable it again at any point by passing it to enable `World.enable` or `World.add`.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#disableBody\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The Body to be disabled.\r\n   */\n  disableBody: function (body) {\n    this.remove(body);\n    body.enable = false;\n  },\n\n  /**\r\n   * Removes an existing Arcade Physics Body or StaticBody from the simulation.\r\n   *\r\n   * The body is disabled and removed from the local search trees.\r\n   *\r\n   * The body itself is not deleted, it just has its `enabled` property set to false, which\r\n   * means you can re-enable it again at any point by passing it to enable `enable` or `add`.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#remove\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The body to be removed from the simulation.\r\n   */\n  remove: function (body) {\n    if (body.physicsType === CONST.DYNAMIC_BODY) {\n      this.tree.remove(body);\n      this.bodies.delete(body);\n    } else if (body.physicsType === CONST.STATIC_BODY) {\n      this.staticBodies.delete(body);\n      this.staticTree.remove(body);\n    }\n  },\n\n  /**\r\n   * Creates a Graphics Game Object that the world will use to render the debug display to.\r\n   *\r\n   * This is called automatically when the World is instantiated if the `debug` config property\r\n   * was set to `true`. However, you can call it at any point should you need to display the\r\n   * debug Graphic from a fixed point.\r\n   *\r\n   * You can control which objects are drawn to the Graphics object, and the colors they use,\r\n   * by setting the debug properties in the physics config.\r\n   *\r\n   * You should not typically use this in a production game. Use it to aid during debugging.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#createDebugGraphic\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.GameObjects.Graphics} The Graphics object that was created for use by the World.\r\n   */\n  createDebugGraphic: function () {\n    var graphic = this.scene.sys.add.graphics({\n      x: 0,\n      y: 0\n    });\n    graphic.setDepth(Number.MAX_VALUE);\n    this.debugGraphic = graphic;\n    this.drawDebug = true;\n    return graphic;\n  },\n\n  /**\r\n   * Sets the position, size and properties of the World boundary.\r\n   *\r\n   * The World boundary is an invisible rectangle that defines the edges of the World.\r\n   * If a Body is set to collide with the world bounds then it will automatically stop\r\n   * when it reaches any of the edges. You can optionally set which edges of the boundary\r\n   * should be checked against.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#setBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The top-left x coordinate of the boundary.\r\n   * @param {number} y - The top-left y coordinate of the boundary.\r\n   * @param {number} width - The width of the boundary.\r\n   * @param {number} height - The height of the boundary.\r\n   * @param {boolean} [checkLeft] - Should bodies check against the left edge of the boundary?\r\n   * @param {boolean} [checkRight] - Should bodies check against the right edge of the boundary?\r\n   * @param {boolean} [checkUp] - Should bodies check against the top edge of the boundary?\r\n   * @param {boolean} [checkDown] - Should bodies check against the bottom edge of the boundary?\r\n   *\r\n   * @return {Phaser.Physics.Arcade.World} This World object.\r\n   */\n  setBounds: function (x, y, width, height, checkLeft, checkRight, checkUp, checkDown) {\n    this.bounds.setTo(x, y, width, height);\n\n    if (checkLeft !== undefined) {\n      this.setBoundsCollision(checkLeft, checkRight, checkUp, checkDown);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Enables or disables collisions on each edge of the World boundary.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#setBoundsCollision\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [left=true] - Should bodies check against the left edge of the boundary?\r\n   * @param {boolean} [right=true] - Should bodies check against the right edge of the boundary?\r\n   * @param {boolean} [up=true] - Should bodies check against the top edge of the boundary?\r\n   * @param {boolean} [down=true] - Should bodies check against the bottom edge of the boundary?\r\n   *\r\n   * @return {Phaser.Physics.Arcade.World} This World object.\r\n   */\n  setBoundsCollision: function (left, right, up, down) {\n    if (left === undefined) {\n      left = true;\n    }\n\n    if (right === undefined) {\n      right = true;\n    }\n\n    if (up === undefined) {\n      up = true;\n    }\n\n    if (down === undefined) {\n      down = true;\n    }\n\n    this.checkCollision.left = left;\n    this.checkCollision.right = right;\n    this.checkCollision.up = up;\n    this.checkCollision.down = down;\n    return this;\n  },\n\n  /**\r\n   * Pauses the simulation.\r\n   *\r\n   * A paused simulation does not update any existing bodies, or run any Colliders.\r\n   *\r\n   * However, you can still enable and disable bodies within it, or manually run collide or overlap\r\n   * checks.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#pause\r\n   * @fires Phaser.Physics.Arcade.Events#PAUSE\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Arcade.World} This World object.\r\n   */\n  pause: function () {\n    this.isPaused = true;\n    this.emit(Events.PAUSE);\n    return this;\n  },\n\n  /**\r\n   * Resumes the simulation, if paused.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#resume\r\n   * @fires Phaser.Physics.Arcade.Events#RESUME\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Arcade.World} This World object.\r\n   */\n  resume: function () {\n    this.isPaused = false;\n    this.emit(Events.RESUME);\n    return this;\n  },\n\n  /**\r\n   * Creates a new Collider object and adds it to the simulation.\r\n   *\r\n   * A Collider is a way to automatically perform collision checks between two objects,\r\n   * calling the collide and process callbacks if they occur.\r\n   *\r\n   * Colliders are run as part of the World update, after all of the Bodies have updated.\r\n   *\r\n   * By creating a Collider you don't need then call `World.collide` in your `update` loop,\r\n   * as it will be handled for you automatically.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#addCollider\r\n   * @since 3.0.0\r\n   * @see Phaser.Physics.Arcade.World#collide\r\n   *\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object to check for collision.\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object2 - The second object to check for collision.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.\r\n   * @param {*} [callbackContext] - The scope in which to call the callbacks.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\r\n   */\n  addCollider: function (object1, object2, collideCallback, processCallback, callbackContext) {\n    if (collideCallback === undefined) {\n      collideCallback = null;\n    }\n\n    if (processCallback === undefined) {\n      processCallback = null;\n    }\n\n    if (callbackContext === undefined) {\n      callbackContext = collideCallback;\n    }\n\n    var collider = new Collider(this, false, object1, object2, collideCallback, processCallback, callbackContext);\n    this.colliders.add(collider);\n    return collider;\n  },\n\n  /**\r\n   * Creates a new Overlap Collider object and adds it to the simulation.\r\n   *\r\n   * A Collider is a way to automatically perform overlap checks between two objects,\r\n   * calling the collide and process callbacks if they occur.\r\n   *\r\n   * Colliders are run as part of the World update, after all of the Bodies have updated.\r\n   *\r\n   * By creating a Collider you don't need then call `World.overlap` in your `update` loop,\r\n   * as it will be handled for you automatically.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#addOverlap\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object to check for overlap.\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object2 - The second object to check for overlap.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects overlap.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects overlap. Must return a boolean.\r\n   * @param {*} [callbackContext] - The scope in which to call the callbacks.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\r\n   */\n  addOverlap: function (object1, object2, collideCallback, processCallback, callbackContext) {\n    if (collideCallback === undefined) {\n      collideCallback = null;\n    }\n\n    if (processCallback === undefined) {\n      processCallback = null;\n    }\n\n    if (callbackContext === undefined) {\n      callbackContext = collideCallback;\n    }\n\n    var collider = new Collider(this, true, object1, object2, collideCallback, processCallback, callbackContext);\n    this.colliders.add(collider);\n    return collider;\n  },\n\n  /**\r\n   * Removes a Collider from the simulation so it is no longer processed.\r\n   *\r\n   * This method does not destroy the Collider. If you wish to add it back at a later stage you can call\r\n   * `World.colliders.add(Collider)`.\r\n   *\r\n   * If you no longer need the Collider you can call the `Collider.destroy` method instead, which will\r\n   * automatically clear all of its references and then remove it from the World. If you call destroy on\r\n   * a Collider you _don't_ need to pass it to this method too.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#removeCollider\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Arcade.Collider} collider - The Collider to remove from the simulation.\r\n   *\r\n   * @return {Phaser.Physics.Arcade.World} This World object.\r\n   */\n  removeCollider: function (collider) {\n    this.colliders.remove(collider);\n    return this;\n  },\n\n  /**\r\n   * Sets the frame rate to run the simulation at.\r\n   *\r\n   * The frame rate value is used to simulate a fixed update time step. This fixed\r\n   * time step allows for a straightforward implementation of a deterministic game state.\r\n   *\r\n   * This frame rate is independent of the frequency at which the game is rendering. The\r\n   * higher you set the fps, the more physics simulation steps will occur per game step.\r\n   * Conversely, the lower you set it, the less will take place.\r\n   *\r\n   * You can optionally advance the simulation directly yourself by calling the `step` method.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#setFPS\r\n   * @since 3.10.0\r\n   *\r\n   * @param {integer} framerate - The frame rate to advance the simulation at.\r\n   *\r\n   * @return {this} This World object.\r\n   */\n  setFPS: function (framerate) {\n    this.fps = framerate;\n    this._frameTime = 1 / this.fps;\n    this._frameTimeMS = 1000 * this._frameTime;\n    return this;\n  },\n\n  /**\r\n   * Advances the simulation based on the elapsed time and fps rate.\r\n   *\r\n   * This is called automatically by your Scene and does not need to be invoked directly.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#update\r\n   * @protected\r\n   * @fires Phaser.Physics.Arcade.Events#WORLD_STEP\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n   * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n   */\n  update: function (time, delta) {\n    if (this.isPaused || this.bodies.size === 0) {\n      return;\n    }\n\n    var i;\n    var fixedDelta = this._frameTime;\n    var msPerFrame = this._frameTimeMS * this.timeScale;\n    this._elapsed += delta; //  Update all active bodies\n\n    var body;\n    var bodies = this.bodies.entries; //  Will a step happen this frame?\n\n    var willStep = this._elapsed >= msPerFrame;\n\n    for (i = 0; i < bodies.length; i++) {\n      body = bodies[i];\n\n      if (body.enable) {\n        body.preUpdate(willStep, fixedDelta);\n      }\n    } //  We know that a step will happen this frame, so let's bundle it all together to save branching and iteration costs\n\n\n    if (willStep) {\n      this._elapsed -= msPerFrame;\n      this.stepsLastFrame = 1; //  Optionally populate our dynamic collision tree\n\n      if (this.useTree) {\n        this.tree.clear();\n        this.tree.load(bodies);\n      } //  Process any colliders\n\n\n      var colliders = this.colliders.update();\n\n      for (i = 0; i < colliders.length; i++) {\n        var collider = colliders[i];\n\n        if (collider.active) {\n          collider.update();\n        }\n      }\n\n      this.emit(Events.WORLD_STEP);\n    } //  Process any additional steps this frame\n\n\n    while (this._elapsed >= msPerFrame) {\n      this._elapsed -= msPerFrame;\n      this.step(fixedDelta);\n    }\n  },\n\n  /**\r\n   * Advances the simulation by a time increment.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#step\r\n   * @fires Phaser.Physics.Arcade.Events#WORLD_STEP\r\n   * @since 3.10.0\r\n   *\r\n   * @param {number} delta - The delta time amount, in seconds, by which to advance the simulation.\r\n   */\n  step: function (delta) {\n    //  Update all active bodies\n    var i;\n    var body;\n    var bodies = this.bodies.entries;\n    var len = bodies.length;\n\n    for (i = 0; i < len; i++) {\n      body = bodies[i];\n\n      if (body.enable) {\n        body.update(delta);\n      }\n    } //  Optionally populate our dynamic collision tree\n\n\n    if (this.useTree) {\n      this.tree.clear();\n      this.tree.load(bodies);\n    } //  Process any colliders\n\n\n    var colliders = this.colliders.update();\n\n    for (i = 0; i < colliders.length; i++) {\n      var collider = colliders[i];\n\n      if (collider.active) {\n        collider.update();\n      }\n    }\n\n    this.emit(Events.WORLD_STEP);\n    this.stepsLastFrame++;\n  },\n\n  /**\r\n   * Updates bodies, draws the debug display, and handles pending queue operations.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#postUpdate\r\n   * @since 3.0.0\r\n   */\n  postUpdate: function () {\n    var i;\n    var body;\n    var bodies = this.bodies.entries;\n    var len = bodies.length;\n    var dynamic = this.bodies;\n    var staticBodies = this.staticBodies; //  We don't need to postUpdate if there wasn't a step this frame\n\n    if (this.stepsLastFrame) {\n      this.stepsLastFrame = 0;\n\n      for (i = 0; i < len; i++) {\n        body = bodies[i];\n\n        if (body.enable) {\n          body.postUpdate();\n        }\n      }\n    }\n\n    if (this.drawDebug) {\n      var graphics = this.debugGraphic;\n      graphics.clear();\n\n      for (i = 0; i < len; i++) {\n        body = bodies[i];\n\n        if (body.willDrawDebug()) {\n          body.drawDebug(graphics);\n        }\n      }\n\n      bodies = staticBodies.entries;\n      len = bodies.length;\n\n      for (i = 0; i < len; i++) {\n        body = bodies[i];\n\n        if (body.willDrawDebug()) {\n          body.drawDebug(graphics);\n        }\n      }\n    }\n\n    var pending = this.pendingDestroy;\n\n    if (pending.size > 0) {\n      var dynamicTree = this.tree;\n      var staticTree = this.staticTree;\n      bodies = pending.entries;\n      len = bodies.length;\n\n      for (i = 0; i < len; i++) {\n        body = bodies[i];\n\n        if (body.physicsType === CONST.DYNAMIC_BODY) {\n          dynamicTree.remove(body);\n          dynamic.delete(body);\n        } else if (body.physicsType === CONST.STATIC_BODY) {\n          staticTree.remove(body);\n          staticBodies.delete(body);\n        }\n\n        body.world = undefined;\n        body.gameObject = undefined;\n      }\n\n      pending.clear();\n    }\n  },\n\n  /**\r\n   * Calculates a Body's velocity and updates its position.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#updateMotion\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Arcade.Body} body - The Body to be updated.\r\n   * @param {number} delta - The delta value to be used in the motion calculations, in seconds.\r\n   */\n  updateMotion: function (body, delta) {\n    if (body.allowRotation) {\n      this.computeAngularVelocity(body, delta);\n    }\n\n    this.computeVelocity(body, delta);\n  },\n\n  /**\r\n   * Calculates a Body's angular velocity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#computeAngularVelocity\r\n   * @since 3.10.0\r\n   *\r\n   * @param {Phaser.Physics.Arcade.Body} body - The Body to compute the velocity for.\r\n   * @param {number} delta - The delta value to be used in the calculation, in seconds.\r\n   */\n  computeAngularVelocity: function (body, delta) {\n    var velocity = body.angularVelocity;\n    var acceleration = body.angularAcceleration;\n    var drag = body.angularDrag;\n    var max = body.maxAngular;\n\n    if (acceleration) {\n      velocity += acceleration * delta;\n    } else if (body.allowDrag && drag) {\n      drag *= delta;\n\n      if (FuzzyGreaterThan(velocity - drag, 0, 0.1)) {\n        velocity -= drag;\n      } else if (FuzzyLessThan(velocity + drag, 0, 0.1)) {\n        velocity += drag;\n      } else {\n        velocity = 0;\n      }\n    }\n\n    velocity = Clamp(velocity, -max, max);\n    var velocityDelta = velocity - body.angularVelocity;\n    body.angularVelocity += velocityDelta;\n    body.rotation += body.angularVelocity * delta;\n  },\n\n  /**\r\n   * Calculates a Body's per-axis velocity.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#computeVelocity\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Arcade.Body} body - The Body to compute the velocity for.\r\n   * @param {number} delta - The delta value to be used in the calculation, in seconds.\r\n   */\n  computeVelocity: function (body, delta) {\n    var velocityX = body.velocity.x;\n    var accelerationX = body.acceleration.x;\n    var dragX = body.drag.x;\n    var maxX = body.maxVelocity.x;\n    var velocityY = body.velocity.y;\n    var accelerationY = body.acceleration.y;\n    var dragY = body.drag.y;\n    var maxY = body.maxVelocity.y;\n    var speed = body.speed;\n    var maxSpeed = body.maxSpeed;\n    var allowDrag = body.allowDrag;\n    var useDamping = body.useDamping;\n\n    if (body.allowGravity) {\n      velocityX += (this.gravity.x + body.gravity.x) * delta;\n      velocityY += (this.gravity.y + body.gravity.y) * delta;\n    }\n\n    if (accelerationX) {\n      velocityX += accelerationX * delta;\n    } else if (allowDrag && dragX) {\n      if (useDamping) {\n        //  Damping based deceleration\n        velocityX *= dragX;\n        speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n\n        if (FuzzyEqual(speed, 0, 0.001)) {\n          velocityX = 0;\n        }\n      } else {\n        //  Linear deceleration\n        dragX *= delta;\n\n        if (FuzzyGreaterThan(velocityX - dragX, 0, 0.01)) {\n          velocityX -= dragX;\n        } else if (FuzzyLessThan(velocityX + dragX, 0, 0.01)) {\n          velocityX += dragX;\n        } else {\n          velocityX = 0;\n        }\n      }\n    }\n\n    if (accelerationY) {\n      velocityY += accelerationY * delta;\n    } else if (allowDrag && dragY) {\n      if (useDamping) {\n        //  Damping based deceleration\n        velocityY *= dragY;\n        speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n\n        if (FuzzyEqual(speed, 0, 0.001)) {\n          velocityY = 0;\n        }\n      } else {\n        //  Linear deceleration\n        dragY *= delta;\n\n        if (FuzzyGreaterThan(velocityY - dragY, 0, 0.01)) {\n          velocityY -= dragY;\n        } else if (FuzzyLessThan(velocityY + dragY, 0, 0.01)) {\n          velocityY += dragY;\n        } else {\n          velocityY = 0;\n        }\n      }\n    }\n\n    velocityX = Clamp(velocityX, -maxX, maxX);\n    velocityY = Clamp(velocityY, -maxY, maxY);\n    body.velocity.set(velocityX, velocityY);\n\n    if (maxSpeed > -1 && speed > maxSpeed) {\n      body.velocity.normalize().scale(maxSpeed);\n      speed = maxSpeed;\n    }\n\n    body.speed = speed;\n  },\n\n  /**\r\n   * Separates two Bodies.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#separate\r\n   * @fires Phaser.Physics.Arcade.Events#COLLIDE\r\n   * @fires Phaser.Physics.Arcade.Events#OVERLAP\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to be separated.\r\n   * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to be separated.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - The process callback.\r\n   * @param {*} [callbackContext] - The context in which to invoke the callback.\r\n   * @param {boolean} [overlapOnly] - If this a collide or overlap check?\r\n   *\r\n   * @return {boolean} True if separation occurred, otherwise false.\r\n   */\n  separate: function (body1, body2, processCallback, callbackContext, overlapOnly) {\n    if (!body1.enable || !body2.enable || body1.checkCollision.none || body2.checkCollision.none || !this.intersects(body1, body2)) {\n      return false;\n    } //  They overlap. Is there a custom process callback? If it returns true then we can carry on, otherwise we should abort.\n\n\n    if (processCallback && processCallback.call(callbackContext, body1.gameObject, body2.gameObject) === false) {\n      return false;\n    } //  Circle vs. Circle quick bail out\n\n\n    if (body1.isCircle && body2.isCircle) {\n      return this.separateCircle(body1, body2, overlapOnly);\n    } // We define the behavior of bodies in a collision circle and rectangle\n    // If a collision occurs in the corner points of the rectangle, the body behave like circles\n    //  Either body1 or body2 is a circle\n\n\n    if (body1.isCircle !== body2.isCircle) {\n      var bodyRect = body1.isCircle ? body2 : body1;\n      var bodyCircle = body1.isCircle ? body1 : body2;\n      var rect = {\n        x: bodyRect.x,\n        y: bodyRect.y,\n        right: bodyRect.right,\n        bottom: bodyRect.bottom\n      };\n      var circle = bodyCircle.center;\n\n      if (circle.y < rect.y || circle.y > rect.bottom) {\n        if (circle.x < rect.x || circle.x > rect.right) {\n          return this.separateCircle(body1, body2, overlapOnly);\n        }\n      }\n    }\n\n    var resultX = false;\n    var resultY = false; //  Do we separate on x or y first?\n\n    if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x)) {\n      resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS); //  Are they still intersecting? Let's do the other axis then\n\n      if (this.intersects(body1, body2)) {\n        resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);\n      }\n    } else {\n      resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS); //  Are they still intersecting? Let's do the other axis then\n\n      if (this.intersects(body1, body2)) {\n        resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);\n      }\n    }\n\n    var result = resultX || resultY;\n\n    if (result) {\n      if (overlapOnly) {\n        if (body1.onOverlap || body2.onOverlap) {\n          this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);\n        }\n      } else if (body1.onCollide || body2.onCollide) {\n        this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);\n      }\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Separates two Bodies, when both are circular.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#separateCircle\r\n   * @fires Phaser.Physics.Arcade.Events#COLLIDE\r\n   * @fires Phaser.Physics.Arcade.Events#OVERLAP\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to be separated.\r\n   * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to be separated.\r\n   * @param {boolean} [overlapOnly] - If this a collide or overlap check?\r\n   * @param {number} [bias] - A small value added to the calculations.\r\n   *\r\n   * @return {boolean} True if separation occurred, otherwise false.\r\n   */\n  separateCircle: function (body1, body2, overlapOnly, bias) {\n    //  Set the bounding box overlap values into the bodies themselves (hence we don't use the return values here)\n    GetOverlapX(body1, body2, false, bias);\n    GetOverlapY(body1, body2, false, bias);\n    var overlap = 0;\n\n    if (body1.isCircle !== body2.isCircle) {\n      var rect = {\n        x: body2.isCircle ? body1.position.x : body2.position.x,\n        y: body2.isCircle ? body1.position.y : body2.position.y,\n        right: body2.isCircle ? body1.right : body2.right,\n        bottom: body2.isCircle ? body1.bottom : body2.bottom\n      };\n      var circle = {\n        x: body1.isCircle ? body1.center.x : body2.center.x,\n        y: body1.isCircle ? body1.center.y : body2.center.y,\n        radius: body1.isCircle ? body1.halfWidth : body2.halfWidth\n      };\n\n      if (circle.y < rect.y) {\n        if (circle.x < rect.x) {\n          overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.y) - circle.radius;\n        } else if (circle.x > rect.right) {\n          overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.y) - circle.radius;\n        }\n      } else if (circle.y > rect.bottom) {\n        if (circle.x < rect.x) {\n          overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.bottom) - circle.radius;\n        } else if (circle.x > rect.right) {\n          overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.bottom) - circle.radius;\n        }\n      }\n\n      overlap *= -1;\n    } else {\n      overlap = body1.halfWidth + body2.halfWidth - DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y);\n    } //  Can't separate two immovable bodies, or a body with its own custom separation logic\n\n\n    if (overlapOnly || overlap === 0 || body1.immovable && body2.immovable || body1.customSeparateX || body2.customSeparateX) {\n      if (overlap !== 0 && (body1.onOverlap || body2.onOverlap)) {\n        this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);\n      } //  return true if there was some overlap, otherwise false\n\n\n      return overlap !== 0;\n    }\n\n    var dx = body1.center.x - body2.center.x;\n    var dy = body1.center.y - body2.center.y;\n    var d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n    var nx = (body2.center.x - body1.center.x) / d || 0;\n    var ny = (body2.center.y - body1.center.y) / d || 0;\n    var p = 2 * (body1.velocity.x * nx + body1.velocity.y * ny - body2.velocity.x * nx - body2.velocity.y * ny) / (body1.mass + body2.mass);\n\n    if (!body1.immovable) {\n      body1.velocity.x = body1.velocity.x - p * body1.mass * nx;\n      body1.velocity.y = body1.velocity.y - p * body1.mass * ny;\n    }\n\n    if (!body2.immovable) {\n      body2.velocity.x = body2.velocity.x + p * body2.mass * nx;\n      body2.velocity.y = body2.velocity.y + p * body2.mass * ny;\n    }\n\n    var dvx = body2.velocity.x - body1.velocity.x;\n    var dvy = body2.velocity.y - body1.velocity.y;\n    var angleCollision = Math.atan2(dvy, dvx);\n    var delta = this._frameTime;\n\n    if (!body1.immovable && !body2.immovable) {\n      overlap /= 2;\n    }\n\n    if (!body1.immovable) {\n      body1.x += body1.velocity.x * delta - overlap * Math.cos(angleCollision);\n      body1.y += body1.velocity.y * delta - overlap * Math.sin(angleCollision);\n    }\n\n    if (!body2.immovable) {\n      body2.x += body2.velocity.x * delta + overlap * Math.cos(angleCollision);\n      body2.y += body2.velocity.y * delta + overlap * Math.sin(angleCollision);\n    }\n\n    body1.velocity.x *= body1.bounce.x;\n    body1.velocity.y *= body1.bounce.y;\n    body2.velocity.x *= body2.bounce.x;\n    body2.velocity.y *= body2.bounce.y;\n\n    if (body1.onCollide || body2.onCollide) {\n      this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Checks to see if two Bodies intersect at all.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#intersects\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Arcade.Body} body1 - The first body to check.\r\n   * @param {Phaser.Physics.Arcade.Body} body2 - The second body to check.\r\n   *\r\n   * @return {boolean} True if the two bodies intersect, otherwise false.\r\n   */\n  intersects: function (body1, body2) {\n    if (body1 === body2) {\n      return false;\n    }\n\n    if (!body1.isCircle && !body2.isCircle) {\n      //  Rect vs. Rect\n      return !(body1.right <= body2.position.x || body1.bottom <= body2.position.y || body1.position.x >= body2.right || body1.position.y >= body2.bottom);\n    } else if (body1.isCircle) {\n      if (body2.isCircle) {\n        //  Circle vs. Circle\n        return DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y) <= body1.halfWidth + body2.halfWidth;\n      } else {\n        //  Circle vs. Rect\n        return this.circleBodyIntersects(body1, body2);\n      }\n    } else {\n      //  Rect vs. Circle\n      return this.circleBodyIntersects(body2, body1);\n    }\n  },\n\n  /**\r\n   * Tests if a circular Body intersects with another Body.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#circleBodyIntersects\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Physics.Arcade.Body} circle - The circular body to test.\r\n   * @param {Phaser.Physics.Arcade.Body} body - The rectangular body to test.\r\n   *\r\n   * @return {boolean} True if the two bodies intersect, otherwise false.\r\n   */\n  circleBodyIntersects: function (circle, body) {\n    var x = Clamp(circle.center.x, body.left, body.right);\n    var y = Clamp(circle.center.y, body.top, body.bottom);\n    var dx = (circle.center.x - x) * (circle.center.x - x);\n    var dy = (circle.center.y - y) * (circle.center.y - y);\n    return dx + dy <= circle.halfWidth * circle.halfWidth;\n  },\n\n  /**\r\n   * Tests if Game Objects overlap.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#overlap\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n   * @param {ArcadePhysicsCallback} [overlapCallback] - An optional callback function that is called if the objects overlap.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `overlapCallback` will only be called if this callback returns `true`.\r\n   * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n   *\r\n   * @return {boolean} True if at least one Game Object overlaps another.\r\n   */\n  overlap: function (object1, object2, overlapCallback, processCallback, callbackContext) {\n    if (overlapCallback === undefined) {\n      overlapCallback = null;\n    }\n\n    if (processCallback === undefined) {\n      processCallback = null;\n    }\n\n    if (callbackContext === undefined) {\n      callbackContext = overlapCallback;\n    }\n\n    return this.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);\n  },\n\n  /**\r\n   * Performs a collision check and separation between the two physics enabled objects given, which can be single\r\n   * Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups.\r\n   *\r\n   * If you don't require separation then use {@link #overlap} instead.\r\n   *\r\n   * If two Groups or arrays are passed, each member of one will be tested against each member of the other.\r\n   *\r\n   * If **only** one Group is passed (as `object1`), each member of the Group will be collided against the other members.\r\n   *\r\n   * If **only** one Array is passed, the array is iterated and every element in it is tested against the others.\r\n   *\r\n   * Two callbacks can be provided. The `collideCallback` is invoked if a collision occurs and the two colliding\r\n   * objects are passed to it.\r\n   *\r\n   * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\r\n   * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\r\n   * The separation that stops two objects penetrating may create a new penetration against a different object. If you\r\n   * require a high level of stability please consider using an alternative physics system, such as Matter.js.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collide\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n   *\r\n   * @return {boolean} `true` if any overlapping Game Objects were separated, otherwise `false`.\r\n   */\n  collide: function (object1, object2, collideCallback, processCallback, callbackContext) {\n    if (collideCallback === undefined) {\n      collideCallback = null;\n    }\n\n    if (processCallback === undefined) {\n      processCallback = null;\n    }\n\n    if (callbackContext === undefined) {\n      callbackContext = collideCallback;\n    }\n\n    return this.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);\n  },\n\n  /**\r\n   * Internal helper function. Please use Phaser.Physics.Arcade.World#collide instead.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collideObjects\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object to check for collision.\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object to check for collision.\r\n   * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.\r\n   * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.\r\n   * @param {any} callbackContext - The scope in which to call the callbacks.\r\n   * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  collideObjects: function (object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {\n    var i;\n    var j;\n\n    if (object1.isParent && object1.physicsType === undefined) {\n      object1 = object1.children.entries;\n    }\n\n    if (object2 && object2.isParent && object2.physicsType === undefined) {\n      object2 = object2.children.entries;\n    }\n\n    var object1isArray = Array.isArray(object1);\n    var object2isArray = Array.isArray(object2);\n    this._total = 0;\n\n    if (!object1isArray && !object2isArray) {\n      //  Neither of them are arrays - do this first as it's the most common use-case\n      this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n    } else if (!object1isArray && object2isArray) {\n      //  Object 2 is an Array\n      for (i = 0; i < object2.length; i++) {\n        this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, overlapOnly);\n      }\n    } else if (object1isArray && !object2isArray) {\n      //  Object 1 is an Array\n      if (!object2) {\n        //  Special case for array vs. self\n        for (i = 0; i < object1.length; i++) {\n          var child = object1[i];\n\n          for (j = i + 1; j < object1.length; j++) {\n            if (i === j) {\n              continue;\n            }\n\n            this.collideHandler(child, object1[j], collideCallback, processCallback, callbackContext, overlapOnly);\n          }\n        }\n      } else {\n        for (i = 0; i < object1.length; i++) {\n          this.collideHandler(object1[i], object2, collideCallback, processCallback, callbackContext, overlapOnly);\n        }\n      }\n    } else {\n      //  They're both arrays\n      for (i = 0; i < object1.length; i++) {\n        for (j = 0; j < object2.length; j++) {\n          this.collideHandler(object1[i], object2[j], collideCallback, processCallback, callbackContext, overlapOnly);\n        }\n      }\n    }\n\n    return this._total > 0;\n  },\n\n  /**\r\n   * Internal helper function. Please use Phaser.Physics.Arcade.World#collide and Phaser.Physics.Arcade.World#overlap instead.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collideHandler\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object2 - The second object or array of objects to check, or `undefined`.\r\n   * @param {ArcadePhysicsCallback} collideCallback - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} processCallback - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} callbackContext - The context in which to run the callbacks.\r\n   * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  collideHandler: function (object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {\n    //  Collide Group with Self\n    //  Only collide valid objects\n    if (object2 === undefined && object1.isParent) {\n      return this.collideGroupVsGroup(object1, object1, collideCallback, processCallback, callbackContext, overlapOnly);\n    } //  If neither of the objects are set then bail out\n\n\n    if (!object1 || !object2) {\n      return false;\n    } //  A Body\n\n\n    if (object1.body) {\n      if (object2.body) {\n        return this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n      } else if (object2.isParent) {\n        return this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n      } else if (object2.isTilemap) {\n        return this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n      }\n    } //  GROUPS\n    else if (object1.isParent) {\n        if (object2.body) {\n          return this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\n        } else if (object2.isParent) {\n          return this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n        } else if (object2.isTilemap) {\n          return this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n        }\n      } //  TILEMAP LAYERS\n      else if (object1.isTilemap) {\n          if (object2.body) {\n            return this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\n          } else if (object2.isParent) {\n            return this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\n          }\n        }\n  },\n\n  /**\r\n   * Internal handler for Sprite vs. Sprite collisions.\r\n   * Please use Phaser.Physics.Arcade.World#collide instead.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collideSpriteVsSprite\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} sprite1 - The first object to check for collision.\r\n   * @param {Phaser.GameObjects.GameObject} sprite2 - The second object to check for collision.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n   * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  collideSpriteVsSprite: function (sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {\n    if (!sprite1.body || !sprite2.body) {\n      return false;\n    }\n\n    if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly)) {\n      if (collideCallback) {\n        collideCallback.call(callbackContext, sprite1, sprite2);\n      }\n\n      this._total++;\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Internal handler for Sprite vs. Group collisions.\r\n   * Please use Phaser.Physics.Arcade.World#collide instead.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collideSpriteVsGroup\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n   * @param {Phaser.GameObjects.Group} group - The second object to check for collision.\r\n   * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.\r\n   * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.\r\n   * @param {any} callbackContext - The scope in which to call the callbacks.\r\n   * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n   *\r\n   * @return {boolean} `true` if the Sprite collided with the given Group, otherwise `false`.\r\n   */\n  collideSpriteVsGroup: function (sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) {\n    var bodyA = sprite.body;\n\n    if (group.length === 0 || !bodyA || !bodyA.enable) {\n      return;\n    } //  Does sprite collide with anything?\n\n\n    var i;\n    var len;\n    var bodyB;\n\n    if (this.useTree) {\n      var minMax = this.treeMinMax;\n      minMax.minX = bodyA.left;\n      minMax.minY = bodyA.top;\n      minMax.maxX = bodyA.right;\n      minMax.maxY = bodyA.bottom;\n      var results = group.physicsType === CONST.DYNAMIC_BODY ? this.tree.search(minMax) : this.staticTree.search(minMax);\n      len = results.length;\n\n      for (i = 0; i < len; i++) {\n        bodyB = results[i];\n\n        if (bodyA === bodyB || !bodyB.enable || !group.contains(bodyB.gameObject)) {\n          //  Skip if comparing against itself, or if bodyB isn't actually part of the Group\n          continue;\n        }\n\n        if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly)) {\n          if (collideCallback) {\n            collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);\n          }\n\n          this._total++;\n        }\n      }\n    } else {\n      var children = group.getChildren();\n      var skipIndex = group.children.entries.indexOf(sprite);\n      len = children.length;\n\n      for (i = 0; i < len; i++) {\n        bodyB = children[i].body;\n\n        if (!bodyB || i === skipIndex || !bodyB.enable) {\n          continue;\n        }\n\n        if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly)) {\n          if (collideCallback) {\n            collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);\n          }\n\n          this._total++;\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Internal handler for Group vs. Tilemap collisions.\r\n   * Please use Phaser.Physics.Arcade.World#collide instead.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collideGroupVsTilemapLayer\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Group} group - The first object to check for collision.\r\n   * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The second object to check for collision.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n   * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  collideGroupVsTilemapLayer: function (group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {\n    var children = group.getChildren();\n\n    if (children.length === 0) {\n      return false;\n    }\n\n    var didCollide = false;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].body) {\n        if (this.collideSpriteVsTilemapLayer(children[i], tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)) {\n          didCollide = true;\n        }\n      }\n    }\n\n    return didCollide;\n  },\n\n  /**\r\n   * This advanced method is specifically for testing for collision between a single Sprite and an array of Tile objects.\r\n   *\r\n   * You should generally use the `collide` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\r\n   * tile filtering and culling for you, as well as handle the interesting face collision automatically.\r\n   *\r\n   * This method is offered for those who would like to check for collision with specific Tiles in a layer, without\r\n   * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic collisions\r\n   * on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\r\n   * you should filter them before passing them to this method.\r\n   *\r\n   * Important: Use of this method skips the `interesting faces` system that Tilemap Layers use. This means if you have\r\n   * say a row or column of tiles, and you jump into, or walk over them, it's possible to get stuck on the edges of the\r\n   * tiles as the interesting face calculations are skipped. However, for quick-fire small collision set tests on\r\n   * dynamic maps, this method can prove very useful.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collideTiles\r\n   * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\r\n   * @since 3.17.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n   * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  collideTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext) {\n    if (!sprite.body.enable || tiles.length === 0) {\n      return false;\n    } else {\n      return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, false, false);\n    }\n  },\n\n  /**\r\n   * This advanced method is specifically for testing for overlaps between a single Sprite and an array of Tile objects.\r\n   *\r\n   * You should generally use the `overlap` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\r\n   * tile filtering and culling for you, as well as handle the interesting face collision automatically.\r\n   *\r\n   * This method is offered for those who would like to check for overlaps with specific Tiles in a layer, without\r\n   * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic overlap\r\n   * tests on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\r\n   * you should filter them before passing them to this method.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#overlapTiles\r\n   * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\r\n   * @since 3.17.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n   * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects overlap.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  overlapTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext) {\n    if (!sprite.body.enable || tiles.length === 0) {\n      return false;\n    } else {\n      return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, true, false);\n    }\n  },\n\n  /**\r\n   * Internal handler for Sprite vs. Tilemap collisions.\r\n   * Please use Phaser.Physics.Arcade.World#collide instead.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collideSpriteVsTilemapLayer\r\n   * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\r\n   * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n   * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The second object to check for collision.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n   * @param {boolean} [overlapOnly] - Whether this is a collision or overlap check.\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  collideSpriteVsTilemapLayer: function (sprite, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {\n    var body = sprite.body;\n\n    if (!body.enable) {\n      return false;\n    }\n\n    var x = body.position.x;\n    var y = body.position.y;\n    var w = body.width;\n    var h = body.height; // TODO: this logic should be encapsulated within the Tilemap API at some point.\n    // If the maps base tile size differs from the layer's tile size, we need to adjust the\n    // selection area by the difference between the two.\n\n    var layerData = tilemapLayer.layer;\n\n    if (layerData.tileWidth > layerData.baseTileWidth) {\n      // The x origin of a tile is the left side, so x and width need to be adjusted.\n      var xDiff = (layerData.tileWidth - layerData.baseTileWidth) * tilemapLayer.scaleX;\n      x -= xDiff;\n      w += xDiff;\n    }\n\n    if (layerData.tileHeight > layerData.baseTileHeight) {\n      // The y origin of a tile is the bottom side, so just the height needs to be adjusted.\n      var yDiff = (layerData.tileHeight - layerData.baseTileHeight) * tilemapLayer.scaleY;\n      h += yDiff;\n    }\n\n    var mapData = tilemapLayer.getTilesWithinWorldXY(x, y, w, h);\n\n    if (mapData.length === 0) {\n      return false;\n    } else {\n      return this.collideSpriteVsTilesHandler(sprite, mapData, collideCallback, processCallback, callbackContext, overlapOnly, true);\n    }\n  },\n\n  /**\r\n   * Internal handler for Sprite vs. Tilemap collisions.\r\n   * Please use Phaser.Physics.Arcade.World#collide instead.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collideSpriteVsTilesHandler\r\n   * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\r\n   * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\r\n   * @private\r\n   * @since 3.17.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n   * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The second object to check for collision.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n   * @param {boolean} [overlapOnly] - Whether this is a collision or overlap check.\r\n   * @param {boolean} [isLayer] - Is this check coming from a TilemapLayer or an array of tiles?\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  collideSpriteVsTilesHandler: function (sprite, tiles, collideCallback, processCallback, callbackContext, overlapOnly, isLayer) {\n    var body = sprite.body;\n    var tile;\n    var tileWorldRect = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    var tilemapLayer;\n    var collision = false;\n\n    for (var i = 0; i < tiles.length; i++) {\n      tile = tiles[i];\n      tilemapLayer = tile.tilemapLayer;\n      tileWorldRect.left = tilemapLayer.tileToWorldX(tile.x);\n      tileWorldRect.top = tilemapLayer.tileToWorldY(tile.y); // If the map's base tile size differs from the layer's tile size, only the top of the rect\n      // needs to be adjusted since its origin is (0, 1).\n\n      if (tile.baseHeight !== tile.height) {\n        tileWorldRect.top -= (tile.height - tile.baseHeight) * tilemapLayer.scaleY;\n      }\n\n      tileWorldRect.right = tileWorldRect.left + tile.width * tilemapLayer.scaleX;\n      tileWorldRect.bottom = tileWorldRect.top + tile.height * tilemapLayer.scaleY;\n\n      if (TileIntersectsBody(tileWorldRect, body) && (!processCallback || processCallback.call(callbackContext, sprite, tile)) && ProcessTileCallbacks(tile, sprite) && (overlapOnly || SeparateTile(i, body, tile, tileWorldRect, tilemapLayer, this.TILE_BIAS, isLayer))) {\n        this._total++;\n        collision = true;\n\n        if (collideCallback) {\n          collideCallback.call(callbackContext, sprite, tile);\n        }\n\n        if (overlapOnly && body.onOverlap) {\n          this.emit(Events.TILE_OVERLAP, sprite, tile, body);\n        } else if (body.onCollide) {\n          this.emit(Events.TILE_COLLIDE, sprite, tile, body);\n        }\n      }\n    }\n\n    return collision;\n  },\n\n  /**\r\n   * Internal helper for Group vs. Group collisions.\r\n   * Please use Phaser.Physics.Arcade.World#collide instead.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#collideGroupVsGroup\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Group} group1 - The first object to check for collision.\r\n   * @param {Phaser.GameObjects.Group} group2 - The second object to check for collision.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n   * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  collideGroupVsGroup: function (group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) {\n    if (group1.length === 0 || group2.length === 0) {\n      return;\n    }\n\n    var children = group1.getChildren();\n\n    for (var i = 0; i < children.length; i++) {\n      this.collideSpriteVsGroup(children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);\n    }\n  },\n\n  /**\r\n   * Wrap an object's coordinates (or several objects' coordinates) within {@link Phaser.Physics.Arcade.World#bounds}.\r\n   *\r\n   * If the object is outside any boundary edge (left, top, right, bottom), it will be moved to the same offset from the opposite edge (the interior).\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#wrap\r\n   * @since 3.3.0\r\n   *\r\n   * @param {*} object - A Game Object, a Group, an object with `x` and `y` coordinates, or an array of such objects.\r\n   * @param {number} [padding=0] - An amount added to each boundary edge during the operation.\r\n   */\n  wrap: function (object, padding) {\n    if (object.body) {\n      this.wrapObject(object, padding);\n    } else if (object.getChildren) {\n      this.wrapArray(object.getChildren(), padding);\n    } else if (Array.isArray(object)) {\n      this.wrapArray(object, padding);\n    } else {\n      this.wrapObject(object, padding);\n    }\n  },\n\n  /**\r\n   * Wrap each object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#wrapArray\r\n   * @since 3.3.0\r\n   *\r\n   * @param {Array.<*>} objects - An array of objects to be wrapped.\r\n   * @param {number} [padding=0] - An amount added to the boundary.\r\n   */\n  wrapArray: function (objects, padding) {\n    for (var i = 0; i < objects.length; i++) {\n      this.wrapObject(objects[i], padding);\n    }\n  },\n\n  /**\r\n   * Wrap an object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#wrapObject\r\n   * @since 3.3.0\r\n   *\r\n   * @param {*} object - A Game Object, a Physics Body, or any object with `x` and `y` coordinates\r\n   * @param {number} [padding=0] - An amount added to the boundary.\r\n   */\n  wrapObject: function (object, padding) {\n    if (padding === undefined) {\n      padding = 0;\n    }\n\n    object.x = Wrap(object.x, this.bounds.left - padding, this.bounds.right + padding);\n    object.y = Wrap(object.y, this.bounds.top - padding, this.bounds.bottom + padding);\n  },\n\n  /**\r\n   * Shuts down the simulation, clearing physics data and removing listeners.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#shutdown\r\n   * @since 3.0.0\r\n   */\n  shutdown: function () {\n    this.tree.clear();\n    this.staticTree.clear();\n    this.bodies.clear();\n    this.staticBodies.clear();\n    this.colliders.destroy();\n    this.removeAllListeners();\n  },\n\n  /**\r\n   * Shuts down the simulation and disconnects it from the current scene.\r\n   *\r\n   * @method Phaser.Physics.Arcade.World#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.shutdown();\n    this.scene = null;\n  }\n});\nmodule.exports = World;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/arcade/World.js"],"names":["Body","require","Clamp","Class","Collider","CONST","DistanceBetween","EventEmitter","Events","FuzzyEqual","FuzzyGreaterThan","FuzzyLessThan","GetOverlapX","GetOverlapY","GetValue","ProcessQueue","ProcessTileCallbacks","Rectangle","RTree","SeparateTile","SeparateX","SeparateY","Set","StaticBody","TileIntersectsBody","TransformMatrix","Vector2","Wrap","World","Extends","initialize","scene","config","call","bodies","staticBodies","pendingDestroy","colliders","gravity","bounds","sys","scale","width","height","checkCollision","up","down","left","right","fps","_elapsed","_frameTime","_frameTimeMS","stepsLastFrame","timeScale","OVERLAP_BIAS","TILE_BIAS","forceX","isPaused","_total","drawDebug","debugGraphic","defaults","debugShowBody","debugShowStaticBody","debugShowVelocity","bodyDebugColor","staticBodyDebugColor","velocityDebugColor","maxEntries","useTree","tree","staticTree","treeMinMax","minX","minY","maxX","maxY","_tempMatrix","_tempMatrix2","createDebugGraphic","enable","object","bodyType","undefined","DYNAMIC_BODY","Array","isArray","i","length","entry","isParent","children","getChildren","c","child","enableBody","body","STATIC_BODY","add","physicsType","set","insert","disable","disableBody","remove","delete","graphic","graphics","x","y","setDepth","Number","MAX_VALUE","setBounds","checkLeft","checkRight","checkUp","checkDown","setTo","setBoundsCollision","pause","emit","PAUSE","resume","RESUME","addCollider","object1","object2","collideCallback","processCallback","callbackContext","collider","addOverlap","removeCollider","setFPS","framerate","update","time","delta","size","fixedDelta","msPerFrame","entries","willStep","preUpdate","clear","load","active","WORLD_STEP","step","len","postUpdate","dynamic","willDrawDebug","pending","dynamicTree","world","gameObject","updateMotion","allowRotation","computeAngularVelocity","computeVelocity","velocity","angularVelocity","acceleration","angularAcceleration","drag","angularDrag","max","maxAngular","allowDrag","velocityDelta","rotation","velocityX","accelerationX","dragX","maxVelocity","velocityY","accelerationY","dragY","speed","maxSpeed","useDamping","allowGravity","Math","sqrt","normalize","separate","body1","body2","overlapOnly","none","intersects","isCircle","separateCircle","bodyRect","bodyCircle","rect","bottom","circle","center","resultX","resultY","abs","result","onOverlap","OVERLAP","onCollide","COLLIDE","bias","overlap","position","radius","halfWidth","immovable","customSeparateX","dx","dy","d","pow","nx","ny","p","mass","dvx","dvy","angleCollision","atan2","cos","sin","bounce","circleBodyIntersects","top","overlapCallback","collideObjects","collide","j","object1isArray","object2isArray","collideHandler","collideGroupVsGroup","collideSpriteVsSprite","collideSpriteVsGroup","isTilemap","collideSpriteVsTilemapLayer","collideGroupVsTilemapLayer","sprite1","sprite2","sprite","group","bodyA","bodyB","minMax","results","search","contains","skipIndex","indexOf","tilemapLayer","didCollide","collideTiles","tiles","collideSpriteVsTilesHandler","overlapTiles","w","h","layerData","layer","tileWidth","baseTileWidth","xDiff","scaleX","tileHeight","baseTileHeight","yDiff","scaleY","mapData","getTilesWithinWorldXY","isLayer","tile","tileWorldRect","collision","tileToWorldX","tileToWorldY","baseHeight","TILE_OVERLAP","TILE_COLLIDE","group1","group2","wrap","padding","wrapObject","wrapArray","objects","shutdown","destroy","removeAllListeners","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Body = require('./Body');\r\nvar Clamp = require('../../math/Clamp');\r\nvar Class = require('../../utils/Class');\r\nvar Collider = require('./Collider');\r\nvar CONST = require('./const');\r\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar FuzzyEqual = require('../../math/fuzzy/Equal');\r\nvar FuzzyGreaterThan = require('../../math/fuzzy/GreaterThan');\r\nvar FuzzyLessThan = require('../../math/fuzzy/LessThan');\r\nvar GetOverlapX = require('./GetOverlapX');\r\nvar GetOverlapY = require('./GetOverlapY');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar ProcessQueue = require('../../structs/ProcessQueue');\r\nvar ProcessTileCallbacks = require('./tilemap/ProcessTileCallbacks');\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar RTree = require('../../structs/RTree');\r\nvar SeparateTile = require('./tilemap/SeparateTile');\r\nvar SeparateX = require('./SeparateX');\r\nvar SeparateY = require('./SeparateY');\r\nvar Set = require('../../structs/Set');\r\nvar StaticBody = require('./StaticBody');\r\nvar TileIntersectsBody = require('./tilemap/TileIntersectsBody');\r\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\r\nvar Vector2 = require('../../math/Vector2');\r\nvar Wrap = require('../../math/Wrap');\r\n\r\n/**\r\n * @classdesc\r\n * The Arcade Physics World.\r\n *\r\n * The World is responsible for creating, managing, colliding and updating all of the bodies within it.\r\n *\r\n * An instance of the World belongs to a Phaser.Scene and is accessed via the property `physics.world`.\r\n *\r\n * @class World\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this World instance belongs.\r\n * @param {Phaser.Types.Physics.Arcade.ArcadeWorldConfig} config - An Arcade Physics Configuration object.\r\n */\r\nvar World = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function World (scene, config)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The Scene this simulation belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * Dynamic Bodies in this simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#bodies\r\n         * @type {Phaser.Structs.Set.<Phaser.Physics.Arcade.Body>}\r\n         * @since 3.0.0\r\n         */\r\n        this.bodies = new Set();\r\n\r\n        /**\r\n         * Static Bodies in this simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#staticBodies\r\n         * @type {Phaser.Structs.Set.<Phaser.Physics.Arcade.StaticBody>}\r\n         * @since 3.0.0\r\n         */\r\n        this.staticBodies = new Set();\r\n\r\n        /**\r\n         * Static Bodies marked for deletion.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#pendingDestroy\r\n         * @type {Phaser.Structs.Set.<(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)>}\r\n         * @since 3.1.0\r\n         */\r\n        this.pendingDestroy = new Set();\r\n\r\n        /**\r\n         * This simulation's collision processors.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#colliders\r\n         * @type {Phaser.Structs.ProcessQueue.<Phaser.Physics.Arcade.Collider>}\r\n         * @since 3.0.0\r\n         */\r\n        this.colliders = new ProcessQueue();\r\n\r\n        /**\r\n         * Acceleration of Bodies due to gravity, in pixels per second.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#gravity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.gravity = new Vector2(GetValue(config, 'gravity.x', 0), GetValue(config, 'gravity.y', 0));\r\n\r\n        /**\r\n         * A boundary constraining Bodies.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#bounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @since 3.0.0\r\n         */\r\n        this.bounds = new Rectangle(\r\n            GetValue(config, 'x', 0),\r\n            GetValue(config, 'y', 0),\r\n            GetValue(config, 'width', scene.sys.scale.width),\r\n            GetValue(config, 'height', scene.sys.scale.height)\r\n        );\r\n\r\n        /**\r\n         * The boundary edges that Bodies can collide with.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#checkCollision\r\n         * @type {Phaser.Types.Physics.Arcade.CheckCollisionObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.checkCollision = {\r\n            up: GetValue(config, 'checkCollision.up', true),\r\n            down: GetValue(config, 'checkCollision.down', true),\r\n            left: GetValue(config, 'checkCollision.left', true),\r\n            right: GetValue(config, 'checkCollision.right', true)\r\n        };\r\n\r\n        /**\r\n         * The number of physics steps to be taken per second.\r\n         *\r\n         * This property is read-only. Use the `setFPS` method to modify it at run-time.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#fps\r\n         * @readonly\r\n         * @type {number}\r\n         * @default 60\r\n         * @since 3.10.0\r\n         */\r\n        this.fps = GetValue(config, 'fps', 60);\r\n\r\n        /**\r\n         * The amount of elapsed ms since the last frame.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_elapsed\r\n         * @private\r\n         * @type {number}\r\n         * @since 3.10.0\r\n         */\r\n        this._elapsed = 0;\r\n\r\n        /**\r\n         * Internal frame time value.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_frameTime\r\n         * @private\r\n         * @type {number}\r\n         * @since 3.10.0\r\n         */\r\n        this._frameTime = 1 / this.fps;\r\n\r\n        /**\r\n         * Internal frame time ms value.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_frameTimeMS\r\n         * @private\r\n         * @type {number}\r\n         * @since 3.10.0\r\n         */\r\n        this._frameTimeMS = 1000 * this._frameTime;\r\n\r\n        /**\r\n         * The number of steps that took place in the last frame.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#stepsLastFrame\r\n         * @readonly\r\n         * @type {number}\r\n         * @since 3.10.0\r\n         */\r\n        this.stepsLastFrame = 0;\r\n\r\n        /**\r\n         * Scaling factor applied to the frame rate.\r\n         *\r\n         * - 1.0 = normal speed\r\n         * - 2.0 = half speed\r\n         * - 0.5 = double speed\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.10.0\r\n         */\r\n        this.timeScale = GetValue(config, 'timeScale', 1);\r\n\r\n        /**\r\n         * The maximum absolute difference of a Body's per-step velocity and its overlap with another Body that will result in separation on *each axis*.\r\n         * Larger values favor separation.\r\n         * Smaller values favor no separation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#OVERLAP_BIAS\r\n         * @type {number}\r\n         * @default 4\r\n         * @since 3.0.0\r\n         */\r\n        this.OVERLAP_BIAS = GetValue(config, 'overlapBias', 4);\r\n\r\n        /**\r\n         * The maximum absolute value of a Body's overlap with a tile that will result in separation on *each axis*.\r\n         * Larger values favor separation.\r\n         * Smaller values favor no separation.\r\n         * The optimum value may be similar to the tile size.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#TILE_BIAS\r\n         * @type {number}\r\n         * @default 16\r\n         * @since 3.0.0\r\n         */\r\n        this.TILE_BIAS = GetValue(config, 'tileBias', 16);\r\n\r\n        /**\r\n         * Always separate overlapping Bodies horizontally before vertically.\r\n         * False (the default) means Bodies are first separated on the axis of greater gravity, or the vertical axis if neither is greater.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#forceX\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.forceX = GetValue(config, 'forceX', false);\r\n\r\n        /**\r\n         * Whether the simulation advances with the game loop.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#isPaused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.isPaused = GetValue(config, 'isPaused', false);\r\n\r\n        /**\r\n         * Temporary total of colliding Bodies.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_total\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._total = 0;\r\n\r\n        /**\r\n         * Enables the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#drawDebug\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.drawDebug = GetValue(config, 'debug', false);\r\n\r\n        /**\r\n         * The graphics object drawing the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#debugGraphic\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugGraphic;\r\n\r\n        /**\r\n         * Default debug display settings for new Bodies.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#defaults\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeWorldDefaults}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaults = {\r\n            debugShowBody: GetValue(config, 'debugShowBody', true),\r\n            debugShowStaticBody: GetValue(config, 'debugShowStaticBody', true),\r\n            debugShowVelocity: GetValue(config, 'debugShowVelocity', true),\r\n            bodyDebugColor: GetValue(config, 'debugBodyColor', 0xff00ff),\r\n            staticBodyDebugColor: GetValue(config, 'debugStaticBodyColor', 0x0000ff),\r\n            velocityDebugColor: GetValue(config, 'debugVelocityColor', 0x00ff00)\r\n        };\r\n\r\n        /**\r\n         * The maximum number of items per node on the RTree.\r\n         *\r\n         * This is ignored if `useTree` is `false`. If you have a large number of bodies in\r\n         * your world then you may find search performance improves by increasing this value,\r\n         * to allow more items per node and less node division.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#maxEntries\r\n         * @type {integer}\r\n         * @default 16\r\n         * @since 3.0.0\r\n         */\r\n        this.maxEntries = GetValue(config, 'maxEntries', 16);\r\n\r\n        /**\r\n         * Should this Arcade Physics World use an RTree for Dynamic and Static Physics bodies?\r\n         *\r\n         * An RTree is a fast way of spatially sorting of all the bodies in the world.\r\n         * However, at certain limits, the cost of clearing and inserting the bodies into the\r\n         * tree every frame becomes more expensive than the search speed gains it provides.\r\n         *\r\n         * If you have a large number of dynamic bodies in your world then it may be best to\r\n         * disable the use of the RTree by setting this property to `false` in the physics config.\r\n         *\r\n         * The number it can cope with depends on browser and device, but a conservative estimate\r\n         * of around 5,000 bodies should be considered the max before disabling it.\r\n         *\r\n         * This only applies to dynamic bodies. Static bodies are always kept in an RTree,\r\n         * because they don't have to be cleared every frame, so you benefit from the\r\n         * massive search speeds all the time.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#useTree\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.10.0\r\n         */\r\n        this.useTree = GetValue(config, 'useTree', true);\r\n\r\n        /**\r\n         * The spatial index of Dynamic Bodies.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#tree\r\n         * @type {Phaser.Structs.RTree}\r\n         * @since 3.0.0\r\n         */\r\n        this.tree = new RTree(this.maxEntries);\r\n\r\n        /**\r\n         * The spatial index of Static Bodies.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#staticTree\r\n         * @type {Phaser.Structs.RTree}\r\n         * @since 3.0.0\r\n         */\r\n        this.staticTree = new RTree(this.maxEntries);\r\n\r\n        /**\r\n         * Recycled input for tree searches.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#treeMinMax\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeWorldTreeMinMax}\r\n         * @since 3.0.0\r\n         */\r\n        this.treeMinMax = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\r\n\r\n        /**\r\n         * A temporary Transform Matrix used by bodies for calculations without them needing their own local copy.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_tempMatrix\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix used by bodies for calculations without them needing their own local copy.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_tempMatrix2\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix2 = new TransformMatrix();\r\n\r\n        if (this.drawDebug)\r\n        {\r\n            this.createDebugGraphic();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds an Arcade Physics Body to a Game Object, an array of Game Objects, or the children of a Group.\r\n     *\r\n     * The difference between this and the `enableBody` method is that you can pass arrays or Groups\r\n     * to this method.\r\n     *\r\n     * You can specify if the bodies are to be Dynamic or Static. A dynamic body can move via velocity and\r\n     * acceleration. A static body remains fixed in place and as such is able to use an optimized search\r\n     * tree, making it ideal for static elements such as level objects. You can still collide and overlap\r\n     * with static bodies.\r\n     *\r\n     * Normally, rather than calling this method directly, you'd use the helper methods available in the\r\n     * Arcade Physics Factory, such as:\r\n     *\r\n     * ```javascript\r\n     * this.physics.add.image(x, y, textureKey);\r\n     * this.physics.add.sprite(x, y, textureKey);\r\n     * ```\r\n     *\r\n     * Calling factory methods encapsulates the creation of a Game Object and the creation of its\r\n     * body at the same time. If you are creating custom classes then you can pass them to this\r\n     * method to have their bodies created.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#enable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object - The object, or objects, on which to create the bodies.\r\n     * @param {integer} [bodyType] - The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.\r\n     */\r\n    enable: function (object, bodyType)\r\n    {\r\n        if (bodyType === undefined) { bodyType = CONST.DYNAMIC_BODY; }\r\n\r\n        if (!Array.isArray(object))\r\n        {\r\n            object = [ object ];\r\n        }\r\n\r\n        for (var i = 0; i < object.length; i++)\r\n        {\r\n            var entry = object[i];\r\n\r\n            if (entry.isParent)\r\n            {\r\n                var children = entry.getChildren();\r\n\r\n                for (var c = 0; c < children.length; c++)\r\n                {\r\n                    var child = children[c];\r\n\r\n                    if (child.isParent)\r\n                    {\r\n                        //  Handle Groups nested inside of Groups\r\n                        this.enable(child, bodyType);\r\n                    }\r\n                    else\r\n                    {\r\n                        this.enableBody(child, bodyType);\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                this.enableBody(entry, bodyType);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates an Arcade Physics Body on a single Game Object.\r\n     *\r\n     * If the Game Object already has a body, this method will simply add it back into the simulation.\r\n     *\r\n     * You can specify if the body is Dynamic or Static. A dynamic body can move via velocity and\r\n     * acceleration. A static body remains fixed in place and as such is able to use an optimized search\r\n     * tree, making it ideal for static elements such as level objects. You can still collide and overlap\r\n     * with static bodies.\r\n     *\r\n     * Normally, rather than calling this method directly, you'd use the helper methods available in the\r\n     * Arcade Physics Factory, such as:\r\n     *\r\n     * ```javascript\r\n     * this.physics.add.image(x, y, textureKey);\r\n     * this.physics.add.sprite(x, y, textureKey);\r\n     * ```\r\n     *\r\n     * Calling factory methods encapsulates the creation of a Game Object and the creation of its\r\n     * body at the same time. If you are creating custom classes then you can pass them to this\r\n     * method to have their bodies created.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#enableBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} object - The Game Object on which to create the body.\r\n     * @param {integer} [bodyType] - The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object on which the body was created.\r\n     */\r\n    enableBody: function (object, bodyType)\r\n    {\r\n        if (bodyType === undefined) { bodyType = CONST.DYNAMIC_BODY; }\r\n\r\n        if (!object.body)\r\n        {\r\n            if (bodyType === CONST.DYNAMIC_BODY)\r\n            {\r\n                object.body = new Body(this, object);\r\n            }\r\n            else if (bodyType === CONST.STATIC_BODY)\r\n            {\r\n                object.body = new StaticBody(this, object);\r\n            }\r\n        }\r\n\r\n        this.add(object.body);\r\n\r\n        return object;\r\n    },\r\n\r\n    /**\r\n     * Adds an existing Arcade Physics Body or StaticBody to the simulation.\r\n     *\r\n     * The body is enabled and added to the local search trees.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#add\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The Body to be added to the simulation.\r\n     *\r\n     * @return {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} The Body that was added to the simulation.\r\n     */\r\n    add: function (body)\r\n    {\r\n        if (body.physicsType === CONST.DYNAMIC_BODY)\r\n        {\r\n            this.bodies.set(body);\r\n        }\r\n        else if (body.physicsType === CONST.STATIC_BODY)\r\n        {\r\n            this.staticBodies.set(body);\r\n\r\n            this.staticTree.insert(body);\r\n        }\r\n\r\n        body.enable = true;\r\n\r\n        return body;\r\n    },\r\n\r\n    /**\r\n     * Disables the Arcade Physics Body of a Game Object, an array of Game Objects, or the children of a Group.\r\n     *\r\n     * The difference between this and the `disableBody` method is that you can pass arrays or Groups\r\n     * to this method.\r\n     *\r\n     * The body itself is not deleted, it just has its `enable` property set to false, which\r\n     * means you can re-enable it again at any point by passing it to enable `World.enable` or `World.add`.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#disable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object - The object, or objects, on which to disable the bodies.\r\n     */\r\n    disable: function (object)\r\n    {\r\n        if (!Array.isArray(object))\r\n        {\r\n            object = [ object ];\r\n        }\r\n\r\n        for (var i = 0; i < object.length; i++)\r\n        {\r\n            var entry = object[i];\r\n\r\n            if (entry.isParent)\r\n            {\r\n                var children = entry.getChildren();\r\n\r\n                for (var c = 0; c < children.length; c++)\r\n                {\r\n                    var child = children[c];\r\n\r\n                    if (child.isParent)\r\n                    {\r\n                        //  Handle Groups nested inside of Groups\r\n                        this.disable(child);\r\n                    }\r\n                    else\r\n                    {\r\n                        this.disableBody(child.body);\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                this.disableBody(entry.body);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Disables an existing Arcade Physics Body or StaticBody and removes it from the simulation.\r\n     *\r\n     * The body is disabled and removed from the local search trees.\r\n     *\r\n     * The body itself is not deleted, it just has its `enable` property set to false, which\r\n     * means you can re-enable it again at any point by passing it to enable `World.enable` or `World.add`.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#disableBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The Body to be disabled.\r\n     */\r\n    disableBody: function (body)\r\n    {\r\n        this.remove(body);\r\n\r\n        body.enable = false;\r\n    },\r\n\r\n    /**\r\n     * Removes an existing Arcade Physics Body or StaticBody from the simulation.\r\n     *\r\n     * The body is disabled and removed from the local search trees.\r\n     *\r\n     * The body itself is not deleted, it just has its `enabled` property set to false, which\r\n     * means you can re-enable it again at any point by passing it to enable `enable` or `add`.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The body to be removed from the simulation.\r\n     */\r\n    remove: function (body)\r\n    {\r\n        if (body.physicsType === CONST.DYNAMIC_BODY)\r\n        {\r\n            this.tree.remove(body);\r\n            this.bodies.delete(body);\r\n        }\r\n        else if (body.physicsType === CONST.STATIC_BODY)\r\n        {\r\n            this.staticBodies.delete(body);\r\n            this.staticTree.remove(body);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a Graphics Game Object that the world will use to render the debug display to.\r\n     *\r\n     * This is called automatically when the World is instantiated if the `debug` config property\r\n     * was set to `true`. However, you can call it at any point should you need to display the\r\n     * debug Graphic from a fixed point.\r\n     *\r\n     * You can control which objects are drawn to the Graphics object, and the colors they use,\r\n     * by setting the debug properties in the physics config.\r\n     *\r\n     * You should not typically use this in a production game. Use it to aid during debugging.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#createDebugGraphic\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The Graphics object that was created for use by the World.\r\n     */\r\n    createDebugGraphic: function ()\r\n    {\r\n        var graphic = this.scene.sys.add.graphics({ x: 0, y: 0 });\r\n\r\n        graphic.setDepth(Number.MAX_VALUE);\r\n\r\n        this.debugGraphic = graphic;\r\n\r\n        this.drawDebug = true;\r\n\r\n        return graphic;\r\n    },\r\n\r\n    /**\r\n     * Sets the position, size and properties of the World boundary.\r\n     *\r\n     * The World boundary is an invisible rectangle that defines the edges of the World.\r\n     * If a Body is set to collide with the world bounds then it will automatically stop\r\n     * when it reaches any of the edges. You can optionally set which edges of the boundary\r\n     * should be checked against.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#setBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The top-left x coordinate of the boundary.\r\n     * @param {number} y - The top-left y coordinate of the boundary.\r\n     * @param {number} width - The width of the boundary.\r\n     * @param {number} height - The height of the boundary.\r\n     * @param {boolean} [checkLeft] - Should bodies check against the left edge of the boundary?\r\n     * @param {boolean} [checkRight] - Should bodies check against the right edge of the boundary?\r\n     * @param {boolean} [checkUp] - Should bodies check against the top edge of the boundary?\r\n     * @param {boolean} [checkDown] - Should bodies check against the bottom edge of the boundary?\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */\r\n    setBounds: function (x, y, width, height, checkLeft, checkRight, checkUp, checkDown)\r\n    {\r\n        this.bounds.setTo(x, y, width, height);\r\n\r\n        if (checkLeft !== undefined)\r\n        {\r\n            this.setBoundsCollision(checkLeft, checkRight, checkUp, checkDown);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enables or disables collisions on each edge of the World boundary.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#setBoundsCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [left=true] - Should bodies check against the left edge of the boundary?\r\n     * @param {boolean} [right=true] - Should bodies check against the right edge of the boundary?\r\n     * @param {boolean} [up=true] - Should bodies check against the top edge of the boundary?\r\n     * @param {boolean} [down=true] - Should bodies check against the bottom edge of the boundary?\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */\r\n    setBoundsCollision: function (left, right, up, down)\r\n    {\r\n        if (left === undefined) { left = true; }\r\n        if (right === undefined) { right = true; }\r\n        if (up === undefined) { up = true; }\r\n        if (down === undefined) { down = true; }\r\n\r\n        this.checkCollision.left = left;\r\n        this.checkCollision.right = right;\r\n        this.checkCollision.up = up;\r\n        this.checkCollision.down = down;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Pauses the simulation.\r\n     *\r\n     * A paused simulation does not update any existing bodies, or run any Colliders.\r\n     *\r\n     * However, you can still enable and disable bodies within it, or manually run collide or overlap\r\n     * checks.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#pause\r\n     * @fires Phaser.Physics.Arcade.Events#PAUSE\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */\r\n    pause: function ()\r\n    {\r\n        this.isPaused = true;\r\n\r\n        this.emit(Events.PAUSE);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resumes the simulation, if paused.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#resume\r\n     * @fires Phaser.Physics.Arcade.Events#RESUME\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */\r\n    resume: function ()\r\n    {\r\n        this.isPaused = false;\r\n\r\n        this.emit(Events.RESUME);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Collider object and adds it to the simulation.\r\n     *\r\n     * A Collider is a way to automatically perform collision checks between two objects,\r\n     * calling the collide and process callbacks if they occur.\r\n     *\r\n     * Colliders are run as part of the World update, after all of the Bodies have updated.\r\n     *\r\n     * By creating a Collider you don't need then call `World.collide` in your `update` loop,\r\n     * as it will be handled for you automatically.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#addCollider\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.World#collide\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object to check for collision.\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object2 - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.\r\n     * @param {*} [callbackContext] - The scope in which to call the callbacks.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\r\n     */\r\n    addCollider: function (object1, object2, collideCallback, processCallback, callbackContext)\r\n    {\r\n        if (collideCallback === undefined) { collideCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = collideCallback; }\r\n\r\n        var collider = new Collider(this, false, object1, object2, collideCallback, processCallback, callbackContext);\r\n\r\n        this.colliders.add(collider);\r\n\r\n        return collider;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Overlap Collider object and adds it to the simulation.\r\n     *\r\n     * A Collider is a way to automatically perform overlap checks between two objects,\r\n     * calling the collide and process callbacks if they occur.\r\n     *\r\n     * Colliders are run as part of the World update, after all of the Bodies have updated.\r\n     *\r\n     * By creating a Collider you don't need then call `World.overlap` in your `update` loop,\r\n     * as it will be handled for you automatically.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#addOverlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object to check for overlap.\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object2 - The second object to check for overlap.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects overlap.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects overlap. Must return a boolean.\r\n     * @param {*} [callbackContext] - The scope in which to call the callbacks.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\r\n     */\r\n    addOverlap: function (object1, object2, collideCallback, processCallback, callbackContext)\r\n    {\r\n        if (collideCallback === undefined) { collideCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = collideCallback; }\r\n\r\n        var collider = new Collider(this, true, object1, object2, collideCallback, processCallback, callbackContext);\r\n\r\n        this.colliders.add(collider);\r\n\r\n        return collider;\r\n    },\r\n\r\n    /**\r\n     * Removes a Collider from the simulation so it is no longer processed.\r\n     *\r\n     * This method does not destroy the Collider. If you wish to add it back at a later stage you can call\r\n     * `World.colliders.add(Collider)`.\r\n     *\r\n     * If you no longer need the Collider you can call the `Collider.destroy` method instead, which will\r\n     * automatically clear all of its references and then remove it from the World. If you call destroy on\r\n     * a Collider you _don't_ need to pass it to this method too.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#removeCollider\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Collider} collider - The Collider to remove from the simulation.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */\r\n    removeCollider: function (collider)\r\n    {\r\n        this.colliders.remove(collider);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the frame rate to run the simulation at.\r\n     *\r\n     * The frame rate value is used to simulate a fixed update time step. This fixed\r\n     * time step allows for a straightforward implementation of a deterministic game state.\r\n     *\r\n     * This frame rate is independent of the frequency at which the game is rendering. The\r\n     * higher you set the fps, the more physics simulation steps will occur per game step.\r\n     * Conversely, the lower you set it, the less will take place.\r\n     *\r\n     * You can optionally advance the simulation directly yourself by calling the `step` method.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#setFPS\r\n     * @since 3.10.0\r\n     *\r\n     * @param {integer} framerate - The frame rate to advance the simulation at.\r\n     *\r\n     * @return {this} This World object.\r\n     */\r\n    setFPS: function (framerate)\r\n    {\r\n        this.fps = framerate;\r\n        this._frameTime = 1 / this.fps;\r\n        this._frameTimeMS = 1000 * this._frameTime;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Advances the simulation based on the elapsed time and fps rate.\r\n     *\r\n     * This is called automatically by your Scene and does not need to be invoked directly.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#update\r\n     * @protected\r\n     * @fires Phaser.Physics.Arcade.Events#WORLD_STEP\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        if (this.isPaused || this.bodies.size === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var i;\r\n        var fixedDelta = this._frameTime;\r\n        var msPerFrame = this._frameTimeMS * this.timeScale;\r\n\r\n        this._elapsed += delta;\r\n\r\n        //  Update all active bodies\r\n        var body;\r\n        var bodies = this.bodies.entries;\r\n\r\n        //  Will a step happen this frame?\r\n        var willStep = (this._elapsed >= msPerFrame);\r\n\r\n        for (i = 0; i < bodies.length; i++)\r\n        {\r\n            body = bodies[i];\r\n\r\n            if (body.enable)\r\n            {\r\n                body.preUpdate(willStep, fixedDelta);\r\n            }\r\n        }\r\n\r\n        //  We know that a step will happen this frame, so let's bundle it all together to save branching and iteration costs\r\n        if (willStep)\r\n        {\r\n            this._elapsed -= msPerFrame;\r\n            this.stepsLastFrame = 1;\r\n\r\n            //  Optionally populate our dynamic collision tree\r\n            if (this.useTree)\r\n            {\r\n                this.tree.clear();\r\n                this.tree.load(bodies);\r\n            }\r\n\r\n            //  Process any colliders\r\n            var colliders = this.colliders.update();\r\n\r\n            for (i = 0; i < colliders.length; i++)\r\n            {\r\n                var collider = colliders[i];\r\n\r\n                if (collider.active)\r\n                {\r\n                    collider.update();\r\n                }\r\n            }\r\n\r\n            this.emit(Events.WORLD_STEP);\r\n        }\r\n\r\n        //  Process any additional steps this frame\r\n        while (this._elapsed >= msPerFrame)\r\n        {\r\n            this._elapsed -= msPerFrame;\r\n\r\n            this.step(fixedDelta);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Advances the simulation by a time increment.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#step\r\n     * @fires Phaser.Physics.Arcade.Events#WORLD_STEP\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} delta - The delta time amount, in seconds, by which to advance the simulation.\r\n     */\r\n    step: function (delta)\r\n    {\r\n        //  Update all active bodies\r\n        var i;\r\n        var body;\r\n        var bodies = this.bodies.entries;\r\n        var len = bodies.length;\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            body = bodies[i];\r\n\r\n            if (body.enable)\r\n            {\r\n                body.update(delta);\r\n            }\r\n        }\r\n\r\n        //  Optionally populate our dynamic collision tree\r\n        if (this.useTree)\r\n        {\r\n            this.tree.clear();\r\n            this.tree.load(bodies);\r\n        }\r\n\r\n        //  Process any colliders\r\n        var colliders = this.colliders.update();\r\n\r\n        for (i = 0; i < colliders.length; i++)\r\n        {\r\n            var collider = colliders[i];\r\n\r\n            if (collider.active)\r\n            {\r\n                collider.update();\r\n            }\r\n        }\r\n\r\n        this.emit(Events.WORLD_STEP);\r\n\r\n        this.stepsLastFrame++;\r\n    },\r\n\r\n    /**\r\n     * Updates bodies, draws the debug display, and handles pending queue operations.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#postUpdate\r\n     * @since 3.0.0\r\n     */\r\n    postUpdate: function ()\r\n    {\r\n        var i;\r\n        var body;\r\n        var bodies = this.bodies.entries;\r\n        var len = bodies.length;\r\n\r\n        var dynamic = this.bodies;\r\n        var staticBodies = this.staticBodies;\r\n\r\n        //  We don't need to postUpdate if there wasn't a step this frame\r\n        if (this.stepsLastFrame)\r\n        {\r\n            this.stepsLastFrame = 0;\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                body = bodies[i];\r\n\r\n                if (body.enable)\r\n                {\r\n                    body.postUpdate();\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.drawDebug)\r\n        {\r\n            var graphics = this.debugGraphic;\r\n\r\n            graphics.clear();\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                body = bodies[i];\r\n\r\n                if (body.willDrawDebug())\r\n                {\r\n                    body.drawDebug(graphics);\r\n                }\r\n            }\r\n\r\n            bodies = staticBodies.entries;\r\n            len = bodies.length;\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                body = bodies[i];\r\n\r\n                if (body.willDrawDebug())\r\n                {\r\n                    body.drawDebug(graphics);\r\n                }\r\n            }\r\n        }\r\n\r\n        var pending = this.pendingDestroy;\r\n\r\n        if (pending.size > 0)\r\n        {\r\n            var dynamicTree = this.tree;\r\n            var staticTree = this.staticTree;\r\n\r\n            bodies = pending.entries;\r\n            len = bodies.length;\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                body = bodies[i];\r\n\r\n                if (body.physicsType === CONST.DYNAMIC_BODY)\r\n                {\r\n                    dynamicTree.remove(body);\r\n                    dynamic.delete(body);\r\n                }\r\n                else if (body.physicsType === CONST.STATIC_BODY)\r\n                {\r\n                    staticTree.remove(body);\r\n                    staticBodies.delete(body);\r\n                }\r\n\r\n                body.world = undefined;\r\n                body.gameObject = undefined;\r\n            }\r\n\r\n            pending.clear();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Calculates a Body's velocity and updates its position.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#updateMotion\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body - The Body to be updated.\r\n     * @param {number} delta - The delta value to be used in the motion calculations, in seconds.\r\n     */\r\n    updateMotion: function (body, delta)\r\n    {\r\n        if (body.allowRotation)\r\n        {\r\n            this.computeAngularVelocity(body, delta);\r\n        }\r\n\r\n        this.computeVelocity(body, delta);\r\n    },\r\n\r\n    /**\r\n     * Calculates a Body's angular velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#computeAngularVelocity\r\n     * @since 3.10.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body - The Body to compute the velocity for.\r\n     * @param {number} delta - The delta value to be used in the calculation, in seconds.\r\n     */\r\n    computeAngularVelocity: function (body, delta)\r\n    {\r\n        var velocity = body.angularVelocity;\r\n        var acceleration = body.angularAcceleration;\r\n        var drag = body.angularDrag;\r\n        var max = body.maxAngular;\r\n\r\n        if (acceleration)\r\n        {\r\n            velocity += acceleration * delta;\r\n        }\r\n        else if (body.allowDrag && drag)\r\n        {\r\n            drag *= delta;\r\n\r\n            if (FuzzyGreaterThan(velocity - drag, 0, 0.1))\r\n            {\r\n                velocity -= drag;\r\n            }\r\n            else if (FuzzyLessThan(velocity + drag, 0, 0.1))\r\n            {\r\n                velocity += drag;\r\n            }\r\n            else\r\n            {\r\n                velocity = 0;\r\n            }\r\n        }\r\n\r\n        velocity = Clamp(velocity, -max, max);\r\n\r\n        var velocityDelta = velocity - body.angularVelocity;\r\n\r\n        body.angularVelocity += velocityDelta;\r\n        body.rotation += (body.angularVelocity * delta);\r\n    },\r\n\r\n    /**\r\n     * Calculates a Body's per-axis velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#computeVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body - The Body to compute the velocity for.\r\n     * @param {number} delta - The delta value to be used in the calculation, in seconds.\r\n     */\r\n    computeVelocity: function (body, delta)\r\n    {\r\n        var velocityX = body.velocity.x;\r\n        var accelerationX = body.acceleration.x;\r\n        var dragX = body.drag.x;\r\n        var maxX = body.maxVelocity.x;\r\n\r\n        var velocityY = body.velocity.y;\r\n        var accelerationY = body.acceleration.y;\r\n        var dragY = body.drag.y;\r\n        var maxY = body.maxVelocity.y;\r\n\r\n        var speed = body.speed;\r\n        var maxSpeed = body.maxSpeed;\r\n        var allowDrag = body.allowDrag;\r\n        var useDamping = body.useDamping;\r\n\r\n        if (body.allowGravity)\r\n        {\r\n            velocityX += (this.gravity.x + body.gravity.x) * delta;\r\n            velocityY += (this.gravity.y + body.gravity.y) * delta;\r\n        }\r\n\r\n        if (accelerationX)\r\n        {\r\n            velocityX += accelerationX * delta;\r\n        }\r\n        else if (allowDrag && dragX)\r\n        {\r\n            if (useDamping)\r\n            {\r\n                //  Damping based deceleration\r\n\r\n                velocityX *= dragX;\r\n\r\n                speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\r\n\r\n                if (FuzzyEqual(speed, 0, 0.001))\r\n                {\r\n                    velocityX = 0;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                //  Linear deceleration\r\n                dragX *= delta;\r\n\r\n                if (FuzzyGreaterThan(velocityX - dragX, 0, 0.01))\r\n                {\r\n                    velocityX -= dragX;\r\n                }\r\n                else if (FuzzyLessThan(velocityX + dragX, 0, 0.01))\r\n                {\r\n                    velocityX += dragX;\r\n                }\r\n                else\r\n                {\r\n                    velocityX = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (accelerationY)\r\n        {\r\n            velocityY += accelerationY * delta;\r\n        }\r\n        else if (allowDrag && dragY)\r\n        {\r\n            if (useDamping)\r\n            {\r\n                //  Damping based deceleration\r\n                velocityY *= dragY;\r\n\r\n                speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\r\n\r\n                if (FuzzyEqual(speed, 0, 0.001))\r\n                {\r\n                    velocityY = 0;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                //  Linear deceleration\r\n                dragY *= delta;\r\n\r\n                if (FuzzyGreaterThan(velocityY - dragY, 0, 0.01))\r\n                {\r\n                    velocityY -= dragY;\r\n                }\r\n                else if (FuzzyLessThan(velocityY + dragY, 0, 0.01))\r\n                {\r\n                    velocityY += dragY;\r\n                }\r\n                else\r\n                {\r\n                    velocityY = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        velocityX = Clamp(velocityX, -maxX, maxX);\r\n        velocityY = Clamp(velocityY, -maxY, maxY);\r\n\r\n        body.velocity.set(velocityX, velocityY);\r\n\r\n        if (maxSpeed > -1 && speed > maxSpeed)\r\n        {\r\n            body.velocity.normalize().scale(maxSpeed);\r\n            speed = maxSpeed;\r\n        }\r\n\r\n        body.speed = speed;\r\n    },\r\n\r\n    /**\r\n     * Separates two Bodies.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#separate\r\n     * @fires Phaser.Physics.Arcade.Events#COLLIDE\r\n     * @fires Phaser.Physics.Arcade.Events#OVERLAP\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to be separated.\r\n     * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to be separated.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - The process callback.\r\n     * @param {*} [callbackContext] - The context in which to invoke the callback.\r\n     * @param {boolean} [overlapOnly] - If this a collide or overlap check?\r\n     *\r\n     * @return {boolean} True if separation occurred, otherwise false.\r\n     */\r\n    separate: function (body1, body2, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        if (\r\n            !body1.enable ||\r\n            !body2.enable ||\r\n            body1.checkCollision.none ||\r\n            body2.checkCollision.none ||\r\n            !this.intersects(body1, body2))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //  They overlap. Is there a custom process callback? If it returns true then we can carry on, otherwise we should abort.\r\n        if (processCallback && processCallback.call(callbackContext, body1.gameObject, body2.gameObject) === false)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //  Circle vs. Circle quick bail out\r\n        if (body1.isCircle && body2.isCircle)\r\n        {\r\n            return this.separateCircle(body1, body2, overlapOnly);\r\n        }\r\n\r\n        // We define the behavior of bodies in a collision circle and rectangle\r\n        // If a collision occurs in the corner points of the rectangle, the body behave like circles\r\n\r\n        //  Either body1 or body2 is a circle\r\n        if (body1.isCircle !== body2.isCircle)\r\n        {\r\n            var bodyRect = (body1.isCircle) ? body2 : body1;\r\n            var bodyCircle = (body1.isCircle) ? body1 : body2;\r\n\r\n            var rect = {\r\n                x: bodyRect.x,\r\n                y: bodyRect.y,\r\n                right: bodyRect.right,\r\n                bottom: bodyRect.bottom\r\n            };\r\n\r\n            var circle = bodyCircle.center;\r\n\r\n            if (circle.y < rect.y || circle.y > rect.bottom)\r\n            {\r\n                if (circle.x < rect.x || circle.x > rect.right)\r\n                {\r\n                    return this.separateCircle(body1, body2, overlapOnly);\r\n                }\r\n            }\r\n        }\r\n\r\n        var resultX = false;\r\n        var resultY = false;\r\n\r\n        //  Do we separate on x or y first?\r\n        if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x))\r\n        {\r\n            resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);\r\n\r\n            //  Are they still intersecting? Let's do the other axis then\r\n            if (this.intersects(body1, body2))\r\n            {\r\n                resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);\r\n\r\n            //  Are they still intersecting? Let's do the other axis then\r\n            if (this.intersects(body1, body2))\r\n            {\r\n                resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);\r\n            }\r\n        }\r\n\r\n        var result = (resultX || resultY);\r\n\r\n        if (result)\r\n        {\r\n            if (overlapOnly)\r\n            {\r\n                if (body1.onOverlap || body2.onOverlap)\r\n                {\r\n                    this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);\r\n                }\r\n            }\r\n            else if (body1.onCollide || body2.onCollide)\r\n            {\r\n                this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    /**\r\n     * Separates two Bodies, when both are circular.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#separateCircle\r\n     * @fires Phaser.Physics.Arcade.Events#COLLIDE\r\n     * @fires Phaser.Physics.Arcade.Events#OVERLAP\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to be separated.\r\n     * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to be separated.\r\n     * @param {boolean} [overlapOnly] - If this a collide or overlap check?\r\n     * @param {number} [bias] - A small value added to the calculations.\r\n     *\r\n     * @return {boolean} True if separation occurred, otherwise false.\r\n     */\r\n    separateCircle: function (body1, body2, overlapOnly, bias)\r\n    {\r\n        //  Set the bounding box overlap values into the bodies themselves (hence we don't use the return values here)\r\n        GetOverlapX(body1, body2, false, bias);\r\n        GetOverlapY(body1, body2, false, bias);\r\n\r\n        var overlap = 0;\r\n\r\n        if (body1.isCircle !== body2.isCircle)\r\n        {\r\n            var rect = {\r\n                x: (body2.isCircle) ? body1.position.x : body2.position.x,\r\n                y: (body2.isCircle) ? body1.position.y : body2.position.y,\r\n                right: (body2.isCircle) ? body1.right : body2.right,\r\n                bottom: (body2.isCircle) ? body1.bottom : body2.bottom\r\n            };\r\n\r\n            var circle = {\r\n                x: (body1.isCircle) ? body1.center.x : body2.center.x,\r\n                y: (body1.isCircle) ? body1.center.y : body2.center.y,\r\n                radius: (body1.isCircle) ? body1.halfWidth : body2.halfWidth\r\n            };\r\n\r\n            if (circle.y < rect.y)\r\n            {\r\n                if (circle.x < rect.x)\r\n                {\r\n                    overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.y) - circle.radius;\r\n                }\r\n                else if (circle.x > rect.right)\r\n                {\r\n                    overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.y) - circle.radius;\r\n                }\r\n            }\r\n            else if (circle.y > rect.bottom)\r\n            {\r\n                if (circle.x < rect.x)\r\n                {\r\n                    overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.bottom) - circle.radius;\r\n                }\r\n                else if (circle.x > rect.right)\r\n                {\r\n                    overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.bottom) - circle.radius;\r\n                }\r\n            }\r\n\r\n            overlap *= -1;\r\n        }\r\n        else\r\n        {\r\n            overlap = (body1.halfWidth + body2.halfWidth) - DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y);\r\n        }\r\n\r\n        //  Can't separate two immovable bodies, or a body with its own custom separation logic\r\n        if (overlapOnly || overlap === 0 || (body1.immovable && body2.immovable) || body1.customSeparateX || body2.customSeparateX)\r\n        {\r\n            if (overlap !== 0 && (body1.onOverlap || body2.onOverlap))\r\n            {\r\n                this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);\r\n            }\r\n\r\n            //  return true if there was some overlap, otherwise false\r\n            return (overlap !== 0);\r\n        }\r\n\r\n        var dx = body1.center.x - body2.center.x;\r\n        var dy = body1.center.y - body2.center.y;\r\n        var d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n        var nx = ((body2.center.x - body1.center.x) / d) || 0;\r\n        var ny = ((body2.center.y - body1.center.y) / d) || 0;\r\n        var p = 2 * (body1.velocity.x * nx + body1.velocity.y * ny - body2.velocity.x * nx - body2.velocity.y * ny) / (body1.mass + body2.mass);\r\n\r\n        if (!body1.immovable)\r\n        {\r\n            body1.velocity.x = (body1.velocity.x - p * body1.mass * nx);\r\n            body1.velocity.y = (body1.velocity.y - p * body1.mass * ny);\r\n        }\r\n\r\n        if (!body2.immovable)\r\n        {\r\n            body2.velocity.x = (body2.velocity.x + p * body2.mass * nx);\r\n            body2.velocity.y = (body2.velocity.y + p * body2.mass * ny);\r\n        }\r\n\r\n        var dvx = body2.velocity.x - body1.velocity.x;\r\n        var dvy = body2.velocity.y - body1.velocity.y;\r\n        var angleCollision = Math.atan2(dvy, dvx);\r\n\r\n        var delta = this._frameTime;\r\n\r\n        if (!body1.immovable && !body2.immovable)\r\n        {\r\n            overlap /= 2;\r\n        }\r\n\r\n        if (!body1.immovable)\r\n        {\r\n            body1.x += (body1.velocity.x * delta) - overlap * Math.cos(angleCollision);\r\n            body1.y += (body1.velocity.y * delta) - overlap * Math.sin(angleCollision);\r\n        }\r\n\r\n        if (!body2.immovable)\r\n        {\r\n            body2.x += (body2.velocity.x * delta) + overlap * Math.cos(angleCollision);\r\n            body2.y += (body2.velocity.y * delta) + overlap * Math.sin(angleCollision);\r\n        }\r\n\r\n        body1.velocity.x *= body1.bounce.x;\r\n        body1.velocity.y *= body1.bounce.y;\r\n        body2.velocity.x *= body2.bounce.x;\r\n        body2.velocity.y *= body2.bounce.y;\r\n\r\n        if (body1.onCollide || body2.onCollide)\r\n        {\r\n            this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if two Bodies intersect at all.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#intersects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body1 - The first body to check.\r\n     * @param {Phaser.Physics.Arcade.Body} body2 - The second body to check.\r\n     *\r\n     * @return {boolean} True if the two bodies intersect, otherwise false.\r\n     */\r\n    intersects: function (body1, body2)\r\n    {\r\n        if (body1 === body2)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        if (!body1.isCircle && !body2.isCircle)\r\n        {\r\n            //  Rect vs. Rect\r\n            return !(\r\n                body1.right <= body2.position.x ||\r\n                body1.bottom <= body2.position.y ||\r\n                body1.position.x >= body2.right ||\r\n                body1.position.y >= body2.bottom\r\n            );\r\n        }\r\n        else if (body1.isCircle)\r\n        {\r\n            if (body2.isCircle)\r\n            {\r\n                //  Circle vs. Circle\r\n                return DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y) <= (body1.halfWidth + body2.halfWidth);\r\n            }\r\n            else\r\n            {\r\n                //  Circle vs. Rect\r\n                return this.circleBodyIntersects(body1, body2);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //  Rect vs. Circle\r\n            return this.circleBodyIntersects(body2, body1);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Tests if a circular Body intersects with another Body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#circleBodyIntersects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} circle - The circular body to test.\r\n     * @param {Phaser.Physics.Arcade.Body} body - The rectangular body to test.\r\n     *\r\n     * @return {boolean} True if the two bodies intersect, otherwise false.\r\n     */\r\n    circleBodyIntersects: function (circle, body)\r\n    {\r\n        var x = Clamp(circle.center.x, body.left, body.right);\r\n        var y = Clamp(circle.center.y, body.top, body.bottom);\r\n\r\n        var dx = (circle.center.x - x) * (circle.center.x - x);\r\n        var dy = (circle.center.y - y) * (circle.center.y - y);\r\n\r\n        return (dx + dy) <= (circle.halfWidth * circle.halfWidth);\r\n    },\r\n\r\n    /**\r\n     * Tests if Game Objects overlap.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#overlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n     * @param {ArcadePhysicsCallback} [overlapCallback] - An optional callback function that is called if the objects overlap.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `overlapCallback` will only be called if this callback returns `true`.\r\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if at least one Game Object overlaps another.\r\n     */\r\n    overlap: function (object1, object2, overlapCallback, processCallback, callbackContext)\r\n    {\r\n        if (overlapCallback === undefined) { overlapCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = overlapCallback; }\r\n\r\n        return this.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);\r\n    },\r\n\r\n    /**\r\n     * Performs a collision check and separation between the two physics enabled objects given, which can be single\r\n     * Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups.\r\n     *\r\n     * If you don't require separation then use {@link #overlap} instead.\r\n     *\r\n     * If two Groups or arrays are passed, each member of one will be tested against each member of the other.\r\n     *\r\n     * If **only** one Group is passed (as `object1`), each member of the Group will be collided against the other members.\r\n     *\r\n     * If **only** one Array is passed, the array is iterated and every element in it is tested against the others.\r\n     *\r\n     * Two callbacks can be provided. The `collideCallback` is invoked if a collision occurs and the two colliding\r\n     * objects are passed to it.\r\n     *\r\n     * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\r\n     * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\r\n     * The separation that stops two objects penetrating may create a new penetration against a different object. If you\r\n     * require a high level of stability please consider using an alternative physics system, such as Matter.js.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} `true` if any overlapping Game Objects were separated, otherwise `false`.\r\n     */\r\n    collide: function (object1, object2, collideCallback, processCallback, callbackContext)\r\n    {\r\n        if (collideCallback === undefined) { collideCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = collideCallback; }\r\n\r\n        return this.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);\r\n    },\r\n\r\n    /**\r\n     * Internal helper function. Please use Phaser.Physics.Arcade.World#collide instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideObjects\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object to check for collision.\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.\r\n     * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.\r\n     * @param {any} callbackContext - The scope in which to call the callbacks.\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideObjects: function (object1, object2, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        var i;\r\n        var j;\r\n\r\n        if (object1.isParent && object1.physicsType === undefined)\r\n        {\r\n            object1 = object1.children.entries;\r\n        }\r\n\r\n        if (object2 && object2.isParent && object2.physicsType === undefined)\r\n        {\r\n            object2 = object2.children.entries;\r\n        }\r\n\r\n        var object1isArray = Array.isArray(object1);\r\n        var object2isArray = Array.isArray(object2);\r\n\r\n        this._total = 0;\r\n\r\n        if (!object1isArray && !object2isArray)\r\n        {\r\n            //  Neither of them are arrays - do this first as it's the most common use-case\r\n            this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n        }\r\n        else if (!object1isArray && object2isArray)\r\n        {\r\n            //  Object 2 is an Array\r\n            for (i = 0; i < object2.length; i++)\r\n            {\r\n                this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n        }\r\n        else if (object1isArray && !object2isArray)\r\n        {\r\n            //  Object 1 is an Array\r\n            if (!object2)\r\n            {\r\n                //  Special case for array vs. self\r\n                for (i = 0; i < object1.length; i++)\r\n                {\r\n                    var child = object1[i];\r\n\r\n                    for (j = i + 1; j < object1.length; j++)\r\n                    {\r\n                        if (i === j)\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        this.collideHandler(child, object1[j], collideCallback, processCallback, callbackContext, overlapOnly);\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                for (i = 0; i < object1.length; i++)\r\n                {\r\n                    this.collideHandler(object1[i], object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //  They're both arrays\r\n            for (i = 0; i < object1.length; i++)\r\n            {\r\n                for (j = 0; j < object2.length; j++)\r\n                {\r\n                    this.collideHandler(object1[i], object2[j], collideCallback, processCallback, callbackContext, overlapOnly);\r\n                }\r\n            }\r\n        }\r\n\r\n        return (this._total > 0);\r\n    },\r\n\r\n    /**\r\n     * Internal helper function. Please use Phaser.Physics.Arcade.World#collide and Phaser.Physics.Arcade.World#overlap instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideHandler\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object2 - The second object or array of objects to check, or `undefined`.\r\n     * @param {ArcadePhysicsCallback} collideCallback - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} processCallback - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} callbackContext - The context in which to run the callbacks.\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideHandler: function (object1, object2, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        //  Collide Group with Self\r\n        //  Only collide valid objects\r\n        if (object2 === undefined && object1.isParent)\r\n        {\r\n            return this.collideGroupVsGroup(object1, object1, collideCallback, processCallback, callbackContext, overlapOnly);\r\n        }\r\n\r\n        //  If neither of the objects are set then bail out\r\n        if (!object1 || !object2)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //  A Body\r\n        if (object1.body)\r\n        {\r\n            if (object2.body)\r\n            {\r\n                return this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n            else if (object2.isParent)\r\n            {\r\n                return this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n            else if (object2.isTilemap)\r\n            {\r\n                return this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n        }\r\n\r\n        //  GROUPS\r\n        else if (object1.isParent)\r\n        {\r\n            if (object2.body)\r\n            {\r\n                return this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n            else if (object2.isParent)\r\n            {\r\n                return this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n            else if (object2.isTilemap)\r\n            {\r\n                return this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n        }\r\n\r\n        //  TILEMAP LAYERS\r\n        else if (object1.isTilemap)\r\n        {\r\n            if (object2.body)\r\n            {\r\n                return this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n            else if (object2.isParent)\r\n            {\r\n                return this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal handler for Sprite vs. Sprite collisions.\r\n     * Please use Phaser.Physics.Arcade.World#collide instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsSprite\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite1 - The first object to check for collision.\r\n     * @param {Phaser.GameObjects.GameObject} sprite2 - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideSpriteVsSprite: function (sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        if (!sprite1.body || !sprite2.body)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly))\r\n        {\r\n            if (collideCallback)\r\n            {\r\n                collideCallback.call(callbackContext, sprite1, sprite2);\r\n            }\r\n\r\n            this._total++;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Internal handler for Sprite vs. Group collisions.\r\n     * Please use Phaser.Physics.Arcade.World#collide instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsGroup\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n     * @param {Phaser.GameObjects.Group} group - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.\r\n     * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.\r\n     * @param {any} callbackContext - The scope in which to call the callbacks.\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} `true` if the Sprite collided with the given Group, otherwise `false`.\r\n     */\r\n    collideSpriteVsGroup: function (sprite, group, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        var bodyA = sprite.body;\r\n\r\n        if (group.length === 0 || !bodyA || !bodyA.enable)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  Does sprite collide with anything?\r\n\r\n        var i;\r\n        var len;\r\n        var bodyB;\r\n\r\n        if (this.useTree)\r\n        {\r\n            var minMax = this.treeMinMax;\r\n\r\n            minMax.minX = bodyA.left;\r\n            minMax.minY = bodyA.top;\r\n            minMax.maxX = bodyA.right;\r\n            minMax.maxY = bodyA.bottom;\r\n\r\n            var results = (group.physicsType === CONST.DYNAMIC_BODY) ? this.tree.search(minMax) : this.staticTree.search(minMax);\r\n\r\n            len = results.length;\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                bodyB = results[i];\r\n\r\n                if (bodyA === bodyB || !bodyB.enable || !group.contains(bodyB.gameObject))\r\n                {\r\n                    //  Skip if comparing against itself, or if bodyB isn't actually part of the Group\r\n                    continue;\r\n                }\r\n\r\n                if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly))\r\n                {\r\n                    if (collideCallback)\r\n                    {\r\n                        collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);\r\n                    }\r\n\r\n                    this._total++;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var children = group.getChildren();\r\n            var skipIndex = group.children.entries.indexOf(sprite);\r\n\r\n            len = children.length;\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                bodyB = children[i].body;\r\n\r\n                if (!bodyB || i === skipIndex || !bodyB.enable)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly))\r\n                {\r\n                    if (collideCallback)\r\n                    {\r\n                        collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);\r\n                    }\r\n\r\n                    this._total++;\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal handler for Group vs. Tilemap collisions.\r\n     * Please use Phaser.Physics.Arcade.World#collide instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideGroupVsTilemapLayer\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Group} group - The first object to check for collision.\r\n     * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideGroupVsTilemapLayer: function (group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        var children = group.getChildren();\r\n\r\n        if (children.length === 0)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var didCollide = false;\r\n\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            if (children[i].body)\r\n            {\r\n                if (this.collideSpriteVsTilemapLayer(children[i], tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly))\r\n                {\r\n                    didCollide = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return didCollide;\r\n    },\r\n\r\n    /**\r\n     * This advanced method is specifically for testing for collision between a single Sprite and an array of Tile objects.\r\n     *\r\n     * You should generally use the `collide` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\r\n     * tile filtering and culling for you, as well as handle the interesting face collision automatically.\r\n     *\r\n     * This method is offered for those who would like to check for collision with specific Tiles in a layer, without\r\n     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic collisions\r\n     * on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\r\n     * you should filter them before passing them to this method.\r\n     *\r\n     * Important: Use of this method skips the `interesting faces` system that Tilemap Layers use. This means if you have\r\n     * say a row or column of tiles, and you jump into, or walk over them, it's possible to get stuck on the edges of the\r\n     * tiles as the interesting face calculations are skipped. However, for quick-fire small collision set tests on\r\n     * dynamic maps, this method can prove very useful.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideTiles\r\n     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext)\r\n    {\r\n        if (!sprite.body.enable || tiles.length === 0)\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, false, false);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * This advanced method is specifically for testing for overlaps between a single Sprite and an array of Tile objects.\r\n     *\r\n     * You should generally use the `overlap` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\r\n     * tile filtering and culling for you, as well as handle the interesting face collision automatically.\r\n     *\r\n     * This method is offered for those who would like to check for overlaps with specific Tiles in a layer, without\r\n     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic overlap\r\n     * tests on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\r\n     * you should filter them before passing them to this method.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#overlapTiles\r\n     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects overlap.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    overlapTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext)\r\n    {\r\n        if (!sprite.body.enable || tiles.length === 0)\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, true, false);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal handler for Sprite vs. Tilemap collisions.\r\n     * Please use Phaser.Physics.Arcade.World#collide instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsTilemapLayer\r\n     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\r\n     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n     * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     * @param {boolean} [overlapOnly] - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideSpriteVsTilemapLayer: function (sprite, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        var body = sprite.body;\r\n\r\n        if (!body.enable)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var x = body.position.x;\r\n        var y = body.position.y;\r\n        var w = body.width;\r\n        var h = body.height;\r\n\r\n        // TODO: this logic should be encapsulated within the Tilemap API at some point.\r\n        // If the maps base tile size differs from the layer's tile size, we need to adjust the\r\n        // selection area by the difference between the two.\r\n        var layerData = tilemapLayer.layer;\r\n\r\n        if (layerData.tileWidth > layerData.baseTileWidth)\r\n        {\r\n            // The x origin of a tile is the left side, so x and width need to be adjusted.\r\n            var xDiff = (layerData.tileWidth - layerData.baseTileWidth) * tilemapLayer.scaleX;\r\n            x -= xDiff;\r\n            w += xDiff;\r\n        }\r\n\r\n        if (layerData.tileHeight > layerData.baseTileHeight)\r\n        {\r\n            // The y origin of a tile is the bottom side, so just the height needs to be adjusted.\r\n            var yDiff = (layerData.tileHeight - layerData.baseTileHeight) * tilemapLayer.scaleY;\r\n            h += yDiff;\r\n        }\r\n\r\n        var mapData = tilemapLayer.getTilesWithinWorldXY(x, y, w, h);\r\n\r\n        if (mapData.length === 0)\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            return this.collideSpriteVsTilesHandler(sprite, mapData, collideCallback, processCallback, callbackContext, overlapOnly, true);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal handler for Sprite vs. Tilemap collisions.\r\n     * Please use Phaser.Physics.Arcade.World#collide instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsTilesHandler\r\n     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\r\n     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\r\n     * @private\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n     * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     * @param {boolean} [overlapOnly] - Whether this is a collision or overlap check.\r\n     * @param {boolean} [isLayer] - Is this check coming from a TilemapLayer or an array of tiles?\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideSpriteVsTilesHandler: function (sprite, tiles, collideCallback, processCallback, callbackContext, overlapOnly, isLayer)\r\n    {\r\n        var body = sprite.body;\r\n\r\n        var tile;\r\n        var tileWorldRect = { left: 0, right: 0, top: 0, bottom: 0 };\r\n        var tilemapLayer;\r\n        var collision = false;\r\n\r\n        for (var i = 0; i < tiles.length; i++)\r\n        {\r\n            tile = tiles[i];\r\n\r\n            tilemapLayer = tile.tilemapLayer;\r\n\r\n            tileWorldRect.left = tilemapLayer.tileToWorldX(tile.x);\r\n            tileWorldRect.top = tilemapLayer.tileToWorldY(tile.y);\r\n\r\n            // If the map's base tile size differs from the layer's tile size, only the top of the rect\r\n            // needs to be adjusted since its origin is (0, 1).\r\n            if (tile.baseHeight !== tile.height)\r\n            {\r\n                tileWorldRect.top -= (tile.height - tile.baseHeight) * tilemapLayer.scaleY;\r\n            }\r\n\r\n            tileWorldRect.right = tileWorldRect.left + tile.width * tilemapLayer.scaleX;\r\n            tileWorldRect.bottom = tileWorldRect.top + tile.height * tilemapLayer.scaleY;\r\n\r\n            if (TileIntersectsBody(tileWorldRect, body)\r\n                && (!processCallback || processCallback.call(callbackContext, sprite, tile))\r\n                && ProcessTileCallbacks(tile, sprite)\r\n                && (overlapOnly || SeparateTile(i, body, tile, tileWorldRect, tilemapLayer, this.TILE_BIAS, isLayer)))\r\n            {\r\n                this._total++;\r\n\r\n                collision = true;\r\n\r\n                if (collideCallback)\r\n                {\r\n                    collideCallback.call(callbackContext, sprite, tile);\r\n                }\r\n\r\n                if (overlapOnly && body.onOverlap)\r\n                {\r\n                    this.emit(Events.TILE_OVERLAP, sprite, tile, body);\r\n                }\r\n                else if (body.onCollide)\r\n                {\r\n                    this.emit(Events.TILE_COLLIDE, sprite, tile, body);\r\n                }\r\n            }\r\n        }\r\n\r\n        return collision;\r\n    },\r\n\r\n    /**\r\n     * Internal helper for Group vs. Group collisions.\r\n     * Please use Phaser.Physics.Arcade.World#collide instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideGroupVsGroup\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Group} group1 - The first object to check for collision.\r\n     * @param {Phaser.GameObjects.Group} group2 - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideGroupVsGroup: function (group1, group2, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        if (group1.length === 0 || group2.length === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var children = group1.getChildren();\r\n\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            this.collideSpriteVsGroup(children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Wrap an object's coordinates (or several objects' coordinates) within {@link Phaser.Physics.Arcade.World#bounds}.\r\n     *\r\n     * If the object is outside any boundary edge (left, top, right, bottom), it will be moved to the same offset from the opposite edge (the interior).\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#wrap\r\n     * @since 3.3.0\r\n     *\r\n     * @param {*} object - A Game Object, a Group, an object with `x` and `y` coordinates, or an array of such objects.\r\n     * @param {number} [padding=0] - An amount added to each boundary edge during the operation.\r\n     */\r\n    wrap: function (object, padding)\r\n    {\r\n        if (object.body)\r\n        {\r\n            this.wrapObject(object, padding);\r\n        }\r\n        else if (object.getChildren)\r\n        {\r\n            this.wrapArray(object.getChildren(), padding);\r\n        }\r\n        else if (Array.isArray(object))\r\n        {\r\n            this.wrapArray(object, padding);\r\n        }\r\n        else\r\n        {\r\n            this.wrapObject(object, padding);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Wrap each object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#wrapArray\r\n     * @since 3.3.0\r\n     *\r\n     * @param {Array.<*>} objects - An array of objects to be wrapped.\r\n     * @param {number} [padding=0] - An amount added to the boundary.\r\n     */\r\n    wrapArray: function (objects, padding)\r\n    {\r\n        for (var i = 0; i < objects.length; i++)\r\n        {\r\n            this.wrapObject(objects[i], padding);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Wrap an object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#wrapObject\r\n     * @since 3.3.0\r\n     *\r\n     * @param {*} object - A Game Object, a Physics Body, or any object with `x` and `y` coordinates\r\n     * @param {number} [padding=0] - An amount added to the boundary.\r\n     */\r\n    wrapObject: function (object, padding)\r\n    {\r\n        if (padding === undefined) { padding = 0; }\r\n\r\n        object.x = Wrap(object.x, this.bounds.left - padding, this.bounds.right + padding);\r\n        object.y = Wrap(object.y, this.bounds.top - padding, this.bounds.bottom + padding);\r\n    },\r\n\r\n    /**\r\n     * Shuts down the simulation, clearing physics data and removing listeners.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#shutdown\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.tree.clear();\r\n        this.staticTree.clear();\r\n        this.bodies.clear();\r\n        this.staticBodies.clear();\r\n        this.colliders.destroy();\r\n\r\n        this.removeAllListeners();\r\n    },\r\n\r\n    /**\r\n     * Shuts down the simulation and disconnects it from the current scene.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = World;\r\n"]},"metadata":{},"sourceType":"script"}