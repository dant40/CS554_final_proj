{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar Vector2 = require('../../math/Vector2');\n/**\r\n * @classdesc\r\n * \r\n * The Body Bounds class contains methods to help you extract the world coordinates from various points around\r\n * the bounds of a Matter Body. Because Matter bodies are positioned based on their center of mass, and not a\r\n * dimension based center, you often need to get the bounds coordinates in order to properly align them in the world.\r\n * \r\n * You can access this class via the MatterPhysics class from a Scene, i.e.:\r\n * \r\n * ```javascript\r\n * this.matter.bodyBounds.getTopLeft(body);\r\n * ```\r\n * \r\n * See also the `MatterPhysics.alignBody` method.\r\n *\r\n * @class BodyBounds\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.22.0\r\n */\n\n\nvar BodyBounds = new Class({\n  initialize: function BodyBounds() {\n    /**\r\n     * A Vector2 that stores the temporary bounds center value during calculations by methods in this class.\r\n     *\r\n     * @name Phaser.Physics.Matter.BodyBounds#boundsCenter\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.22.0\r\n     */\n    this.boundsCenter = new Vector2();\n    /**\r\n     * A Vector2 that stores the temporary center diff values during calculations by methods in this class.\r\n     *\r\n     * @name Phaser.Physics.Matter.BodyBounds#centerDiff\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.22.0\r\n     */\n\n    this.centerDiff = new Vector2();\n  },\n\n  /**\r\n   * Parses the given body to get the bounds diff values from it.\r\n   * \r\n   * They're stored in this class in the temporary properties `boundsCenter` and `centerDiff`.\r\n   * \r\n   * This method is called automatically by all other methods in this class.\r\n   *\r\n   * @method Phaser.Physics.Matter.BodyBounds#parseBody\r\n   * @since 3.22.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the bounds position from.\r\n   *\r\n   * @return {boolean} `true` if it was able to get the bounds, otherwise `false`.\r\n   */\n  parseBody: function (body) {\n    body = body.hasOwnProperty('body') ? body.body : body;\n\n    if (!body.hasOwnProperty('bounds') || !body.hasOwnProperty('centerOfMass')) {\n      return false;\n    }\n\n    var boundsCenter = this.boundsCenter;\n    var centerDiff = this.centerDiff;\n    var boundsWidth = body.bounds.max.x - body.bounds.min.x;\n    var boundsHeight = body.bounds.max.y - body.bounds.min.y;\n    var bodyCenterX = boundsWidth * body.centerOfMass.x;\n    var bodyCenterY = boundsHeight * body.centerOfMass.y;\n    boundsCenter.set(boundsWidth / 2, boundsHeight / 2);\n    centerDiff.set(bodyCenterX - boundsCenter.x, bodyCenterY - boundsCenter.y);\n    return true;\n  },\n\n  /**\r\n   * Takes a Body and returns the world coordinates of the top-left of its _bounds_.\r\n   * \r\n   * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n   * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n   *\r\n   * @method Phaser.Physics.Matter.BodyBounds#getTopLeft\r\n   * @since 3.22.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n   * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n   * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n   *\r\n   * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n   */\n  getTopLeft: function (body, x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (this.parseBody(body)) {\n      var center = this.boundsCenter;\n      var diff = this.centerDiff;\n      return new Vector2(x + center.x + diff.x, y + center.y + diff.y);\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Takes a Body and returns the world coordinates of the top-center of its _bounds_.\r\n   * \r\n   * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n   * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n   *\r\n   * @method Phaser.Physics.Matter.BodyBounds#getTopCenter\r\n   * @since 3.22.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n   * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n   * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n   *\r\n   * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n   */\n  getTopCenter: function (body, x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (this.parseBody(body)) {\n      var center = this.boundsCenter;\n      var diff = this.centerDiff;\n      return new Vector2(x + diff.x, y + center.y + diff.y);\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Takes a Body and returns the world coordinates of the top-right of its _bounds_.\r\n   * \r\n   * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n   * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n   *\r\n   * @method Phaser.Physics.Matter.BodyBounds#getTopRight\r\n   * @since 3.22.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n   * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n   * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n   *\r\n   * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n   */\n  getTopRight: function (body, x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (this.parseBody(body)) {\n      var center = this.boundsCenter;\n      var diff = this.centerDiff;\n      return new Vector2(x - (center.x - diff.x), y + center.y + diff.y);\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Takes a Body and returns the world coordinates of the left-center of its _bounds_.\r\n   * \r\n   * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n   * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n   *\r\n   * @method Phaser.Physics.Matter.BodyBounds#getLeftCenter\r\n   * @since 3.22.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n   * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n   * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n   *\r\n   * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n   */\n  getLeftCenter: function (body, x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (this.parseBody(body)) {\n      var center = this.boundsCenter;\n      var diff = this.centerDiff;\n      return new Vector2(x + center.x + diff.x, y + diff.y);\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Takes a Body and returns the world coordinates of the center of its _bounds_.\r\n   * \r\n   * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n   * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n   *\r\n   * @method Phaser.Physics.Matter.BodyBounds#getCenter\r\n   * @since 3.22.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n   * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n   * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n   *\r\n   * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n   */\n  getCenter: function (body, x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (this.parseBody(body)) {\n      var diff = this.centerDiff;\n      return new Vector2(x + diff.x, y + diff.y);\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Takes a Body and returns the world coordinates of the right-center of its _bounds_.\r\n   * \r\n   * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n   * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n   *\r\n   * @method Phaser.Physics.Matter.BodyBounds#getRightCenter\r\n   * @since 3.22.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n   * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n   * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n   *\r\n   * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n   */\n  getRightCenter: function (body, x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (this.parseBody(body)) {\n      var center = this.boundsCenter;\n      var diff = this.centerDiff;\n      return new Vector2(x - (center.x - diff.x), y + diff.y);\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Takes a Body and returns the world coordinates of the bottom-left of its _bounds_.\r\n   * \r\n   * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n   * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n   *\r\n   * @method Phaser.Physics.Matter.BodyBounds#getBottomLeft\r\n   * @since 3.22.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n   * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n   * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n   *\r\n   * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n   */\n  getBottomLeft: function (body, x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (this.parseBody(body)) {\n      var center = this.boundsCenter;\n      var diff = this.centerDiff;\n      return new Vector2(x + center.x + diff.x, y - (center.y - diff.y));\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Takes a Body and returns the world coordinates of the bottom-center of its _bounds_.\r\n   * \r\n   * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n   * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n   *\r\n   * @method Phaser.Physics.Matter.BodyBounds#getBottomCenter\r\n   * @since 3.22.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n   * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n   * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n   *\r\n   * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n   */\n  getBottomCenter: function (body, x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (this.parseBody(body)) {\n      var center = this.boundsCenter;\n      var diff = this.centerDiff;\n      return new Vector2(x + diff.x, y - (center.y - diff.y));\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Takes a Body and returns the world coordinates of the bottom-right of its _bounds_.\r\n   * \r\n   * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n   * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n   *\r\n   * @method Phaser.Physics.Matter.BodyBounds#getBottomRight\r\n   * @since 3.22.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n   * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n   * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n   *\r\n   * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n   */\n  getBottomRight: function (body, x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (this.parseBody(body)) {\n      var center = this.boundsCenter;\n      var diff = this.centerDiff;\n      return new Vector2(x - (center.x - diff.x), y - (center.y - diff.y));\n    }\n\n    return false;\n  }\n});\nmodule.exports = BodyBounds;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/BodyBounds.js"],"names":["Class","require","Vector2","BodyBounds","initialize","boundsCenter","centerDiff","parseBody","body","hasOwnProperty","boundsWidth","bounds","max","x","min","boundsHeight","y","bodyCenterX","centerOfMass","bodyCenterY","set","getTopLeft","undefined","center","diff","getTopCenter","getTopRight","getLeftCenter","getCenter","getRightCenter","getBottomLeft","getBottomCenter","getBottomRight","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * \r\n * The Body Bounds class contains methods to help you extract the world coordinates from various points around\r\n * the bounds of a Matter Body. Because Matter bodies are positioned based on their center of mass, and not a\r\n * dimension based center, you often need to get the bounds coordinates in order to properly align them in the world.\r\n * \r\n * You can access this class via the MatterPhysics class from a Scene, i.e.:\r\n * \r\n * ```javascript\r\n * this.matter.bodyBounds.getTopLeft(body);\r\n * ```\r\n * \r\n * See also the `MatterPhysics.alignBody` method.\r\n *\r\n * @class BodyBounds\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.22.0\r\n */\r\nvar BodyBounds = new Class({\r\n\r\n    initialize:\r\n\r\n    function BodyBounds ()\r\n    {\r\n        /**\r\n         * A Vector2 that stores the temporary bounds center value during calculations by methods in this class.\r\n         *\r\n         * @name Phaser.Physics.Matter.BodyBounds#boundsCenter\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.22.0\r\n         */\r\n        this.boundsCenter = new Vector2();\r\n\r\n        /**\r\n         * A Vector2 that stores the temporary center diff values during calculations by methods in this class.\r\n         *\r\n         * @name Phaser.Physics.Matter.BodyBounds#centerDiff\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.22.0\r\n         */\r\n        this.centerDiff = new Vector2();\r\n    },\r\n\r\n    /**\r\n     * Parses the given body to get the bounds diff values from it.\r\n     * \r\n     * They're stored in this class in the temporary properties `boundsCenter` and `centerDiff`.\r\n     * \r\n     * This method is called automatically by all other methods in this class.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#parseBody\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the bounds position from.\r\n     *\r\n     * @return {boolean} `true` if it was able to get the bounds, otherwise `false`.\r\n     */\r\n    parseBody: function (body)\r\n    {\r\n        body = (body.hasOwnProperty('body')) ? body.body : body;\r\n\r\n        if (!body.hasOwnProperty('bounds') || !body.hasOwnProperty('centerOfMass'))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var boundsCenter = this.boundsCenter;\r\n        var centerDiff = this.centerDiff;\r\n\r\n        var boundsWidth = body.bounds.max.x - body.bounds.min.x;\r\n        var boundsHeight = body.bounds.max.y - body.bounds.min.y;\r\n\r\n        var bodyCenterX = boundsWidth * body.centerOfMass.x;\r\n        var bodyCenterY = boundsHeight * body.centerOfMass.y;\r\n\r\n        boundsCenter.set(boundsWidth / 2, boundsHeight / 2);\r\n        centerDiff.set(bodyCenterX - boundsCenter.x, bodyCenterY - boundsCenter.y);\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the top-left of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getTopLeft\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getTopLeft: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var center = this.boundsCenter;\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x + center.x + diff.x,\r\n                y + center.y + diff.y\r\n            );\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the top-center of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getTopCenter\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getTopCenter: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var center = this.boundsCenter;\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x + diff.x,\r\n                y + center.y + diff.y\r\n            );\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the top-right of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getTopRight\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getTopRight: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var center = this.boundsCenter;\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x - (center.x - diff.x),\r\n                y + center.y + diff.y\r\n            );\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the left-center of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getLeftCenter\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getLeftCenter: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var center = this.boundsCenter;\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x + center.x + diff.x,\r\n                y + diff.y\r\n            );\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the center of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getCenter\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getCenter: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x + diff.x,\r\n                y + diff.y\r\n            );\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the right-center of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getRightCenter\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getRightCenter: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var center = this.boundsCenter;\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x - (center.x - diff.x),\r\n                y + diff.y\r\n            );\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the bottom-left of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getBottomLeft\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getBottomLeft: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var center = this.boundsCenter;\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x + center.x + diff.x,\r\n                y - (center.y - diff.y)\r\n            );\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the bottom-center of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getBottomCenter\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getBottomCenter: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var center = this.boundsCenter;\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x + diff.x,\r\n                y - (center.y - diff.y)\r\n            );\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the bottom-right of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getBottomRight\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getBottomRight: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var center = this.boundsCenter;\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x - (center.x - diff.x),\r\n                y - (center.y - diff.y)\r\n            );\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = BodyBounds;\r\n"]},"metadata":{},"sourceType":"script"}