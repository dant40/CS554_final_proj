{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../../utils/Class');\n\nvar Components = require('../../components');\n\nvar GameObject = require('../../GameObject');\n\nvar GetBitmapTextSize = require('../GetBitmapTextSize');\n\nvar ParseFromAtlas = require('../ParseFromAtlas');\n\nvar ParseXMLBitmapFont = require('../ParseXMLBitmapFont');\n\nvar Render = require('./BitmapTextRender');\n/**\r\n * @classdesc\r\n * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.\r\n *\r\n * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to\r\n * match the font structure.\r\n *\r\n * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability\r\n * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by\r\n * processing the font texture in an image editor, applying fills and any other effects required.\r\n *\r\n * To create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\r\n *\r\n * To create a BitmapText data files you need a 3rd party app such as:\r\n *\r\n * BMFont (Windows, free): {@link http://www.angelcode.com/products/bmfont/|http://www.angelcode.com/products/bmfont/}\r\n * Glyph Designer (OS X, commercial): {@link http://www.71squared.com/en/glyphdesigner|http://www.71squared.com/en/glyphdesigner}\r\n * Littera (Web-based, free): {@link http://kvazars.com/littera/|http://kvazars.com/littera/}\r\n *\r\n * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of\r\n * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: {@link http://codebeautify.org/xmltojson|http://codebeautify.org/xmltojson}\r\n *\r\n * @class BitmapText\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.\r\n * @param {number} x - The x coordinate of this Game Object in world space.\r\n * @param {number} y - The y coordinate of this Game Object in world space.\r\n * @param {string} font - The key of the font to use from the Bitmap Font cache.\r\n * @param {(string|string[])} [text] - The string, or array of strings, to be set as the content of this Bitmap Text.\r\n * @param {number} [size] - The font size of this Bitmap Text.\r\n * @param {integer} [align=0] - The alignment of the text in a multi-line BitmapText object.\r\n */\n\n\nvar BitmapText = new Class({\n  Extends: GameObject,\n  Mixins: [Components.Alpha, Components.BlendMode, Components.Depth, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Texture, Components.Tint, Components.Transform, Components.Visible, Render],\n  initialize: function BitmapText(scene, x, y, font, text, size, align) {\n    if (text === undefined) {\n      text = '';\n    }\n\n    if (align === undefined) {\n      align = 0;\n    }\n\n    GameObject.call(this, scene, 'BitmapText');\n    /**\r\n     * The key of the Bitmap Font used by this Bitmap Text.\r\n     * To change the font after creation please use `setFont`.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#font\r\n     * @type {string}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\n\n    this.font = font;\n    var entry = this.scene.sys.cache.bitmapFont.get(font);\n    /**\r\n     * The data of the Bitmap Font used by this Bitmap Text.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#fontData\r\n     * @type {Phaser.Types.GameObjects.BitmapText.BitmapFontData}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\n\n    this.fontData = entry.data;\n    /**\r\n     * The text that this Bitmap Text object displays.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#_text\r\n     * @type {string}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._text = '';\n    /**\r\n     * The font size of this Bitmap Text.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#_fontSize\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._fontSize = size || this.fontData.size;\n    /**\r\n     * Adds / Removes spacing between characters.\r\n     *\r\n     * Can be a negative or positive number.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#_letterSpacing\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.4.0\r\n     */\n\n    this._letterSpacing = 0;\n    /**\r\n     * Controls the alignment of each line of text in this BitmapText object.\r\n     * Only has any effect when this BitmapText contains multiple lines of text, split with carriage-returns.\r\n     * Has no effect with single-lines of text.\r\n     *\r\n     * See the methods `setLeftAlign`, `setCenterAlign` and `setRightAlign`.\r\n     *\r\n     * 0 = Left aligned (default)\r\n     * 1 = Middle aligned\r\n     * 2 = Right aligned\r\n     *\r\n     * The alignment position is based on the longest line of text.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#_align\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.11.0\r\n     */\n\n    this._align = align;\n    /**\r\n     * An object that describes the size of this Bitmap Text.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#_bounds\r\n     * @type {Phaser.Types.GameObjects.BitmapText.BitmapTextSize}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._bounds = GetBitmapTextSize();\n    /**\r\n     * An internal dirty flag for bounds calculation.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#_dirty\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.11.0\r\n     */\n\n    this._dirty = true;\n    /**\r\n     * Internal cache var holding the maxWidth.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#_maxWidth\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.21.0\r\n     */\n\n    this._maxWidth = 0;\n    /**\r\n     * The character code used to detect for word wrapping.\r\n     * Defaults to 32 (a space character).\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#wordWrapCharCode\r\n     * @type {number}\r\n     * @since 3.21.0\r\n     */\n\n    this.wordWrapCharCode = 32;\n    this.setTexture(entry.texture, entry.frame);\n    this.setPosition(x, y);\n    this.setOrigin(0, 0);\n    this.initPipeline();\n    this.setText(text);\n  },\n\n  /**\r\n   * Set the lines of text in this BitmapText to be left-aligned.\r\n   * This only has any effect if this BitmapText contains more than one line of text.\r\n   *\r\n   * @method Phaser.GameObjects.BitmapText#setLeftAlign\r\n   * @since 3.11.0\r\n   *\r\n   * @return {this} This BitmapText Object.\r\n   */\n  setLeftAlign: function () {\n    this._align = BitmapText.ALIGN_LEFT;\n    this._dirty = true;\n    return this;\n  },\n\n  /**\r\n   * Set the lines of text in this BitmapText to be center-aligned.\r\n   * This only has any effect if this BitmapText contains more than one line of text.\r\n   *\r\n   * @method Phaser.GameObjects.BitmapText#setCenterAlign\r\n   * @since 3.11.0\r\n   *\r\n   * @return {this} This BitmapText Object.\r\n   */\n  setCenterAlign: function () {\n    this._align = BitmapText.ALIGN_CENTER;\n    this._dirty = true;\n    return this;\n  },\n\n  /**\r\n   * Set the lines of text in this BitmapText to be right-aligned.\r\n   * This only has any effect if this BitmapText contains more than one line of text.\r\n   *\r\n   * @method Phaser.GameObjects.BitmapText#setRightAlign\r\n   * @since 3.11.0\r\n   *\r\n   * @return {this} This BitmapText Object.\r\n   */\n  setRightAlign: function () {\n    this._align = BitmapText.ALIGN_RIGHT;\n    this._dirty = true;\n    return this;\n  },\n\n  /**\r\n   * Set the font size of this Bitmap Text.\r\n   *\r\n   * @method Phaser.GameObjects.BitmapText#setFontSize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} size - The font size to set.\r\n   *\r\n   * @return {this} This BitmapText Object.\r\n   */\n  setFontSize: function (size) {\n    this._fontSize = size;\n    this._dirty = true;\n    return this;\n  },\n\n  /**\r\n   * Sets the letter spacing between each character of this Bitmap Text.\r\n   * Can be a positive value to increase the space, or negative to reduce it.\r\n   * Spacing is applied after the kerning values have been set.\r\n   *\r\n   * @method Phaser.GameObjects.BitmapText#setLetterSpacing\r\n   * @since 3.4.0\r\n   *\r\n   * @param {number} [spacing=0] - The amount of horizontal space to add between each character.\r\n   *\r\n   * @return {this} This BitmapText Object.\r\n   */\n  setLetterSpacing: function (spacing) {\n    if (spacing === undefined) {\n      spacing = 0;\n    }\n\n    this._letterSpacing = spacing;\n    this._dirty = true;\n    return this;\n  },\n\n  /**\r\n   * Set the textual content of this BitmapText.\r\n   *\r\n   * An array of strings will be converted into multi-line text. Use the align methods to change multi-line alignment.\r\n   *\r\n   * @method Phaser.GameObjects.BitmapText#setText\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|string[])} value - The string, or array of strings, to be set as the content of this BitmapText.\r\n   *\r\n   * @return {this} This BitmapText Object.\r\n   */\n  setText: function (value) {\n    if (!value && value !== 0) {\n      value = '';\n    }\n\n    if (Array.isArray(value)) {\n      value = value.join('\\n');\n    }\n\n    if (value !== this.text) {\n      this._text = value.toString();\n      this._dirty = true;\n      this.updateDisplayOrigin();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Calculate the bounds of this Bitmap Text.\r\n   *\r\n   * An object is returned that contains the position, width and height of the Bitmap Text in local and global\r\n   * contexts.\r\n   *\r\n   * Local size is based on just the font size and a [0, 0] position.\r\n   *\r\n   * Global size takes into account the Game Object's scale, world position and display origin.\r\n   *\r\n   * Also in the object is data regarding the length of each line, should this be a multi-line BitmapText.\r\n   *\r\n   * @method Phaser.GameObjects.BitmapText#getTextBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [round] - Whether to round the results to the nearest integer.\r\n   *\r\n   * @return {Phaser.Types.GameObjects.BitmapText.BitmapTextSize} An object that describes the size of this Bitmap Text.\r\n   */\n  getTextBounds: function (round) {\n    //  local = The BitmapText based on fontSize and 0x0 coords\n    //  global = The BitmapText, taking into account scale and world position\n    //  lines = The BitmapText line data\n    var bounds = this._bounds;\n\n    if (this._dirty || this.scaleX !== bounds.scaleX || this.scaleY !== bounds.scaleY) {\n      GetBitmapTextSize(this, round, bounds);\n      this._dirty = false;\n      this.updateDisplayOrigin();\n    }\n\n    return bounds;\n  },\n\n  /**\r\n   * Changes the font this BitmapText is using to render.\r\n   *\r\n   * The new texture is loaded and applied to the BitmapText. The existing test, size and alignment are preserved,\r\n   * unless overridden via the arguments.\r\n   *\r\n   * @method Phaser.GameObjects.BitmapText#setFont\r\n   * @since 3.11.0\r\n   *\r\n   * @param {string} font - The key of the font to use from the Bitmap Font cache.\r\n   * @param {number} [size] - The font size of this Bitmap Text. If not specified the current size will be used.\r\n   * @param {integer} [align=0] - The alignment of the text in a multi-line BitmapText object. If not specified the current alignment will be used.\r\n   *\r\n   * @return {this} This BitmapText Object.\r\n   */\n  setFont: function (key, size, align) {\n    if (size === undefined) {\n      size = this._fontSize;\n    }\n\n    if (align === undefined) {\n      align = this._align;\n    }\n\n    if (key !== this.font) {\n      var entry = this.scene.sys.cache.bitmapFont.get(key);\n\n      if (entry) {\n        this.font = key;\n        this.fontData = entry.data;\n        this._fontSize = size;\n        this._align = align;\n        this.setTexture(entry.texture, entry.frame);\n        GetBitmapTextSize(this, false, this._bounds);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the maximum display width of this BitmapText in pixels.\r\n   *\r\n   * If `BitmapText.text` is longer than `maxWidth` then the lines will be automatically wrapped\r\n   * based on the previous whitespace character found in the line.\r\n   *\r\n   * If no whitespace was found then no wrapping will take place and consequently the `maxWidth` value will not be honored.\r\n   *\r\n   * Disable maxWidth by setting the value to 0.\r\n   *\r\n   * You can set the whitespace character to be searched for by setting the `wordWrapCharCode` parameter or property.\r\n   *\r\n   * @method Phaser.GameObjects.BitmapText#setMaxWidth\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} value - The maximum display width of this BitmapText in pixels. Set to zero to disable.\r\n   * @param {number} [wordWrapCharCode] - The character code to check for when word wrapping. Defaults to 32 (the space character).\r\n   *\r\n   * @return {this} This BitmapText Object.\r\n   */\n  setMaxWidth: function (value, wordWrapCharCode) {\n    this._maxWidth = value;\n    this._dirty = true;\n\n    if (wordWrapCharCode !== undefined) {\n      this.wordWrapCharCode = wordWrapCharCode;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Controls the alignment of each line of text in this BitmapText object.\r\n   *\r\n   * Only has any effect when this BitmapText contains multiple lines of text, split with carriage-returns.\r\n   * Has no effect with single-lines of text.\r\n   *\r\n   * See the methods `setLeftAlign`, `setCenterAlign` and `setRightAlign`.\r\n   *\r\n   * 0 = Left aligned (default)\r\n   * 1 = Middle aligned\r\n   * 2 = Right aligned\r\n   *\r\n   * The alignment position is based on the longest line of text.\r\n   *\r\n   * @name Phaser.GameObjects.BitmapText#align\r\n   * @type {integer}\r\n   * @since 3.11.0\r\n   */\n  align: {\n    set: function (value) {\n      this._align = value;\n      this._dirty = true;\n    },\n    get: function () {\n      return this._align;\n    }\n  },\n\n  /**\r\n   * The text that this Bitmap Text object displays.\r\n   *\r\n   * You can also use the method `setText` if you want a chainable way to change the text content.\r\n   *\r\n   * @name Phaser.GameObjects.BitmapText#text\r\n   * @type {string}\r\n   * @since 3.0.0\r\n   */\n  text: {\n    set: function (value) {\n      this.setText(value);\n    },\n    get: function () {\n      return this._text;\n    }\n  },\n\n  /**\r\n   * The font size of this Bitmap Text.\r\n   *\r\n   * You can also use the method `setFontSize` if you want a chainable way to change the font size.\r\n   *\r\n   * @name Phaser.GameObjects.BitmapText#fontSize\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  fontSize: {\n    set: function (value) {\n      this._fontSize = value;\n      this._dirty = true;\n    },\n    get: function () {\n      return this._fontSize;\n    }\n  },\n\n  /**\r\n   * Adds / Removes spacing between characters.\r\n   *\r\n   * Can be a negative or positive number.\r\n   *\r\n   * You can also use the method `setLetterSpacing` if you want a chainable way to change the letter spacing.\r\n   *\r\n   * @name Phaser.GameObjects.BitmapText#letterSpacing\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  letterSpacing: {\n    set: function (value) {\n      this._letterSpacing = value;\n      this._dirty = true;\n    },\n    get: function () {\n      return this._letterSpacing;\n    }\n  },\n\n  /**\r\n   * The maximum display width of this BitmapText in pixels.\r\n   *\r\n   * If BitmapText.text is longer than maxWidth then the lines will be automatically wrapped\r\n   * based on the last whitespace character found in the line.\r\n   *\r\n   * If no whitespace was found then no wrapping will take place and consequently the maxWidth value will not be honored.\r\n   *\r\n   * Disable maxWidth by setting the value to 0.\r\n   *\r\n   * @name Phaser.GameObjects.BitmapText#maxWidth\r\n   * @type {number}\r\n   * @since 3.21.0\r\n   */\n  maxWidth: {\n    set: function (value) {\n      this._maxWidth = value;\n      this._dirty = true;\n    },\n    get: function () {\n      return this._maxWidth;\n    }\n  },\n\n  /**\r\n   * The width of this Bitmap Text.\r\n   *\r\n   * @name Phaser.GameObjects.BitmapText#width\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  width: {\n    get: function () {\n      this.getTextBounds(false);\n      return this._bounds.global.width;\n    }\n  },\n\n  /**\r\n   * The height of this bitmap text.\r\n   *\r\n   * @name Phaser.GameObjects.BitmapText#height\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  height: {\n    get: function () {\n      this.getTextBounds(false);\n      return this._bounds.global.height;\n    }\n  },\n\n  /**\r\n   * Build a JSON representation of this Bitmap Text.\r\n   *\r\n   * @method Phaser.GameObjects.BitmapText#toJSON\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Types.GameObjects.BitmapText.JSONBitmapText} A JSON representation of this Bitmap Text.\r\n   */\n  toJSON: function () {\n    var out = Components.ToJSON(this); //  Extra data is added here\n\n    var data = {\n      font: this.font,\n      text: this.text,\n      fontSize: this.fontSize,\n      letterSpacing: this.letterSpacing,\n      align: this.align\n    };\n    out.data = data;\n    return out;\n  }\n});\n/**\r\n * Left align the text characters in a multi-line BitmapText object.\r\n *\r\n * @name Phaser.GameObjects.BitmapText.ALIGN_LEFT\r\n * @type {integer}\r\n * @since 3.11.0\r\n */\n\nBitmapText.ALIGN_LEFT = 0;\n/**\r\n * Center align the text characters in a multi-line BitmapText object.\r\n *\r\n * @name Phaser.GameObjects.BitmapText.ALIGN_CENTER\r\n * @type {integer}\r\n * @since 3.11.0\r\n */\n\nBitmapText.ALIGN_CENTER = 1;\n/**\r\n * Right align the text characters in a multi-line BitmapText object.\r\n *\r\n * @name Phaser.GameObjects.BitmapText.ALIGN_RIGHT\r\n * @type {integer}\r\n * @since 3.11.0\r\n */\n\nBitmapText.ALIGN_RIGHT = 2;\n/**\r\n * Parse an XML Bitmap Font from an Atlas.\r\n *\r\n * Adds the parsed Bitmap Font data to the cache with the `fontName` key.\r\n *\r\n * @method Phaser.GameObjects.BitmapText.ParseFromAtlas\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to parse the Bitmap Font for.\r\n * @param {string} fontName - The key of the font to add to the Bitmap Font cache.\r\n * @param {string} textureKey - The key of the BitmapFont's texture.\r\n * @param {string} frameKey - The key of the BitmapFont texture's frame.\r\n * @param {string} xmlKey - The key of the XML data of the font to parse.\r\n * @param {integer} [xSpacing] - The x-axis spacing to add between each letter.\r\n * @param {integer} [ySpacing] - The y-axis spacing to add to the line height.\r\n *\r\n * @return {boolean} Whether the parsing was successful or not.\r\n */\n\nBitmapText.ParseFromAtlas = ParseFromAtlas;\n/**\r\n * Parse an XML font to Bitmap Font data for the Bitmap Font cache.\r\n *\r\n * @method Phaser.GameObjects.BitmapText.ParseXMLBitmapFont\r\n * @since 3.17.0\r\n *\r\n * @param {XMLDocument} xml - The XML Document to parse the font from.\r\n * @param {integer} [xSpacing=0] - The x-axis spacing to add between each letter.\r\n * @param {integer} [ySpacing=0] - The y-axis spacing to add to the line height.\r\n * @param {Phaser.Textures.Frame} [frame] - The texture frame to take into account while parsing.\r\n *\r\n * @return {Phaser.Types.GameObjects.BitmapText.BitmapFontData} The parsed Bitmap Font data.\r\n */\n\nBitmapText.ParseXMLBitmapFont = ParseXMLBitmapFont;\nmodule.exports = BitmapText;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapText.js"],"names":["Class","require","Components","GameObject","GetBitmapTextSize","ParseFromAtlas","ParseXMLBitmapFont","Render","BitmapText","Extends","Mixins","Alpha","BlendMode","Depth","Mask","Origin","Pipeline","ScrollFactor","Texture","Tint","Transform","Visible","initialize","scene","x","y","font","text","size","align","undefined","call","entry","sys","cache","bitmapFont","get","fontData","data","_text","_fontSize","_letterSpacing","_align","_bounds","_dirty","_maxWidth","wordWrapCharCode","setTexture","texture","frame","setPosition","setOrigin","initPipeline","setText","setLeftAlign","ALIGN_LEFT","setCenterAlign","ALIGN_CENTER","setRightAlign","ALIGN_RIGHT","setFontSize","setLetterSpacing","spacing","value","Array","isArray","join","toString","updateDisplayOrigin","getTextBounds","round","bounds","scaleX","scaleY","setFont","key","setMaxWidth","set","fontSize","letterSpacing","maxWidth","width","global","height","toJSON","out","ToJSON","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Components = require('../../components');\r\nvar GameObject = require('../../GameObject');\r\nvar GetBitmapTextSize = require('../GetBitmapTextSize');\r\nvar ParseFromAtlas = require('../ParseFromAtlas');\r\nvar ParseXMLBitmapFont = require('../ParseXMLBitmapFont');\r\nvar Render = require('./BitmapTextRender');\r\n\r\n/**\r\n * @classdesc\r\n * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.\r\n *\r\n * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to\r\n * match the font structure.\r\n *\r\n * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability\r\n * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by\r\n * processing the font texture in an image editor, applying fills and any other effects required.\r\n *\r\n * To create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\r\n *\r\n * To create a BitmapText data files you need a 3rd party app such as:\r\n *\r\n * BMFont (Windows, free): {@link http://www.angelcode.com/products/bmfont/|http://www.angelcode.com/products/bmfont/}\r\n * Glyph Designer (OS X, commercial): {@link http://www.71squared.com/en/glyphdesigner|http://www.71squared.com/en/glyphdesigner}\r\n * Littera (Web-based, free): {@link http://kvazars.com/littera/|http://kvazars.com/littera/}\r\n *\r\n * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of\r\n * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: {@link http://codebeautify.org/xmltojson|http://codebeautify.org/xmltojson}\r\n *\r\n * @class BitmapText\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.\r\n * @param {number} x - The x coordinate of this Game Object in world space.\r\n * @param {number} y - The y coordinate of this Game Object in world space.\r\n * @param {string} font - The key of the font to use from the Bitmap Font cache.\r\n * @param {(string|string[])} [text] - The string, or array of strings, to be set as the content of this Bitmap Text.\r\n * @param {number} [size] - The font size of this Bitmap Text.\r\n * @param {integer} [align=0] - The alignment of the text in a multi-line BitmapText object.\r\n */\r\nvar BitmapText = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Texture,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function BitmapText (scene, x, y, font, text, size, align)\r\n    {\r\n        if (text === undefined) { text = ''; }\r\n        if (align === undefined) { align = 0; }\r\n\r\n        GameObject.call(this, scene, 'BitmapText');\r\n\r\n        /**\r\n         * The key of the Bitmap Font used by this Bitmap Text.\r\n         * To change the font after creation please use `setFont`.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#font\r\n         * @type {string}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.font = font;\r\n\r\n        var entry = this.scene.sys.cache.bitmapFont.get(font);\r\n\r\n        /**\r\n         * The data of the Bitmap Font used by this Bitmap Text.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#fontData\r\n         * @type {Phaser.Types.GameObjects.BitmapText.BitmapFontData}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.fontData = entry.data;\r\n\r\n        /**\r\n         * The text that this Bitmap Text object displays.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_text\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._text = '';\r\n\r\n        /**\r\n         * The font size of this Bitmap Text.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_fontSize\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._fontSize = size || this.fontData.size;\r\n\r\n        /**\r\n         * Adds / Removes spacing between characters.\r\n         *\r\n         * Can be a negative or positive number.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_letterSpacing\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this._letterSpacing = 0;\r\n\r\n        /**\r\n         * Controls the alignment of each line of text in this BitmapText object.\r\n         * Only has any effect when this BitmapText contains multiple lines of text, split with carriage-returns.\r\n         * Has no effect with single-lines of text.\r\n         *\r\n         * See the methods `setLeftAlign`, `setCenterAlign` and `setRightAlign`.\r\n         *\r\n         * 0 = Left aligned (default)\r\n         * 1 = Middle aligned\r\n         * 2 = Right aligned\r\n         *\r\n         * The alignment position is based on the longest line of text.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_align\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.11.0\r\n         */\r\n        this._align = align;\r\n\r\n        /**\r\n         * An object that describes the size of this Bitmap Text.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_bounds\r\n         * @type {Phaser.Types.GameObjects.BitmapText.BitmapTextSize}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._bounds = GetBitmapTextSize();\r\n\r\n        /**\r\n         * An internal dirty flag for bounds calculation.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_dirty\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.11.0\r\n         */\r\n        this._dirty = true;\r\n\r\n        /**\r\n         * Internal cache var holding the maxWidth.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_maxWidth\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.21.0\r\n         */\r\n        this._maxWidth = 0;\r\n\r\n        /**\r\n         * The character code used to detect for word wrapping.\r\n         * Defaults to 32 (a space character).\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#wordWrapCharCode\r\n         * @type {number}\r\n         * @since 3.21.0\r\n         */\r\n        this.wordWrapCharCode = 32;\r\n\r\n        this.setTexture(entry.texture, entry.frame);\r\n        this.setPosition(x, y);\r\n        this.setOrigin(0, 0);\r\n        this.initPipeline();\r\n\r\n        this.setText(text);\r\n    },\r\n\r\n    /**\r\n     * Set the lines of text in this BitmapText to be left-aligned.\r\n     * This only has any effect if this BitmapText contains more than one line of text.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setLeftAlign\r\n     * @since 3.11.0\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setLeftAlign: function ()\r\n    {\r\n        this._align = BitmapText.ALIGN_LEFT;\r\n\r\n        this._dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the lines of text in this BitmapText to be center-aligned.\r\n     * This only has any effect if this BitmapText contains more than one line of text.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setCenterAlign\r\n     * @since 3.11.0\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setCenterAlign: function ()\r\n    {\r\n        this._align = BitmapText.ALIGN_CENTER;\r\n\r\n        this._dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the lines of text in this BitmapText to be right-aligned.\r\n     * This only has any effect if this BitmapText contains more than one line of text.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setRightAlign\r\n     * @since 3.11.0\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setRightAlign: function ()\r\n    {\r\n        this._align = BitmapText.ALIGN_RIGHT;\r\n\r\n        this._dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the font size of this Bitmap Text.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setFontSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} size - The font size to set.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setFontSize: function (size)\r\n    {\r\n        this._fontSize = size;\r\n\r\n        this._dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the letter spacing between each character of this Bitmap Text.\r\n     * Can be a positive value to increase the space, or negative to reduce it.\r\n     * Spacing is applied after the kerning values have been set.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setLetterSpacing\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} [spacing=0] - The amount of horizontal space to add between each character.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setLetterSpacing: function (spacing)\r\n    {\r\n        if (spacing === undefined) { spacing = 0; }\r\n\r\n        this._letterSpacing = spacing;\r\n\r\n        this._dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the textual content of this BitmapText.\r\n     *\r\n     * An array of strings will be converted into multi-line text. Use the align methods to change multi-line alignment.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} value - The string, or array of strings, to be set as the content of this BitmapText.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setText: function (value)\r\n    {\r\n        if (!value && value !== 0)\r\n        {\r\n            value = '';\r\n        }\r\n\r\n        if (Array.isArray(value))\r\n        {\r\n            value = value.join('\\n');\r\n        }\r\n\r\n        if (value !== this.text)\r\n        {\r\n            this._text = value.toString();\r\n\r\n            this._dirty = true;\r\n\r\n            this.updateDisplayOrigin();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the bounds of this Bitmap Text.\r\n     *\r\n     * An object is returned that contains the position, width and height of the Bitmap Text in local and global\r\n     * contexts.\r\n     *\r\n     * Local size is based on just the font size and a [0, 0] position.\r\n     *\r\n     * Global size takes into account the Game Object's scale, world position and display origin.\r\n     *\r\n     * Also in the object is data regarding the length of each line, should this be a multi-line BitmapText.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#getTextBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [round] - Whether to round the results to the nearest integer.\r\n     *\r\n     * @return {Phaser.Types.GameObjects.BitmapText.BitmapTextSize} An object that describes the size of this Bitmap Text.\r\n     */\r\n    getTextBounds: function (round)\r\n    {\r\n        //  local = The BitmapText based on fontSize and 0x0 coords\r\n        //  global = The BitmapText, taking into account scale and world position\r\n        //  lines = The BitmapText line data\r\n\r\n        var bounds = this._bounds;\r\n\r\n        if (this._dirty || this.scaleX !== bounds.scaleX || this.scaleY !== bounds.scaleY)\r\n        {\r\n            GetBitmapTextSize(this, round, bounds);\r\n\r\n            this._dirty = false;\r\n\r\n            this.updateDisplayOrigin();\r\n        }\r\n\r\n        return bounds;\r\n    },\r\n\r\n    /**\r\n     * Changes the font this BitmapText is using to render.\r\n     *\r\n     * The new texture is loaded and applied to the BitmapText. The existing test, size and alignment are preserved,\r\n     * unless overridden via the arguments.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setFont\r\n     * @since 3.11.0\r\n     *\r\n     * @param {string} font - The key of the font to use from the Bitmap Font cache.\r\n     * @param {number} [size] - The font size of this Bitmap Text. If not specified the current size will be used.\r\n     * @param {integer} [align=0] - The alignment of the text in a multi-line BitmapText object. If not specified the current alignment will be used.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setFont: function (key, size, align)\r\n    {\r\n        if (size === undefined) { size = this._fontSize; }\r\n        if (align === undefined) { align = this._align; }\r\n\r\n        if (key !== this.font)\r\n        {\r\n            var entry = this.scene.sys.cache.bitmapFont.get(key);\r\n\r\n            if (entry)\r\n            {\r\n                this.font = key;\r\n                this.fontData = entry.data;\r\n                this._fontSize = size;\r\n                this._align = align;\r\n\r\n                this.setTexture(entry.texture, entry.frame);\r\n\r\n                GetBitmapTextSize(this, false, this._bounds);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the maximum display width of this BitmapText in pixels.\r\n     *\r\n     * If `BitmapText.text` is longer than `maxWidth` then the lines will be automatically wrapped\r\n     * based on the previous whitespace character found in the line.\r\n     *\r\n     * If no whitespace was found then no wrapping will take place and consequently the `maxWidth` value will not be honored.\r\n     *\r\n     * Disable maxWidth by setting the value to 0.\r\n     *\r\n     * You can set the whitespace character to be searched for by setting the `wordWrapCharCode` parameter or property.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setMaxWidth\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The maximum display width of this BitmapText in pixels. Set to zero to disable.\r\n     * @param {number} [wordWrapCharCode] - The character code to check for when word wrapping. Defaults to 32 (the space character).\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setMaxWidth: function (value, wordWrapCharCode)\r\n    {\r\n        this._maxWidth = value;\r\n\r\n        this._dirty = true;\r\n\r\n        if (wordWrapCharCode !== undefined)\r\n        {\r\n            this.wordWrapCharCode = wordWrapCharCode;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Controls the alignment of each line of text in this BitmapText object.\r\n     *\r\n     * Only has any effect when this BitmapText contains multiple lines of text, split with carriage-returns.\r\n     * Has no effect with single-lines of text.\r\n     *\r\n     * See the methods `setLeftAlign`, `setCenterAlign` and `setRightAlign`.\r\n     *\r\n     * 0 = Left aligned (default)\r\n     * 1 = Middle aligned\r\n     * 2 = Right aligned\r\n     *\r\n     * The alignment position is based on the longest line of text.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#align\r\n     * @type {integer}\r\n     * @since 3.11.0\r\n     */\r\n    align: {\r\n\r\n        set: function (value)\r\n        {\r\n            this._align = value;\r\n            this._dirty = true;\r\n        },\r\n\r\n        get: function ()\r\n        {\r\n            return this._align;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The text that this Bitmap Text object displays.\r\n     *\r\n     * You can also use the method `setText` if you want a chainable way to change the text content.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#text\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\r\n    text: {\r\n\r\n        set: function (value)\r\n        {\r\n            this.setText(value);\r\n        },\r\n\r\n        get: function ()\r\n        {\r\n            return this._text;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The font size of this Bitmap Text.\r\n     *\r\n     * You can also use the method `setFontSize` if you want a chainable way to change the font size.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#fontSize\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    fontSize: {\r\n\r\n        set: function (value)\r\n        {\r\n            this._fontSize = value;\r\n            this._dirty = true;\r\n        },\r\n\r\n        get: function ()\r\n        {\r\n            return this._fontSize;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Adds / Removes spacing between characters.\r\n     *\r\n     * Can be a negative or positive number.\r\n     *\r\n     * You can also use the method `setLetterSpacing` if you want a chainable way to change the letter spacing.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#letterSpacing\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    letterSpacing: {\r\n\r\n        set: function (value)\r\n        {\r\n            this._letterSpacing = value;\r\n            this._dirty = true;\r\n        },\r\n\r\n        get: function ()\r\n        {\r\n            return this._letterSpacing;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The maximum display width of this BitmapText in pixels.\r\n     *\r\n     * If BitmapText.text is longer than maxWidth then the lines will be automatically wrapped\r\n     * based on the last whitespace character found in the line.\r\n     *\r\n     * If no whitespace was found then no wrapping will take place and consequently the maxWidth value will not be honored.\r\n     *\r\n     * Disable maxWidth by setting the value to 0.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#maxWidth\r\n     * @type {number}\r\n     * @since 3.21.0\r\n     */\r\n    maxWidth: {\r\n\r\n        set: function (value)\r\n        {\r\n            this._maxWidth = value;\r\n            this._dirty = true;\r\n        },\r\n\r\n        get: function ()\r\n        {\r\n            return this._maxWidth;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The width of this Bitmap Text.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#width\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    width: {\r\n\r\n        get: function ()\r\n        {\r\n            this.getTextBounds(false);\r\n\r\n            return this._bounds.global.width;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The height of this bitmap text.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#height\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    height: {\r\n\r\n        get: function ()\r\n        {\r\n            this.getTextBounds(false);\r\n\r\n            return this._bounds.global.height;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Build a JSON representation of this Bitmap Text.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.GameObjects.BitmapText.JSONBitmapText} A JSON representation of this Bitmap Text.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        var out = Components.ToJSON(this);\r\n\r\n        //  Extra data is added here\r\n\r\n        var data = {\r\n            font: this.font,\r\n            text: this.text,\r\n            fontSize: this.fontSize,\r\n            letterSpacing: this.letterSpacing,\r\n            align: this.align\r\n        };\r\n\r\n        out.data = data;\r\n\r\n        return out;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Left align the text characters in a multi-line BitmapText object.\r\n *\r\n * @name Phaser.GameObjects.BitmapText.ALIGN_LEFT\r\n * @type {integer}\r\n * @since 3.11.0\r\n */\r\nBitmapText.ALIGN_LEFT = 0;\r\n\r\n/**\r\n * Center align the text characters in a multi-line BitmapText object.\r\n *\r\n * @name Phaser.GameObjects.BitmapText.ALIGN_CENTER\r\n * @type {integer}\r\n * @since 3.11.0\r\n */\r\nBitmapText.ALIGN_CENTER = 1;\r\n\r\n/**\r\n * Right align the text characters in a multi-line BitmapText object.\r\n *\r\n * @name Phaser.GameObjects.BitmapText.ALIGN_RIGHT\r\n * @type {integer}\r\n * @since 3.11.0\r\n */\r\nBitmapText.ALIGN_RIGHT = 2;\r\n\r\n/**\r\n * Parse an XML Bitmap Font from an Atlas.\r\n *\r\n * Adds the parsed Bitmap Font data to the cache with the `fontName` key.\r\n *\r\n * @method Phaser.GameObjects.BitmapText.ParseFromAtlas\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to parse the Bitmap Font for.\r\n * @param {string} fontName - The key of the font to add to the Bitmap Font cache.\r\n * @param {string} textureKey - The key of the BitmapFont's texture.\r\n * @param {string} frameKey - The key of the BitmapFont texture's frame.\r\n * @param {string} xmlKey - The key of the XML data of the font to parse.\r\n * @param {integer} [xSpacing] - The x-axis spacing to add between each letter.\r\n * @param {integer} [ySpacing] - The y-axis spacing to add to the line height.\r\n *\r\n * @return {boolean} Whether the parsing was successful or not.\r\n */\r\nBitmapText.ParseFromAtlas = ParseFromAtlas;\r\n\r\n/**\r\n * Parse an XML font to Bitmap Font data for the Bitmap Font cache.\r\n *\r\n * @method Phaser.GameObjects.BitmapText.ParseXMLBitmapFont\r\n * @since 3.17.0\r\n *\r\n * @param {XMLDocument} xml - The XML Document to parse the font from.\r\n * @param {integer} [xSpacing=0] - The x-axis spacing to add between each letter.\r\n * @param {integer} [ySpacing=0] - The y-axis spacing to add to the line height.\r\n * @param {Phaser.Textures.Frame} [frame] - The texture frame to take into account while parsing.\r\n *\r\n * @return {Phaser.Types.GameObjects.BitmapText.BitmapFontData} The parsed Bitmap Font data.\r\n */\r\nBitmapText.ParseXMLBitmapFont = ParseXMLBitmapFont;\r\n\r\nmodule.exports = BitmapText;\r\n"]},"metadata":{},"sourceType":"script"}