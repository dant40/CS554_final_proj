{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../../utils/Class');\n\nvar Events = require('../events');\n\nvar GetFastValue = require('../../../utils/object/GetFastValue');\n\nvar ProcessKeyCombo = require('./ProcessKeyCombo');\n\nvar ResetKeyCombo = require('./ResetKeyCombo');\n/**\r\n * @classdesc\r\n * A KeyCombo will listen for a specific string of keys from the Keyboard, and when it receives them\r\n * it will emit a `keycombomatch` event from the Keyboard Manager.\r\n *\r\n * The keys to be listened for can be defined as:\r\n *\r\n * A string (i.e. 'ATARI')\r\n * An array of either integers (key codes) or strings, or a mixture of both\r\n * An array of objects (such as Key objects) with a public 'keyCode' property\r\n *\r\n * For example, to listen for the Konami code (up, up, down, down, left, right, left, right, b, a, enter)\r\n * you could pass the following array of key codes:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });\r\n *\r\n * this.input.keyboard.on('keycombomatch', function (event) {\r\n *     console.log('Konami Code entered!');\r\n * });\r\n * ```\r\n *\r\n * Or, to listen for the user entering the word PHASER:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.createCombo('PHASER');\r\n * ```\r\n *\r\n * @class KeyCombo\r\n * @memberof Phaser.Input.Keyboard\r\n * @constructor\r\n * @listens Phaser.Input.Keyboard.Events#ANY_KEY_DOWN\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.KeyboardPlugin} keyboardPlugin - A reference to the Keyboard Plugin.\r\n * @param {(string|integer[]|object[])} keys - The keys that comprise this combo.\r\n * @param {Phaser.Types.Input.Keyboard.KeyComboConfig} [config] - A Key Combo configuration object.\r\n */\n\n\nvar KeyCombo = new Class({\n  initialize: function KeyCombo(keyboardPlugin, keys, config) {\n    if (config === undefined) {\n      config = {};\n    } //  Can't have a zero or single length combo (string or array based)\n\n\n    if (keys.length < 2) {\n      return false;\n    }\n    /**\r\n     * A reference to the Keyboard Manager\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#manager\r\n     * @type {Phaser.Input.Keyboard.KeyboardPlugin}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.manager = keyboardPlugin;\n    /**\r\n     * A flag that controls if this Key Combo is actively processing keys or not.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#enabled\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.enabled = true;\n    /**\r\n     * An array of the keycodes that comprise this combo.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#keyCodes\r\n     * @type {array}\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this.keyCodes = []; //  if 'keys' is a string we need to get the keycode of each character in it\n\n    for (var i = 0; i < keys.length; i++) {\n      var char = keys[i];\n\n      if (typeof char === 'string') {\n        this.keyCodes.push(char.toUpperCase().charCodeAt(0));\n      } else if (typeof char === 'number') {\n        this.keyCodes.push(char);\n      } else if (char.hasOwnProperty('keyCode')) {\n        this.keyCodes.push(char.keyCode);\n      }\n    }\n    /**\r\n     * The current keyCode the combo is waiting for.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#current\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.current = this.keyCodes[0];\n    /**\r\n     * The current index of the key being waited for in the 'keys' string.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#index\r\n     * @type {integer}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.index = 0;\n    /**\r\n     * The length of this combo (in keycodes)\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#size\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.size = this.keyCodes.length;\n    /**\r\n     * The time the previous key in the combo was matched.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#timeLastMatched\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.timeLastMatched = 0;\n    /**\r\n     * Has this Key Combo been matched yet?\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#matched\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.matched = false;\n    /**\r\n     * The time the entire combo was matched.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#timeMatched\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.timeMatched = 0;\n    /**\r\n     * If they press the wrong key do we reset the combo?\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#resetOnWrongKey\r\n     * @type {boolean}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.resetOnWrongKey = GetFastValue(config, 'resetOnWrongKey', true);\n    /**\r\n     * The max delay in ms between each key press. Above this the combo is reset. 0 means disabled.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#maxKeyDelay\r\n     * @type {integer}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.maxKeyDelay = GetFastValue(config, 'maxKeyDelay', 0);\n    /**\r\n     * If previously matched and they press the first key of the combo again, will it reset?\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#resetOnMatch\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.resetOnMatch = GetFastValue(config, 'resetOnMatch', false);\n    /**\r\n     * If the combo matches, will it delete itself?\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#deleteOnMatch\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.deleteOnMatch = GetFastValue(config, 'deleteOnMatch', false);\n\n    var _this = this;\n\n    var onKeyDownHandler = function (event) {\n      if (_this.matched || !_this.enabled) {\n        return;\n      }\n\n      var matched = ProcessKeyCombo(event, _this);\n\n      if (matched) {\n        _this.manager.emit(Events.COMBO_MATCH, _this, event);\n\n        if (_this.resetOnMatch) {\n          ResetKeyCombo(_this);\n        } else if (_this.deleteOnMatch) {\n          _this.destroy();\n        }\n      }\n    };\n    /**\r\n     * The internal Key Down handler.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#onKeyDown\r\n     * @private\r\n     * @type {KeyboardKeydownCallback}\r\n     * @fires Phaser.Input.Keyboard.Events#COMBO_MATCH\r\n     * @since 3.0.0\r\n     */\n\n\n    this.onKeyDown = onKeyDownHandler;\n    this.manager.on(Events.ANY_KEY_DOWN, this.onKeyDown);\n  },\n\n  /**\r\n   * How far complete is this combo? A value between 0 and 1.\r\n   *\r\n   * @name Phaser.Input.Keyboard.KeyCombo#progress\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  progress: {\n    get: function () {\n      return this.index / this.size;\n    }\n  },\n\n  /**\r\n   * Destroys this Key Combo and all of its references.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyCombo#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.enabled = false;\n    this.keyCodes = [];\n    this.manager.off(Events.ANY_KEY_DOWN, this.onKeyDown);\n    this.manager = null;\n  }\n});\nmodule.exports = KeyCombo;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/input/keyboard/combo/KeyCombo.js"],"names":["Class","require","Events","GetFastValue","ProcessKeyCombo","ResetKeyCombo","KeyCombo","initialize","keyboardPlugin","keys","config","undefined","length","manager","enabled","keyCodes","i","char","push","toUpperCase","charCodeAt","hasOwnProperty","keyCode","current","index","size","timeLastMatched","matched","timeMatched","resetOnWrongKey","maxKeyDelay","resetOnMatch","deleteOnMatch","_this","onKeyDownHandler","event","emit","COMBO_MATCH","destroy","onKeyDown","on","ANY_KEY_DOWN","progress","get","off","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Events = require('../events');\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar ProcessKeyCombo = require('./ProcessKeyCombo');\r\nvar ResetKeyCombo = require('./ResetKeyCombo');\r\n\r\n/**\r\n * @classdesc\r\n * A KeyCombo will listen for a specific string of keys from the Keyboard, and when it receives them\r\n * it will emit a `keycombomatch` event from the Keyboard Manager.\r\n *\r\n * The keys to be listened for can be defined as:\r\n *\r\n * A string (i.e. 'ATARI')\r\n * An array of either integers (key codes) or strings, or a mixture of both\r\n * An array of objects (such as Key objects) with a public 'keyCode' property\r\n *\r\n * For example, to listen for the Konami code (up, up, down, down, left, right, left, right, b, a, enter)\r\n * you could pass the following array of key codes:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });\r\n *\r\n * this.input.keyboard.on('keycombomatch', function (event) {\r\n *     console.log('Konami Code entered!');\r\n * });\r\n * ```\r\n *\r\n * Or, to listen for the user entering the word PHASER:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.createCombo('PHASER');\r\n * ```\r\n *\r\n * @class KeyCombo\r\n * @memberof Phaser.Input.Keyboard\r\n * @constructor\r\n * @listens Phaser.Input.Keyboard.Events#ANY_KEY_DOWN\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.KeyboardPlugin} keyboardPlugin - A reference to the Keyboard Plugin.\r\n * @param {(string|integer[]|object[])} keys - The keys that comprise this combo.\r\n * @param {Phaser.Types.Input.Keyboard.KeyComboConfig} [config] - A Key Combo configuration object.\r\n */\r\nvar KeyCombo = new Class({\r\n\r\n    initialize:\r\n\r\n    function KeyCombo (keyboardPlugin, keys, config)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        //  Can't have a zero or single length combo (string or array based)\r\n        if (keys.length < 2)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * A reference to the Keyboard Manager\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#manager\r\n         * @type {Phaser.Input.Keyboard.KeyboardPlugin}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = keyboardPlugin;\r\n\r\n        /**\r\n         * A flag that controls if this Key Combo is actively processing keys or not.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * An array of the keycodes that comprise this combo.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#keyCodes\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.keyCodes = [];\r\n\r\n        //  if 'keys' is a string we need to get the keycode of each character in it\r\n\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            var char = keys[i];\r\n\r\n            if (typeof char === 'string')\r\n            {\r\n                this.keyCodes.push(char.toUpperCase().charCodeAt(0));\r\n            }\r\n            else if (typeof char === 'number')\r\n            {\r\n                this.keyCodes.push(char);\r\n            }\r\n            else if (char.hasOwnProperty('keyCode'))\r\n            {\r\n                this.keyCodes.push(char.keyCode);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * The current keyCode the combo is waiting for.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#current\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.current = this.keyCodes[0];\r\n\r\n        /**\r\n         * The current index of the key being waited for in the 'keys' string.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#index\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.index = 0;\r\n\r\n        /**\r\n         * The length of this combo (in keycodes)\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#size\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.size = this.keyCodes.length;\r\n\r\n        /**\r\n         * The time the previous key in the combo was matched.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#timeLastMatched\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.timeLastMatched = 0;\r\n\r\n        /**\r\n         * Has this Key Combo been matched yet?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#matched\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.matched = false;\r\n\r\n        /**\r\n         * The time the entire combo was matched.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#timeMatched\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.timeMatched = 0;\r\n\r\n        /**\r\n         * If they press the wrong key do we reset the combo?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#resetOnWrongKey\r\n         * @type {boolean}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.resetOnWrongKey = GetFastValue(config, 'resetOnWrongKey', true);\r\n\r\n        /**\r\n         * The max delay in ms between each key press. Above this the combo is reset. 0 means disabled.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#maxKeyDelay\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.maxKeyDelay = GetFastValue(config, 'maxKeyDelay', 0);\r\n\r\n        /**\r\n         * If previously matched and they press the first key of the combo again, will it reset?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#resetOnMatch\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.resetOnMatch = GetFastValue(config, 'resetOnMatch', false);\r\n\r\n        /**\r\n         * If the combo matches, will it delete itself?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#deleteOnMatch\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.deleteOnMatch = GetFastValue(config, 'deleteOnMatch', false);\r\n\r\n        var _this = this;\r\n\r\n        var onKeyDownHandler = function (event)\r\n        {\r\n            if (_this.matched || !_this.enabled)\r\n            {\r\n                return;\r\n            }\r\n\r\n            var matched = ProcessKeyCombo(event, _this);\r\n\r\n            if (matched)\r\n            {\r\n                _this.manager.emit(Events.COMBO_MATCH, _this, event);\r\n\r\n                if (_this.resetOnMatch)\r\n                {\r\n                    ResetKeyCombo(_this);\r\n                }\r\n                else if (_this.deleteOnMatch)\r\n                {\r\n                    _this.destroy();\r\n                }\r\n            }\r\n        };\r\n\r\n        /**\r\n         * The internal Key Down handler.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#onKeyDown\r\n         * @private\r\n         * @type {KeyboardKeydownCallback}\r\n         * @fires Phaser.Input.Keyboard.Events#COMBO_MATCH\r\n         * @since 3.0.0\r\n         */\r\n        this.onKeyDown = onKeyDownHandler;\r\n\r\n        this.manager.on(Events.ANY_KEY_DOWN, this.onKeyDown);\r\n    },\r\n\r\n    /**\r\n     * How far complete is this combo? A value between 0 and 1.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#progress\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    progress: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.index / this.size;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Destroys this Key Combo and all of its references.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyCombo#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.enabled = false;\r\n        this.keyCodes = [];\r\n\r\n        this.manager.off(Events.ANY_KEY_DOWN, this.onKeyDown);\r\n\r\n        this.manager = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = KeyCombo;\r\n"]},"metadata":{},"sourceType":"script"}