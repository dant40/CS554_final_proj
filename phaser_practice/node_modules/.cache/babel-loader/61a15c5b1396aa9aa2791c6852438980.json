{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar BlendModes = require('../../renderer/BlendModes');\n\nvar Camera = require('../../cameras/2d/BaseCamera');\n\nvar CanvasPool = require('../../display/canvas/CanvasPool');\n\nvar Class = require('../../utils/Class');\n\nvar Components = require('../components');\n\nvar CONST = require('../../const');\n\nvar Frame = require('../../textures/Frame');\n\nvar GameObject = require('../GameObject');\n\nvar Render = require('./RenderTextureRender');\n\nvar Utils = require('../../renderer/webgl/Utils');\n\nvar UUID = require('../../utils/string/UUID');\n/**\r\n * @classdesc\r\n * A Render Texture.\r\n * \r\n * A Render Texture is a special texture that allows any number of Game Objects to be drawn to it. You can take many complex objects and\r\n * draw them all to this one texture, which can they be used as the texture for other Game Object's. It's a way to generate dynamic\r\n * textures at run-time that are WebGL friendly and don't invoke expensive GPU uploads.\r\n * \r\n * Note that under WebGL a FrameBuffer, which is what the Render Texture uses internally, cannot be anti-aliased. This means\r\n * that when drawing objects such as Shapes to a Render Texture they will appear to be drawn with no aliasing, however this\r\n * is a technical limitation of WebGL. To get around it, create your shape as a texture in an art package, then draw that\r\n * to the Render Texture.\r\n *\r\n * @class RenderTexture\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.2.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Crop\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {integer} [width=32] - The width of the Render Texture.\r\n * @param {integer} [height=32] - The height of the Render Texture.\r\n * @property {string} [key] - The texture key to make the RenderTexture from.\r\n * @property {string} [frame] - the frame to make the RenderTexture from.\r\n */\n\n\nvar RenderTexture = new Class({\n  Extends: GameObject,\n  Mixins: [Components.Alpha, Components.BlendMode, Components.ComputedSize, Components.Crop, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Tint, Components.Transform, Components.Visible, Render],\n  initialize: function RenderTexture(scene, x, y, width, height, key, frame) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = 32;\n    }\n\n    if (height === undefined) {\n      height = 32;\n    }\n\n    GameObject.call(this, scene, 'RenderTexture');\n    /**\r\n     * A reference to either the Canvas or WebGL Renderer that the Game instance is using.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#renderer\r\n     * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n     * @since 3.2.0\r\n     */\n\n    this.renderer = scene.sys.game.renderer;\n    /**\r\n     * A reference to the Texture Manager.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#textureManager\r\n     * @type {Phaser.Textures.TextureManager}\r\n     * @since 3.12.0\r\n     */\n\n    this.textureManager = scene.sys.textures;\n    /**\r\n     * The tint of the Render Texture when rendered.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#globalTint\r\n     * @type {number}\r\n     * @default 0xffffff\r\n     * @since 3.2.0\r\n     */\n\n    this.globalTint = 0xffffff;\n    /**\r\n     * The alpha of the Render Texture when rendered.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#globalAlpha\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.2.0\r\n     */\n\n    this.globalAlpha = 1;\n    /**\r\n     * The HTML Canvas Element that the Render Texture is drawing to when using the Canvas Renderer.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#canvas\r\n     * @type {HTMLCanvasElement}\r\n     * @since 3.2.0\r\n     */\n\n    this.canvas = null;\n    /**\r\n     * A reference to the GL Frame Buffer this Render Texture is drawing to.\r\n     * This is only set if Phaser is running with the WebGL Renderer.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#framebuffer\r\n     * @type {?WebGLFramebuffer}\r\n     * @since 3.2.0\r\n     */\n\n    this.framebuffer = null;\n    /**\r\n     * Is this Render Texture dirty or not? If not it won't spend time clearing or filling itself.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#dirty\r\n     * @type {boolean}\r\n     * @since 3.12.0\r\n     */\n\n    this.dirty = false;\n    /**\r\n     * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#_crop\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._crop = this.resetCropObject();\n    /**\r\n     * The Texture corresponding to this Render Texture.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#texture\r\n     * @type {Phaser.Textures.Texture}\r\n     * @since 3.12.0\r\n     */\n\n    this.texture = null;\n    /**\r\n     * The Frame corresponding to this Render Texture.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#frame\r\n     * @type {Phaser.Textures.Frame}\r\n     * @since 3.12.0\r\n     */\n\n    this.frame = null;\n    /**\r\n     * Internal saved texture flag.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#_saved\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._saved = false;\n\n    if (key === undefined) {\n      this.canvas = CanvasPool.create2D(this, width, height); //  Create a new Texture for this Text object\n\n      this.texture = scene.sys.textures.addCanvas(UUID(), this.canvas); //  Get the frame\n\n      this.frame = this.texture.get();\n    } else {\n      this.texture = scene.sys.textures.get(key); //  Get the frame\n\n      this.frame = this.texture.get(frame);\n      this.canvas = this.frame.source.image;\n      this._saved = true;\n      this.dirty = true;\n      this.width = this.frame.cutWidth;\n      this.height = this.frame.cutHeight;\n    }\n    /**\r\n     * A reference to the Rendering Context belonging to the Canvas Element this Render Texture is drawing to.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#context\r\n     * @type {CanvasRenderingContext2D}\r\n     * @since 3.2.0\r\n     */\n\n\n    this.context = this.canvas.getContext('2d');\n    /**\r\n     * Internal erase mode flag.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#_eraseMode\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this._eraseMode = false;\n    /**\r\n     * An internal Camera that can be used to move around the Render Texture.\r\n     * Control it just like you would any Scene Camera. The difference is that it only impacts the placement of what\r\n     * is drawn to the Render Texture. You can scroll, zoom and rotate this Camera.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#camera\r\n     * @type {Phaser.Cameras.Scene2D.BaseCamera}\r\n     * @since 3.12.0\r\n     */\n\n    this.camera = new Camera(0, 0, width, height);\n    /**\r\n     * A reference to the WebGL Rendering Context.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#gl\r\n     * @type {WebGLRenderingContext}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.gl = null;\n    /**\r\n     * A reference to the WebGLTexture that is being rendered to in a WebGL Context.\r\n     *\r\n     * @name Phaser.GameObjects.RenderTexture#glTexture\r\n     * @type {WebGLTexture}\r\n     * @default null\r\n     * @readonly\r\n     * @since 3.19.0\r\n     */\n\n    this.glTexture = null;\n    var renderer = this.renderer;\n\n    if (renderer.type === CONST.WEBGL) {\n      var gl = renderer.gl;\n      this.gl = gl;\n      this.glTexture = this.frame.source.glTexture;\n      this.drawGameObject = this.batchGameObjectWebGL;\n      this.framebuffer = renderer.createFramebuffer(width, height, this.glTexture, false);\n    } else if (renderer.type === CONST.CANVAS) {\n      this.drawGameObject = this.batchGameObjectCanvas;\n    }\n\n    this.camera.setScene(scene);\n    this.setPosition(x, y);\n\n    if (key === undefined) {\n      this.setSize(width, height);\n    }\n\n    this.setOrigin(0, 0);\n    this.initPipeline();\n  },\n\n  /**\r\n   * Sets the size of this Game Object.\r\n   * \r\n   * @method Phaser.GameObjects.RenderTexture#setSize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} width - The width of this Game Object.\r\n   * @param {number} height - The height of this Game Object.\r\n   * \r\n   * @return {this} This Game Object instance.\r\n   */\n  setSize: function (width, height) {\n    return this.resize(width, height);\n  },\n\n  /**\r\n   * Resizes the Render Texture to the new dimensions given.\r\n   * \r\n   * If Render Texture was created from specific frame, only the size of the frame will be changed. The size of the source\r\n   * texture will not change.\r\n   *\r\n   * If Render Texture was not created from specific frame, the following will happen:\r\n   * In WebGL it will destroy and then re-create the frame buffer being used by the Render Texture.\r\n   * In Canvas it will resize the underlying canvas element.\r\n   * Both approaches will erase everything currently drawn to the Render Texture.\r\n   *\r\n   * If the dimensions given are the same as those already being used, calling this method will do nothing.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#resize\r\n   * @since 3.10.0\r\n   *\r\n   * @param {number} width - The new width of the Render Texture.\r\n   * @param {number} [height=width] - The new height of the Render Texture. If not specified, will be set the same as the `width`.\r\n   *\r\n   * @return {this} This Render Texture.\r\n   */\n  resize: function (width, height) {\n    if (height === undefined) {\n      height = width;\n    }\n\n    if (width !== this.width || height !== this.height) {\n      if (this.frame.name === '__BASE') {\n        //  Resize the texture\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.texture.width = width;\n        this.texture.height = height;\n\n        if (this.gl) {\n          var gl = this.gl;\n          this.renderer.deleteTexture(this.frame.source.glTexture);\n          this.renderer.deleteFramebuffer(this.framebuffer);\n          var glTexture = this.renderer.createTexture2D(0, gl.NEAREST, gl.NEAREST, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.RGBA, null, width, height, false);\n          this.framebuffer = this.renderer.createFramebuffer(width, height, glTexture, false);\n          this.frame.source.isRenderTexture = true;\n          this.frame.glTexture = glTexture;\n          this.glTexture = glTexture;\n        }\n\n        this.frame.source.width = width;\n        this.frame.source.height = height;\n        this.camera.setSize(width, height);\n        this.frame.setSize(width, height);\n        this.width = width;\n        this.height = height;\n      }\n    } else {\n      //  Resize the frame\n      var baseFrame = this.texture.getSourceImage();\n\n      if (this.frame.cutX + width > baseFrame.width) {\n        width = baseFrame.width - this.frame.cutX;\n      }\n\n      if (this.frame.cutY + height > baseFrame.height) {\n        height = baseFrame.height - this.frame.cutY;\n      }\n\n      this.frame.setSize(width, height, this.frame.cutX, this.frame.cutY);\n    }\n\n    this.updateDisplayOrigin();\n    var input = this.input;\n\n    if (input && !input.customHitArea) {\n      input.hitArea.width = width;\n      input.hitArea.height = height;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Set the tint to use when rendering this Render Texture.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#setGlobalTint\r\n   * @since 3.2.0\r\n   *\r\n   * @param {integer} tint - The tint value.\r\n   *\r\n   * @return {this} This Render Texture.\r\n   */\n  setGlobalTint: function (tint) {\n    this.globalTint = tint;\n    return this;\n  },\n\n  /**\r\n   * Set the alpha to use when rendering this Render Texture.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#setGlobalAlpha\r\n   * @since 3.2.0\r\n   *\r\n   * @param {number} alpha - The alpha value.\r\n   *\r\n   * @return {this} This Render Texture.\r\n   */\n  setGlobalAlpha: function (alpha) {\n    this.globalAlpha = alpha;\n    return this;\n  },\n\n  /**\r\n   * Stores a copy of this Render Texture in the Texture Manager using the given key.\r\n   * \r\n   * After doing this, any texture based Game Object, such as a Sprite, can use the contents of this\r\n   * Render Texture by using the texture key:\r\n   * \r\n   * ```javascript\r\n   * var rt = this.add.renderTexture(0, 0, 128, 128);\r\n   * \r\n   * // Draw something to the Render Texture\r\n   * \r\n   * rt.saveTexture('doodle');\r\n   * \r\n   * this.add.image(400, 300, 'doodle');\r\n   * ```\r\n   * \r\n   * Updating the contents of this Render Texture will automatically update _any_ Game Object\r\n   * that is using it as a texture. Calling `saveTexture` again will not save another copy\r\n   * of the same texture, it will just rename the key of the existing copy.\r\n   * \r\n   * By default it will create a single base texture. You can add frames to the texture\r\n   * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n   * to use a specific frame from a Render Texture.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#saveTexture\r\n   * @since 3.12.0\r\n   *\r\n   * @param {string} key - The unique key to store the texture as within the global Texture Manager.\r\n   *\r\n   * @return {Phaser.Textures.Texture} The Texture that was saved.\r\n   */\n  saveTexture: function (key) {\n    this.textureManager.renameTexture(this.texture.key, key);\n    this._saved = true;\n    return this.texture;\n  },\n\n  /**\r\n   * Fills the Render Texture with the given color.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#fill\r\n   * @since 3.2.0\r\n   *\r\n   * @param {number} rgb - The color to fill the Render Texture with.\r\n   * @param {number} [alpha=1] - The alpha value used by the fill.\r\n   * @param {number} [x=0] - The left coordinate of the fill rectangle.\r\n   * @param {number} [y=0] - The top coordinate of the fill rectangle.\r\n   * @param {number} [width=this.frame.cutWidth] - The width of the fill rectangle.\r\n   * @param {number} [height=this.frame.cutHeight] - The height of the fill rectangle.\r\n   *\r\n   * @return {this} This Render Texture instance.\r\n   */\n  fill: function (rgb, alpha, x, y, width, height) {\n    if (alpha === undefined) {\n      alpha = 1;\n    }\n\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = this.frame.cutWidth;\n    }\n\n    if (height === undefined) {\n      height = this.frame.cutHeight;\n    }\n\n    var r = (rgb >> 16 | 0) & 0xff;\n    var g = (rgb >> 8 | 0) & 0xff;\n    var b = (rgb | 0) & 0xff;\n    var gl = this.gl;\n    var frame = this.frame;\n    this.camera.preRender(1, 1);\n\n    if (gl) {\n      var cx = this.camera._cx;\n      var cy = this.camera._cy;\n      var cw = this.camera._cw;\n      var ch = this.camera._ch;\n      this.renderer.setFramebuffer(this.framebuffer, false);\n      this.renderer.pushScissor(cx, cy, cw, ch, ch);\n      var pipeline = this.pipeline;\n      pipeline.projOrtho(0, this.texture.width, 0, this.texture.height, -1000.0, 1000.0);\n      pipeline.drawFillRect(x, y, width, height, Utils.getTintFromFloats(r / 255, g / 255, b / 255, 1), alpha);\n      this.renderer.setFramebuffer(null, false);\n      this.renderer.popScissor();\n      pipeline.projOrtho(0, pipeline.width, pipeline.height, 0, -1000.0, 1000.0);\n    } else {\n      this.renderer.setContext(this.context);\n      this.context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';\n      this.context.fillRect(x + frame.cutX, y + frame.cutY, width, height);\n      this.renderer.setContext();\n    }\n\n    this.dirty = true;\n    return this;\n  },\n\n  /**\r\n   * Clears the Render Texture.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#clear\r\n   * @since 3.2.0\r\n   *\r\n   * @return {this} This Render Texture instance.\r\n   */\n  clear: function () {\n    if (this.dirty) {\n      var gl = this.gl;\n\n      if (gl) {\n        var renderer = this.renderer;\n        renderer.setFramebuffer(this.framebuffer, true);\n\n        if (this.frame.cutWidth !== this.canvas.width || this.frame.cutHeight !== this.canvas.height) {\n          gl.scissor(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight);\n        }\n\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        renderer.setFramebuffer(null, true);\n      } else {\n        var ctx = this.context;\n        ctx.save();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight);\n        ctx.restore();\n      }\n\n      this.dirty = false;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Draws the given object, or an array of objects, to this Render Texture using a blend mode of ERASE.\r\n   * This has the effect of erasing any filled pixels in the objects from this Render Texture.\r\n   * \r\n   * It can accept any of the following:\r\n   * \r\n   * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.\r\n   * * Dynamic and Static Tilemap Layers.\r\n   * * A Group. The contents of which will be iterated and drawn in turn.\r\n   * * A Container. The contents of which will be iterated fully, and drawn in turn.\r\n   * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.\r\n   * * Another Render Texture.\r\n   * * A Texture Frame instance.\r\n   * * A string. This is used to look-up a texture from the Texture Manager.\r\n   * \r\n   * Note: You cannot erase a Render Texture from itself.\r\n   * \r\n   * If passing in a Group or Container it will only draw children that return `true`\r\n   * when their `willRender()` method is called. I.e. a Container with 10 children,\r\n   * 5 of which have `visible=false` will only draw the 5 visible ones.\r\n   * \r\n   * If passing in an array of Game Objects it will draw them all, regardless if\r\n   * they pass a `willRender` check or not.\r\n   * \r\n   * You can pass in a string in which case it will look for a texture in the Texture\r\n   * Manager matching that string, and draw the base frame.\r\n   * \r\n   * You can pass in the `x` and `y` coordinates to draw the objects at. The use of\r\n   * the coordinates differ based on what objects are being drawn. If the object is\r\n   * a Group, Container or Display List, the coordinates are _added_ to the positions\r\n   * of the children. For all other types of object, the coordinates are exact.\r\n   * \r\n   * Calling this method causes the WebGL batch to flush, so it can write the texture\r\n   * data to the framebuffer being used internally. The batch is flushed at the end,\r\n   * after the entries have been iterated. So if you've a bunch of objects to draw,\r\n   * try and pass them in an array in one single call, rather than making lots of\r\n   * separate calls.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#erase\r\n   * @since 3.16.0\r\n   *\r\n   * @param {any} entries - Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.\r\n   * @param {number} [x] - The x position to draw the Frame at, or the offset applied to the object.\r\n   * @param {number} [y] - The y position to draw the Frame at, or the offset applied to the object.\r\n   *\r\n   * @return {this} This Render Texture instance.\r\n   */\n  erase: function (entries, x, y) {\n    this._eraseMode = true;\n    var blendMode = this.renderer.currentBlendMode;\n    this.renderer.setBlendMode(BlendModes.ERASE);\n    this.draw(entries, x, y, 1, 16777215);\n    this.renderer.setBlendMode(blendMode);\n    this._eraseMode = false;\n    return this;\n  },\n\n  /**\r\n   * Draws the given object, or an array of objects, to this Render Texture.\r\n   * \r\n   * It can accept any of the following:\r\n   * \r\n   * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.\r\n   * * Dynamic and Static Tilemap Layers.\r\n   * * A Group. The contents of which will be iterated and drawn in turn.\r\n   * * A Container. The contents of which will be iterated fully, and drawn in turn.\r\n   * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.\r\n   * * Another Render Texture.\r\n   * * A Texture Frame instance.\r\n   * * A string. This is used to look-up a texture from the Texture Manager.\r\n   * \r\n   * Note: You cannot draw a Render Texture to itself.\r\n   * \r\n   * If passing in a Group or Container it will only draw children that return `true`\r\n   * when their `willRender()` method is called. I.e. a Container with 10 children,\r\n   * 5 of which have `visible=false` will only draw the 5 visible ones.\r\n   * \r\n   * If passing in an array of Game Objects it will draw them all, regardless if\r\n   * they pass a `willRender` check or not.\r\n   * \r\n   * You can pass in a string in which case it will look for a texture in the Texture\r\n   * Manager matching that string, and draw the base frame. If you need to specify\r\n   * exactly which frame to draw then use the method `drawFrame` instead.\r\n   * \r\n   * You can pass in the `x` and `y` coordinates to draw the objects at. The use of\r\n   * the coordinates differ based on what objects are being drawn. If the object is\r\n   * a Group, Container or Display List, the coordinates are _added_ to the positions\r\n   * of the children. For all other types of object, the coordinates are exact.\r\n   * \r\n   * The `alpha` and `tint` values are only used by Texture Frames.\r\n   * Game Objects use their own alpha and tint values when being drawn.\r\n   * \r\n   * Calling this method causes the WebGL batch to flush, so it can write the texture\r\n   * data to the framebuffer being used internally. The batch is flushed at the end,\r\n   * after the entries have been iterated. So if you've a bunch of objects to draw,\r\n   * try and pass them in an array in one single call, rather than making lots of\r\n   * separate calls.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#draw\r\n   * @since 3.2.0\r\n   *\r\n   * @param {any} entries - Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.\r\n   * @param {number} [x] - The x position to draw the Frame at, or the offset applied to the object.\r\n   * @param {number} [y] - The y position to draw the Frame at, or the offset applied to the object.\r\n   * @param {number} [alpha] -  The alpha value. Only used for Texture Frames and if not specified defaults to the `globalAlpha` property. Game Objects use their own current alpha value.\r\n   * @param {number} [tint] -  WebGL only. The tint color value. Only used for Texture Frames and if not specified defaults to the `globalTint` property. Game Objects use their own current tint value.\r\n   *\r\n   * @return {this} This Render Texture instance.\r\n   */\n  draw: function (entries, x, y, alpha, tint) {\n    if (alpha === undefined) {\n      alpha = this.globalAlpha;\n    }\n\n    if (tint === undefined) {\n      tint = (this.globalTint >> 16) + (this.globalTint & 0xff00) + ((this.globalTint & 0xff) << 16);\n    } else {\n      tint = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16);\n    }\n\n    if (!Array.isArray(entries)) {\n      entries = [entries];\n    }\n\n    var gl = this.gl;\n    this.camera.preRender(1, 1);\n\n    if (gl) {\n      var cx = this.camera._cx;\n      var cy = this.camera._cy;\n      var cw = this.camera._cw;\n      var ch = this.camera._ch;\n      this.renderer.setFramebuffer(this.framebuffer, false);\n      this.renderer.pushScissor(cx, cy, cw, ch, ch);\n      var pipeline = this.pipeline;\n      pipeline.projOrtho(0, this.texture.width, 0, this.texture.height, -1000.0, 1000.0);\n      this.batchList(entries, x, y, alpha, tint);\n      pipeline.flush();\n      this.renderer.setFramebuffer(null, false);\n      this.renderer.popScissor();\n      pipeline.projOrtho(0, pipeline.width, pipeline.height, 0, -1000.0, 1000.0);\n    } else {\n      this.renderer.setContext(this.context);\n      this.batchList(entries, x, y, alpha, tint);\n      this.renderer.setContext();\n    }\n\n    this.dirty = true;\n    return this;\n  },\n\n  /**\r\n   * Draws the Texture Frame to the Render Texture at the given position.\r\n   * \r\n   * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n   * \r\n   * ```javascript\r\n   * var rt = this.add.renderTexture(0, 0, 800, 600);\r\n   * rt.drawFrame(key, frame);\r\n   * ```\r\n   * \r\n   * You can optionally provide a position, alpha and tint value to apply to the frame\r\n   * before it is drawn.\r\n   * \r\n   * Calling this method will cause a batch flush, so if you've got a stack of things to draw\r\n   * in a tight loop, try using the `draw` method instead.\r\n   * \r\n   * If you need to draw a Sprite to this Render Texture, use the `draw` method instead.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#drawFrame\r\n   * @since 3.12.0\r\n   *\r\n   * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n   * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.\r\n   * @param {number} [x=0] - The x position to draw the frame at.\r\n   * @param {number} [y=0] - The y position to draw the frame at.\r\n   * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n   * @param {number} [tint] - WebGL only. The tint color to use. If not specified it uses the `globalTint` property.\r\n   *\r\n   * @return {this} This Render Texture instance.\r\n   */\n  drawFrame: function (key, frame, x, y, alpha, tint) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (alpha === undefined) {\n      alpha = this.globalAlpha;\n    }\n\n    if (tint === undefined) {\n      tint = (this.globalTint >> 16) + (this.globalTint & 0xff00) + ((this.globalTint & 0xff) << 16);\n    } else {\n      tint = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16);\n    }\n\n    var gl = this.gl;\n    var textureFrame = this.textureManager.getFrame(key, frame);\n\n    if (textureFrame) {\n      this.camera.preRender(1, 1);\n\n      if (gl) {\n        var cx = this.camera._cx;\n        var cy = this.camera._cy;\n        var cw = this.camera._cw;\n        var ch = this.camera._ch;\n        this.renderer.setFramebuffer(this.framebuffer, false);\n        this.renderer.pushScissor(cx, cy, cw, ch, ch);\n        var pipeline = this.pipeline;\n        pipeline.projOrtho(0, this.texture.width, 0, this.texture.height, -1000.0, 1000.0);\n        pipeline.batchTextureFrame(textureFrame, x + this.frame.cutX, y + this.frame.cutY, tint, alpha, this.camera.matrix, null);\n        pipeline.flush();\n        this.renderer.setFramebuffer(null, false);\n        this.renderer.popScissor();\n        pipeline.projOrtho(0, pipeline.width, pipeline.height, 0, -1000.0, 1000.0);\n      } else {\n        this.batchTextureFrame(textureFrame, x + this.frame.cutX, y + this.frame.cutY, alpha, tint);\n      }\n\n      this.dirty = true;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Internal method that handles the drawing of an array of children.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#batchList\r\n   * @private\r\n   * @since 3.12.0\r\n   *\r\n   * @param {array} children - The array of Game Objects to draw.\r\n   * @param {number} [x] - The x position to offset the Game Object by.\r\n   * @param {number} [y] - The y position to offset the Game Object by.\r\n   * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n   * @param {number} [tint] - The tint color to use. If not specified it uses the `globalTint` property.\r\n   */\n  batchList: function (children, x, y, alpha, tint) {\n    for (var i = 0; i < children.length; i++) {\n      var entry = children[i];\n\n      if (!entry || entry === this) {\n        continue;\n      }\n\n      if (entry.renderWebGL || entry.renderCanvas) {\n        //  Game Objects\n        this.drawGameObject(entry, x, y);\n      } else if (entry.isParent || entry.list) {\n        //  Groups / Display Lists\n        this.batchGroup(entry.getChildren(), x, y);\n      } else if (typeof entry === 'string') {\n        //  Texture key\n        this.batchTextureFrameKey(entry, null, x, y, alpha, tint);\n      } else if (entry instanceof Frame) {\n        //  Texture Frame instance\n        this.batchTextureFrame(entry, x, y, alpha, tint);\n      } else if (Array.isArray(entry)) {\n        //  Another Array\n        this.batchList(entry, x, y, alpha, tint);\n      }\n    }\n  },\n\n  /**\r\n   * Internal method that handles the drawing a Phaser Group contents.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#batchGroup\r\n   * @private\r\n   * @since 3.12.0\r\n   *\r\n   * @param {array} children - The array of Game Objects to draw.\r\n   * @param {number} [x=0] - The x position to offset the Game Object by.\r\n   * @param {number} [y=0] - The y position to offset the Game Object by.\r\n   */\n  batchGroup: function (children, x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    x += this.frame.cutX;\n    y += this.frame.cutY;\n\n    for (var i = 0; i < children.length; i++) {\n      var entry = children[i];\n\n      if (entry.willRender()) {\n        var tx = entry.x + x;\n        var ty = entry.y + y;\n        this.drawGameObject(entry, tx, ty);\n      }\n    }\n  },\n\n  /**\r\n   * Internal method that handles drawing a single Phaser Game Object to this Render Texture using WebGL.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#batchGameObjectWebGL\r\n   * @private\r\n   * @since 3.12.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to draw.\r\n   * @param {number} [x] - The x position to draw the Game Object at.\r\n   * @param {number} [y] - The y position to draw the Game Object at.\r\n   */\n  batchGameObjectWebGL: function (gameObject, x, y) {\n    if (x === undefined) {\n      x = gameObject.x;\n    }\n\n    if (y === undefined) {\n      y = gameObject.y;\n    }\n\n    var prevX = gameObject.x;\n    var prevY = gameObject.y;\n\n    if (!this._eraseMode) {\n      this.renderer.setBlendMode(gameObject.blendMode);\n    }\n\n    gameObject.setPosition(x + this.frame.cutX, y + this.frame.cutY);\n    gameObject.renderWebGL(this.renderer, gameObject, 0, this.camera, null);\n    gameObject.setPosition(prevX, prevY);\n  },\n\n  /**\r\n   * Internal method that handles drawing a single Phaser Game Object to this Render Texture using Canvas.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#batchGameObjectCanvas\r\n   * @private\r\n   * @since 3.12.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to draw.\r\n   * @param {number} [x] - The x position to draw the Game Object at.\r\n   * @param {number} [y] - The y position to draw the Game Object at.\r\n   */\n  batchGameObjectCanvas: function (gameObject, x, y) {\n    if (x === undefined) {\n      x = gameObject.x;\n    }\n\n    if (y === undefined) {\n      y = gameObject.y;\n    }\n\n    var prevX = gameObject.x;\n    var prevY = gameObject.y;\n\n    if (this._eraseMode) {\n      var blendMode = gameObject.blendMode;\n      gameObject.blendMode = BlendModes.ERASE;\n    }\n\n    gameObject.setPosition(x + this.frame.cutX, y + this.frame.cutY);\n    gameObject.renderCanvas(this.renderer, gameObject, 0, this.camera, null);\n    gameObject.setPosition(prevX, prevY);\n\n    if (this._eraseMode) {\n      gameObject.blendMode = blendMode;\n    }\n  },\n\n  /**\r\n   * Internal method that handles the drawing of an array of children.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#batchTextureFrameKey\r\n   * @private\r\n   * @since 3.12.0\r\n   *\r\n   * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n   * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.\r\n   * @param {number} [x=0] - The x position to offset the Game Object by.\r\n   * @param {number} [y=0] - The y position to offset the Game Object by.\r\n   * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n   * @param {number} [tint] - The tint color to use. If not specified it uses the `globalTint` property.\r\n   */\n  batchTextureFrameKey: function (key, frame, x, y, alpha, tint) {\n    var textureFrame = this.textureManager.getFrame(key, frame);\n\n    if (textureFrame) {\n      this.batchTextureFrame(textureFrame, x, y, alpha, tint);\n    }\n  },\n\n  /**\r\n   * Internal method that handles the drawing of a Texture Frame to this Render Texture.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#batchTextureFrame\r\n   * @private\r\n   * @since 3.12.0\r\n   *\r\n   * @param {Phaser.Textures.Frame} textureFrame - The Texture Frame to draw.\r\n   * @param {number} [x=0] - The x position to draw the Frame at.\r\n   * @param {number} [y=0] - The y position to draw the Frame at.\r\n   * @param {number} [tint] - A tint color to be applied to the frame drawn to the Render Texture.\r\n   */\n  batchTextureFrame: function (textureFrame, x, y, alpha, tint) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    x += this.frame.cutX;\n    y += this.frame.cutY;\n\n    if (this.gl) {\n      this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);\n    } else {\n      var ctx = this.context;\n      var cd = textureFrame.canvasData;\n      var source = textureFrame.source.image;\n      var matrix = this.camera.matrix;\n      ctx.globalAlpha = this.globalAlpha;\n      ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n      ctx.drawImage(source, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);\n    }\n  },\n\n  /**\r\n   * Takes a snapshot of the given area of this Render Texture.\r\n   * \r\n   * The snapshot is taken immediately.\r\n   * \r\n   * To capture the whole Render Texture see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.\r\n   * \r\n   * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n   * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n   * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n   * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#snapshotArea\r\n   * @since 3.19.0\r\n   *\r\n   * @param {integer} x - The x coordinate to grab from.\r\n   * @param {integer} y - The y coordinate to grab from.\r\n   * @param {integer} width - The width of the area to grab.\r\n   * @param {integer} height - The height of the area to grab.\r\n   * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n   * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n   * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n   *\r\n   * @return {this} This Render Texture instance.\r\n   */\n  snapshotArea: function (x, y, width, height, callback, type, encoderOptions) {\n    if (this.gl) {\n      this.renderer.snapshotFramebuffer(this.framebuffer, this.width, this.height, callback, false, x, y, width, height, type, encoderOptions);\n    } else {\n      this.renderer.snapshotCanvas(this.canvas, callback, false, x, y, width, height, type, encoderOptions);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Takes a snapshot of the whole of this Render Texture.\r\n   * \r\n   * The snapshot is taken immediately.\r\n   * \r\n   * To capture just a portion of the Render Texture see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.\r\n   * \r\n   * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n   * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n   * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n   * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#snapshot\r\n   * @since 3.19.0\r\n   *\r\n   * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n   * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n   * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n   *\r\n   * @return {this} This Render Texture instance.\r\n   */\n  snapshot: function (callback, type, encoderOptions) {\n    if (this.gl) {\n      this.renderer.snapshotFramebuffer(this.framebuffer, this.width, this.height, callback, false, 0, 0, this.width, this.height, type, encoderOptions);\n    } else {\n      this.renderer.snapshotCanvas(this.canvas, callback, false, 0, 0, this.width, this.height, type, encoderOptions);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Takes a snapshot of the given pixel from this Render Texture.\r\n   * \r\n   * The snapshot is taken immediately.\r\n   * \r\n   * To capture the whole Render Texture see the `snapshot` method. To capture a specific portion, see `snapshotArea`.\r\n   * \r\n   * Unlike the other two snapshot methods, this one will send your callback a `Color` object containing the color data for\r\n   * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,\r\n   * using less memory, than the other snapshot methods.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#snapshotPixel\r\n   * @since 3.19.0\r\n   *\r\n   * @param {integer} x - The x coordinate of the pixel to get.\r\n   * @param {integer} y - The y coordinate of the pixel to get.\r\n   * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.\r\n   *\r\n   * @return {this} This Render Texture instance.\r\n   */\n  snapshotPixel: function (x, y, callback) {\n    if (this.gl) {\n      this.renderer.snapshotFramebuffer(this.framebuffer, this.width, this.height, callback, true, x, y);\n    } else {\n      this.renderer.snapshotCanvas(this.canvas, callback, true, x, y);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Internal destroy handler, called as part of the destroy process.\r\n   *\r\n   * @method Phaser.GameObjects.RenderTexture#preDestroy\r\n   * @protected\r\n   * @since 3.9.0\r\n   */\n  preDestroy: function () {\n    if (!this._saved) {\n      CanvasPool.remove(this.canvas);\n\n      if (this.gl) {\n        this.renderer.deleteFramebuffer(this.framebuffer);\n      }\n\n      this.texture.destroy();\n      this.camera.destroy();\n      this.canvas = null;\n      this.context = null;\n      this.framebuffer = null;\n      this.texture = null;\n      this.glTexture = null;\n    }\n  }\n});\nmodule.exports = RenderTexture;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/rendertexture/RenderTexture.js"],"names":["BlendModes","require","Camera","CanvasPool","Class","Components","CONST","Frame","GameObject","Render","Utils","UUID","RenderTexture","Extends","Mixins","Alpha","BlendMode","ComputedSize","Crop","Depth","Flip","GetBounds","Mask","Origin","Pipeline","ScrollFactor","Tint","Transform","Visible","initialize","scene","x","y","width","height","key","frame","undefined","call","renderer","sys","game","textureManager","textures","globalTint","globalAlpha","canvas","framebuffer","dirty","_crop","resetCropObject","texture","_saved","create2D","addCanvas","get","source","image","cutWidth","cutHeight","context","getContext","_eraseMode","camera","gl","glTexture","type","WEBGL","drawGameObject","batchGameObjectWebGL","createFramebuffer","CANVAS","batchGameObjectCanvas","setScene","setPosition","setSize","setOrigin","initPipeline","resize","name","deleteTexture","deleteFramebuffer","createTexture2D","NEAREST","CLAMP_TO_EDGE","RGBA","isRenderTexture","baseFrame","getSourceImage","cutX","cutY","updateDisplayOrigin","input","customHitArea","hitArea","setGlobalTint","tint","setGlobalAlpha","alpha","saveTexture","renameTexture","fill","rgb","r","g","b","preRender","cx","_cx","cy","_cy","cw","_cw","ch","_ch","setFramebuffer","pushScissor","pipeline","projOrtho","drawFillRect","getTintFromFloats","popScissor","setContext","fillStyle","fillRect","clear","scissor","clearColor","COLOR_BUFFER_BIT","ctx","save","setTransform","clearRect","restore","erase","entries","blendMode","currentBlendMode","setBlendMode","ERASE","draw","Array","isArray","batchList","flush","drawFrame","textureFrame","getFrame","batchTextureFrame","matrix","children","i","length","entry","renderWebGL","renderCanvas","isParent","list","batchGroup","getChildren","batchTextureFrameKey","willRender","tx","ty","gameObject","prevX","prevY","cd","canvasData","drawImage","snapshotArea","callback","encoderOptions","snapshotFramebuffer","snapshotCanvas","snapshot","snapshotPixel","preDestroy","remove","destroy","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BlendModes = require('../../renderer/BlendModes');\r\nvar Camera = require('../../cameras/2d/BaseCamera');\r\nvar CanvasPool = require('../../display/canvas/CanvasPool');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar CONST = require('../../const');\r\nvar Frame = require('../../textures/Frame');\r\nvar GameObject = require('../GameObject');\r\nvar Render = require('./RenderTextureRender');\r\nvar Utils = require('../../renderer/webgl/Utils');\r\nvar UUID = require('../../utils/string/UUID');\r\n\r\n/**\r\n * @classdesc\r\n * A Render Texture.\r\n * \r\n * A Render Texture is a special texture that allows any number of Game Objects to be drawn to it. You can take many complex objects and\r\n * draw them all to this one texture, which can they be used as the texture for other Game Object's. It's a way to generate dynamic\r\n * textures at run-time that are WebGL friendly and don't invoke expensive GPU uploads.\r\n * \r\n * Note that under WebGL a FrameBuffer, which is what the Render Texture uses internally, cannot be anti-aliased. This means\r\n * that when drawing objects such as Shapes to a Render Texture they will appear to be drawn with no aliasing, however this\r\n * is a technical limitation of WebGL. To get around it, create your shape as a texture in an art package, then draw that\r\n * to the Render Texture.\r\n *\r\n * @class RenderTexture\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.2.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Crop\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {integer} [width=32] - The width of the Render Texture.\r\n * @param {integer} [height=32] - The height of the Render Texture.\r\n * @property {string} [key] - The texture key to make the RenderTexture from.\r\n * @property {string} [frame] - the frame to make the RenderTexture from.\r\n */\r\nvar RenderTexture = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.ComputedSize,\r\n        Components.Crop,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function RenderTexture (scene, x, y, width, height, key, frame)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = 32; }\r\n        if (height === undefined) { height = 32; }\r\n\r\n        GameObject.call(this, scene, 'RenderTexture');\r\n\r\n        /**\r\n         * A reference to either the Canvas or WebGL Renderer that the Game instance is using.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.2.0\r\n         */\r\n        this.renderer = scene.sys.game.renderer;\r\n\r\n        /**\r\n         * A reference to the Texture Manager.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#textureManager\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @since 3.12.0\r\n         */\r\n        this.textureManager = scene.sys.textures;\r\n\r\n        /**\r\n         * The tint of the Render Texture when rendered.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#globalTint\r\n         * @type {number}\r\n         * @default 0xffffff\r\n         * @since 3.2.0\r\n         */\r\n        this.globalTint = 0xffffff;\r\n\r\n        /**\r\n         * The alpha of the Render Texture when rendered.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#globalAlpha\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.2.0\r\n         */\r\n        this.globalAlpha = 1;\r\n\r\n        /**\r\n         * The HTML Canvas Element that the Render Texture is drawing to when using the Canvas Renderer.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.2.0\r\n         */\r\n        this.canvas = null;\r\n\r\n        /**\r\n         * A reference to the GL Frame Buffer this Render Texture is drawing to.\r\n         * This is only set if Phaser is running with the WebGL Renderer.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#framebuffer\r\n         * @type {?WebGLFramebuffer}\r\n         * @since 3.2.0\r\n         */\r\n        this.framebuffer = null;\r\n\r\n        /**\r\n         * Is this Render Texture dirty or not? If not it won't spend time clearing or filling itself.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#dirty\r\n         * @type {boolean}\r\n         * @since 3.12.0\r\n         */\r\n        this.dirty = false;\r\n\r\n        /**\r\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#_crop\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._crop = this.resetCropObject();\r\n\r\n        /**\r\n         * The Texture corresponding to this Render Texture.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#texture\r\n         * @type {Phaser.Textures.Texture}\r\n         * @since 3.12.0\r\n         */\r\n        this.texture = null;\r\n\r\n        /**\r\n         * The Frame corresponding to this Render Texture.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @since 3.12.0\r\n         */\r\n        this.frame = null;\r\n\r\n        /**\r\n         * Internal saved texture flag.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#_saved\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._saved = false;\r\n\r\n        if (key === undefined)\r\n        {\r\n            this.canvas = CanvasPool.create2D(this, width, height);\r\n\r\n            //  Create a new Texture for this Text object\r\n            this.texture = scene.sys.textures.addCanvas(UUID(), this.canvas);\r\n            \r\n            //  Get the frame\r\n            this.frame = this.texture.get();\r\n        }\r\n        else\r\n        {\r\n            this.texture = scene.sys.textures.get(key);\r\n            \r\n            //  Get the frame\r\n            this.frame = this.texture.get(frame);\r\n\r\n            this.canvas = this.frame.source.image;\r\n            this._saved = true;\r\n\r\n            this.dirty = true;\r\n\r\n            this.width = this.frame.cutWidth;\r\n            this.height = this.frame.cutHeight;\r\n        }\r\n\r\n        /**\r\n         * A reference to the Rendering Context belonging to the Canvas Element this Render Texture is drawing to.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#context\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.2.0\r\n         */\r\n        this.context = this.canvas.getContext('2d');\r\n\r\n        /**\r\n         * Internal erase mode flag.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#_eraseMode\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._eraseMode = false;\r\n\r\n        /**\r\n         * An internal Camera that can be used to move around the Render Texture.\r\n         * Control it just like you would any Scene Camera. The difference is that it only impacts the placement of what\r\n         * is drawn to the Render Texture. You can scroll, zoom and rotate this Camera.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#camera\r\n         * @type {Phaser.Cameras.Scene2D.BaseCamera}\r\n         * @since 3.12.0\r\n         */\r\n        this.camera = new Camera(0, 0, width, height);\r\n\r\n        /**\r\n         * A reference to the WebGL Rendering Context.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#gl\r\n         * @type {WebGLRenderingContext}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.gl = null;\r\n\r\n        /**\r\n         * A reference to the WebGLTexture that is being rendered to in a WebGL Context.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#glTexture\r\n         * @type {WebGLTexture}\r\n         * @default null\r\n         * @readonly\r\n         * @since 3.19.0\r\n         */\r\n        this.glTexture = null;\r\n\r\n        var renderer = this.renderer;\r\n\r\n        if (renderer.type === CONST.WEBGL)\r\n        {\r\n            var gl = renderer.gl;\r\n\r\n            this.gl = gl;\r\n            this.glTexture = this.frame.source.glTexture;\r\n            this.drawGameObject = this.batchGameObjectWebGL;\r\n            this.framebuffer = renderer.createFramebuffer(width, height, this.glTexture, false);\r\n        }\r\n        else if (renderer.type === CONST.CANVAS)\r\n        {\r\n            this.drawGameObject = this.batchGameObjectCanvas;\r\n        }\r\n\r\n        this.camera.setScene(scene);\r\n\r\n        this.setPosition(x, y);\r\n\r\n        if (key === undefined)\r\n        {\r\n            this.setSize(width, height);\r\n        }\r\n\r\n        this.setOrigin(0, 0);\r\n        this.initPipeline();\r\n    },\r\n\r\n    /**\r\n     * Sets the size of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.RenderTexture#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        return this.resize(width, height);\r\n    },\r\n\r\n    /**\r\n     * Resizes the Render Texture to the new dimensions given.\r\n     * \r\n     * If Render Texture was created from specific frame, only the size of the frame will be changed. The size of the source\r\n     * texture will not change.\r\n     *\r\n     * If Render Texture was not created from specific frame, the following will happen:\r\n     * In WebGL it will destroy and then re-create the frame buffer being used by the Render Texture.\r\n     * In Canvas it will resize the underlying canvas element.\r\n     * Both approaches will erase everything currently drawn to the Render Texture.\r\n     *\r\n     * If the dimensions given are the same as those already being used, calling this method will do nothing.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#resize\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} width - The new width of the Render Texture.\r\n     * @param {number} [height=width] - The new height of the Render Texture. If not specified, will be set the same as the `width`.\r\n     *\r\n     * @return {this} This Render Texture.\r\n     */\r\n    resize: function (width, height)\r\n    {\r\n        if (height === undefined) { height = width; }\r\n\r\n        if (width !== this.width || height !== this.height)\r\n        {\r\n            if (this.frame.name === '__BASE')\r\n            {\r\n                //  Resize the texture\r\n\r\n                this.canvas.width = width;\r\n                this.canvas.height = height;\r\n                \r\n                this.texture.width = width;\r\n                this.texture.height = height;\r\n                \r\n                if (this.gl)\r\n                {\r\n                    var gl = this.gl;\r\n\r\n                    this.renderer.deleteTexture(this.frame.source.glTexture);\r\n                    this.renderer.deleteFramebuffer(this.framebuffer);\r\n\r\n                    var glTexture = this.renderer.createTexture2D(0, gl.NEAREST, gl.NEAREST, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.RGBA, null, width, height, false);\r\n\r\n                    this.framebuffer = this.renderer.createFramebuffer(width, height, glTexture, false);\r\n\r\n                    this.frame.source.isRenderTexture = true;\r\n\r\n                    this.frame.glTexture = glTexture;\r\n                    this.glTexture = glTexture;\r\n                }\r\n\r\n                this.frame.source.width = width;\r\n                this.frame.source.height = height;\r\n\r\n                this.camera.setSize(width, height);\r\n\r\n                this.frame.setSize(width, height);\r\n\r\n                this.width = width;\r\n                this.height = height;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //  Resize the frame\r\n\r\n            var baseFrame = this.texture.getSourceImage();\r\n\r\n            if (this.frame.cutX + width > baseFrame.width)\r\n            {\r\n                width = baseFrame.width - this.frame.cutX;\r\n            }\r\n\r\n            if (this.frame.cutY + height > baseFrame.height)\r\n            {\r\n                height = baseFrame.height - this.frame.cutY;\r\n            }\r\n\r\n            this.frame.setSize(width, height, this.frame.cutX, this.frame.cutY);\r\n        }\r\n\r\n        this.updateDisplayOrigin();\r\n\r\n        var input = this.input;\r\n\r\n        if (input && !input.customHitArea)\r\n        {\r\n            input.hitArea.width = width;\r\n            input.hitArea.height = height;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the tint to use when rendering this Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#setGlobalTint\r\n     * @since 3.2.0\r\n     *\r\n     * @param {integer} tint - The tint value.\r\n     *\r\n     * @return {this} This Render Texture.\r\n     */\r\n    setGlobalTint: function (tint)\r\n    {\r\n        this.globalTint = tint;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the alpha to use when rendering this Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#setGlobalAlpha\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} alpha - The alpha value.\r\n     *\r\n     * @return {this} This Render Texture.\r\n     */\r\n    setGlobalAlpha: function (alpha)\r\n    {\r\n        this.globalAlpha = alpha;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stores a copy of this Render Texture in the Texture Manager using the given key.\r\n     * \r\n     * After doing this, any texture based Game Object, such as a Sprite, can use the contents of this\r\n     * Render Texture by using the texture key:\r\n     * \r\n     * ```javascript\r\n     * var rt = this.add.renderTexture(0, 0, 128, 128);\r\n     * \r\n     * // Draw something to the Render Texture\r\n     * \r\n     * rt.saveTexture('doodle');\r\n     * \r\n     * this.add.image(400, 300, 'doodle');\r\n     * ```\r\n     * \r\n     * Updating the contents of this Render Texture will automatically update _any_ Game Object\r\n     * that is using it as a texture. Calling `saveTexture` again will not save another copy\r\n     * of the same texture, it will just rename the key of the existing copy.\r\n     * \r\n     * By default it will create a single base texture. You can add frames to the texture\r\n     * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n     * to use a specific frame from a Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#saveTexture\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} key - The unique key to store the texture as within the global Texture Manager.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was saved.\r\n     */\r\n    saveTexture: function (key)\r\n    {\r\n        this.textureManager.renameTexture(this.texture.key, key);\r\n        \r\n        this._saved = true;\r\n\r\n        return this.texture;\r\n    },\r\n\r\n    /**\r\n     * Fills the Render Texture with the given color.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#fill\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} rgb - The color to fill the Render Texture with.\r\n     * @param {number} [alpha=1] - The alpha value used by the fill.\r\n     * @param {number} [x=0] - The left coordinate of the fill rectangle.\r\n     * @param {number} [y=0] - The top coordinate of the fill rectangle.\r\n     * @param {number} [width=this.frame.cutWidth] - The width of the fill rectangle.\r\n     * @param {number} [height=this.frame.cutHeight] - The height of the fill rectangle.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    fill: function (rgb, alpha, x, y, width, height)\r\n    {\r\n        if (alpha === undefined) { alpha = 1; }\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.frame.cutWidth; }\r\n        if (height === undefined) { height = this.frame.cutHeight; }\r\n\r\n        var r = ((rgb >> 16) | 0) & 0xff;\r\n        var g = ((rgb >> 8) | 0) & 0xff;\r\n        var b = (rgb | 0) & 0xff;\r\n\r\n        var gl = this.gl;\r\n        var frame = this.frame;\r\n\r\n        this.camera.preRender(1, 1);\r\n\r\n        if (gl)\r\n        {\r\n            var cx = this.camera._cx;\r\n            var cy = this.camera._cy;\r\n            var cw = this.camera._cw;\r\n            var ch = this.camera._ch;\r\n\r\n            this.renderer.setFramebuffer(this.framebuffer, false);\r\n\r\n            this.renderer.pushScissor(cx, cy, cw, ch, ch);\r\n\r\n            var pipeline = this.pipeline;\r\n    \r\n            pipeline.projOrtho(0, this.texture.width, 0, this.texture.height, -1000.0, 1000.0);\r\n\r\n            pipeline.drawFillRect(\r\n                x, y, width, height,\r\n                Utils.getTintFromFloats(r / 255, g / 255, b / 255, 1),\r\n                alpha\r\n            );\r\n\r\n            this.renderer.setFramebuffer(null, false);\r\n\r\n            this.renderer.popScissor();\r\n\r\n            pipeline.projOrtho(0, pipeline.width, pipeline.height, 0, -1000.0, 1000.0);\r\n        }\r\n        else\r\n        {\r\n            this.renderer.setContext(this.context);\r\n\r\n            this.context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';\r\n            this.context.fillRect(x + frame.cutX, y + frame.cutY, width, height);\r\n\r\n            this.renderer.setContext();\r\n        }\r\n\r\n        this.dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clears the Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#clear\r\n     * @since 3.2.0\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    clear: function ()\r\n    {\r\n        if (this.dirty)\r\n        {\r\n            var gl = this.gl;\r\n\r\n            if (gl)\r\n            {\r\n                var renderer = this.renderer;\r\n\r\n                renderer.setFramebuffer(this.framebuffer, true);\r\n        \r\n                if (this.frame.cutWidth !== this.canvas.width || this.frame.cutHeight !== this.canvas.height)\r\n                {\r\n                    gl.scissor(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight);\r\n                }\r\n\r\n                gl.clearColor(0, 0, 0, 0);\r\n                gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n                renderer.setFramebuffer(null, true);\r\n            }\r\n            else\r\n            {\r\n                var ctx = this.context;\r\n\r\n                ctx.save();\r\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n                ctx.clearRect(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight);\r\n                ctx.restore();\r\n            }\r\n\r\n            this.dirty = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the given object, or an array of objects, to this Render Texture using a blend mode of ERASE.\r\n     * This has the effect of erasing any filled pixels in the objects from this Render Texture.\r\n     * \r\n     * It can accept any of the following:\r\n     * \r\n     * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.\r\n     * * Dynamic and Static Tilemap Layers.\r\n     * * A Group. The contents of which will be iterated and drawn in turn.\r\n     * * A Container. The contents of which will be iterated fully, and drawn in turn.\r\n     * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.\r\n     * * Another Render Texture.\r\n     * * A Texture Frame instance.\r\n     * * A string. This is used to look-up a texture from the Texture Manager.\r\n     * \r\n     * Note: You cannot erase a Render Texture from itself.\r\n     * \r\n     * If passing in a Group or Container it will only draw children that return `true`\r\n     * when their `willRender()` method is called. I.e. a Container with 10 children,\r\n     * 5 of which have `visible=false` will only draw the 5 visible ones.\r\n     * \r\n     * If passing in an array of Game Objects it will draw them all, regardless if\r\n     * they pass a `willRender` check or not.\r\n     * \r\n     * You can pass in a string in which case it will look for a texture in the Texture\r\n     * Manager matching that string, and draw the base frame.\r\n     * \r\n     * You can pass in the `x` and `y` coordinates to draw the objects at. The use of\r\n     * the coordinates differ based on what objects are being drawn. If the object is\r\n     * a Group, Container or Display List, the coordinates are _added_ to the positions\r\n     * of the children. For all other types of object, the coordinates are exact.\r\n     * \r\n     * Calling this method causes the WebGL batch to flush, so it can write the texture\r\n     * data to the framebuffer being used internally. The batch is flushed at the end,\r\n     * after the entries have been iterated. So if you've a bunch of objects to draw,\r\n     * try and pass them in an array in one single call, rather than making lots of\r\n     * separate calls.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#erase\r\n     * @since 3.16.0\r\n     *\r\n     * @param {any} entries - Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.\r\n     * @param {number} [x] - The x position to draw the Frame at, or the offset applied to the object.\r\n     * @param {number} [y] - The y position to draw the Frame at, or the offset applied to the object.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    erase: function (entries, x, y)\r\n    {\r\n        this._eraseMode = true;\r\n\r\n        var blendMode = this.renderer.currentBlendMode;\r\n\r\n        this.renderer.setBlendMode(BlendModes.ERASE);\r\n\r\n        this.draw(entries, x, y, 1, 16777215);\r\n\r\n        this.renderer.setBlendMode(blendMode);\r\n\r\n        this._eraseMode = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the given object, or an array of objects, to this Render Texture.\r\n     * \r\n     * It can accept any of the following:\r\n     * \r\n     * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.\r\n     * * Dynamic and Static Tilemap Layers.\r\n     * * A Group. The contents of which will be iterated and drawn in turn.\r\n     * * A Container. The contents of which will be iterated fully, and drawn in turn.\r\n     * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.\r\n     * * Another Render Texture.\r\n     * * A Texture Frame instance.\r\n     * * A string. This is used to look-up a texture from the Texture Manager.\r\n     * \r\n     * Note: You cannot draw a Render Texture to itself.\r\n     * \r\n     * If passing in a Group or Container it will only draw children that return `true`\r\n     * when their `willRender()` method is called. I.e. a Container with 10 children,\r\n     * 5 of which have `visible=false` will only draw the 5 visible ones.\r\n     * \r\n     * If passing in an array of Game Objects it will draw them all, regardless if\r\n     * they pass a `willRender` check or not.\r\n     * \r\n     * You can pass in a string in which case it will look for a texture in the Texture\r\n     * Manager matching that string, and draw the base frame. If you need to specify\r\n     * exactly which frame to draw then use the method `drawFrame` instead.\r\n     * \r\n     * You can pass in the `x` and `y` coordinates to draw the objects at. The use of\r\n     * the coordinates differ based on what objects are being drawn. If the object is\r\n     * a Group, Container or Display List, the coordinates are _added_ to the positions\r\n     * of the children. For all other types of object, the coordinates are exact.\r\n     * \r\n     * The `alpha` and `tint` values are only used by Texture Frames.\r\n     * Game Objects use their own alpha and tint values when being drawn.\r\n     * \r\n     * Calling this method causes the WebGL batch to flush, so it can write the texture\r\n     * data to the framebuffer being used internally. The batch is flushed at the end,\r\n     * after the entries have been iterated. So if you've a bunch of objects to draw,\r\n     * try and pass them in an array in one single call, rather than making lots of\r\n     * separate calls.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#draw\r\n     * @since 3.2.0\r\n     *\r\n     * @param {any} entries - Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.\r\n     * @param {number} [x] - The x position to draw the Frame at, or the offset applied to the object.\r\n     * @param {number} [y] - The y position to draw the Frame at, or the offset applied to the object.\r\n     * @param {number} [alpha] -  The alpha value. Only used for Texture Frames and if not specified defaults to the `globalAlpha` property. Game Objects use their own current alpha value.\r\n     * @param {number} [tint] -  WebGL only. The tint color value. Only used for Texture Frames and if not specified defaults to the `globalTint` property. Game Objects use their own current tint value.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    draw: function (entries, x, y, alpha, tint)\r\n    {\r\n        if (alpha === undefined) { alpha = this.globalAlpha; }\r\n\r\n        if (tint === undefined)\r\n        {\r\n            tint = (this.globalTint >> 16) + (this.globalTint & 0xff00) + ((this.globalTint & 0xff) << 16);\r\n        }\r\n        else\r\n        {\r\n            tint = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16);\r\n        }\r\n\r\n        if (!Array.isArray(entries))\r\n        {\r\n            entries = [ entries ];\r\n        }\r\n\r\n        var gl = this.gl;\r\n\r\n        this.camera.preRender(1, 1);\r\n\r\n        if (gl)\r\n        {\r\n            var cx = this.camera._cx;\r\n            var cy = this.camera._cy;\r\n            var cw = this.camera._cw;\r\n            var ch = this.camera._ch;\r\n\r\n            this.renderer.setFramebuffer(this.framebuffer, false);\r\n\r\n            this.renderer.pushScissor(cx, cy, cw, ch, ch);\r\n\r\n            var pipeline = this.pipeline;\r\n    \r\n            pipeline.projOrtho(0, this.texture.width, 0, this.texture.height, -1000.0, 1000.0);\r\n\r\n            this.batchList(entries, x, y, alpha, tint);\r\n\r\n            pipeline.flush();\r\n\r\n            this.renderer.setFramebuffer(null, false);\r\n\r\n            this.renderer.popScissor();\r\n\r\n            pipeline.projOrtho(0, pipeline.width, pipeline.height, 0, -1000.0, 1000.0);\r\n        }\r\n        else\r\n        {\r\n            this.renderer.setContext(this.context);\r\n\r\n            this.batchList(entries, x, y, alpha, tint);\r\n\r\n            this.renderer.setContext();\r\n        }\r\n\r\n        this.dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the Texture Frame to the Render Texture at the given position.\r\n     * \r\n     * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n     * \r\n     * ```javascript\r\n     * var rt = this.add.renderTexture(0, 0, 800, 600);\r\n     * rt.drawFrame(key, frame);\r\n     * ```\r\n     * \r\n     * You can optionally provide a position, alpha and tint value to apply to the frame\r\n     * before it is drawn.\r\n     * \r\n     * Calling this method will cause a batch flush, so if you've got a stack of things to draw\r\n     * in a tight loop, try using the `draw` method instead.\r\n     * \r\n     * If you need to draw a Sprite to this Render Texture, use the `draw` method instead.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#drawFrame\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.\r\n     * @param {number} [x=0] - The x position to draw the frame at.\r\n     * @param {number} [y=0] - The y position to draw the frame at.\r\n     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n     * @param {number} [tint] - WebGL only. The tint color to use. If not specified it uses the `globalTint` property.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    drawFrame: function (key, frame, x, y, alpha, tint)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (alpha === undefined) { alpha = this.globalAlpha; }\r\n\r\n        if (tint === undefined)\r\n        {\r\n            tint = (this.globalTint >> 16) + (this.globalTint & 0xff00) + ((this.globalTint & 0xff) << 16);\r\n        }\r\n        else\r\n        {\r\n            tint = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16);\r\n        }\r\n\r\n        var gl = this.gl;\r\n        var textureFrame = this.textureManager.getFrame(key, frame);\r\n\r\n        if (textureFrame)\r\n        {\r\n            this.camera.preRender(1, 1);\r\n\r\n            if (gl)\r\n            {\r\n                var cx = this.camera._cx;\r\n                var cy = this.camera._cy;\r\n                var cw = this.camera._cw;\r\n                var ch = this.camera._ch;\r\n    \r\n                this.renderer.setFramebuffer(this.framebuffer, false);\r\n    \r\n                this.renderer.pushScissor(cx, cy, cw, ch, ch);\r\n    \r\n                var pipeline = this.pipeline;\r\n        \r\n                pipeline.projOrtho(0, this.texture.width, 0, this.texture.height, -1000.0, 1000.0);\r\n        \r\n                pipeline.batchTextureFrame(textureFrame, x + this.frame.cutX, y + this.frame.cutY, tint, alpha, this.camera.matrix, null);\r\n            \r\n                pipeline.flush();\r\n        \r\n                this.renderer.setFramebuffer(null, false);\r\n\r\n                this.renderer.popScissor();\r\n            \r\n                pipeline.projOrtho(0, pipeline.width, pipeline.height, 0, -1000.0, 1000.0);\r\n            }\r\n            else\r\n            {\r\n                this.batchTextureFrame(textureFrame, x + this.frame.cutX, y + this.frame.cutY, alpha, tint);\r\n            }\r\n\r\n            this.dirty = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles the drawing of an array of children.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchList\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {array} children - The array of Game Objects to draw.\r\n     * @param {number} [x] - The x position to offset the Game Object by.\r\n     * @param {number} [y] - The y position to offset the Game Object by.\r\n     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n     * @param {number} [tint] - The tint color to use. If not specified it uses the `globalTint` property.\r\n     */\r\n    batchList: function (children, x, y, alpha, tint)\r\n    {\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            var entry = children[i];\r\n\r\n            if (!entry || entry === this)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (entry.renderWebGL || entry.renderCanvas)\r\n            {\r\n                //  Game Objects\r\n                this.drawGameObject(entry, x, y);\r\n            }\r\n            else if (entry.isParent || entry.list)\r\n            {\r\n                //  Groups / Display Lists\r\n                this.batchGroup(entry.getChildren(), x, y);\r\n            }\r\n            else if (typeof entry === 'string')\r\n            {\r\n                //  Texture key\r\n                this.batchTextureFrameKey(entry, null, x, y, alpha, tint);\r\n            }\r\n            else if (entry instanceof Frame)\r\n            {\r\n                //  Texture Frame instance\r\n                this.batchTextureFrame(entry, x, y, alpha, tint);\r\n            }\r\n            else if (Array.isArray(entry))\r\n            {\r\n                //  Another Array\r\n                this.batchList(entry, x, y, alpha, tint);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles the drawing a Phaser Group contents.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchGroup\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {array} children - The array of Game Objects to draw.\r\n     * @param {number} [x=0] - The x position to offset the Game Object by.\r\n     * @param {number} [y=0] - The y position to offset the Game Object by.\r\n     */\r\n    batchGroup: function (children, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        x += this.frame.cutX;\r\n        y += this.frame.cutY;\r\n\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            var entry = children[i];\r\n\r\n            if (entry.willRender())\r\n            {\r\n                var tx = entry.x + x;\r\n                var ty = entry.y + y;\r\n\r\n                this.drawGameObject(entry, tx, ty);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles drawing a single Phaser Game Object to this Render Texture using WebGL.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchGameObjectWebGL\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to draw.\r\n     * @param {number} [x] - The x position to draw the Game Object at.\r\n     * @param {number} [y] - The y position to draw the Game Object at.\r\n     */\r\n    batchGameObjectWebGL: function (gameObject, x, y)\r\n    {\r\n        if (x === undefined) { x = gameObject.x; }\r\n        if (y === undefined) { y = gameObject.y; }\r\n\r\n        var prevX = gameObject.x;\r\n        var prevY = gameObject.y;\r\n\r\n        if (!this._eraseMode)\r\n        {\r\n            this.renderer.setBlendMode(gameObject.blendMode);\r\n        }\r\n\r\n        gameObject.setPosition(x + this.frame.cutX, y + this.frame.cutY);\r\n        \r\n        gameObject.renderWebGL(this.renderer, gameObject, 0, this.camera, null);\r\n\r\n        gameObject.setPosition(prevX, prevY);\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles drawing a single Phaser Game Object to this Render Texture using Canvas.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchGameObjectCanvas\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to draw.\r\n     * @param {number} [x] - The x position to draw the Game Object at.\r\n     * @param {number} [y] - The y position to draw the Game Object at.\r\n     */\r\n    batchGameObjectCanvas: function (gameObject, x, y)\r\n    {\r\n        if (x === undefined) { x = gameObject.x; }\r\n        if (y === undefined) { y = gameObject.y; }\r\n\r\n        var prevX = gameObject.x;\r\n        var prevY = gameObject.y;\r\n\r\n        if (this._eraseMode)\r\n        {\r\n            var blendMode = gameObject.blendMode;\r\n\r\n            gameObject.blendMode = BlendModes.ERASE;\r\n        }\r\n\r\n        gameObject.setPosition(x + this.frame.cutX, y + this.frame.cutY);\r\n\r\n        gameObject.renderCanvas(this.renderer, gameObject, 0, this.camera, null);\r\n\r\n        gameObject.setPosition(prevX, prevY);\r\n\r\n        if (this._eraseMode)\r\n        {\r\n            gameObject.blendMode = blendMode;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles the drawing of an array of children.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchTextureFrameKey\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.\r\n     * @param {number} [x=0] - The x position to offset the Game Object by.\r\n     * @param {number} [y=0] - The y position to offset the Game Object by.\r\n     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n     * @param {number} [tint] - The tint color to use. If not specified it uses the `globalTint` property.\r\n     */\r\n    batchTextureFrameKey: function (key, frame, x, y, alpha, tint)\r\n    {\r\n        var textureFrame = this.textureManager.getFrame(key, frame);\r\n\r\n        if (textureFrame)\r\n        {\r\n            this.batchTextureFrame(textureFrame, x, y, alpha, tint);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles the drawing of a Texture Frame to this Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchTextureFrame\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.Textures.Frame} textureFrame - The Texture Frame to draw.\r\n     * @param {number} [x=0] - The x position to draw the Frame at.\r\n     * @param {number} [y=0] - The y position to draw the Frame at.\r\n     * @param {number} [tint] - A tint color to be applied to the frame drawn to the Render Texture.\r\n     */\r\n    batchTextureFrame: function (textureFrame, x, y, alpha, tint)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        x += this.frame.cutX;\r\n        y += this.frame.cutY;\r\n\r\n        if (this.gl)\r\n        {\r\n            this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);\r\n        }\r\n        else\r\n        {\r\n            var ctx = this.context;\r\n            var cd = textureFrame.canvasData;\r\n            var source = textureFrame.source.image;\r\n    \r\n            var matrix = this.camera.matrix;\r\n    \r\n            ctx.globalAlpha = this.globalAlpha;\r\n\r\n            ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\r\n\r\n            ctx.drawImage(source, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the given area of this Render Texture.\r\n     * \r\n     * The snapshot is taken immediately.\r\n     * \r\n     * To capture the whole Render Texture see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.\r\n     * \r\n     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#snapshotArea\r\n     * @since 3.19.0\r\n     *\r\n     * @param {integer} x - The x coordinate to grab from.\r\n     * @param {integer} y - The y coordinate to grab from.\r\n     * @param {integer} width - The width of the area to grab.\r\n     * @param {integer} height - The height of the area to grab.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    snapshotArea: function (x, y, width, height, callback, type, encoderOptions)\r\n    {\r\n        if (this.gl)\r\n        {\r\n            this.renderer.snapshotFramebuffer(this.framebuffer, this.width, this.height, callback, false, x, y, width, height, type, encoderOptions);\r\n        }\r\n        else\r\n        {\r\n            this.renderer.snapshotCanvas(this.canvas, callback, false, x, y, width, height, type, encoderOptions);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the whole of this Render Texture.\r\n     * \r\n     * The snapshot is taken immediately.\r\n     * \r\n     * To capture just a portion of the Render Texture see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.\r\n     * \r\n     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#snapshot\r\n     * @since 3.19.0\r\n     *\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    snapshot: function (callback, type, encoderOptions)\r\n    {\r\n        if (this.gl)\r\n        {\r\n            this.renderer.snapshotFramebuffer(this.framebuffer, this.width, this.height, callback, false, 0, 0, this.width, this.height, type, encoderOptions);\r\n        }\r\n        else\r\n        {\r\n            this.renderer.snapshotCanvas(this.canvas, callback, false, 0, 0, this.width, this.height, type, encoderOptions);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the given pixel from this Render Texture.\r\n     * \r\n     * The snapshot is taken immediately.\r\n     * \r\n     * To capture the whole Render Texture see the `snapshot` method. To capture a specific portion, see `snapshotArea`.\r\n     * \r\n     * Unlike the other two snapshot methods, this one will send your callback a `Color` object containing the color data for\r\n     * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,\r\n     * using less memory, than the other snapshot methods.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#snapshotPixel\r\n     * @since 3.19.0\r\n     *\r\n     * @param {integer} x - The x coordinate of the pixel to get.\r\n     * @param {integer} y - The y coordinate of the pixel to get.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    snapshotPixel: function (x, y, callback)\r\n    {\r\n        if (this.gl)\r\n        {\r\n            this.renderer.snapshotFramebuffer(this.framebuffer, this.width, this.height, callback, true, x, y);\r\n        }\r\n        else\r\n        {\r\n            this.renderer.snapshotCanvas(this.canvas, callback, true, x, y);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#preDestroy\r\n     * @protected\r\n     * @since 3.9.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        if (!this._saved)\r\n        {\r\n            CanvasPool.remove(this.canvas);\r\n\r\n            if (this.gl)\r\n            {\r\n                this.renderer.deleteFramebuffer(this.framebuffer);\r\n            }\r\n\r\n            this.texture.destroy();\r\n            this.camera.destroy();\r\n\r\n            this.canvas = null;\r\n            this.context = null;\r\n            this.framebuffer = null;\r\n            this.texture = null;\r\n            this.glTexture = null;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = RenderTexture;\r\n"]},"metadata":{},"sourceType":"script"}