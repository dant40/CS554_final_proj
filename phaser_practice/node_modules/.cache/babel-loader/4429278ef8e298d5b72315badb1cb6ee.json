{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\nvar Class = require('../utils/Class');\n/**\r\n * @classdesc\r\n * A representation of a vector in 2D space.\r\n *\r\n * A two-component vector.\r\n *\r\n * @class Vector2\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number|Phaser.Types.Math.Vector2Like} [x] - The x component, or an object with `x` and `y` properties.\r\n * @param {number} [y] - The y component.\r\n */\n\n\nvar Vector2 = new Class({\n  initialize: function Vector2(x, y) {\n    /**\r\n     * The x component of this Vector.\r\n     *\r\n     * @name Phaser.Math.Vector2#x\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n    this.x = 0;\n    /**\r\n     * The y component of this Vector.\r\n     *\r\n     * @name Phaser.Math.Vector2#y\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.y = 0;\n\n    if (typeof x === 'object') {\n      this.x = x.x || 0;\n      this.y = x.y || 0;\n    } else {\n      if (y === undefined) {\n        y = x;\n      }\n\n      this.x = x || 0;\n      this.y = y || 0;\n    }\n  },\n\n  /**\r\n   * Make a clone of this Vector2.\r\n   *\r\n   * @method Phaser.Math.Vector2#clone\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Vector2} A clone of this Vector2.\r\n   */\n  clone: function () {\n    return new Vector2(this.x, this.y);\n  },\n\n  /**\r\n   * Copy the components of a given Vector into this Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#copy\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector to copy the components from.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  copy: function (src) {\n    this.x = src.x || 0;\n    this.y = src.y || 0;\n    return this;\n  },\n\n  /**\r\n   * Set the component values of this Vector from a given Vector2Like object.\r\n   *\r\n   * @method Phaser.Math.Vector2#setFromObject\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.Math.Vector2Like} obj - The object containing the component values to set for this Vector.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  setFromObject: function (obj) {\n    this.x = obj.x || 0;\n    this.y = obj.y || 0;\n    return this;\n  },\n\n  /**\r\n   * Set the `x` and `y` components of the this Vector to the given `x` and `y` values.\r\n   *\r\n   * @method Phaser.Math.Vector2#set\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The x value to set for this Vector.\r\n   * @param {number} [y=x] - The y value to set for this Vector.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  set: function (x, y) {\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n\n  /**\r\n   * This method is an alias for `Vector2.set`.\r\n   *\r\n   * @method Phaser.Math.Vector2#setTo\r\n   * @since 3.4.0\r\n   *\r\n   * @param {number} x - The x value to set for this Vector.\r\n   * @param {number} [y=x] - The y value to set for this Vector.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  setTo: function (x, y) {\n    return this.set(x, y);\n  },\n\n  /**\r\n   * Sets the `x` and `y` values of this object from a given polar coordinate.\r\n   *\r\n   * @method Phaser.Math.Vector2#setToPolar\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} azimuth - The angular coordinate, in radians.\r\n   * @param {number} [radius=1] - The radial coordinate (length).\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  setToPolar: function (azimuth, radius) {\n    if (radius == null) {\n      radius = 1;\n    }\n\n    this.x = Math.cos(azimuth) * radius;\n    this.y = Math.sin(azimuth) * radius;\n    return this;\n  },\n\n  /**\r\n   * Check whether this Vector is equal to a given Vector.\r\n   *\r\n   * Performs a strict equality check against each Vector's components.\r\n   *\r\n   * @method Phaser.Math.Vector2#equals\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} v - The vector to compare with this Vector.\r\n   *\r\n   * @return {boolean} Whether the given Vector is equal to this Vector.\r\n   */\n  equals: function (v) {\n    return this.x === v.x && this.y === v.y;\n  },\n\n  /**\r\n   * Calculate the angle between this Vector and the positive x-axis, in radians.\r\n   *\r\n   * @method Phaser.Math.Vector2#angle\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The angle between this Vector, and the positive x-axis, given in radians.\r\n   */\n  angle: function () {\n    // computes the angle in radians with respect to the positive x-axis\n    var angle = Math.atan2(this.y, this.x);\n\n    if (angle < 0) {\n      angle += 2 * Math.PI;\n    }\n\n    return angle;\n  },\n\n  /**\r\n   * Add a given Vector to this Vector. Addition is component-wise.\r\n   *\r\n   * @method Phaser.Math.Vector2#add\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector to add to this Vector.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  add: function (src) {\n    this.x += src.x;\n    this.y += src.y;\n    return this;\n  },\n\n  /**\r\n   * Subtract the given Vector from this Vector. Subtraction is component-wise.\r\n   *\r\n   * @method Phaser.Math.Vector2#subtract\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector to subtract from this Vector.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  subtract: function (src) {\n    this.x -= src.x;\n    this.y -= src.y;\n    return this;\n  },\n\n  /**\r\n   * Perform a component-wise multiplication between this Vector and the given Vector.\r\n   *\r\n   * Multiplies this Vector by the given Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#multiply\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector to multiply this Vector by.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  multiply: function (src) {\n    this.x *= src.x;\n    this.y *= src.y;\n    return this;\n  },\n\n  /**\r\n   * Scale this Vector by the given value.\r\n   *\r\n   * @method Phaser.Math.Vector2#scale\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The value to scale this Vector by.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  scale: function (value) {\n    if (isFinite(value)) {\n      this.x *= value;\n      this.y *= value;\n    } else {\n      this.x = 0;\n      this.y = 0;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Perform a component-wise division between this Vector and the given Vector.\r\n   *\r\n   * Divides this Vector by the given Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#divide\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector to divide this Vector by.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  divide: function (src) {\n    this.x /= src.x;\n    this.y /= src.y;\n    return this;\n  },\n\n  /**\r\n   * Negate the `x` and `y` components of this Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#negate\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  negate: function () {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  },\n\n  /**\r\n   * Calculate the distance between this Vector and the given Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#distance\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector to calculate the distance to.\r\n   *\r\n   * @return {number} The distance from this Vector to the given Vector.\r\n   */\n  distance: function (src) {\n    var dx = src.x - this.x;\n    var dy = src.y - this.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  },\n\n  /**\r\n   * Calculate the distance between this Vector and the given Vector, squared.\r\n   *\r\n   * @method Phaser.Math.Vector2#distanceSq\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector to calculate the distance to.\r\n   *\r\n   * @return {number} The distance from this Vector to the given Vector, squared.\r\n   */\n  distanceSq: function (src) {\n    var dx = src.x - this.x;\n    var dy = src.y - this.y;\n    return dx * dx + dy * dy;\n  },\n\n  /**\r\n   * Calculate the length (or magnitude) of this Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#length\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The length of this Vector.\r\n   */\n  length: function () {\n    var x = this.x;\n    var y = this.y;\n    return Math.sqrt(x * x + y * y);\n  },\n\n  /**\r\n   * Calculate the length of this Vector squared.\r\n   *\r\n   * @method Phaser.Math.Vector2#lengthSq\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} The length of this Vector, squared.\r\n   */\n  lengthSq: function () {\n    var x = this.x;\n    var y = this.y;\n    return x * x + y * y;\n  },\n\n  /**\r\n   * Normalize this Vector.\r\n   *\r\n   * Makes the vector a unit length vector (magnitude of 1) in the same direction.\r\n   *\r\n   * @method Phaser.Math.Vector2#normalize\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  normalize: function () {\n    var x = this.x;\n    var y = this.y;\n    var len = x * x + y * y;\n\n    if (len > 0) {\n      len = 1 / Math.sqrt(len);\n      this.x = x * len;\n      this.y = y * len;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Right-hand normalize (make unit length) this Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#normalizeRightHand\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  normalizeRightHand: function () {\n    var x = this.x;\n    this.x = this.y * -1;\n    this.y = x;\n    return this;\n  },\n\n  /**\r\n   * Calculate the dot product of this Vector and the given Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#dot\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector2 to dot product with this Vector2.\r\n   *\r\n   * @return {number} The dot product of this Vector and the given Vector.\r\n   */\n  dot: function (src) {\n    return this.x * src.x + this.y * src.y;\n  },\n\n  /**\r\n   * Calculate the cross product of this Vector and the given Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#cross\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector2 to cross with this Vector2.\r\n   *\r\n   * @return {number} The cross product of this Vector and the given Vector.\r\n   */\n  cross: function (src) {\n    return this.x * src.y - this.y * src.x;\n  },\n\n  /**\r\n   * Linearly interpolate between this Vector and the given Vector.\r\n   *\r\n   * Interpolates this Vector towards the given Vector.\r\n   *\r\n   * @method Phaser.Math.Vector2#lerp\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Vector2} src - The Vector2 to interpolate towards.\r\n   * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  lerp: function (src, t) {\n    if (t === undefined) {\n      t = 0;\n    }\n\n    var ax = this.x;\n    var ay = this.y;\n    this.x = ax + t * (src.x - ax);\n    this.y = ay + t * (src.y - ay);\n    return this;\n  },\n\n  /**\r\n   * Transform this Vector with the given Matrix.\r\n   *\r\n   * @method Phaser.Math.Vector2#transformMat3\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Matrix3} mat - The Matrix3 to transform this Vector2 with.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  transformMat3: function (mat) {\n    var x = this.x;\n    var y = this.y;\n    var m = mat.val;\n    this.x = m[0] * x + m[3] * y + m[6];\n    this.y = m[1] * x + m[4] * y + m[7];\n    return this;\n  },\n\n  /**\r\n   * Transform this Vector with the given Matrix.\r\n   *\r\n   * @method Phaser.Math.Vector2#transformMat4\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector2 with.\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  transformMat4: function (mat) {\n    var x = this.x;\n    var y = this.y;\n    var m = mat.val;\n    this.x = m[0] * x + m[4] * y + m[12];\n    this.y = m[1] * x + m[5] * y + m[13];\n    return this;\n  },\n\n  /**\r\n   * Make this Vector the zero vector (0, 0).\r\n   *\r\n   * @method Phaser.Math.Vector2#reset\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Math.Vector2} This Vector2.\r\n   */\n  reset: function () {\n    this.x = 0;\n    this.y = 0;\n    return this;\n  }\n});\n/**\r\n * A static zero Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.ZERO\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.1.0\r\n */\n\nVector2.ZERO = new Vector2();\n/**\r\n * A static right Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.RIGHT\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\n\nVector2.RIGHT = new Vector2(1, 0);\n/**\r\n * A static left Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.LEFT\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\n\nVector2.LEFT = new Vector2(-1, 0);\n/**\r\n * A static up Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.UP\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\n\nVector2.UP = new Vector2(0, -1);\n/**\r\n * A static down Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.DOWN\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\n\nVector2.DOWN = new Vector2(0, 1);\n/**\r\n * A static one Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.ONE\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\n\nVector2.ONE = new Vector2(1, 1);\nmodule.exports = Vector2;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/math/Vector2.js"],"names":["Class","require","Vector2","initialize","x","y","undefined","clone","copy","src","setFromObject","obj","set","setTo","setToPolar","azimuth","radius","Math","cos","sin","equals","v","angle","atan2","PI","add","subtract","multiply","scale","value","isFinite","divide","negate","distance","dx","dy","sqrt","distanceSq","length","lengthSq","normalize","len","normalizeRightHand","dot","cross","lerp","t","ax","ay","transformMat3","mat","m","val","transformMat4","reset","ZERO","RIGHT","LEFT","UP","DOWN","ONE","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A representation of a vector in 2D space.\r\n *\r\n * A two-component vector.\r\n *\r\n * @class Vector2\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number|Phaser.Types.Math.Vector2Like} [x] - The x component, or an object with `x` and `y` properties.\r\n * @param {number} [y] - The y component.\r\n */\r\nvar Vector2 = new Class({\r\n\r\n    initialize:\r\n\r\n    function Vector2 (x, y)\r\n    {\r\n        /**\r\n         * The x component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector2#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = 0;\r\n\r\n        /**\r\n         * The y component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector2#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = 0;\r\n\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n        }\r\n        else\r\n        {\r\n            if (y === undefined) { y = x; }\r\n\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Make a clone of this Vector2.\r\n     *\r\n     * @method Phaser.Math.Vector2#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} A clone of this Vector2.\r\n     */\r\n    clone: function ()\r\n    {\r\n        return new Vector2(this.x, this.y);\r\n    },\r\n\r\n    /**\r\n     * Copy the components of a given Vector into this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to copy the components from.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        this.x = src.x || 0;\r\n        this.y = src.y || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the component values of this Vector from a given Vector2Like object.\r\n     *\r\n     * @method Phaser.Math.Vector2#setFromObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} obj - The object containing the component values to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setFromObject: function (obj)\r\n    {\r\n        this.x = obj.x || 0;\r\n        this.y = obj.y || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the `x` and `y` components of the this Vector to the given `x` and `y` values.\r\n     *\r\n     * @method Phaser.Math.Vector2#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x value to set for this Vector.\r\n     * @param {number} [y=x] - The y value to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    set: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This method is an alias for `Vector2.set`.\r\n     *\r\n     * @method Phaser.Math.Vector2#setTo\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} x - The x value to set for this Vector.\r\n     * @param {number} [y=x] - The y value to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setTo: function (x, y)\r\n    {\r\n        return this.set(x, y);\r\n    },\r\n\r\n    /**\r\n     * Sets the `x` and `y` values of this object from a given polar coordinate.\r\n     *\r\n     * @method Phaser.Math.Vector2#setToPolar\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} azimuth - The angular coordinate, in radians.\r\n     * @param {number} [radius=1] - The radial coordinate (length).\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setToPolar: function (azimuth, radius)\r\n    {\r\n        if (radius == null) { radius = 1; }\r\n\r\n        this.x = Math.cos(azimuth) * radius;\r\n        this.y = Math.sin(azimuth) * radius;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Check whether this Vector is equal to a given Vector.\r\n     *\r\n     * Performs a strict equality check against each Vector's components.\r\n     *\r\n     * @method Phaser.Math.Vector2#equals\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} v - The vector to compare with this Vector.\r\n     *\r\n     * @return {boolean} Whether the given Vector is equal to this Vector.\r\n     */\r\n    equals: function (v)\r\n    {\r\n        return ((this.x === v.x) && (this.y === v.y));\r\n    },\r\n\r\n    /**\r\n     * Calculate the angle between this Vector and the positive x-axis, in radians.\r\n     *\r\n     * @method Phaser.Math.Vector2#angle\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The angle between this Vector, and the positive x-axis, given in radians.\r\n     */\r\n    angle: function ()\r\n    {\r\n        // computes the angle in radians with respect to the positive x-axis\r\n\r\n        var angle = Math.atan2(this.y, this.x);\r\n\r\n        if (angle < 0)\r\n        {\r\n            angle += 2 * Math.PI;\r\n        }\r\n\r\n        return angle;\r\n    },\r\n\r\n    /**\r\n     * Add a given Vector to this Vector. Addition is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector2#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to add to this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    add: function (src)\r\n    {\r\n        this.x += src.x;\r\n        this.y += src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Subtract the given Vector from this Vector. Subtraction is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector2#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to subtract from this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    subtract: function (src)\r\n    {\r\n        this.x -= src.x;\r\n        this.y -= src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise multiplication between this Vector and the given Vector.\r\n     *\r\n     * Multiplies this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to multiply this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    multiply: function (src)\r\n    {\r\n        this.x *= src.x;\r\n        this.y *= src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scale this Vector by the given value.\r\n     *\r\n     * @method Phaser.Math.Vector2#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The value to scale this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    scale: function (value)\r\n    {\r\n        if (isFinite(value))\r\n        {\r\n            this.x *= value;\r\n            this.y *= value;\r\n        }\r\n        else\r\n        {\r\n            this.x = 0;\r\n            this.y = 0;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise division between this Vector and the given Vector.\r\n     *\r\n     * Divides this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#divide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to divide this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    divide: function (src)\r\n    {\r\n        this.x /= src.x;\r\n        this.y /= src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Negate the `x` and `y` components of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#negate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    negate: function ()\r\n    {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#distance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector.\r\n     */\r\n    distance: function (src)\r\n    {\r\n        var dx = src.x - this.x;\r\n        var dy = src.y - this.y;\r\n\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector, squared.\r\n     *\r\n     * @method Phaser.Math.Vector2#distanceSq\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector, squared.\r\n     */\r\n    distanceSq: function (src)\r\n    {\r\n        var dx = src.x - this.x;\r\n        var dy = src.y - this.y;\r\n\r\n        return dx * dx + dy * dy;\r\n    },\r\n\r\n    /**\r\n     * Calculate the length (or magnitude) of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector.\r\n     */\r\n    length: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n\r\n        return Math.sqrt(x * x + y * y);\r\n    },\r\n\r\n    /**\r\n     * Calculate the length of this Vector squared.\r\n     *\r\n     * @method Phaser.Math.Vector2#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector, squared.\r\n     */\r\n    lengthSq: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n\r\n        return x * x + y * y;\r\n    },\r\n\r\n    /**\r\n     * Normalize this Vector.\r\n     *\r\n     * Makes the vector a unit length vector (magnitude of 1) in the same direction.\r\n     *\r\n     * @method Phaser.Math.Vector2#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    normalize: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var len = x * x + y * y;\r\n\r\n        if (len > 0)\r\n        {\r\n            len = 1 / Math.sqrt(len);\r\n\r\n            this.x = x * len;\r\n            this.y = y * len;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Right-hand normalize (make unit length) this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#normalizeRightHand\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    normalizeRightHand: function ()\r\n    {\r\n        var x = this.x;\r\n\r\n        this.x = this.y * -1;\r\n        this.y = x;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the dot product of this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector2 to dot product with this Vector2.\r\n     *\r\n     * @return {number} The dot product of this Vector and the given Vector.\r\n     */\r\n    dot: function (src)\r\n    {\r\n        return this.x * src.x + this.y * src.y;\r\n    },\r\n\r\n    /**\r\n     * Calculate the cross product of this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#cross\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector2 to cross with this Vector2.\r\n     *\r\n     * @return {number} The cross product of this Vector and the given Vector.\r\n     */\r\n    cross: function (src)\r\n    {\r\n        return this.x * src.y - this.y * src.x;\r\n    },\r\n\r\n    /**\r\n     * Linearly interpolate between this Vector and the given Vector.\r\n     *\r\n     * Interpolates this Vector towards the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} src - The Vector2 to interpolate towards.\r\n     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    lerp: function (src, t)\r\n    {\r\n        if (t === undefined) { t = 0; }\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n\r\n        this.x = ax + t * (src.x - ax);\r\n        this.y = ay + t * (src.y - ay);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector2#transformMat3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} mat - The Matrix3 to transform this Vector2 with.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    transformMat3: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var m = mat.val;\r\n\r\n        this.x = m[0] * x + m[3] * y + m[6];\r\n        this.y = m[1] * x + m[4] * y + m[7];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector2#transformMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector2 with.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    transformMat4: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var m = mat.val;\r\n\r\n        this.x = m[0] * x + m[4] * y + m[12];\r\n        this.y = m[1] * x + m[5] * y + m[13];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Make this Vector the zero vector (0, 0).\r\n     *\r\n     * @method Phaser.Math.Vector2#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 0;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * A static zero Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.ZERO\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.1.0\r\n */\r\nVector2.ZERO = new Vector2();\r\n\r\n/**\r\n * A static right Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.RIGHT\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.RIGHT = new Vector2(1, 0);\r\n\r\n/**\r\n * A static left Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.LEFT\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.LEFT = new Vector2(-1, 0);\r\n\r\n/**\r\n * A static up Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.UP\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.UP = new Vector2(0, -1);\r\n\r\n/**\r\n * A static down Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.DOWN\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.DOWN = new Vector2(0, 1);\r\n\r\n/**\r\n * A static one Vector2 for use by reference.\r\n * \r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.ONE\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.ONE = new Vector2(1, 1);\r\n\r\nmodule.exports = Vector2;\r\n"]},"metadata":{},"sourceType":"script"}