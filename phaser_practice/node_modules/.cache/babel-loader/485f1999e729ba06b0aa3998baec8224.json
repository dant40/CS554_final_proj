{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../../utils/Class');\n/**\r\n * @classdesc\r\n * A zone that places particles on a shape's edges.\r\n *\r\n * @class EdgeZone\r\n * @memberof Phaser.GameObjects.Particles.Zones\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Particles.EdgeZoneSource} source - An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.\r\n * @param {integer} quantity - The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.\r\n * @param {number} stepRate - The distance between each particle. When set, `quantity` is implied and should be set to 0.\r\n * @param {boolean} [yoyo=false] - Whether particles are placed from start to end and then end to start.\r\n * @param {boolean} [seamless=true] - Whether one endpoint will be removed if it's identical to the other.\r\n */\n\n\nvar EdgeZone = new Class({\n  initialize: function EdgeZone(source, quantity, stepRate, yoyo, seamless) {\n    if (yoyo === undefined) {\n      yoyo = false;\n    }\n\n    if (seamless === undefined) {\n      seamless = true;\n    }\n    /**\r\n     * An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.Zones.EdgeZone#source\r\n     * @type {Phaser.Types.GameObjects.Particles.EdgeZoneSource|Phaser.Types.GameObjects.Particles.RandomZoneSource}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.source = source;\n    /**\r\n     * The points placed on the source edge.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.Zones.EdgeZone#points\r\n     * @type {Phaser.Geom.Point[]}\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this.points = [];\n    /**\r\n     * The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.Zones.EdgeZone#quantity\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.quantity = quantity;\n    /**\r\n     * The distance between each particle. When set, `quantity` is implied and should be set to 0.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.Zones.EdgeZone#stepRate\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\n\n    this.stepRate = stepRate;\n    /**\r\n     * Whether particles are placed from start to end and then end to start.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.Zones.EdgeZone#yoyo\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.yoyo = yoyo;\n    /**\r\n     * The counter used for iterating the EdgeZone's points.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.Zones.EdgeZone#counter\r\n     * @type {number}\r\n     * @default -1\r\n     * @since 3.0.0\r\n     */\n\n    this.counter = -1;\n    /**\r\n     * Whether one endpoint will be removed if it's identical to the other.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.Zones.EdgeZone#seamless\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\n\n    this.seamless = seamless;\n    /**\r\n     * An internal count of the points belonging to this EdgeZone.\r\n     *\r\n     * @name Phaser.GameObjects.Particles.Zones.EdgeZone#_length\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this._length = 0;\n    /**\r\n     * An internal value used to keep track of the current iteration direction for the EdgeZone's points.\r\n     *\r\n     * 0 = forwards, 1 = backwards\r\n     *\r\n     * @name Phaser.GameObjects.Particles.Zones.EdgeZone#_direction\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this._direction = 0;\n    this.updateSource();\n  },\n\n  /**\r\n   * Update the {@link Phaser.GameObjects.Particles.Zones.EdgeZone#points} from the EdgeZone's\r\n   * {@link Phaser.GameObjects.Particles.Zones.EdgeZone#source}.\r\n   *\r\n   * Also updates internal properties.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.Zones.EdgeZone#updateSource\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.GameObjects.Particles.Zones.EdgeZone} This Edge Zone.\r\n   */\n  updateSource: function () {\n    this.points = this.source.getPoints(this.quantity, this.stepRate); //  Remove ends?\n\n    if (this.seamless) {\n      var a = this.points[0];\n      var b = this.points[this.points.length - 1];\n\n      if (a.x === b.x && a.y === b.y) {\n        this.points.pop();\n      }\n    }\n\n    var oldLength = this._length;\n    this._length = this.points.length; //  Adjust counter if we now have less points than before\n\n    if (this._length < oldLength && this.counter > this._length) {\n      this.counter = this._length - 1;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Change the source of the EdgeZone.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.Zones.EdgeZone#changeSource\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.GameObjects.Particles.EdgeZoneSource} source - An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.\r\n   *\r\n   * @return {Phaser.GameObjects.Particles.Zones.EdgeZone} This Edge Zone.\r\n   */\n  changeSource: function (source) {\n    this.source = source;\n    return this.updateSource();\n  },\n\n  /**\r\n   * Get the next point in the Zone and set its coordinates on the given Particle.\r\n   *\r\n   * @method Phaser.GameObjects.Particles.Zones.EdgeZone#getPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle.\r\n   */\n  getPoint: function (particle) {\n    if (this._direction === 0) {\n      this.counter++;\n\n      if (this.counter >= this._length) {\n        if (this.yoyo) {\n          this._direction = 1;\n          this.counter = this._length - 1;\n        } else {\n          this.counter = 0;\n        }\n      }\n    } else {\n      this.counter--;\n\n      if (this.counter === -1) {\n        if (this.yoyo) {\n          this._direction = 0;\n          this.counter = 0;\n        } else {\n          this.counter = this._length - 1;\n        }\n      }\n    }\n\n    var point = this.points[this.counter];\n\n    if (point) {\n      particle.x = point.x;\n      particle.y = point.y;\n    }\n  }\n});\nmodule.exports = EdgeZone;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/particles/zones/EdgeZone.js"],"names":["Class","require","EdgeZone","initialize","source","quantity","stepRate","yoyo","seamless","undefined","points","counter","_length","_direction","updateSource","getPoints","a","b","length","x","y","pop","oldLength","changeSource","getPoint","particle","point","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A zone that places particles on a shape's edges.\r\n *\r\n * @class EdgeZone\r\n * @memberof Phaser.GameObjects.Particles.Zones\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Particles.EdgeZoneSource} source - An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.\r\n * @param {integer} quantity - The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.\r\n * @param {number} stepRate - The distance between each particle. When set, `quantity` is implied and should be set to 0.\r\n * @param {boolean} [yoyo=false] - Whether particles are placed from start to end and then end to start.\r\n * @param {boolean} [seamless=true] - Whether one endpoint will be removed if it's identical to the other.\r\n */\r\nvar EdgeZone = new Class({\r\n\r\n    initialize:\r\n\r\n    function EdgeZone (source, quantity, stepRate, yoyo, seamless)\r\n    {\r\n        if (yoyo === undefined) { yoyo = false; }\r\n        if (seamless === undefined) { seamless = true; }\r\n\r\n        /**\r\n         * An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#source\r\n         * @type {Phaser.Types.GameObjects.Particles.EdgeZoneSource|Phaser.Types.GameObjects.Particles.RandomZoneSource}\r\n         * @since 3.0.0\r\n         */\r\n        this.source = source;\r\n\r\n        /**\r\n         * The points placed on the source edge.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#points\r\n         * @type {Phaser.Geom.Point[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.points = [];\r\n\r\n        /**\r\n         * The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#quantity\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.quantity = quantity;\r\n\r\n        /**\r\n         * The distance between each particle. When set, `quantity` is implied and should be set to 0.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#stepRate\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.stepRate = stepRate;\r\n\r\n        /**\r\n         * Whether particles are placed from start to end and then end to start.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#yoyo\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.yoyo = yoyo;\r\n\r\n        /**\r\n         * The counter used for iterating the EdgeZone's points.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#counter\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.counter = -1;\r\n\r\n        /**\r\n         * Whether one endpoint will be removed if it's identical to the other.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#seamless\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.seamless = seamless;\r\n\r\n        /**\r\n         * An internal count of the points belonging to this EdgeZone.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#_length\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._length = 0;\r\n\r\n        /**\r\n         * An internal value used to keep track of the current iteration direction for the EdgeZone's points.\r\n         *\r\n         * 0 = forwards, 1 = backwards\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#_direction\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._direction = 0;\r\n\r\n        this.updateSource();\r\n    },\r\n\r\n    /**\r\n     * Update the {@link Phaser.GameObjects.Particles.Zones.EdgeZone#points} from the EdgeZone's\r\n     * {@link Phaser.GameObjects.Particles.Zones.EdgeZone#source}.\r\n     *\r\n     * Also updates internal properties.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#updateSource\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.Zones.EdgeZone} This Edge Zone.\r\n     */\r\n    updateSource: function ()\r\n    {\r\n        this.points = this.source.getPoints(this.quantity, this.stepRate);\r\n\r\n        //  Remove ends?\r\n        if (this.seamless)\r\n        {\r\n            var a = this.points[0];\r\n            var b = this.points[this.points.length - 1];\r\n\r\n            if (a.x === b.x && a.y === b.y)\r\n            {\r\n                this.points.pop();\r\n            }\r\n        }\r\n\r\n        var oldLength = this._length;\r\n\r\n        this._length = this.points.length;\r\n\r\n        //  Adjust counter if we now have less points than before\r\n        if (this._length < oldLength && this.counter > this._length)\r\n        {\r\n            this.counter = this._length - 1;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Change the source of the EdgeZone.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#changeSource\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EdgeZoneSource} source - An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.Zones.EdgeZone} This Edge Zone.\r\n     */\r\n    changeSource: function (source)\r\n    {\r\n        this.source = source;\r\n\r\n        return this.updateSource();\r\n    },\r\n\r\n    /**\r\n     * Get the next point in the Zone and set its coordinates on the given Particle.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle.\r\n     */\r\n    getPoint: function (particle)\r\n    {\r\n        if (this._direction === 0)\r\n        {\r\n            this.counter++;\r\n\r\n            if (this.counter >= this._length)\r\n            {\r\n                if (this.yoyo)\r\n                {\r\n                    this._direction = 1;\r\n                    this.counter = this._length - 1;\r\n                }\r\n                else\r\n                {\r\n                    this.counter = 0;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.counter--;\r\n\r\n            if (this.counter === -1)\r\n            {\r\n                if (this.yoyo)\r\n                {\r\n                    this._direction = 0;\r\n                    this.counter = 0;\r\n                }\r\n                else\r\n                {\r\n                    this.counter = this._length - 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        var point = this.points[this.counter];\r\n\r\n        if (point)\r\n        {\r\n            particle.x = point.x;\r\n            particle.y = point.y;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = EdgeZone;\r\n"]},"metadata":{},"sourceType":"script"}