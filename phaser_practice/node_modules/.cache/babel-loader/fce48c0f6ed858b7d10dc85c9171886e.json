{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar CONST = require('./const');\n\nvar Events = require('./events');\n\nvar GameEvents = require('../core/events');\n\nvar GetValue = require('../utils/object/GetValue');\n\nvar LoaderEvents = require('../loader/events');\n\nvar NOOP = require('../utils/NOOP');\n\nvar Scene = require('./Scene');\n\nvar Systems = require('./Systems');\n/**\r\n * @classdesc\r\n * The Scene Manager.\r\n *\r\n * The Scene Manager is a Game level system, responsible for creating, processing and updating all of the\r\n * Scenes in a Game instance.\r\n *\r\n *\r\n * @class SceneManager\r\n * @memberof Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser.Game instance this Scene Manager belongs to.\r\n * @param {object} sceneConfig - Scene specific configuration settings.\r\n */\n\n\nvar SceneManager = new Class({\n  initialize: function SceneManager(game, sceneConfig) {\n    /**\r\n     * The Game that this SceneManager belongs to.\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#game\r\n     * @type {Phaser.Game}\r\n     * @since 3.0.0\r\n     */\n    this.game = game;\n    /**\r\n     * An object that maps the keys to the scene so we can quickly get a scene from a key without iteration.\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#keys\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.keys = {};\n    /**\r\n     * The array in which all of the scenes are kept.\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#scenes\r\n     * @type {array}\r\n     * @since 3.0.0\r\n     */\n\n    this.scenes = [];\n    /**\r\n     * Scenes pending to be added are stored in here until the manager has time to add it.\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#_pending\r\n     * @type {array}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._pending = [];\n    /**\r\n     * An array of scenes waiting to be started once the game has booted.\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#_start\r\n     * @type {array}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._start = [];\n    /**\r\n     * An operations queue, because we don't manipulate the scenes array during processing.\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#_queue\r\n     * @type {array}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._queue = [];\n    /**\r\n     * Boot time data to merge.\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#_data\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.4.0\r\n     */\n\n    this._data = {};\n    /**\r\n     * Is the Scene Manager actively processing the Scenes list?\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#isProcessing\r\n     * @type {boolean}\r\n     * @default false\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\n\n    this.isProcessing = false;\n    /**\r\n     * Has the Scene Manager properly started?\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#isBooted\r\n     * @type {boolean}\r\n     * @default false\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\n\n    this.isBooted = false;\n    /**\r\n     * Do any of the Cameras in any of the Scenes require a custom viewport?\r\n     * If not we can skip scissor tests.\r\n     *\r\n     * @name Phaser.Scenes.SceneManager#customViewports\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.12.0\r\n     */\n\n    this.customViewports = 0;\n\n    if (sceneConfig) {\n      if (!Array.isArray(sceneConfig)) {\n        sceneConfig = [sceneConfig];\n      }\n\n      for (var i = 0; i < sceneConfig.length; i++) {\n        //  The i === 0 part just autostarts the first Scene given (unless it says otherwise in its config)\n        this._pending.push({\n          key: 'default',\n          scene: sceneConfig[i],\n          autoStart: i === 0,\n          data: {}\n        });\n      }\n    }\n\n    game.events.once(GameEvents.READY, this.bootQueue, this);\n  },\n\n  /**\r\n   * Internal first-time Scene boot handler.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#bootQueue\r\n   * @private\r\n   * @since 3.2.0\r\n   */\n  bootQueue: function () {\n    if (this.isBooted) {\n      return;\n    }\n\n    var i;\n    var entry;\n    var key;\n    var sceneConfig;\n\n    for (i = 0; i < this._pending.length; i++) {\n      entry = this._pending[i];\n      key = entry.key;\n      sceneConfig = entry.scene;\n      var newScene;\n\n      if (sceneConfig instanceof Scene) {\n        newScene = this.createSceneFromInstance(key, sceneConfig);\n      } else if (typeof sceneConfig === 'object') {\n        newScene = this.createSceneFromObject(key, sceneConfig);\n      } else if (typeof sceneConfig === 'function') {\n        newScene = this.createSceneFromFunction(key, sceneConfig);\n      } //  Replace key in case the scene changed it\n\n\n      key = newScene.sys.settings.key;\n      this.keys[key] = newScene;\n      this.scenes.push(newScene); //  Any data to inject?\n\n      if (this._data[key]) {\n        newScene.sys.settings.data = this._data[key].data;\n\n        if (this._data[key].autoStart) {\n          entry.autoStart = true;\n        }\n      }\n\n      if (entry.autoStart || newScene.sys.settings.active) {\n        this._start.push(key);\n      }\n    } //  Clear the pending lists\n\n\n    this._pending.length = 0;\n    this._data = {};\n    this.isBooted = true; //  _start might have been populated by the above\n\n    for (i = 0; i < this._start.length; i++) {\n      entry = this._start[i];\n      this.start(entry);\n    }\n\n    this._start.length = 0;\n  },\n\n  /**\r\n   * Process the Scene operations queue.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#processQueue\r\n   * @since 3.0.0\r\n   */\n  processQueue: function () {\n    var pendingLength = this._pending.length;\n    var queueLength = this._queue.length;\n\n    if (pendingLength === 0 && queueLength === 0) {\n      return;\n    }\n\n    var i;\n    var entry;\n\n    if (pendingLength) {\n      for (i = 0; i < pendingLength; i++) {\n        entry = this._pending[i];\n        this.add(entry.key, entry.scene, entry.autoStart, entry.data);\n      } //  _start might have been populated by this.add\n\n\n      for (i = 0; i < this._start.length; i++) {\n        entry = this._start[i];\n        this.start(entry);\n      } //  Clear the pending lists\n\n\n      this._start.length = 0;\n      this._pending.length = 0;\n      return;\n    }\n\n    for (i = 0; i < this._queue.length; i++) {\n      entry = this._queue[i];\n      this[entry.op](entry.keyA, entry.keyB);\n    }\n\n    this._queue.length = 0;\n  },\n\n  /**\r\n   * Adds a new Scene into the SceneManager.\r\n   * You must give each Scene a unique key by which you'll identify it.\r\n   *\r\n   * The `sceneConfig` can be:\r\n   *\r\n   * * A `Phaser.Scene` object, or an object that extends it.\r\n   * * A plain JavaScript object\r\n   * * A JavaScript ES6 Class that extends `Phaser.Scene`\r\n   * * A JavaScript ES5 prototype based Class\r\n   * * A JavaScript function\r\n   *\r\n   * If a function is given then a new Scene will be created by calling it.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#add\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - A unique key used to reference the Scene, i.e. `MainMenu` or `Level1`.\r\n   * @param {(Phaser.Scene|Phaser.Types.Scenes.SettingsConfig|Phaser.Types.Scenes.CreateSceneFromObjectConfig|function)} sceneConfig - The config for the Scene\r\n   * @param {boolean} [autoStart=false] - If `true` the Scene will be started immediately after being added.\r\n   * @param {object} [data] - Optional data object. This will be set as Scene.settings.data and passed to `Scene.init`.\r\n   *\r\n   * @return {?Phaser.Scene} The added Scene, if it was added immediately, otherwise `null`.\r\n   */\n  add: function (key, sceneConfig, autoStart, data) {\n    if (autoStart === undefined) {\n      autoStart = false;\n    }\n\n    if (data === undefined) {\n      data = {};\n    } //  If processing or not booted then put scene into a holding pattern\n\n\n    if (this.isProcessing || !this.isBooted) {\n      this._pending.push({\n        key: key,\n        scene: sceneConfig,\n        autoStart: autoStart,\n        data: data\n      });\n\n      if (!this.isBooted) {\n        this._data[key] = {\n          data: data\n        };\n      }\n\n      return null;\n    }\n\n    key = this.getKey(key, sceneConfig);\n    var newScene;\n\n    if (sceneConfig instanceof Scene) {\n      newScene = this.createSceneFromInstance(key, sceneConfig);\n    } else if (typeof sceneConfig === 'object') {\n      sceneConfig.key = key;\n      newScene = this.createSceneFromObject(key, sceneConfig);\n    } else if (typeof sceneConfig === 'function') {\n      newScene = this.createSceneFromFunction(key, sceneConfig);\n    } //  Any data to inject?\n\n\n    newScene.sys.settings.data = data; //  Replace key in case the scene changed it\n\n    key = newScene.sys.settings.key;\n    this.keys[key] = newScene;\n    this.scenes.push(newScene);\n\n    if (autoStart || newScene.sys.settings.active) {\n      if (this._pending.length) {\n        this._start.push(key);\n      } else {\n        this.start(key);\n      }\n    }\n\n    return newScene;\n  },\n\n  /**\r\n   * Removes a Scene from the SceneManager.\r\n   *\r\n   * The Scene is removed from the local scenes array, it's key is cleared from the keys\r\n   * cache and Scene.Systems.destroy is then called on it.\r\n   *\r\n   * If the SceneManager is processing the Scenes when this method is called it will\r\n   * queue the operation for the next update sequence.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#remove\r\n   * @since 3.2.0\r\n   *\r\n   * @param {string} key - A unique key used to reference the Scene, i.e. `MainMenu` or `Level1`.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  remove: function (key) {\n    if (this.isProcessing) {\n      this._queue.push({\n        op: 'remove',\n        keyA: key,\n        keyB: null\n      });\n    } else {\n      var sceneToRemove = this.getScene(key);\n\n      if (!sceneToRemove || sceneToRemove.sys.isTransitioning()) {\n        return this;\n      }\n\n      var index = this.scenes.indexOf(sceneToRemove);\n      var sceneKey = sceneToRemove.sys.settings.key;\n\n      if (index > -1) {\n        delete this.keys[sceneKey];\n        this.scenes.splice(index, 1);\n\n        if (this._start.indexOf(sceneKey) > -1) {\n          index = this._start.indexOf(sceneKey);\n\n          this._start.splice(index, 1);\n        }\n\n        sceneToRemove.sys.destroy();\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Boot the given Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#bootScene\r\n   * @private\r\n   * @fires Phaser.Scenes.Events#TRANSITION_INIT\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Scene} scene - The Scene to boot.\r\n   */\n  bootScene: function (scene) {\n    var sys = scene.sys;\n    var settings = sys.settings;\n\n    if (scene.init) {\n      scene.init.call(scene, settings.data);\n      settings.status = CONST.INIT;\n\n      if (settings.isTransition) {\n        sys.events.emit(Events.TRANSITION_INIT, settings.transitionFrom, settings.transitionDuration);\n      }\n    }\n\n    var loader;\n\n    if (sys.load) {\n      loader = sys.load;\n      loader.reset();\n    }\n\n    if (loader && scene.preload) {\n      scene.preload.call(scene); //  Is the loader empty?\n\n      if (loader.list.size === 0) {\n        this.create(scene);\n      } else {\n        settings.status = CONST.LOADING; //  Start the loader going as we have something in the queue\n\n        loader.once(LoaderEvents.COMPLETE, this.loadComplete, this);\n        loader.start();\n      }\n    } else {\n      //  No preload? Then there was nothing to load either\n      this.create(scene);\n    }\n  },\n\n  /**\r\n   * Handles load completion for a Scene's Loader.\r\n   *\r\n   * Starts the Scene that the Loader belongs to.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#loadComplete\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Loader.LoaderPlugin} loader - The loader that has completed loading.\r\n   */\n  loadComplete: function (loader) {\n    var scene = loader.scene; //  TODO - Remove. This should *not* be handled here\n    //  Try to unlock HTML5 sounds every time any loader completes\n\n    if (this.game.sound && this.game.sound.onBlurPausedSounds) {\n      this.game.sound.unlock();\n    }\n\n    this.create(scene);\n  },\n\n  /**\r\n   * Handle payload completion for a Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#payloadComplete\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Loader.LoaderPlugin} loader - The loader that has completed loading its Scene's payload.\r\n   */\n  payloadComplete: function (loader) {\n    this.bootScene(loader.scene);\n  },\n\n  /**\r\n   * Updates the Scenes.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#update\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} time - Time elapsed.\r\n   * @param {number} delta - Delta time from the last update.\r\n   */\n  update: function (time, delta) {\n    this.processQueue();\n    this.isProcessing = true; //  Loop through the active scenes in reverse order\n\n    for (var i = this.scenes.length - 1; i >= 0; i--) {\n      var sys = this.scenes[i].sys;\n\n      if (sys.settings.status > CONST.START && sys.settings.status <= CONST.RUNNING) {\n        sys.step(time, delta);\n      }\n    }\n  },\n\n  /**\r\n   * Renders the Scenes.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#render\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer to use.\r\n   */\n  render: function (renderer) {\n    //  Loop through the scenes in forward order\n    for (var i = 0; i < this.scenes.length; i++) {\n      var sys = this.scenes[i].sys;\n\n      if (sys.settings.visible && sys.settings.status >= CONST.LOADING && sys.settings.status < CONST.SLEEPING) {\n        sys.render(renderer);\n      }\n    }\n\n    this.isProcessing = false;\n  },\n\n  /**\r\n   * Calls the given Scene's {@link Phaser.Scene#create} method and updates its status.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#create\r\n   * @private\r\n   * @fires Phaser.Scenes.Events#CREATE\r\n   * @fires Phaser.Scenes.Events#TRANSITION_INIT\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Scene} scene - The Scene to create.\r\n   */\n  create: function (scene) {\n    var sys = scene.sys;\n    var settings = sys.settings;\n\n    if (scene.create) {\n      settings.status = CONST.CREATING;\n      scene.create.call(scene, settings.data);\n\n      if (settings.status === CONST.DESTROYED) {\n        return;\n      }\n    }\n\n    if (settings.isTransition) {\n      sys.events.emit(Events.TRANSITION_START, settings.transitionFrom, settings.transitionDuration);\n    } //  If the Scene has an update function we'll set it now, otherwise it'll remain as NOOP\n\n\n    if (scene.update) {\n      sys.sceneUpdate = scene.update;\n    }\n\n    settings.status = CONST.RUNNING;\n    sys.events.emit(Events.CREATE, scene);\n  },\n\n  /**\r\n   * Creates and initializes a Scene from a function.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#createSceneFromFunction\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The key of the Scene.\r\n   * @param {function} scene - The function to create the Scene from.\r\n   *\r\n   * @return {Phaser.Scene} The created Scene.\r\n   */\n  createSceneFromFunction: function (key, scene) {\n    var newScene = new scene();\n\n    if (newScene instanceof Scene) {\n      var configKey = newScene.sys.settings.key;\n\n      if (configKey !== '') {\n        key = configKey;\n      }\n\n      if (this.keys.hasOwnProperty(key)) {\n        throw new Error('Cannot add a Scene with duplicate key: ' + key);\n      }\n\n      return this.createSceneFromInstance(key, newScene);\n    } else {\n      newScene.sys = new Systems(newScene);\n      newScene.sys.settings.key = key;\n      newScene.sys.init(this.game);\n      return newScene;\n    }\n  },\n\n  /**\r\n   * Creates and initializes a Scene instance.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#createSceneFromInstance\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The key of the Scene.\r\n   * @param {Phaser.Scene} newScene - The Scene instance.\r\n   *\r\n   * @return {Phaser.Scene} The created Scene.\r\n   */\n  createSceneFromInstance: function (key, newScene) {\n    var configKey = newScene.sys.settings.key;\n\n    if (configKey !== '') {\n      key = configKey;\n    } else {\n      newScene.sys.settings.key = key;\n    }\n\n    newScene.sys.init(this.game);\n    return newScene;\n  },\n\n  /**\r\n   * Creates and initializes a Scene from an Object definition.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#createSceneFromObject\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The key of the Scene.\r\n   * @param {(string|Phaser.Types.Scenes.SettingsConfig|Phaser.Types.Scenes.CreateSceneFromObjectConfig)} sceneConfig - The Scene config.\r\n   *\r\n   * @return {Phaser.Scene} The created Scene.\r\n   */\n  createSceneFromObject: function (key, sceneConfig) {\n    var newScene = new Scene(sceneConfig);\n    var configKey = newScene.sys.settings.key;\n\n    if (configKey !== '') {\n      key = configKey;\n    } else {\n      newScene.sys.settings.key = key;\n    }\n\n    newScene.sys.init(this.game); //  Extract callbacks\n\n    var defaults = ['init', 'preload', 'create', 'update', 'render'];\n\n    for (var i = 0; i < defaults.length; i++) {\n      var sceneCallback = GetValue(sceneConfig, defaults[i], null);\n\n      if (sceneCallback) {\n        newScene[defaults[i]] = sceneCallback;\n      }\n    } //  Now let's move across any other functions or properties that may exist in the extend object:\n\n    /*\r\n    scene: {\r\n        preload: preload,\r\n        create: create,\r\n        extend: {\r\n            hello: 1,\r\n            test: 'atari',\r\n            addImage: addImage\r\n        }\r\n    }\r\n    */\n\n\n    if (sceneConfig.hasOwnProperty('extend')) {\n      for (var propertyKey in sceneConfig.extend) {\n        if (!sceneConfig.extend.hasOwnProperty(propertyKey)) {\n          continue;\n        }\n\n        var value = sceneConfig.extend[propertyKey];\n\n        if (propertyKey === 'data' && newScene.hasOwnProperty('data') && typeof value === 'object') {\n          //  Populate the DataManager\n          newScene.data.merge(value);\n        } else if (propertyKey !== 'sys') {\n          newScene[propertyKey] = value;\n        }\n      }\n    }\n\n    return newScene;\n  },\n\n  /**\r\n   * Retrieves the key of a Scene from a Scene config.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#getKey\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The key to check in the Scene config.\r\n   * @param {(Phaser.Scene|Phaser.Types.Scenes.SettingsConfig|function)} sceneConfig - The Scene config.\r\n   *\r\n   * @return {string} The Scene key.\r\n   */\n  getKey: function (key, sceneConfig) {\n    if (!key) {\n      key = 'default';\n    }\n\n    if (typeof sceneConfig === 'function') {\n      return key;\n    } else if (sceneConfig instanceof Scene) {\n      key = sceneConfig.sys.settings.key;\n    } else if (typeof sceneConfig === 'object' && sceneConfig.hasOwnProperty('key')) {\n      key = sceneConfig.key;\n    } //  By this point it's either 'default' or extracted from the Scene\n\n\n    if (this.keys.hasOwnProperty(key)) {\n      throw new Error('Cannot add a Scene with duplicate key: ' + key);\n    } else {\n      return key;\n    }\n  },\n\n  /**\r\n   * Returns an array of all the current Scenes being managed by this Scene Manager.\r\n   *\r\n   * You can filter the output by the active state of the Scene and choose to have\r\n   * the array returned in normal or reversed order.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#getScenes\r\n   * @since 3.16.0\r\n   *\r\n   * @param {boolean} [isActive=true] - Only include Scene's that are currently active?\r\n   * @param {boolean} [inReverse=false] - Return the array of Scenes in reverse?\r\n   *\r\n   * @return {Phaser.Scene[]} An array containing all of the Scenes in the Scene Manager.\r\n   */\n  getScenes: function (isActive, inReverse) {\n    if (isActive === undefined) {\n      isActive = true;\n    }\n\n    if (inReverse === undefined) {\n      inReverse = false;\n    }\n\n    var out = [];\n    var scenes = this.scenes;\n\n    for (var i = 0; i < scenes.length; i++) {\n      var scene = scenes[i];\n\n      if (scene && (!isActive || isActive && scene.sys.isActive())) {\n        out.push(scene);\n      }\n    }\n\n    return inReverse ? out.reverse() : out;\n  },\n\n  /**\r\n   * Retrieves a Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#getScene\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string|Phaser.Scene} key - The Scene to retrieve.\r\n   *\r\n   * @return {?Phaser.Scene} The Scene.\r\n   */\n  getScene: function (key) {\n    if (typeof key === 'string') {\n      if (this.keys[key]) {\n        return this.keys[key];\n      }\n    } else {\n      for (var i = 0; i < this.scenes.length; i++) {\n        if (key === this.scenes[i]) {\n          return key;\n        }\n      }\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Determines whether a Scene is running.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#isActive\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to check.\r\n   *\r\n   * @return {boolean} Whether the Scene is running.\r\n   */\n  isActive: function (key) {\n    var scene = this.getScene(key);\n\n    if (scene) {\n      return scene.sys.isActive();\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Determines whether a Scene is paused.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#isPaused\r\n   * @since 3.17.0\r\n   *\r\n   * @param {string} key - The Scene to check.\r\n   *\r\n   * @return {boolean} Whether the Scene is paused.\r\n   */\n  isPaused: function (key) {\n    var scene = this.getScene(key);\n\n    if (scene) {\n      return scene.sys.isPaused();\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Determines whether a Scene is visible.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#isVisible\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to check.\r\n   *\r\n   * @return {boolean} Whether the Scene is visible.\r\n   */\n  isVisible: function (key) {\n    var scene = this.getScene(key);\n\n    if (scene) {\n      return scene.sys.isVisible();\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Determines whether a Scene is sleeping.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#isSleeping\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to check.\r\n   *\r\n   * @return {boolean} Whether the Scene is sleeping.\r\n   */\n  isSleeping: function (key) {\n    var scene = this.getScene(key);\n\n    if (scene) {\n      return scene.sys.isSleeping();\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Pauses the given Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#pause\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to pause.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its pause event.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  pause: function (key, data) {\n    var scene = this.getScene(key);\n\n    if (scene) {\n      scene.sys.pause(data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Resumes the given Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#resume\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to resume.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its resume event.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  resume: function (key, data) {\n    var scene = this.getScene(key);\n\n    if (scene) {\n      scene.sys.resume(data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Puts the given Scene to sleep.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#sleep\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to put to sleep.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its sleep event.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  sleep: function (key, data) {\n    var scene = this.getScene(key);\n\n    if (scene && !scene.sys.isTransitioning()) {\n      scene.sys.sleep(data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Awakens the given Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#wake\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to wake up.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its wake event.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  wake: function (key, data) {\n    var scene = this.getScene(key);\n\n    if (scene) {\n      scene.sys.wake(data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Runs the given Scene.\r\n   *\r\n   * If the given Scene is paused, it will resume it. If sleeping, it will wake it.\r\n   * If not running at all, it will be started.\r\n   *\r\n   * Use this if you wish to open a modal Scene by calling `pause` on the current\r\n   * Scene, then `run` on the modal Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#run\r\n   * @since 3.10.0\r\n   *\r\n   * @param {string} key - The Scene to run.\r\n   * @param {object} [data] - A data object that will be passed to the Scene on start, wake, or resume.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This Scene Manager.\r\n   */\n  run: function (key, data) {\n    var scene = this.getScene(key);\n\n    if (!scene) {\n      for (var i = 0; i < this._pending.length; i++) {\n        if (this._pending[i].key === key) {\n          this.queueOp('start', key, data);\n          break;\n        }\n      }\n\n      return this;\n    }\n\n    if (scene.sys.isSleeping()) {\n      //  Sleeping?\n      scene.sys.wake(data);\n    } else if (scene.sys.isPaused()) {\n      //  Paused?\n      scene.sys.resume(data);\n    } else {\n      //  Not actually running?\n      this.start(key, data);\n    }\n  },\n\n  /**\r\n   * Starts the given Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#start\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to start.\r\n   * @param {object} [data] - Optional data object to pass to Scene.Settings and Scene.init.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  start: function (key, data) {\n    //  If the Scene Manager is not running, then put the Scene into a holding pattern\n    if (!this.isBooted) {\n      this._data[key] = {\n        autoStart: true,\n        data: data\n      };\n      return this;\n    }\n\n    var scene = this.getScene(key);\n\n    if (scene) {\n      //  If the Scene is already running (perhaps they called start from a launched sub-Scene?)\n      //  then we close it down before starting it again.\n      if (scene.sys.isActive() || scene.sys.isPaused()) {\n        scene.sys.shutdown();\n        scene.sys.start(data);\n      } else {\n        scene.sys.start(data);\n        var loader;\n\n        if (scene.sys.load) {\n          loader = scene.sys.load;\n        } //  Files payload?\n\n\n        if (loader && scene.sys.settings.hasOwnProperty('pack')) {\n          loader.reset();\n\n          if (loader.addPack({\n            payload: scene.sys.settings.pack\n          })) {\n            scene.sys.settings.status = CONST.LOADING;\n            loader.once(LoaderEvents.COMPLETE, this.payloadComplete, this);\n            loader.start();\n            return this;\n          }\n        }\n      }\n\n      this.bootScene(scene);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Stops the given Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#stop\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to stop.\r\n   * @param {object} [data] - Optional data object to pass to Scene.shutdown.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  stop: function (key, data) {\n    var scene = this.getScene(key);\n\n    if (scene && !scene.sys.isTransitioning()) {\n      scene.sys.shutdown(data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sleeps one one Scene and starts the other.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#switch\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} from - The Scene to sleep.\r\n   * @param {string} to - The Scene to start.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  switch: function (from, to) {\n    var sceneA = this.getScene(from);\n    var sceneB = this.getScene(to);\n\n    if (sceneA && sceneB && sceneA !== sceneB) {\n      this.sleep(from);\n\n      if (this.isSleeping(to)) {\n        this.wake(to);\n      } else {\n        this.start(to);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Retrieves a Scene by numeric index.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#getAt\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} index - The index of the Scene to retrieve.\r\n   *\r\n   * @return {(Phaser.Scene|undefined)} The Scene.\r\n   */\n  getAt: function (index) {\n    return this.scenes[index];\n  },\n\n  /**\r\n   * Retrieves the numeric index of a Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#getIndex\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} key - The key of the Scene.\r\n   *\r\n   * @return {integer} The index of the Scene.\r\n   */\n  getIndex: function (key) {\n    var scene = this.getScene(key);\n    return this.scenes.indexOf(scene);\n  },\n\n  /**\r\n   * Brings a Scene to the top of the Scenes list.\r\n   *\r\n   * This means it will render above all other Scenes.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#bringToTop\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  bringToTop: function (key) {\n    if (this.isProcessing) {\n      this._queue.push({\n        op: 'bringToTop',\n        keyA: key,\n        keyB: null\n      });\n    } else {\n      var index = this.getIndex(key);\n\n      if (index !== -1 && index < this.scenes.length) {\n        var scene = this.getScene(key);\n        this.scenes.splice(index, 1);\n        this.scenes.push(scene);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sends a Scene to the back of the Scenes list.\r\n   *\r\n   * This means it will render below all other Scenes.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#sendToBack\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  sendToBack: function (key) {\n    if (this.isProcessing) {\n      this._queue.push({\n        op: 'sendToBack',\n        keyA: key,\n        keyB: null\n      });\n    } else {\n      var index = this.getIndex(key);\n\n      if (index !== -1 && index > 0) {\n        var scene = this.getScene(key);\n        this.scenes.splice(index, 1);\n        this.scenes.unshift(scene);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Moves a Scene down one position in the Scenes list.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#moveDown\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  moveDown: function (key) {\n    if (this.isProcessing) {\n      this._queue.push({\n        op: 'moveDown',\n        keyA: key,\n        keyB: null\n      });\n    } else {\n      var indexA = this.getIndex(key);\n\n      if (indexA > 0) {\n        var indexB = indexA - 1;\n        var sceneA = this.getScene(key);\n        var sceneB = this.getAt(indexB);\n        this.scenes[indexA] = sceneB;\n        this.scenes[indexB] = sceneA;\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Moves a Scene up one position in the Scenes list.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#moveUp\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  moveUp: function (key) {\n    if (this.isProcessing) {\n      this._queue.push({\n        op: 'moveUp',\n        keyA: key,\n        keyB: null\n      });\n    } else {\n      var indexA = this.getIndex(key);\n\n      if (indexA < this.scenes.length - 1) {\n        var indexB = indexA + 1;\n        var sceneA = this.getScene(key);\n        var sceneB = this.getAt(indexB);\n        this.scenes[indexA] = sceneB;\n        this.scenes[indexB] = sceneA;\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Moves a Scene so it is immediately above another Scene in the Scenes list.\r\n   *\r\n   * This means it will render over the top of the other Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#moveAbove\r\n   * @since 3.2.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved above.\r\n   * @param {(string|Phaser.Scene)} keyB - The Scene to be moved.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  moveAbove: function (keyA, keyB) {\n    if (keyA === keyB) {\n      return this;\n    }\n\n    if (this.isProcessing) {\n      this._queue.push({\n        op: 'moveAbove',\n        keyA: keyA,\n        keyB: keyB\n      });\n    } else {\n      var indexA = this.getIndex(keyA);\n      var indexB = this.getIndex(keyB);\n\n      if (indexA !== -1 && indexB !== -1) {\n        var tempScene = this.getAt(indexB); //  Remove\n\n        this.scenes.splice(indexB, 1); //  Add in new location\n\n        this.scenes.splice(indexA + 1, 0, tempScene);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Moves a Scene so it is immediately below another Scene in the Scenes list.\r\n   *\r\n   * This means it will render behind the other Scene.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#moveBelow\r\n   * @since 3.2.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved above.\r\n   * @param {(string|Phaser.Scene)} keyB - The Scene to be moved.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  moveBelow: function (keyA, keyB) {\n    if (keyA === keyB) {\n      return this;\n    }\n\n    if (this.isProcessing) {\n      this._queue.push({\n        op: 'moveBelow',\n        keyA: keyA,\n        keyB: keyB\n      });\n    } else {\n      var indexA = this.getIndex(keyA);\n      var indexB = this.getIndex(keyB);\n\n      if (indexA !== -1 && indexB !== -1) {\n        var tempScene = this.getAt(indexB); //  Remove\n\n        this.scenes.splice(indexB, 1);\n\n        if (indexA === 0) {\n          this.scenes.unshift(tempScene);\n        } else {\n          //  Add in new location\n          this.scenes.splice(indexA, 0, tempScene);\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Queue a Scene operation for the next update.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#queueOp\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} op - The operation to perform.\r\n   * @param {(string|Phaser.Scene)} keyA - Scene A.\r\n   * @param {(any|string|Phaser.Scene)} [keyB] - Scene B, or a data object.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  queueOp: function (op, keyA, keyB) {\n    this._queue.push({\n      op: op,\n      keyA: keyA,\n      keyB: keyB\n    });\n\n    return this;\n  },\n\n  /**\r\n   * Swaps the positions of two Scenes in the Scenes list.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#swapPosition\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} keyA - The first Scene to swap.\r\n   * @param {(string|Phaser.Scene)} keyB - The second Scene to swap.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  swapPosition: function (keyA, keyB) {\n    if (keyA === keyB) {\n      return this;\n    }\n\n    if (this.isProcessing) {\n      this._queue.push({\n        op: 'swapPosition',\n        keyA: keyA,\n        keyB: keyB\n      });\n    } else {\n      var indexA = this.getIndex(keyA);\n      var indexB = this.getIndex(keyB);\n\n      if (indexA !== indexB && indexA !== -1 && indexB !== -1) {\n        var tempScene = this.getAt(indexA);\n        this.scenes[indexA] = this.scenes[indexB];\n        this.scenes[indexB] = tempScene;\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Dumps debug information about each Scene to the developer console.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#dump\r\n   * @since 3.2.0\r\n   */\n  dump: function () {\n    var out = [];\n    var map = ['pending', 'init', 'start', 'loading', 'creating', 'running', 'paused', 'sleeping', 'shutdown', 'destroyed'];\n\n    for (var i = 0; i < this.scenes.length; i++) {\n      var sys = this.scenes[i].sys;\n      var key = sys.settings.visible && (sys.settings.status === CONST.RUNNING || sys.settings.status === CONST.PAUSED) ? '[*] ' : '[-] ';\n      key += sys.settings.key + ' (' + map[sys.settings.status] + ')';\n      out.push(key);\n    }\n\n    console.log(out.join('\\n'));\n  },\n\n  /**\r\n   * Destroy the SceneManager and all of its Scene's systems.\r\n   *\r\n   * @method Phaser.Scenes.SceneManager#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    for (var i = 0; i < this.scenes.length; i++) {\n      var sys = this.scenes[i].sys;\n      sys.destroy();\n    }\n\n    this.update = NOOP;\n    this.scenes = [];\n    this._pending = [];\n    this._start = [];\n    this._queue = [];\n    this.game = null;\n  }\n});\nmodule.exports = SceneManager;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/scene/SceneManager.js"],"names":["Class","require","CONST","Events","GameEvents","GetValue","LoaderEvents","NOOP","Scene","Systems","SceneManager","initialize","game","sceneConfig","keys","scenes","_pending","_start","_queue","_data","isProcessing","isBooted","customViewports","Array","isArray","i","length","push","key","scene","autoStart","data","events","once","READY","bootQueue","entry","newScene","createSceneFromInstance","createSceneFromObject","createSceneFromFunction","sys","settings","active","start","processQueue","pendingLength","queueLength","add","op","keyA","keyB","undefined","getKey","remove","sceneToRemove","getScene","isTransitioning","index","indexOf","sceneKey","splice","destroy","bootScene","init","call","status","INIT","isTransition","emit","TRANSITION_INIT","transitionFrom","transitionDuration","loader","load","reset","preload","list","size","create","LOADING","COMPLETE","loadComplete","sound","onBlurPausedSounds","unlock","payloadComplete","update","time","delta","START","RUNNING","step","render","renderer","visible","SLEEPING","CREATING","DESTROYED","TRANSITION_START","sceneUpdate","CREATE","configKey","hasOwnProperty","Error","defaults","sceneCallback","propertyKey","extend","value","merge","getScenes","isActive","inReverse","out","reverse","isPaused","isVisible","isSleeping","pause","resume","sleep","wake","run","queueOp","shutdown","addPack","payload","pack","stop","switch","from","to","sceneA","sceneB","getAt","getIndex","bringToTop","sendToBack","unshift","moveDown","indexA","indexB","moveUp","moveAbove","tempScene","moveBelow","swapPosition","dump","map","PAUSED","console","log","join","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar Events = require('./events');\r\nvar GameEvents = require('../core/events');\r\nvar GetValue = require('../utils/object/GetValue');\r\nvar LoaderEvents = require('../loader/events');\r\nvar NOOP = require('../utils/NOOP');\r\nvar Scene = require('./Scene');\r\nvar Systems = require('./Systems');\r\n\r\n/**\r\n * @classdesc\r\n * The Scene Manager.\r\n *\r\n * The Scene Manager is a Game level system, responsible for creating, processing and updating all of the\r\n * Scenes in a Game instance.\r\n *\r\n *\r\n * @class SceneManager\r\n * @memberof Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser.Game instance this Scene Manager belongs to.\r\n * @param {object} sceneConfig - Scene specific configuration settings.\r\n */\r\nvar SceneManager = new Class({\r\n\r\n    initialize:\r\n\r\n    function SceneManager (game, sceneConfig)\r\n    {\r\n        /**\r\n         * The Game that this SceneManager belongs to.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * An object that maps the keys to the scene so we can quickly get a scene from a key without iteration.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#keys\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.keys = {};\r\n\r\n        /**\r\n         * The array in which all of the scenes are kept.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#scenes\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.scenes = [];\r\n\r\n        /**\r\n         * Scenes pending to be added are stored in here until the manager has time to add it.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_pending\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._pending = [];\r\n\r\n        /**\r\n         * An array of scenes waiting to be started once the game has booted.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_start\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._start = [];\r\n\r\n        /**\r\n         * An operations queue, because we don't manipulate the scenes array during processing.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_queue\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._queue = [];\r\n\r\n        /**\r\n         * Boot time data to merge.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_data\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this._data = {};\r\n\r\n        /**\r\n         * Is the Scene Manager actively processing the Scenes list?\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#isProcessing\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.isProcessing = false;\r\n\r\n        /**\r\n         * Has the Scene Manager properly started?\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#isBooted\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readonly\r\n         * @since 3.4.0\r\n         */\r\n        this.isBooted = false;\r\n\r\n        /**\r\n         * Do any of the Cameras in any of the Scenes require a custom viewport?\r\n         * If not we can skip scissor tests.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#customViewports\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.12.0\r\n         */\r\n        this.customViewports = 0;\r\n\r\n        if (sceneConfig)\r\n        {\r\n            if (!Array.isArray(sceneConfig))\r\n            {\r\n                sceneConfig = [ sceneConfig ];\r\n            }\r\n\r\n            for (var i = 0; i < sceneConfig.length; i++)\r\n            {\r\n                //  The i === 0 part just autostarts the first Scene given (unless it says otherwise in its config)\r\n                this._pending.push({\r\n                    key: 'default',\r\n                    scene: sceneConfig[i],\r\n                    autoStart: (i === 0),\r\n                    data: {}\r\n                });\r\n            }\r\n        }\r\n\r\n        game.events.once(GameEvents.READY, this.bootQueue, this);\r\n    },\r\n\r\n    /**\r\n     * Internal first-time Scene boot handler.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#bootQueue\r\n     * @private\r\n     * @since 3.2.0\r\n     */\r\n    bootQueue: function ()\r\n    {\r\n        if (this.isBooted)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var i;\r\n        var entry;\r\n        var key;\r\n        var sceneConfig;\r\n\r\n        for (i = 0; i < this._pending.length; i++)\r\n        {\r\n            entry = this._pending[i];\r\n\r\n            key = entry.key;\r\n            sceneConfig = entry.scene;\r\n\r\n            var newScene;\r\n\r\n            if (sceneConfig instanceof Scene)\r\n            {\r\n                newScene = this.createSceneFromInstance(key, sceneConfig);\r\n            }\r\n            else if (typeof sceneConfig === 'object')\r\n            {\r\n                newScene = this.createSceneFromObject(key, sceneConfig);\r\n            }\r\n            else if (typeof sceneConfig === 'function')\r\n            {\r\n                newScene = this.createSceneFromFunction(key, sceneConfig);\r\n            }\r\n\r\n            //  Replace key in case the scene changed it\r\n            key = newScene.sys.settings.key;\r\n\r\n            this.keys[key] = newScene;\r\n\r\n            this.scenes.push(newScene);\r\n\r\n            //  Any data to inject?\r\n            if (this._data[key])\r\n            {\r\n                newScene.sys.settings.data = this._data[key].data;\r\n\r\n                if (this._data[key].autoStart)\r\n                {\r\n                    entry.autoStart = true;\r\n                }\r\n            }\r\n\r\n            if (entry.autoStart || newScene.sys.settings.active)\r\n            {\r\n                this._start.push(key);\r\n            }\r\n        }\r\n\r\n        //  Clear the pending lists\r\n        this._pending.length = 0;\r\n\r\n        this._data = {};\r\n\r\n        this.isBooted = true;\r\n\r\n        //  _start might have been populated by the above\r\n        for (i = 0; i < this._start.length; i++)\r\n        {\r\n            entry = this._start[i];\r\n\r\n            this.start(entry);\r\n        }\r\n\r\n        this._start.length = 0;\r\n    },\r\n\r\n    /**\r\n     * Process the Scene operations queue.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#processQueue\r\n     * @since 3.0.0\r\n     */\r\n    processQueue: function ()\r\n    {\r\n        var pendingLength = this._pending.length;\r\n        var queueLength = this._queue.length;\r\n\r\n        if (pendingLength === 0 && queueLength === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var i;\r\n        var entry;\r\n\r\n        if (pendingLength)\r\n        {\r\n            for (i = 0; i < pendingLength; i++)\r\n            {\r\n                entry = this._pending[i];\r\n\r\n                this.add(entry.key, entry.scene, entry.autoStart, entry.data);\r\n            }\r\n\r\n            //  _start might have been populated by this.add\r\n            for (i = 0; i < this._start.length; i++)\r\n            {\r\n                entry = this._start[i];\r\n\r\n                this.start(entry);\r\n            }\r\n\r\n            //  Clear the pending lists\r\n            this._start.length = 0;\r\n            this._pending.length = 0;\r\n\r\n            return;\r\n        }\r\n\r\n        for (i = 0; i < this._queue.length; i++)\r\n        {\r\n            entry = this._queue[i];\r\n\r\n            this[entry.op](entry.keyA, entry.keyB);\r\n        }\r\n\r\n        this._queue.length = 0;\r\n    },\r\n\r\n    /**\r\n     * Adds a new Scene into the SceneManager.\r\n     * You must give each Scene a unique key by which you'll identify it.\r\n     *\r\n     * The `sceneConfig` can be:\r\n     *\r\n     * * A `Phaser.Scene` object, or an object that extends it.\r\n     * * A plain JavaScript object\r\n     * * A JavaScript ES6 Class that extends `Phaser.Scene`\r\n     * * A JavaScript ES5 prototype based Class\r\n     * * A JavaScript function\r\n     *\r\n     * If a function is given then a new Scene will be created by calling it.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - A unique key used to reference the Scene, i.e. `MainMenu` or `Level1`.\r\n     * @param {(Phaser.Scene|Phaser.Types.Scenes.SettingsConfig|Phaser.Types.Scenes.CreateSceneFromObjectConfig|function)} sceneConfig - The config for the Scene\r\n     * @param {boolean} [autoStart=false] - If `true` the Scene will be started immediately after being added.\r\n     * @param {object} [data] - Optional data object. This will be set as Scene.settings.data and passed to `Scene.init`.\r\n     *\r\n     * @return {?Phaser.Scene} The added Scene, if it was added immediately, otherwise `null`.\r\n     */\r\n    add: function (key, sceneConfig, autoStart, data)\r\n    {\r\n        if (autoStart === undefined) { autoStart = false; }\r\n        if (data === undefined) { data = {}; }\r\n\r\n        //  If processing or not booted then put scene into a holding pattern\r\n        if (this.isProcessing || !this.isBooted)\r\n        {\r\n            this._pending.push({\r\n                key: key,\r\n                scene: sceneConfig,\r\n                autoStart: autoStart,\r\n                data: data\r\n            });\r\n\r\n            if (!this.isBooted)\r\n            {\r\n                this._data[key] = { data: data };\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        key = this.getKey(key, sceneConfig);\r\n\r\n        var newScene;\r\n\r\n        if (sceneConfig instanceof Scene)\r\n        {\r\n            newScene = this.createSceneFromInstance(key, sceneConfig);\r\n        }\r\n        else if (typeof sceneConfig === 'object')\r\n        {\r\n            sceneConfig.key = key;\r\n\r\n            newScene = this.createSceneFromObject(key, sceneConfig);\r\n        }\r\n        else if (typeof sceneConfig === 'function')\r\n        {\r\n            newScene = this.createSceneFromFunction(key, sceneConfig);\r\n        }\r\n\r\n        //  Any data to inject?\r\n        newScene.sys.settings.data = data;\r\n\r\n        //  Replace key in case the scene changed it\r\n        key = newScene.sys.settings.key;\r\n\r\n        this.keys[key] = newScene;\r\n\r\n        this.scenes.push(newScene);\r\n\r\n        if (autoStart || newScene.sys.settings.active)\r\n        {\r\n            if (this._pending.length)\r\n            {\r\n                this._start.push(key);\r\n            }\r\n            else\r\n            {\r\n                this.start(key);\r\n            }\r\n        }\r\n\r\n        return newScene;\r\n    },\r\n\r\n    /**\r\n     * Removes a Scene from the SceneManager.\r\n     *\r\n     * The Scene is removed from the local scenes array, it's key is cleared from the keys\r\n     * cache and Scene.Systems.destroy is then called on it.\r\n     *\r\n     * If the SceneManager is processing the Scenes when this method is called it will\r\n     * queue the operation for the next update sequence.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#remove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} key - A unique key used to reference the Scene, i.e. `MainMenu` or `Level1`.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    remove: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'remove', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var sceneToRemove = this.getScene(key);\r\n\r\n            if (!sceneToRemove || sceneToRemove.sys.isTransitioning())\r\n            {\r\n                return this;\r\n            }\r\n\r\n            var index = this.scenes.indexOf(sceneToRemove);\r\n            var sceneKey = sceneToRemove.sys.settings.key;\r\n\r\n            if (index > -1)\r\n            {\r\n                delete this.keys[sceneKey];\r\n                this.scenes.splice(index, 1);\r\n\r\n                if (this._start.indexOf(sceneKey) > -1)\r\n                {\r\n                    index = this._start.indexOf(sceneKey);\r\n                    this._start.splice(index, 1);\r\n                }\r\n\r\n                sceneToRemove.sys.destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Boot the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#bootScene\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#TRANSITION_INIT\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene to boot.\r\n     */\r\n    bootScene: function (scene)\r\n    {\r\n        var sys = scene.sys;\r\n        var settings = sys.settings;\r\n\r\n        if (scene.init)\r\n        {\r\n            scene.init.call(scene, settings.data);\r\n\r\n            settings.status = CONST.INIT;\r\n\r\n            if (settings.isTransition)\r\n            {\r\n                sys.events.emit(Events.TRANSITION_INIT, settings.transitionFrom, settings.transitionDuration);\r\n            }\r\n        }\r\n\r\n        var loader;\r\n\r\n        if (sys.load)\r\n        {\r\n            loader = sys.load;\r\n\r\n            loader.reset();\r\n        }\r\n\r\n        if (loader && scene.preload)\r\n        {\r\n            scene.preload.call(scene);\r\n\r\n            //  Is the loader empty?\r\n            if (loader.list.size === 0)\r\n            {\r\n                this.create(scene);\r\n            }\r\n            else\r\n            {\r\n                settings.status = CONST.LOADING;\r\n\r\n                //  Start the loader going as we have something in the queue\r\n                loader.once(LoaderEvents.COMPLETE, this.loadComplete, this);\r\n\r\n                loader.start();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //  No preload? Then there was nothing to load either\r\n            this.create(scene);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Handles load completion for a Scene's Loader.\r\n     *\r\n     * Starts the Scene that the Loader belongs to.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#loadComplete\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.LoaderPlugin} loader - The loader that has completed loading.\r\n     */\r\n    loadComplete: function (loader)\r\n    {\r\n        var scene = loader.scene;\r\n\r\n        //  TODO - Remove. This should *not* be handled here\r\n        //  Try to unlock HTML5 sounds every time any loader completes\r\n        if (this.game.sound && this.game.sound.onBlurPausedSounds)\r\n        {\r\n            this.game.sound.unlock();\r\n        }\r\n\r\n        this.create(scene);\r\n    },\r\n\r\n    /**\r\n     * Handle payload completion for a Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#payloadComplete\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.LoaderPlugin} loader - The loader that has completed loading its Scene's payload.\r\n     */\r\n    payloadComplete: function (loader)\r\n    {\r\n        this.bootScene(loader.scene);\r\n    },\r\n\r\n    /**\r\n     * Updates the Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - Time elapsed.\r\n     * @param {number} delta - Delta time from the last update.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        this.processQueue();\r\n\r\n        this.isProcessing = true;\r\n\r\n        //  Loop through the active scenes in reverse order\r\n        for (var i = this.scenes.length - 1; i >= 0; i--)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            if (sys.settings.status > CONST.START && sys.settings.status <= CONST.RUNNING)\r\n            {\r\n                sys.step(time, delta);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Renders the Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#render\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer to use.\r\n     */\r\n    render: function (renderer)\r\n    {\r\n        //  Loop through the scenes in forward order\r\n        for (var i = 0; i < this.scenes.length; i++)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            if (sys.settings.visible && sys.settings.status >= CONST.LOADING && sys.settings.status < CONST.SLEEPING)\r\n            {\r\n                sys.render(renderer);\r\n            }\r\n        }\r\n\r\n        this.isProcessing = false;\r\n    },\r\n\r\n    /**\r\n     * Calls the given Scene's {@link Phaser.Scene#create} method and updates its status.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#create\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#CREATE\r\n     * @fires Phaser.Scenes.Events#TRANSITION_INIT\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene to create.\r\n     */\r\n    create: function (scene)\r\n    {\r\n        var sys = scene.sys;\r\n        var settings = sys.settings;\r\n\r\n        if (scene.create)\r\n        {\r\n            settings.status = CONST.CREATING;\r\n\r\n            scene.create.call(scene, settings.data);\r\n\r\n            if (settings.status === CONST.DESTROYED)\r\n            {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (settings.isTransition)\r\n        {\r\n            sys.events.emit(Events.TRANSITION_START, settings.transitionFrom, settings.transitionDuration);\r\n        }\r\n\r\n        //  If the Scene has an update function we'll set it now, otherwise it'll remain as NOOP\r\n        if (scene.update)\r\n        {\r\n            sys.sceneUpdate = scene.update;\r\n        }\r\n\r\n        settings.status = CONST.RUNNING;\r\n\r\n        sys.events.emit(Events.CREATE, scene);\r\n    },\r\n\r\n    /**\r\n     * Creates and initializes a Scene from a function.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#createSceneFromFunction\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Scene.\r\n     * @param {function} scene - The function to create the Scene from.\r\n     *\r\n     * @return {Phaser.Scene} The created Scene.\r\n     */\r\n    createSceneFromFunction: function (key, scene)\r\n    {\r\n        var newScene = new scene();\r\n\r\n        if (newScene instanceof Scene)\r\n        {\r\n            var configKey = newScene.sys.settings.key;\r\n\r\n            if (configKey !== '')\r\n            {\r\n                key = configKey;\r\n            }\r\n\r\n            if (this.keys.hasOwnProperty(key))\r\n            {\r\n                throw new Error('Cannot add a Scene with duplicate key: ' + key);\r\n            }\r\n\r\n            return this.createSceneFromInstance(key, newScene);\r\n        }\r\n        else\r\n        {\r\n            newScene.sys = new Systems(newScene);\r\n\r\n            newScene.sys.settings.key = key;\r\n\r\n            newScene.sys.init(this.game);\r\n\r\n            return newScene;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates and initializes a Scene instance.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#createSceneFromInstance\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Scene.\r\n     * @param {Phaser.Scene} newScene - The Scene instance.\r\n     *\r\n     * @return {Phaser.Scene} The created Scene.\r\n     */\r\n    createSceneFromInstance: function (key, newScene)\r\n    {\r\n        var configKey = newScene.sys.settings.key;\r\n\r\n        if (configKey !== '')\r\n        {\r\n            key = configKey;\r\n        }\r\n        else\r\n        {\r\n            newScene.sys.settings.key = key;\r\n        }\r\n\r\n        newScene.sys.init(this.game);\r\n\r\n        return newScene;\r\n    },\r\n\r\n    /**\r\n     * Creates and initializes a Scene from an Object definition.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#createSceneFromObject\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Scene.\r\n     * @param {(string|Phaser.Types.Scenes.SettingsConfig|Phaser.Types.Scenes.CreateSceneFromObjectConfig)} sceneConfig - The Scene config.\r\n     *\r\n     * @return {Phaser.Scene} The created Scene.\r\n     */\r\n    createSceneFromObject: function (key, sceneConfig)\r\n    {\r\n        var newScene = new Scene(sceneConfig);\r\n\r\n        var configKey = newScene.sys.settings.key;\r\n\r\n        if (configKey !== '')\r\n        {\r\n            key = configKey;\r\n        }\r\n        else\r\n        {\r\n            newScene.sys.settings.key = key;\r\n        }\r\n\r\n        newScene.sys.init(this.game);\r\n\r\n        //  Extract callbacks\r\n\r\n        var defaults = [ 'init', 'preload', 'create', 'update', 'render' ];\r\n\r\n        for (var i = 0; i < defaults.length; i++)\r\n        {\r\n            var sceneCallback = GetValue(sceneConfig, defaults[i], null);\r\n\r\n            if (sceneCallback)\r\n            {\r\n                newScene[defaults[i]] = sceneCallback;\r\n            }\r\n        }\r\n\r\n        //  Now let's move across any other functions or properties that may exist in the extend object:\r\n\r\n        /*\r\n        scene: {\r\n            preload: preload,\r\n            create: create,\r\n            extend: {\r\n                hello: 1,\r\n                test: 'atari',\r\n                addImage: addImage\r\n            }\r\n        }\r\n        */\r\n\r\n        if (sceneConfig.hasOwnProperty('extend'))\r\n        {\r\n            for (var propertyKey in sceneConfig.extend)\r\n            {\r\n                if (!sceneConfig.extend.hasOwnProperty(propertyKey))\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                var value = sceneConfig.extend[propertyKey];\r\n\r\n                if (propertyKey === 'data' && newScene.hasOwnProperty('data') && typeof value === 'object')\r\n                {\r\n                    //  Populate the DataManager\r\n                    newScene.data.merge(value);\r\n                }\r\n                else if (propertyKey !== 'sys')\r\n                {\r\n                    newScene[propertyKey] = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        return newScene;\r\n    },\r\n\r\n    /**\r\n     * Retrieves the key of a Scene from a Scene config.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getKey\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key to check in the Scene config.\r\n     * @param {(Phaser.Scene|Phaser.Types.Scenes.SettingsConfig|function)} sceneConfig - The Scene config.\r\n     *\r\n     * @return {string} The Scene key.\r\n     */\r\n    getKey: function (key, sceneConfig)\r\n    {\r\n        if (!key) { key = 'default'; }\r\n\r\n        if (typeof sceneConfig === 'function')\r\n        {\r\n            return key;\r\n        }\r\n        else if (sceneConfig instanceof Scene)\r\n        {\r\n            key = sceneConfig.sys.settings.key;\r\n        }\r\n        else if (typeof sceneConfig === 'object' && sceneConfig.hasOwnProperty('key'))\r\n        {\r\n            key = sceneConfig.key;\r\n        }\r\n\r\n        //  By this point it's either 'default' or extracted from the Scene\r\n\r\n        if (this.keys.hasOwnProperty(key))\r\n        {\r\n            throw new Error('Cannot add a Scene with duplicate key: ' + key);\r\n        }\r\n        else\r\n        {\r\n            return key;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns an array of all the current Scenes being managed by this Scene Manager.\r\n     *\r\n     * You can filter the output by the active state of the Scene and choose to have\r\n     * the array returned in normal or reversed order.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getScenes\r\n     * @since 3.16.0\r\n     *\r\n     * @param {boolean} [isActive=true] - Only include Scene's that are currently active?\r\n     * @param {boolean} [inReverse=false] - Return the array of Scenes in reverse?\r\n     *\r\n     * @return {Phaser.Scene[]} An array containing all of the Scenes in the Scene Manager.\r\n     */\r\n    getScenes: function (isActive, inReverse)\r\n    {\r\n        if (isActive === undefined) { isActive = true; }\r\n        if (inReverse === undefined) { inReverse = false; }\r\n\r\n        var out = [];\r\n        var scenes = this.scenes;\r\n\r\n        for (var i = 0; i < scenes.length; i++)\r\n        {\r\n            var scene = scenes[i];\r\n\r\n            if (scene && (!isActive || (isActive && scene.sys.isActive())))\r\n            {\r\n                out.push(scene);\r\n            }\r\n        }\r\n\r\n        return (inReverse) ? out.reverse() : out;\r\n    },\r\n\r\n    /**\r\n     * Retrieves a Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getScene\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string|Phaser.Scene} key - The Scene to retrieve.\r\n     *\r\n     * @return {?Phaser.Scene} The Scene.\r\n     */\r\n    getScene: function (key)\r\n    {\r\n        if (typeof key === 'string')\r\n        {\r\n            if (this.keys[key])\r\n            {\r\n                return this.keys[key];\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (var i = 0; i < this.scenes.length; i++)\r\n            {\r\n                if (key === this.scenes[i])\r\n                {\r\n                    return key;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Determines whether a Scene is running.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is running.\r\n     */\r\n    isActive: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            return scene.sys.isActive();\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Determines whether a Scene is paused.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isPaused\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is paused.\r\n     */\r\n    isPaused: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            return scene.sys.isPaused();\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Determines whether a Scene is visible.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is visible.\r\n     */\r\n    isVisible: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            return scene.sys.isVisible();\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Determines whether a Scene is sleeping.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isSleeping\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is sleeping.\r\n     */\r\n    isSleeping: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            return scene.sys.isSleeping();\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Pauses the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to pause.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its pause event.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    pause: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.pause(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resumes the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to resume.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its resume event.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    resume: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.resume(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Puts the given Scene to sleep.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#sleep\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to put to sleep.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its sleep event.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    sleep: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene && !scene.sys.isTransitioning())\r\n        {\r\n            scene.sys.sleep(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Awakens the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#wake\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to wake up.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its wake event.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    wake: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.wake(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Runs the given Scene.\r\n     *\r\n     * If the given Scene is paused, it will resume it. If sleeping, it will wake it.\r\n     * If not running at all, it will be started.\r\n     *\r\n     * Use this if you wish to open a modal Scene by calling `pause` on the current\r\n     * Scene, then `run` on the modal Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#run\r\n     * @since 3.10.0\r\n     *\r\n     * @param {string} key - The Scene to run.\r\n     * @param {object} [data] - A data object that will be passed to the Scene on start, wake, or resume.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This Scene Manager.\r\n     */\r\n    run: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (!scene)\r\n        {\r\n            for (var i = 0; i < this._pending.length; i++)\r\n            {\r\n                if (this._pending[i].key === key)\r\n                {\r\n                    this.queueOp('start', key, data);\r\n                    break;\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n\r\n        if (scene.sys.isSleeping())\r\n        {\r\n            //  Sleeping?\r\n            scene.sys.wake(data);\r\n        }\r\n        else if (scene.sys.isPaused())\r\n        {\r\n            //  Paused?\r\n            scene.sys.resume(data);\r\n        }\r\n        else\r\n        {\r\n            //  Not actually running?\r\n            this.start(key, data);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Starts the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#start\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to start.\r\n     * @param {object} [data] - Optional data object to pass to Scene.Settings and Scene.init.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    start: function (key, data)\r\n    {\r\n        //  If the Scene Manager is not running, then put the Scene into a holding pattern\r\n        if (!this.isBooted)\r\n        {\r\n            this._data[key] = {\r\n                autoStart: true,\r\n                data: data\r\n            };\r\n\r\n            return this;\r\n        }\r\n\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            //  If the Scene is already running (perhaps they called start from a launched sub-Scene?)\r\n            //  then we close it down before starting it again.\r\n            if (scene.sys.isActive() || scene.sys.isPaused())\r\n            {\r\n                scene.sys.shutdown();\r\n\r\n                scene.sys.start(data);\r\n            }\r\n            else\r\n            {\r\n                scene.sys.start(data);\r\n\r\n                var loader;\r\n\r\n                if (scene.sys.load)\r\n                {\r\n                    loader = scene.sys.load;\r\n                }\r\n\r\n                //  Files payload?\r\n                if (loader && scene.sys.settings.hasOwnProperty('pack'))\r\n                {\r\n                    loader.reset();\r\n\r\n                    if (loader.addPack({ payload: scene.sys.settings.pack }))\r\n                    {\r\n                        scene.sys.settings.status = CONST.LOADING;\r\n\r\n                        loader.once(LoaderEvents.COMPLETE, this.payloadComplete, this);\r\n\r\n                        loader.start();\r\n\r\n                        return this;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.bootScene(scene);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stops the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to stop.\r\n     * @param {object} [data] - Optional data object to pass to Scene.shutdown.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    stop: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene && !scene.sys.isTransitioning())\r\n        {\r\n            scene.sys.shutdown(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sleeps one one Scene and starts the other.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#switch\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} from - The Scene to sleep.\r\n     * @param {string} to - The Scene to start.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    switch: function (from, to)\r\n    {\r\n        var sceneA = this.getScene(from);\r\n        var sceneB = this.getScene(to);\r\n\r\n        if (sceneA && sceneB && sceneA !== sceneB)\r\n        {\r\n            this.sleep(from);\r\n\r\n            if (this.isSleeping(to))\r\n            {\r\n                this.wake(to);\r\n            }\r\n            else\r\n            {\r\n                this.start(to);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieves a Scene by numeric index.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The index of the Scene to retrieve.\r\n     *\r\n     * @return {(Phaser.Scene|undefined)} The Scene.\r\n     */\r\n    getAt: function (index)\r\n    {\r\n        return this.scenes[index];\r\n    },\r\n\r\n    /**\r\n     * Retrieves the numeric index of a Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The key of the Scene.\r\n     *\r\n     * @return {integer} The index of the Scene.\r\n     */\r\n    getIndex: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        return this.scenes.indexOf(scene);\r\n    },\r\n\r\n    /**\r\n     * Brings a Scene to the top of the Scenes list.\r\n     *\r\n     * This means it will render above all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#bringToTop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    bringToTop: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'bringToTop', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var index = this.getIndex(key);\r\n\r\n            if (index !== -1 && index < this.scenes.length)\r\n            {\r\n                var scene = this.getScene(key);\r\n\r\n                this.scenes.splice(index, 1);\r\n                this.scenes.push(scene);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sends a Scene to the back of the Scenes list.\r\n     *\r\n     * This means it will render below all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#sendToBack\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    sendToBack: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'sendToBack', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var index = this.getIndex(key);\r\n\r\n            if (index !== -1 && index > 0)\r\n            {\r\n                var scene = this.getScene(key);\r\n\r\n                this.scenes.splice(index, 1);\r\n                this.scenes.unshift(scene);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene down one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveDown\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    moveDown: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'moveDown', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(key);\r\n\r\n            if (indexA > 0)\r\n            {\r\n                var indexB = indexA - 1;\r\n                var sceneA = this.getScene(key);\r\n                var sceneB = this.getAt(indexB);\r\n\r\n                this.scenes[indexA] = sceneB;\r\n                this.scenes[indexB] = sceneA;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene up one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveUp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    moveUp: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'moveUp', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(key);\r\n\r\n            if (indexA < this.scenes.length - 1)\r\n            {\r\n                var indexB = indexA + 1;\r\n                var sceneA = this.getScene(key);\r\n                var sceneB = this.getAt(indexB);\r\n\r\n                this.scenes[indexA] = sceneB;\r\n                this.scenes[indexB] = sceneA;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene so it is immediately above another Scene in the Scenes list.\r\n     *\r\n     * This means it will render over the top of the other Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveAbove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved above.\r\n     * @param {(string|Phaser.Scene)} keyB - The Scene to be moved.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    moveAbove: function (keyA, keyB)\r\n    {\r\n        if (keyA === keyB)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'moveAbove', keyA: keyA, keyB: keyB });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(keyA);\r\n            var indexB = this.getIndex(keyB);\r\n\r\n            if (indexA !== -1 && indexB !== -1)\r\n            {\r\n                var tempScene = this.getAt(indexB);\r\n\r\n                //  Remove\r\n                this.scenes.splice(indexB, 1);\r\n\r\n                //  Add in new location\r\n                this.scenes.splice(indexA + 1, 0, tempScene);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene so it is immediately below another Scene in the Scenes list.\r\n     *\r\n     * This means it will render behind the other Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveBelow\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved above.\r\n     * @param {(string|Phaser.Scene)} keyB - The Scene to be moved.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    moveBelow: function (keyA, keyB)\r\n    {\r\n        if (keyA === keyB)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'moveBelow', keyA: keyA, keyB: keyB });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(keyA);\r\n            var indexB = this.getIndex(keyB);\r\n\r\n            if (indexA !== -1 && indexB !== -1)\r\n            {\r\n                var tempScene = this.getAt(indexB);\r\n\r\n                //  Remove\r\n                this.scenes.splice(indexB, 1);\r\n\r\n                if (indexA === 0)\r\n                {\r\n                    this.scenes.unshift(tempScene);\r\n                }\r\n                else\r\n                {\r\n                    //  Add in new location\r\n                    this.scenes.splice(indexA, 0, tempScene);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Queue a Scene operation for the next update.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#queueOp\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} op - The operation to perform.\r\n     * @param {(string|Phaser.Scene)} keyA - Scene A.\r\n     * @param {(any|string|Phaser.Scene)} [keyB] - Scene B, or a data object.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    queueOp: function (op, keyA, keyB)\r\n    {\r\n        this._queue.push({ op: op, keyA: keyA, keyB: keyB });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Swaps the positions of two Scenes in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#swapPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The first Scene to swap.\r\n     * @param {(string|Phaser.Scene)} keyB - The second Scene to swap.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    swapPosition: function (keyA, keyB)\r\n    {\r\n        if (keyA === keyB)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'swapPosition', keyA: keyA, keyB: keyB });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(keyA);\r\n            var indexB = this.getIndex(keyB);\r\n\r\n            if (indexA !== indexB && indexA !== -1 && indexB !== -1)\r\n            {\r\n                var tempScene = this.getAt(indexA);\r\n\r\n                this.scenes[indexA] = this.scenes[indexB];\r\n                this.scenes[indexB] = tempScene;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Dumps debug information about each Scene to the developer console.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#dump\r\n     * @since 3.2.0\r\n     */\r\n    dump: function ()\r\n    {\r\n        var out = [];\r\n        var map = [ 'pending', 'init', 'start', 'loading', 'creating', 'running', 'paused', 'sleeping', 'shutdown', 'destroyed' ];\r\n\r\n        for (var i = 0; i < this.scenes.length; i++)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            var key = (sys.settings.visible && (sys.settings.status === CONST.RUNNING || sys.settings.status === CONST.PAUSED)) ? '[*] ' : '[-] ';\r\n            key += sys.settings.key + ' (' + map[sys.settings.status] + ')';\r\n\r\n            out.push(key);\r\n        }\r\n\r\n        console.log(out.join('\\n'));\r\n    },\r\n\r\n    /**\r\n     * Destroy the SceneManager and all of its Scene's systems.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        for (var i = 0; i < this.scenes.length; i++)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            sys.destroy();\r\n        }\r\n\r\n        this.update = NOOP;\r\n\r\n        this.scenes = [];\r\n\r\n        this._pending = [];\r\n        this._start = [];\r\n        this._queue = [];\r\n\r\n        this.game = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = SceneManager;\r\n"]},"metadata":{},"sourceType":"script"}