{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar GameEvents = require('../../core/events');\n\nvar GetValue = require('../../utils/object/GetValue');\n\nvar InputEvents = require('../events');\n\nvar InputPluginCache = require('../InputPluginCache');\n\nvar Key = require('./keys/Key');\n\nvar KeyCodes = require('./keys/KeyCodes');\n\nvar KeyCombo = require('./combo/KeyCombo');\n\nvar KeyMap = require('./keys/KeyMap');\n\nvar SnapFloor = require('../../math/snap/SnapFloor');\n/**\r\n * @classdesc\r\n * The Keyboard Plugin is an input plugin that belongs to the Scene-owned Input system.\r\n * \r\n * Its role is to listen for native DOM Keyboard Events and then process them.\r\n * \r\n * You do not need to create this class directly, the Input system will create an instance of it automatically.\r\n * \r\n * You can access it from within a Scene using `this.input.keyboard`. For example, you can do:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.on('keydown', callback, context);\r\n * ```\r\n *\r\n * Or, to listen for a specific key:\r\n * \r\n * ```javascript\r\n * this.input.keyboard.on('keydown-A', callback, context);\r\n * ```\r\n *\r\n * You can also create Key objects, which you can then poll in your game loop:\r\n *\r\n * ```javascript\r\n * var spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\r\n * ```\r\n * \r\n * If you have multiple parallel Scenes, each trying to get keyboard input, be sure to disable capture on them to stop them from\r\n * stealing input from another Scene in the list. You can do this with `this.input.keyboard.enabled = false` within the\r\n * Scene to stop all input, or `this.input.keyboard.preventDefault = false` to stop a Scene halting input on another Scene.\r\n *\r\n * _Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\r\n * See http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/ for more details.\r\n *\r\n * Also please be aware that certain browser extensions can disable or override Phaser keyboard handling.\r\n * For example the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.\r\n * And there are others. So, please check your extensions before opening Phaser issues about keys that don't work.\r\n *\r\n * @class KeyboardPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input.Keyboard\r\n * @constructor\r\n * @since 3.10.0\r\n *\r\n * @param {Phaser.Input.InputPlugin} sceneInputPlugin - A reference to the Scene Input Plugin that the KeyboardPlugin belongs to.\r\n */\n\n\nvar KeyboardPlugin = new Class({\n  Extends: EventEmitter,\n  initialize: function KeyboardPlugin(sceneInputPlugin) {\n    EventEmitter.call(this);\n    /**\r\n     * A reference to the core game, so we can listen for visibility events.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyboardPlugin#game\r\n     * @type {Phaser.Game}\r\n     * @since 3.16.0\r\n     */\n\n    this.game = sceneInputPlugin.systems.game;\n    /**\r\n     * A reference to the Scene that this Input Plugin is responsible for.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyboardPlugin#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.10.0\r\n     */\n\n    this.scene = sceneInputPlugin.scene;\n    /**\r\n     * A reference to the Scene Systems Settings.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyboardPlugin#settings\r\n     * @type {Phaser.Types.Scenes.SettingsObject}\r\n     * @since 3.10.0\r\n     */\n\n    this.settings = this.scene.sys.settings;\n    /**\r\n     * A reference to the Scene Input Plugin that created this Keyboard Plugin.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyboardPlugin#sceneInputPlugin\r\n     * @type {Phaser.Input.InputPlugin}\r\n     * @since 3.10.0\r\n     */\n\n    this.sceneInputPlugin = sceneInputPlugin;\n    /**\r\n     * A reference to the global Keyboard Manager.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyboardPlugin#manager\r\n     * @type {Phaser.Input.InputPlugin}\r\n     * @since 3.16.0\r\n     */\n\n    this.manager = sceneInputPlugin.manager.keyboard;\n    /**\r\n     * A boolean that controls if this Keyboard Plugin is enabled or not.\r\n     * Can be toggled on the fly.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyboardPlugin#enabled\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.10.0\r\n     */\n\n    this.enabled = true;\n    /**\r\n     * An array of Key objects to process.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyboardPlugin#keys\r\n     * @type {Phaser.Input.Keyboard.Key[]}\r\n     * @since 3.10.0\r\n     */\n\n    this.keys = [];\n    /**\r\n     * An array of KeyCombo objects to process.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyboardPlugin#combos\r\n     * @type {Phaser.Input.Keyboard.KeyCombo[]}\r\n     * @since 3.10.0\r\n     */\n\n    this.combos = [];\n    sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);\n    sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);\n  },\n\n  /**\r\n   * This method is called automatically, only once, when the Scene is first created.\r\n   * Do not invoke it directly.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#boot\r\n   * @private\r\n   * @since 3.10.0\r\n   */\n  boot: function () {\n    var settings = this.settings.input;\n    this.enabled = GetValue(settings, 'keyboard', true);\n    var captures = GetValue(settings, 'keyboard.capture', null);\n\n    if (captures) {\n      this.addCaptures(captures);\n    }\n\n    this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);\n  },\n\n  /**\r\n   * This method is called automatically by the Scene when it is starting up.\r\n   * It is responsible for creating local systems, properties and listening for Scene events.\r\n   * Do not invoke it directly.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#start\r\n   * @private\r\n   * @since 3.10.0\r\n   */\n  start: function () {\n    if (this.sceneInputPlugin.manager.useQueue) {\n      this.sceneInputPlugin.pluginEvents.on(InputEvents.UPDATE, this.update, this);\n    } else {\n      this.sceneInputPlugin.manager.events.on(InputEvents.MANAGER_PROCESS, this.update, this);\n    }\n\n    this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);\n    this.game.events.on(GameEvents.BLUR, this.resetKeys, this);\n  },\n\n  /**\r\n   * Checks to see if both this plugin and the Scene to which it belongs is active.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#isActive\r\n   * @since 3.10.0\r\n   *\r\n   * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n   */\n  isActive: function () {\n    return this.enabled && this.scene.sys.isActive();\n  },\n\n  /**\r\n   * By default when a key is pressed Phaser will not stop the event from propagating up to the browser.\r\n   * There are some keys this can be annoying for, like the arrow keys or space bar, which make the browser window scroll.\r\n   *\r\n   * This `addCapture` method enables consuming keyboard events for specific keys, so they don't bubble up the browser\r\n   * and cause the default behaviors.\r\n   * \r\n   * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to say prevent\r\n   * the SPACE BAR from triggering a page scroll, then it will prevent it for any Scene in your game, not just the calling one.\r\n   * \r\n   * You can pass a single key code value:\r\n   * \r\n   * ```javascript\r\n   * this.input.keyboard.addCapture(62);\r\n   * ```\r\n   * \r\n   * An array of key codes:\r\n   * \r\n   * ```javascript\r\n   * this.input.keyboard.addCapture([ 62, 63, 64 ]);\r\n   * ```\r\n   * \r\n   * Or, a comma-delimited string:\r\n   * \r\n   * ```javascript\r\n   * this.input.keyboard.addCapture('W,S,A,D');\r\n   * ```\r\n   * \r\n   * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.\r\n   * \r\n   * You can also provide an array mixing both strings and key code integers.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#addCapture\r\n   * @since 3.16.0\r\n   * \r\n   * @param {(string|integer|integer[]|any[])} keycode - The Key Codes to enable event capture for.\r\n   *\r\n   * @return {Phaser.Input.Keyboard.KeyboardPlugin} This KeyboardPlugin object.\r\n   */\n  addCapture: function (keycode) {\n    this.manager.addCapture(keycode);\n    return this;\n  },\n\n  /**\r\n   * Removes an existing key capture.\r\n   * \r\n   * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to remove\r\n   * the capture of a key, then it will remove it for any Scene in your game, not just the calling one.\r\n   * \r\n   * You can pass a single key code value:\r\n   * \r\n   * ```javascript\r\n   * this.input.keyboard.removeCapture(62);\r\n   * ```\r\n   * \r\n   * An array of key codes:\r\n   * \r\n   * ```javascript\r\n   * this.input.keyboard.removeCapture([ 62, 63, 64 ]);\r\n   * ```\r\n   * \r\n   * Or, a comma-delimited string:\r\n   * \r\n   * ```javascript\r\n   * this.input.keyboard.removeCapture('W,S,A,D');\r\n   * ```\r\n   * \r\n   * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.\r\n   * \r\n   * You can also provide an array mixing both strings and key code integers.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#removeCapture\r\n   * @since 3.16.0\r\n   * \r\n   * @param {(string|integer|integer[]|any[])} keycode - The Key Codes to disable event capture for.\r\n   *\r\n   * @return {Phaser.Input.Keyboard.KeyboardPlugin} This KeyboardPlugin object.\r\n   */\n  removeCapture: function (keycode) {\n    this.manager.removeCapture(keycode);\n    return this;\n  },\n\n  /**\r\n   * Returns an array that contains all of the keyboard captures currently enabled.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#getCaptures\r\n   * @since 3.16.0\r\n   * \r\n   * @return {integer[]} An array of all the currently capturing key codes.\r\n   */\n  getCaptures: function () {\n    return this.manager.captures;\n  },\n\n  /**\r\n   * Allows Phaser to prevent any key captures you may have defined from bubbling up the browser.\r\n   * You can use this to re-enable event capturing if you had paused it via `disableGlobalCapture`.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#enableGlobalCapture\r\n   * @since 3.16.0\r\n   *\r\n   * @return {Phaser.Input.Keyboard.KeyboardPlugin} This KeyboardPlugin object.\r\n   */\n  enableGlobalCapture: function () {\n    this.manager.preventDefault = true;\n    return this;\n  },\n\n  /**\r\n   * Disables Phaser from preventing any key captures you may have defined, without actually removing them.\r\n   * You can use this to temporarily disable event capturing if, for example, you swap to a DOM element.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#disableGlobalCapture\r\n   * @since 3.16.0\r\n   *\r\n   * @return {Phaser.Input.Keyboard.KeyboardPlugin} This KeyboardPlugin object.\r\n   */\n  disableGlobalCapture: function () {\n    this.manager.preventDefault = false;\n    return this;\n  },\n\n  /**\r\n   * Removes all keyboard captures.\r\n   * \r\n   * Note that this is a global change. It will clear all event captures across your game, not just for this specific Scene.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#clearCaptures\r\n   * @since 3.16.0\r\n   *\r\n   * @return {Phaser.Input.Keyboard.KeyboardPlugin} This KeyboardPlugin object.\r\n   */\n  clearCaptures: function () {\n    this.manager.clearCaptures();\n    return this;\n  },\n\n  /**\r\n   * Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right, and also Space Bar and shift.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#createCursorKeys\r\n   * @since 3.10.0\r\n   *\r\n   * @return {Phaser.Types.Input.Keyboard.CursorKeys} An object containing the properties: `up`, `down`, `left`, `right`, `space` and `shift`.\r\n   */\n  createCursorKeys: function () {\n    return this.addKeys({\n      up: KeyCodes.UP,\n      down: KeyCodes.DOWN,\n      left: KeyCodes.LEFT,\n      right: KeyCodes.RIGHT,\n      space: KeyCodes.SPACE,\n      shift: KeyCodes.SHIFT\n    });\n  },\n\n  /**\r\n   * A practical way to create an object containing user selected hotkeys.\r\n   *\r\n   * For example:\r\n   *\r\n   * ```javascript\r\n   * this.input.keyboard.addKeys({ 'up': Phaser.Input.Keyboard.KeyCodes.W, 'down': Phaser.Input.Keyboard.KeyCodes.S });\r\n   * ```\r\n   * \r\n   * would return an object containing the properties (`up` and `down`) mapped to W and S {@link Phaser.Input.Keyboard.Key} objects.\r\n   *\r\n   * You can also pass in a comma-separated string:\r\n   * \r\n   * ```javascript\r\n   * this.input.keyboard.addKeys('W,S,A,D');\r\n   * ```\r\n   *\r\n   * Which will return an object with the properties W, S, A and D mapped to the relevant Key objects.\r\n   *\r\n   * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#addKeys\r\n   * @since 3.10.0\r\n   *\r\n   * @param {(object|string)} keys - An object containing Key Codes, or a comma-separated string.\r\n   * @param {boolean} [enableCapture=true] - Automatically call `preventDefault` on the native DOM browser event for the key codes being added.\r\n   * @param {boolean} [emitOnRepeat=false] - Controls if the Key will continuously emit a 'down' event while being held down (true), or emit the event just once (false, the default).\r\n   *\r\n   * @return {object} An object containing Key objects mapped to the input properties.\r\n   */\n  addKeys: function (keys, enableCapture, emitOnRepeat) {\n    if (enableCapture === undefined) {\n      enableCapture = true;\n    }\n\n    if (emitOnRepeat === undefined) {\n      emitOnRepeat = false;\n    }\n\n    var output = {};\n\n    if (typeof keys === 'string') {\n      keys = keys.split(',');\n\n      for (var i = 0; i < keys.length; i++) {\n        var currentKey = keys[i].trim();\n\n        if (currentKey) {\n          output[currentKey] = this.addKey(currentKey, enableCapture, emitOnRepeat);\n        }\n      }\n    } else {\n      for (var key in keys) {\n        output[key] = this.addKey(keys[key], enableCapture, emitOnRepeat);\n      }\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Adds a Key object to this Keyboard Plugin.\r\n   *\r\n   * The given argument can be either an existing Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n   *\r\n   * If a Key object is given, and one already exists matching the same key code, the existing one is replaced with the new one.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#addKey\r\n   * @since 3.10.0\r\n   *\r\n   * @param {(Phaser.Input.Keyboard.Key|string|integer)} key - Either a Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n   * @param {boolean} [enableCapture=true] - Automatically call `preventDefault` on the native DOM browser event for the key codes being added.\r\n   * @param {boolean} [emitOnRepeat=false] - Controls if the Key will continuously emit a 'down' event while being held down (true), or emit the event just once (false, the default).\r\n   *\r\n   * @return {Phaser.Input.Keyboard.Key} The newly created Key object, or a reference to it if it already existed in the keys array.\r\n   */\n  addKey: function (key, enableCapture, emitOnRepeat) {\n    if (enableCapture === undefined) {\n      enableCapture = true;\n    }\n\n    if (emitOnRepeat === undefined) {\n      emitOnRepeat = false;\n    }\n\n    var keys = this.keys;\n\n    if (key instanceof Key) {\n      var idx = keys.indexOf(key);\n\n      if (idx > -1) {\n        keys[idx] = key;\n      } else {\n        keys[key.keyCode] = key;\n      }\n\n      if (enableCapture) {\n        this.addCapture(key.keyCode);\n      }\n\n      key.setEmitOnRepeat(emitOnRepeat);\n      return key;\n    }\n\n    if (typeof key === 'string') {\n      key = KeyCodes[key.toUpperCase()];\n    }\n\n    if (!keys[key]) {\n      keys[key] = new Key(this, key);\n\n      if (enableCapture) {\n        this.addCapture(key);\n      }\n\n      keys[key].setEmitOnRepeat(emitOnRepeat);\n    }\n\n    return keys[key];\n  },\n\n  /**\r\n   * Removes a Key object from this Keyboard Plugin.\r\n   *\r\n   * The given argument can be either a Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#removeKey\r\n   * @since 3.10.0\r\n   *\r\n   * @param {(Phaser.Input.Keyboard.Key|string|integer)} key - Either a Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n   * @param {boolean} [destroy=false] - Call `Key.destroy` on the removed Key object?\r\n   *\r\n   * @return {Phaser.Input.Keyboard.KeyboardPlugin} This KeyboardPlugin object.\r\n   */\n  removeKey: function (key, destroy) {\n    if (destroy === undefined) {\n      destroy = false;\n    }\n\n    var keys = this.keys;\n    var ref;\n\n    if (key instanceof Key) {\n      var idx = keys.indexOf(key);\n\n      if (idx > -1) {\n        ref = this.keys[idx];\n        this.keys[idx] = undefined;\n      }\n    } else if (typeof key === 'string') {\n      key = KeyCodes[key.toUpperCase()];\n    }\n\n    if (keys[key]) {\n      ref = keys[key];\n      keys[key] = undefined;\n    }\n\n    if (ref) {\n      ref.plugin = null;\n\n      if (destroy) {\n        ref.destroy();\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Creates a new KeyCombo.\r\n   * \r\n   * A KeyCombo will listen for a specific string of keys from the Keyboard, and when it receives them\r\n   * it will emit a `keycombomatch` event from this Keyboard Plugin.\r\n   *\r\n   * The keys to be listened for can be defined as:\r\n   *\r\n   * A string (i.e. 'ATARI')\r\n   * An array of either integers (key codes) or strings, or a mixture of both\r\n   * An array of objects (such as Key objects) with a public 'keyCode' property\r\n   *\r\n   * For example, to listen for the Konami code (up, up, down, down, left, right, left, right, b, a, enter)\r\n   * you could pass the following array of key codes:\r\n   *\r\n   * ```javascript\r\n   * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });\r\n   *\r\n   * this.input.keyboard.on('keycombomatch', function (event) {\r\n   *     console.log('Konami Code entered!');\r\n   * });\r\n   * ```\r\n   *\r\n   * Or, to listen for the user entering the word PHASER:\r\n   *\r\n   * ```javascript\r\n   * this.input.keyboard.createCombo('PHASER');\r\n   * ```\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#createCombo\r\n   * @since 3.10.0\r\n   *\r\n   * @param {(string|integer[]|object[])} keys - The keys that comprise this combo.\r\n   * @param {Phaser.Types.Input.Keyboard.KeyComboConfig} [config] - A Key Combo configuration object.\r\n   *\r\n   * @return {Phaser.Input.Keyboard.KeyCombo} The new KeyCombo object.\r\n   */\n  createCombo: function (keys, config) {\n    return new KeyCombo(this, keys, config);\n  },\n\n  /**\r\n   * Checks if the given Key object is currently being held down.\r\n   * \r\n   * The difference between this method and checking the `Key.isDown` property directly is that you can provide\r\n   * a duration to this method. For example, if you wanted a key press to fire a bullet, but you only wanted\r\n   * it to be able to fire every 100ms, then you can call this method with a `duration` of 100 and it\r\n   * will only return `true` every 100ms.\r\n   * \r\n   * If the Keyboard Plugin has been disabled, this method will always return `false`.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#checkDown\r\n   * @since 3.11.0\r\n   *\r\n   * @param {Phaser.Input.Keyboard.Key} key - A Key object.\r\n   * @param {number} [duration=0] - The duration which must have elapsed before this Key is considered as being down.\r\n   * \r\n   * @return {boolean} `true` if the Key is down within the duration specified, otherwise `false`.\r\n   */\n  checkDown: function (key, duration) {\n    if (this.enabled && key.isDown) {\n      var t = SnapFloor(this.time - key.timeDown, duration);\n\n      if (t > key._tick) {\n        key._tick = t;\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Internal update handler called by the Input Plugin, which is in turn invoked by the Game step.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#update\r\n   * @private\r\n   * @since 3.10.0\r\n   */\n  update: function () {\n    var queue = this.manager.queue;\n    var len = queue.length;\n\n    if (!this.isActive() || len === 0) {\n      return;\n    }\n\n    var keys = this.keys; //  Process the event queue, dispatching all of the events that have stored up\n\n    for (var i = 0; i < len; i++) {\n      var event = queue[i];\n      var code = event.keyCode;\n      var key = keys[code];\n      var repeat = false; //  Override the default functions (it's too late for the browser to use them anyway, so we may as well)\n\n      if (event.cancelled === undefined) {\n        //  Event allowed to flow across all handlers in this Scene, and any other Scene in the Scene list\n        event.cancelled = 0; //  Won't reach any more local (Scene level) handlers\n\n        event.stopImmediatePropagation = function () {\n          event.cancelled = 1;\n        }; //  Won't reach any more handlers in any Scene further down the Scene list\n\n\n        event.stopPropagation = function () {\n          event.cancelled = -1;\n        };\n      }\n\n      if (event.cancelled === -1) {\n        //  This event has been stopped from broadcasting to any other Scene, so abort.\n        continue;\n      }\n\n      if (event.type === 'keydown') {\n        //  Key specific callback first\n        if (key) {\n          repeat = key.isDown;\n          key.onDown(event);\n        }\n\n        if (!event.cancelled && (!key || !repeat)) {\n          if (KeyMap[code]) {\n            this.emit(Events.KEY_DOWN + KeyMap[code], event); //  Deprecated, kept in for compatibility with 3.15\n            //  To be removed by 3.20.\n\n            this.emit('keydown_' + KeyMap[code], event);\n          }\n\n          if (!event.cancelled) {\n            this.emit(Events.ANY_KEY_DOWN, event);\n          }\n        }\n      } else {\n        //  Key specific callback first\n        if (key) {\n          key.onUp(event);\n        }\n\n        if (!event.cancelled) {\n          if (KeyMap[code]) {\n            this.emit(Events.KEY_UP + KeyMap[code], event); //  Deprecated, kept in for compatibility with 3.15\n            //  To be removed by 3.20.\n\n            this.emit('keyup_' + KeyMap[code], event);\n          }\n\n          if (!event.cancelled) {\n            this.emit(Events.ANY_KEY_UP, event);\n          }\n        }\n      } //  Reset the cancel state for other Scenes to use\n\n\n      if (event.cancelled === 1) {\n        event.cancelled = 0;\n      }\n    }\n  },\n\n  /**\r\n   * Resets all Key objects created by _this_ Keyboard Plugin back to their default un-pressed states.\r\n   * This can only reset keys created via the `addKey`, `addKeys` or `createCursorKeys` methods.\r\n   * If you have created a Key object directly you'll need to reset it yourself.\r\n   * \r\n   * This method is called automatically when the Keyboard Plugin shuts down, but can be\r\n   * invoked directly at any time you require.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#resetKeys\r\n   * @since 3.15.0\r\n   *\r\n   * @return {Phaser.Input.Keyboard.KeyboardPlugin} This KeyboardPlugin object.\r\n   */\n  resetKeys: function () {\n    var keys = this.keys;\n\n    for (var i = 0; i < keys.length; i++) {\n      //  Because it's a sparsely populated array\n      if (keys[i]) {\n        keys[i].reset();\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Shuts this Keyboard Plugin down. This performs the following tasks:\r\n   * \r\n   * 1 - Resets all keys created by this Keyboard plugin.\r\n   * 2 - Stops and removes the keyboard event listeners.\r\n   * 3 - Clears out any pending requests in the queue, without processing them.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#shutdown\r\n   * @private\r\n   * @since 3.10.0\r\n   */\n  shutdown: function () {\n    this.resetKeys();\n\n    if (this.sceneInputPlugin.manager.useQueue) {\n      this.sceneInputPlugin.pluginEvents.off(InputEvents.UPDATE, this.update, this);\n    } else {\n      this.sceneInputPlugin.manager.events.off(InputEvents.MANAGER_PROCESS, this.update, this);\n    }\n\n    this.game.events.off(GameEvents.BLUR, this.resetKeys);\n    this.removeAllListeners();\n    this.queue = [];\n  },\n\n  /**\r\n   * Destroys this Keyboard Plugin instance and all references it holds, plus clears out local arrays.\r\n   *\r\n   * @method Phaser.Input.Keyboard.KeyboardPlugin#destroy\r\n   * @private\r\n   * @since 3.10.0\r\n   */\n  destroy: function () {\n    this.shutdown();\n    var keys = this.keys;\n\n    for (var i = 0; i < keys.length; i++) {\n      //  Because it's a sparsely populated array\n      if (keys[i]) {\n        keys[i].destroy();\n      }\n    }\n\n    this.keys = [];\n    this.combos = [];\n    this.queue = [];\n    this.scene = null;\n    this.settings = null;\n    this.sceneInputPlugin = null;\n    this.manager = null;\n  },\n\n  /**\r\n   * Internal time value.\r\n   *\r\n   * @name Phaser.Input.Keyboard.KeyboardPlugin#time\r\n   * @type {number}\r\n   * @private\r\n   * @since 3.11.0\r\n   */\n  time: {\n    get: function () {\n      return this.sceneInputPlugin.manager.time;\n    }\n  }\n});\n/**\r\n * An instance of the Keyboard Plugin class, if enabled via the `input.keyboard` Scene or Game Config property.\r\n * Use this to create Key objects and listen for keyboard specific events.\r\n *\r\n * @name Phaser.Input.InputPlugin#keyboard\r\n * @type {?Phaser.Input.Keyboard.KeyboardPlugin}\r\n * @since 3.10.0\r\n */\n\nInputPluginCache.register('KeyboardPlugin', KeyboardPlugin, 'keyboard', 'keyboard', 'inputKeyboard');\nmodule.exports = KeyboardPlugin;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/input/keyboard/KeyboardPlugin.js"],"names":["Class","require","EventEmitter","Events","GameEvents","GetValue","InputEvents","InputPluginCache","Key","KeyCodes","KeyCombo","KeyMap","SnapFloor","KeyboardPlugin","Extends","initialize","sceneInputPlugin","call","game","systems","scene","settings","sys","manager","keyboard","enabled","keys","combos","pluginEvents","once","BOOT","boot","on","START","start","input","captures","addCaptures","DESTROY","destroy","useQueue","UPDATE","update","events","MANAGER_PROCESS","SHUTDOWN","shutdown","BLUR","resetKeys","isActive","addCapture","keycode","removeCapture","getCaptures","enableGlobalCapture","preventDefault","disableGlobalCapture","clearCaptures","createCursorKeys","addKeys","up","UP","down","DOWN","left","LEFT","right","RIGHT","space","SPACE","shift","SHIFT","enableCapture","emitOnRepeat","undefined","output","split","i","length","currentKey","trim","addKey","key","idx","indexOf","keyCode","setEmitOnRepeat","toUpperCase","removeKey","ref","plugin","createCombo","config","checkDown","duration","isDown","t","time","timeDown","_tick","queue","len","event","code","repeat","cancelled","stopImmediatePropagation","stopPropagation","type","onDown","emit","KEY_DOWN","ANY_KEY_DOWN","onUp","KEY_UP","ANY_KEY_UP","reset","off","removeAllListeners","get","register","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar GameEvents = require('../../core/events');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar InputEvents = require('../events');\r\nvar InputPluginCache = require('../InputPluginCache');\r\nvar Key = require('./keys/Key');\r\nvar KeyCodes = require('./keys/KeyCodes');\r\nvar KeyCombo = require('./combo/KeyCombo');\r\nvar KeyMap = require('./keys/KeyMap');\r\nvar SnapFloor = require('../../math/snap/SnapFloor');\r\n\r\n/**\r\n * @classdesc\r\n * The Keyboard Plugin is an input plugin that belongs to the Scene-owned Input system.\r\n * \r\n * Its role is to listen for native DOM Keyboard Events and then process them.\r\n * \r\n * You do not need to create this class directly, the Input system will create an instance of it automatically.\r\n * \r\n * You can access it from within a Scene using `this.input.keyboard`. For example, you can do:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.on('keydown', callback, context);\r\n * ```\r\n *\r\n * Or, to listen for a specific key:\r\n * \r\n * ```javascript\r\n * this.input.keyboard.on('keydown-A', callback, context);\r\n * ```\r\n *\r\n * You can also create Key objects, which you can then poll in your game loop:\r\n *\r\n * ```javascript\r\n * var spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\r\n * ```\r\n * \r\n * If you have multiple parallel Scenes, each trying to get keyboard input, be sure to disable capture on them to stop them from\r\n * stealing input from another Scene in the list. You can do this with `this.input.keyboard.enabled = false` within the\r\n * Scene to stop all input, or `this.input.keyboard.preventDefault = false` to stop a Scene halting input on another Scene.\r\n *\r\n * _Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\r\n * See http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/ for more details.\r\n *\r\n * Also please be aware that certain browser extensions can disable or override Phaser keyboard handling.\r\n * For example the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.\r\n * And there are others. So, please check your extensions before opening Phaser issues about keys that don't work.\r\n *\r\n * @class KeyboardPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input.Keyboard\r\n * @constructor\r\n * @since 3.10.0\r\n *\r\n * @param {Phaser.Input.InputPlugin} sceneInputPlugin - A reference to the Scene Input Plugin that the KeyboardPlugin belongs to.\r\n */\r\nvar KeyboardPlugin = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function KeyboardPlugin (sceneInputPlugin)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the core game, so we can listen for visibility events.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.16.0\r\n         */\r\n        this.game = sceneInputPlugin.systems.game;\r\n\r\n        /**\r\n         * A reference to the Scene that this Input Plugin is responsible for.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.10.0\r\n         */\r\n        this.scene = sceneInputPlugin.scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems Settings.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#settings\r\n         * @type {Phaser.Types.Scenes.SettingsObject}\r\n         * @since 3.10.0\r\n         */\r\n        this.settings = this.scene.sys.settings;\r\n\r\n        /**\r\n         * A reference to the Scene Input Plugin that created this Keyboard Plugin.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#sceneInputPlugin\r\n         * @type {Phaser.Input.InputPlugin}\r\n         * @since 3.10.0\r\n         */\r\n        this.sceneInputPlugin = sceneInputPlugin;\r\n\r\n        /**\r\n         * A reference to the global Keyboard Manager.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#manager\r\n         * @type {Phaser.Input.InputPlugin}\r\n         * @since 3.16.0\r\n         */\r\n        this.manager = sceneInputPlugin.manager.keyboard;\r\n\r\n        /**\r\n         * A boolean that controls if this Keyboard Plugin is enabled or not.\r\n         * Can be toggled on the fly.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.10.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * An array of Key objects to process.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#keys\r\n         * @type {Phaser.Input.Keyboard.Key[]}\r\n         * @since 3.10.0\r\n         */\r\n        this.keys = [];\r\n\r\n        /**\r\n         * An array of KeyCombo objects to process.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#combos\r\n         * @type {Phaser.Input.Keyboard.KeyCombo[]}\r\n         * @since 3.10.0\r\n         */\r\n        this.combos = [];\r\n\r\n        sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);\r\n        sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#boot\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        var settings = this.settings.input;\r\n\r\n        this.enabled = GetValue(settings, 'keyboard', true);\r\n\r\n        var captures = GetValue(settings, 'keyboard.capture', null);\r\n\r\n        if (captures)\r\n        {\r\n            this.addCaptures(captures);\r\n        }\r\n\r\n        this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#start\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    start: function ()\r\n    {\r\n        if (this.sceneInputPlugin.manager.useQueue)\r\n        {\r\n            this.sceneInputPlugin.pluginEvents.on(InputEvents.UPDATE, this.update, this);\r\n        }\r\n        else\r\n        {\r\n            this.sceneInputPlugin.manager.events.on(InputEvents.MANAGER_PROCESS, this.update, this);\r\n        }\r\n\r\n        this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);\r\n\r\n        this.game.events.on(GameEvents.BLUR, this.resetKeys, this);\r\n    },\r\n\r\n    /**\r\n     * Checks to see if both this plugin and the Scene to which it belongs is active.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#isActive\r\n     * @since 3.10.0\r\n     *\r\n     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n     */\r\n    isActive: function ()\r\n    {\r\n        return (this.enabled && this.scene.sys.isActive());\r\n    },\r\n\r\n    /**\r\n     * By default when a key is pressed Phaser will not stop the event from propagating up to the browser.\r\n     * There are some keys this can be annoying for, like the arrow keys or space bar, which make the browser window scroll.\r\n     *\r\n     * This `addCapture` method enables consuming keyboard events for specific keys, so they don't bubble up the browser\r\n     * and cause the default behaviors.\r\n     * \r\n     * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to say prevent\r\n     * the SPACE BAR from triggering a page scroll, then it will prevent it for any Scene in your game, not just the calling one.\r\n     * \r\n     * You can pass a single key code value:\r\n     * \r\n     * ```javascript\r\n     * this.input.keyboard.addCapture(62);\r\n     * ```\r\n     * \r\n     * An array of key codes:\r\n     * \r\n     * ```javascript\r\n     * this.input.keyboard.addCapture([ 62, 63, 64 ]);\r\n     * ```\r\n     * \r\n     * Or, a comma-delimited string:\r\n     * \r\n     * ```javascript\r\n     * this.input.keyboard.addCapture('W,S,A,D');\r\n     * ```\r\n     * \r\n     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.\r\n     * \r\n     * You can also provide an array mixing both strings and key code integers.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#addCapture\r\n     * @since 3.16.0\r\n     * \r\n     * @param {(string|integer|integer[]|any[])} keycode - The Key Codes to enable event capture for.\r\n     *\r\n     * @return {Phaser.Input.Keyboard.KeyboardPlugin} This KeyboardPlugin object.\r\n     */\r\n    addCapture: function (keycode)\r\n    {\r\n        this.manager.addCapture(keycode);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes an existing key capture.\r\n     * \r\n     * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to remove\r\n     * the capture of a key, then it will remove it for any Scene in your game, not just the calling one.\r\n     * \r\n     * You can pass a single key code value:\r\n     * \r\n     * ```javascript\r\n     * this.input.keyboard.removeCapture(62);\r\n     * ```\r\n     * \r\n     * An array of key codes:\r\n     * \r\n     * ```javascript\r\n     * this.input.keyboard.removeCapture([ 62, 63, 64 ]);\r\n     * ```\r\n     * \r\n     * Or, a comma-delimited string:\r\n     * \r\n     * ```javascript\r\n     * this.input.keyboard.removeCapture('W,S,A,D');\r\n     * ```\r\n     * \r\n     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.\r\n     * \r\n     * You can also provide an array mixing both strings and key code integers.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#removeCapture\r\n     * @since 3.16.0\r\n     * \r\n     * @param {(string|integer|integer[]|any[])} keycode - The Key Codes to disable event capture for.\r\n     *\r\n     * @return {Phaser.Input.Keyboard.KeyboardPlugin} This KeyboardPlugin object.\r\n     */\r\n    removeCapture: function (keycode)\r\n    {\r\n        this.manager.removeCapture(keycode);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns an array that contains all of the keyboard captures currently enabled.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#getCaptures\r\n     * @since 3.16.0\r\n     * \r\n     * @return {integer[]} An array of all the currently capturing key codes.\r\n     */\r\n    getCaptures: function ()\r\n    {\r\n        return this.manager.captures;\r\n    },\r\n\r\n    /**\r\n     * Allows Phaser to prevent any key captures you may have defined from bubbling up the browser.\r\n     * You can use this to re-enable event capturing if you had paused it via `disableGlobalCapture`.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#enableGlobalCapture\r\n     * @since 3.16.0\r\n     *\r\n     * @return {Phaser.Input.Keyboard.KeyboardPlugin} This KeyboardPlugin object.\r\n     */\r\n    enableGlobalCapture: function ()\r\n    {\r\n        this.manager.preventDefault = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Disables Phaser from preventing any key captures you may have defined, without actually removing them.\r\n     * You can use this to temporarily disable event capturing if, for example, you swap to a DOM element.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#disableGlobalCapture\r\n     * @since 3.16.0\r\n     *\r\n     * @return {Phaser.Input.Keyboard.KeyboardPlugin} This KeyboardPlugin object.\r\n     */\r\n    disableGlobalCapture: function ()\r\n    {\r\n        this.manager.preventDefault = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes all keyboard captures.\r\n     * \r\n     * Note that this is a global change. It will clear all event captures across your game, not just for this specific Scene.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#clearCaptures\r\n     * @since 3.16.0\r\n     *\r\n     * @return {Phaser.Input.Keyboard.KeyboardPlugin} This KeyboardPlugin object.\r\n     */\r\n    clearCaptures: function ()\r\n    {\r\n        this.manager.clearCaptures();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right, and also Space Bar and shift.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#createCursorKeys\r\n     * @since 3.10.0\r\n     *\r\n     * @return {Phaser.Types.Input.Keyboard.CursorKeys} An object containing the properties: `up`, `down`, `left`, `right`, `space` and `shift`.\r\n     */\r\n    createCursorKeys: function ()\r\n    {\r\n        return this.addKeys({\r\n            up: KeyCodes.UP,\r\n            down: KeyCodes.DOWN,\r\n            left: KeyCodes.LEFT,\r\n            right: KeyCodes.RIGHT,\r\n            space: KeyCodes.SPACE,\r\n            shift: KeyCodes.SHIFT\r\n        });\r\n    },\r\n\r\n    /**\r\n     * A practical way to create an object containing user selected hotkeys.\r\n     *\r\n     * For example:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.addKeys({ 'up': Phaser.Input.Keyboard.KeyCodes.W, 'down': Phaser.Input.Keyboard.KeyCodes.S });\r\n     * ```\r\n     * \r\n     * would return an object containing the properties (`up` and `down`) mapped to W and S {@link Phaser.Input.Keyboard.Key} objects.\r\n     *\r\n     * You can also pass in a comma-separated string:\r\n     * \r\n     * ```javascript\r\n     * this.input.keyboard.addKeys('W,S,A,D');\r\n     * ```\r\n     *\r\n     * Which will return an object with the properties W, S, A and D mapped to the relevant Key objects.\r\n     *\r\n     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#addKeys\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(object|string)} keys - An object containing Key Codes, or a comma-separated string.\r\n     * @param {boolean} [enableCapture=true] - Automatically call `preventDefault` on the native DOM browser event for the key codes being added.\r\n     * @param {boolean} [emitOnRepeat=false] - Controls if the Key will continuously emit a 'down' event while being held down (true), or emit the event just once (false, the default).\r\n     *\r\n     * @return {object} An object containing Key objects mapped to the input properties.\r\n     */\r\n    addKeys: function (keys, enableCapture, emitOnRepeat)\r\n    {\r\n        if (enableCapture === undefined) { enableCapture = true; }\r\n        if (emitOnRepeat === undefined) { emitOnRepeat = false; }\r\n\r\n        var output = {};\r\n\r\n        if (typeof keys === 'string')\r\n        {\r\n            keys = keys.split(',');\r\n\r\n            for (var i = 0; i < keys.length; i++)\r\n            {\r\n                var currentKey = keys[i].trim();\r\n\r\n                if (currentKey)\r\n                {\r\n                    output[currentKey] = this.addKey(currentKey, enableCapture, emitOnRepeat);\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (var key in keys)\r\n            {\r\n                output[key] = this.addKey(keys[key], enableCapture, emitOnRepeat);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Adds a Key object to this Keyboard Plugin.\r\n     *\r\n     * The given argument can be either an existing Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     *\r\n     * If a Key object is given, and one already exists matching the same key code, the existing one is replaced with the new one.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#addKey\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(Phaser.Input.Keyboard.Key|string|integer)} key - Either a Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     * @param {boolean} [enableCapture=true] - Automatically call `preventDefault` on the native DOM browser event for the key codes being added.\r\n     * @param {boolean} [emitOnRepeat=false] - Controls if the Key will continuously emit a 'down' event while being held down (true), or emit the event just once (false, the default).\r\n     *\r\n     * @return {Phaser.Input.Keyboard.Key} The newly created Key object, or a reference to it if it already existed in the keys array.\r\n     */\r\n    addKey: function (key, enableCapture, emitOnRepeat)\r\n    {\r\n        if (enableCapture === undefined) { enableCapture = true; }\r\n        if (emitOnRepeat === undefined) { emitOnRepeat = false; }\r\n\r\n        var keys = this.keys;\r\n\r\n        if (key instanceof Key)\r\n        {\r\n            var idx = keys.indexOf(key);\r\n\r\n            if (idx > -1)\r\n            {\r\n                keys[idx] = key;\r\n            }\r\n            else\r\n            {\r\n                keys[key.keyCode] = key;\r\n            }\r\n\r\n            if (enableCapture)\r\n            {\r\n                this.addCapture(key.keyCode);\r\n            }\r\n\r\n            key.setEmitOnRepeat(emitOnRepeat);\r\n\r\n            return key;\r\n        }\r\n\r\n        if (typeof key === 'string')\r\n        {\r\n            key = KeyCodes[key.toUpperCase()];\r\n        }\r\n\r\n        if (!keys[key])\r\n        {\r\n            keys[key] = new Key(this, key);\r\n\r\n            if (enableCapture)\r\n            {\r\n                this.addCapture(key);\r\n            }\r\n\r\n            keys[key].setEmitOnRepeat(emitOnRepeat);\r\n        }\r\n\r\n        return keys[key];\r\n    },\r\n\r\n    /**\r\n     * Removes a Key object from this Keyboard Plugin.\r\n     *\r\n     * The given argument can be either a Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#removeKey\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(Phaser.Input.Keyboard.Key|string|integer)} key - Either a Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     * @param {boolean} [destroy=false] - Call `Key.destroy` on the removed Key object?\r\n     *\r\n     * @return {Phaser.Input.Keyboard.KeyboardPlugin} This KeyboardPlugin object.\r\n     */\r\n    removeKey: function (key, destroy)\r\n    {\r\n        if (destroy === undefined) { destroy = false; }\r\n\r\n        var keys = this.keys;\r\n        var ref;\r\n\r\n        if (key instanceof Key)\r\n        {\r\n            var idx = keys.indexOf(key);\r\n\r\n            if (idx > -1)\r\n            {\r\n                ref = this.keys[idx];\r\n\r\n                this.keys[idx] = undefined;\r\n            }\r\n        }\r\n        else if (typeof key === 'string')\r\n        {\r\n            key = KeyCodes[key.toUpperCase()];\r\n        }\r\n\r\n        if (keys[key])\r\n        {\r\n            ref = keys[key];\r\n\r\n            keys[key] = undefined;\r\n        }\r\n\r\n        if (ref)\r\n        {\r\n            ref.plugin = null;\r\n\r\n            if (destroy)\r\n            {\r\n                ref.destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a new KeyCombo.\r\n     * \r\n     * A KeyCombo will listen for a specific string of keys from the Keyboard, and when it receives them\r\n     * it will emit a `keycombomatch` event from this Keyboard Plugin.\r\n     *\r\n     * The keys to be listened for can be defined as:\r\n     *\r\n     * A string (i.e. 'ATARI')\r\n     * An array of either integers (key codes) or strings, or a mixture of both\r\n     * An array of objects (such as Key objects) with a public 'keyCode' property\r\n     *\r\n     * For example, to listen for the Konami code (up, up, down, down, left, right, left, right, b, a, enter)\r\n     * you could pass the following array of key codes:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });\r\n     *\r\n     * this.input.keyboard.on('keycombomatch', function (event) {\r\n     *     console.log('Konami Code entered!');\r\n     * });\r\n     * ```\r\n     *\r\n     * Or, to listen for the user entering the word PHASER:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.createCombo('PHASER');\r\n     * ```\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#createCombo\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(string|integer[]|object[])} keys - The keys that comprise this combo.\r\n     * @param {Phaser.Types.Input.Keyboard.KeyComboConfig} [config] - A Key Combo configuration object.\r\n     *\r\n     * @return {Phaser.Input.Keyboard.KeyCombo} The new KeyCombo object.\r\n     */\r\n    createCombo: function (keys, config)\r\n    {\r\n        return new KeyCombo(this, keys, config);\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Key object is currently being held down.\r\n     * \r\n     * The difference between this method and checking the `Key.isDown` property directly is that you can provide\r\n     * a duration to this method. For example, if you wanted a key press to fire a bullet, but you only wanted\r\n     * it to be able to fire every 100ms, then you can call this method with a `duration` of 100 and it\r\n     * will only return `true` every 100ms.\r\n     * \r\n     * If the Keyboard Plugin has been disabled, this method will always return `false`.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#checkDown\r\n     * @since 3.11.0\r\n     *\r\n     * @param {Phaser.Input.Keyboard.Key} key - A Key object.\r\n     * @param {number} [duration=0] - The duration which must have elapsed before this Key is considered as being down.\r\n     * \r\n     * @return {boolean} `true` if the Key is down within the duration specified, otherwise `false`.\r\n     */\r\n    checkDown: function (key, duration)\r\n    {\r\n        if (this.enabled && key.isDown)\r\n        {\r\n            var t = SnapFloor(this.time - key.timeDown, duration);\r\n\r\n            if (t > key._tick)\r\n            {\r\n                key._tick = t;\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler called by the Input Plugin, which is in turn invoked by the Game step.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#update\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    update: function ()\r\n    {\r\n        var queue = this.manager.queue;\r\n        var len = queue.length;\r\n\r\n        if (!this.isActive() || len === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var keys = this.keys;\r\n\r\n        //  Process the event queue, dispatching all of the events that have stored up\r\n        for (var i = 0; i < len; i++)\r\n        {\r\n            var event = queue[i];\r\n            var code = event.keyCode;\r\n            var key = keys[code];\r\n            var repeat = false;\r\n\r\n            //  Override the default functions (it's too late for the browser to use them anyway, so we may as well)\r\n            if (event.cancelled === undefined)\r\n            {\r\n                //  Event allowed to flow across all handlers in this Scene, and any other Scene in the Scene list\r\n                event.cancelled = 0;\r\n\r\n                //  Won't reach any more local (Scene level) handlers\r\n                event.stopImmediatePropagation = function ()\r\n                {\r\n                    event.cancelled = 1;\r\n                };\r\n    \r\n                //  Won't reach any more handlers in any Scene further down the Scene list\r\n                event.stopPropagation = function ()\r\n                {\r\n                    event.cancelled = -1;\r\n                };\r\n            }\r\n\r\n            if (event.cancelled === -1)\r\n            {\r\n                //  This event has been stopped from broadcasting to any other Scene, so abort.\r\n                continue;\r\n            }\r\n\r\n            if (event.type === 'keydown')\r\n            {\r\n                //  Key specific callback first\r\n                if (key)\r\n                {\r\n                    repeat = key.isDown;\r\n\r\n                    key.onDown(event);\r\n                }\r\n\r\n                if (!event.cancelled && (!key || !repeat))\r\n                {\r\n                    if (KeyMap[code])\r\n                    {\r\n                        this.emit(Events.KEY_DOWN + KeyMap[code], event);\r\n\r\n                        //  Deprecated, kept in for compatibility with 3.15\r\n                        //  To be removed by 3.20.\r\n                        this.emit('keydown_' + KeyMap[code], event);\r\n                    }\r\n\r\n                    if (!event.cancelled)\r\n                    {\r\n                        this.emit(Events.ANY_KEY_DOWN, event);\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                //  Key specific callback first\r\n                if (key)\r\n                {\r\n                    key.onUp(event);\r\n                }\r\n\r\n                if (!event.cancelled)\r\n                {\r\n                    if (KeyMap[code])\r\n                    {\r\n                        this.emit(Events.KEY_UP + KeyMap[code], event);\r\n\r\n                        //  Deprecated, kept in for compatibility with 3.15\r\n                        //  To be removed by 3.20.\r\n                        this.emit('keyup_' + KeyMap[code], event);\r\n                    }\r\n\r\n                    if (!event.cancelled)\r\n                    {\r\n                        this.emit(Events.ANY_KEY_UP, event);\r\n                    }\r\n                }\r\n            }\r\n\r\n            //  Reset the cancel state for other Scenes to use\r\n            if (event.cancelled === 1)\r\n            {\r\n                event.cancelled = 0;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Resets all Key objects created by _this_ Keyboard Plugin back to their default un-pressed states.\r\n     * This can only reset keys created via the `addKey`, `addKeys` or `createCursorKeys` methods.\r\n     * If you have created a Key object directly you'll need to reset it yourself.\r\n     * \r\n     * This method is called automatically when the Keyboard Plugin shuts down, but can be\r\n     * invoked directly at any time you require.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#resetKeys\r\n     * @since 3.15.0\r\n     *\r\n     * @return {Phaser.Input.Keyboard.KeyboardPlugin} This KeyboardPlugin object.\r\n     */\r\n    resetKeys: function ()\r\n    {\r\n        var keys = this.keys;\r\n\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            //  Because it's a sparsely populated array\r\n            if (keys[i])\r\n            {\r\n                keys[i].reset();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuts this Keyboard Plugin down. This performs the following tasks:\r\n     * \r\n     * 1 - Resets all keys created by this Keyboard plugin.\r\n     * 2 - Stops and removes the keyboard event listeners.\r\n     * 3 - Clears out any pending requests in the queue, without processing them.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#shutdown\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.resetKeys();\r\n\r\n        if (this.sceneInputPlugin.manager.useQueue)\r\n        {\r\n            this.sceneInputPlugin.pluginEvents.off(InputEvents.UPDATE, this.update, this);\r\n        }\r\n        else\r\n        {\r\n            this.sceneInputPlugin.manager.events.off(InputEvents.MANAGER_PROCESS, this.update, this);\r\n        }\r\n\r\n        this.game.events.off(GameEvents.BLUR, this.resetKeys);\r\n\r\n        this.removeAllListeners();\r\n\r\n        this.queue = [];\r\n    },\r\n\r\n    /**\r\n     * Destroys this Keyboard Plugin instance and all references it holds, plus clears out local arrays.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#destroy\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        var keys = this.keys;\r\n\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            //  Because it's a sparsely populated array\r\n            if (keys[i])\r\n            {\r\n                keys[i].destroy();\r\n            }\r\n        }\r\n\r\n        this.keys = [];\r\n        this.combos = [];\r\n        this.queue = [];\r\n\r\n        this.scene = null;\r\n        this.settings = null;\r\n        this.sceneInputPlugin = null;\r\n        this.manager = null;\r\n    },\r\n\r\n    /**\r\n     * Internal time value.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyboardPlugin#time\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.11.0\r\n     */\r\n    time: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.sceneInputPlugin.manager.time;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * An instance of the Keyboard Plugin class, if enabled via the `input.keyboard` Scene or Game Config property.\r\n * Use this to create Key objects and listen for keyboard specific events.\r\n *\r\n * @name Phaser.Input.InputPlugin#keyboard\r\n * @type {?Phaser.Input.Keyboard.KeyboardPlugin}\r\n * @since 3.10.0\r\n */\r\nInputPluginCache.register('KeyboardPlugin', KeyboardPlugin, 'keyboard', 'keyboard', 'inputKeyboard');\r\n\r\nmodule.exports = KeyboardPlugin;\r\n"]},"metadata":{},"sourceType":"script"}