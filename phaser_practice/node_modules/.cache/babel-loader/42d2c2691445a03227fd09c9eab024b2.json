{"ast":null,"code":"/**\r\n* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.\r\n* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.\r\n* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Vertices\r\n*/\nvar Vertices = {};\nmodule.exports = Vertices;\n\nvar Vector = require('../geometry/Vector');\n\nvar Common = require('../core/Common');\n\n(function () {\n  /**\r\n   * Creates a new set of `Matter.Body` compatible vertices.\r\n   * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:\r\n   *\r\n   *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\r\n   *\r\n   * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,\r\n   * but with some additional references required for efficient collision detection routines.\r\n   *\r\n   * Vertices must be specified in clockwise order.\r\n   *\r\n   * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.\r\n   *\r\n   * @method create\r\n   * @param {vector[]} points\r\n   * @param {body} body\r\n   */\n  Vertices.create = function (points, body) {\n    var vertices = [];\n\n    for (var i = 0; i < points.length; i++) {\n      var point = points[i],\n          vertex = {\n        x: point.x,\n        y: point.y,\n        index: i,\n        body: body,\n        isInternal: false,\n        contact: null,\n        offset: null\n      };\n      vertex.contact = {\n        vertex: vertex,\n        normalImpulse: 0,\n        tangentImpulse: 0\n      };\n      vertices.push(vertex);\n    }\n\n    return vertices;\n  };\n  /**\r\n   * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), \r\n   * into a `Matter.Vertices` object for the given `Matter.Body`.\r\n   * For parsing SVG paths, see `Svg.pathToVertices`.\r\n   * @method fromPath\r\n   * @param {string} path\r\n   * @param {body} body\r\n   * @return {vertices} vertices\r\n   */\n\n\n  Vertices.fromPath = function (path, body) {\n    var pathPattern = /L?\\s*([-\\d.e]+)[\\s,]*([-\\d.e]+)*/ig,\n        points = [];\n    path.replace(pathPattern, function (match, x, y) {\n      points.push({\n        x: parseFloat(x),\n        y: parseFloat(y)\n      });\n    });\n    return Vertices.create(points, body);\n  };\n  /**\r\n   * Returns the centre (centroid) of the set of vertices.\r\n   * @method centre\r\n   * @param {vertices} vertices\r\n   * @return {vector} The centre point\r\n   */\n\n\n  Vertices.centre = function (vertices) {\n    var area = Vertices.area(vertices, true),\n        centre = {\n      x: 0,\n      y: 0\n    },\n        cross,\n        temp,\n        j;\n\n    for (var i = 0; i < vertices.length; i++) {\n      j = (i + 1) % vertices.length;\n      cross = Vector.cross(vertices[i], vertices[j]);\n      temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);\n      centre = Vector.add(centre, temp);\n    }\n\n    return Vector.div(centre, 6 * area);\n  };\n  /**\r\n   * Returns the average (mean) of the set of vertices.\r\n   * @method mean\r\n   * @param {vertices} vertices\r\n   * @return {vector} The average point\r\n   */\n\n\n  Vertices.mean = function (vertices) {\n    var average = {\n      x: 0,\n      y: 0\n    };\n\n    for (var i = 0; i < vertices.length; i++) {\n      average.x += vertices[i].x;\n      average.y += vertices[i].y;\n    }\n\n    return Vector.div(average, vertices.length);\n  };\n  /**\r\n   * Returns the area of the set of vertices.\r\n   * @method area\r\n   * @param {vertices} vertices\r\n   * @param {bool} signed\r\n   * @return {number} The area\r\n   */\n\n\n  Vertices.area = function (vertices, signed) {\n    var area = 0,\n        j = vertices.length - 1;\n\n    for (var i = 0; i < vertices.length; i++) {\n      area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);\n      j = i;\n    }\n\n    if (signed) return area / 2;\n    return Math.abs(area) / 2;\n  };\n  /**\r\n   * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.\r\n   * @method inertia\r\n   * @param {vertices} vertices\r\n   * @param {number} mass\r\n   * @return {number} The polygon's moment of inertia\r\n   */\n\n\n  Vertices.inertia = function (vertices, mass) {\n    var numerator = 0,\n        denominator = 0,\n        v = vertices,\n        cross,\n        j; // find the polygon's moment of inertia, using second moment of area\n    // from equations at http://www.physicsforums.com/showthread.php?t=25293\n\n    for (var n = 0; n < v.length; n++) {\n      j = (n + 1) % v.length;\n      cross = Math.abs(Vector.cross(v[j], v[n]));\n      numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));\n      denominator += cross;\n    }\n\n    return mass / 6 * (numerator / denominator);\n  };\n  /**\r\n   * Translates the set of vertices in-place.\r\n   * @method translate\r\n   * @param {vertices} vertices\r\n   * @param {vector} vector\r\n   * @param {number} scalar\r\n   */\n\n\n  Vertices.translate = function (vertices, vector, scalar) {\n    var i;\n\n    if (scalar) {\n      for (i = 0; i < vertices.length; i++) {\n        vertices[i].x += vector.x * scalar;\n        vertices[i].y += vector.y * scalar;\n      }\n    } else {\n      for (i = 0; i < vertices.length; i++) {\n        vertices[i].x += vector.x;\n        vertices[i].y += vector.y;\n      }\n    }\n\n    return vertices;\n  };\n  /**\r\n   * Rotates the set of vertices in-place.\r\n   * @method rotate\r\n   * @param {vertices} vertices\r\n   * @param {number} angle\r\n   * @param {vector} point\r\n   */\n\n\n  Vertices.rotate = function (vertices, angle, point) {\n    if (angle === 0) return;\n    var cos = Math.cos(angle),\n        sin = Math.sin(angle);\n\n    for (var i = 0; i < vertices.length; i++) {\n      var vertice = vertices[i],\n          dx = vertice.x - point.x,\n          dy = vertice.y - point.y;\n      vertice.x = point.x + (dx * cos - dy * sin);\n      vertice.y = point.y + (dx * sin + dy * cos);\n    }\n\n    return vertices;\n  };\n  /**\r\n   * Returns `true` if the `point` is inside the set of `vertices`.\r\n   * @method contains\r\n   * @param {vertices} vertices\r\n   * @param {vector} point\r\n   * @return {boolean} True if the vertices contains point, otherwise false\r\n   */\n\n\n  Vertices.contains = function (vertices, point) {\n    for (var i = 0; i < vertices.length; i++) {\n      var vertice = vertices[i],\n          nextVertice = vertices[(i + 1) % vertices.length];\n\n      if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Scales the vertices from a point (default is centre) in-place.\r\n   * @method scale\r\n   * @param {vertices} vertices\r\n   * @param {number} scaleX\r\n   * @param {number} scaleY\r\n   * @param {vector} point\r\n   */\n\n\n  Vertices.scale = function (vertices, scaleX, scaleY, point) {\n    if (scaleX === 1 && scaleY === 1) return vertices;\n    point = point || Vertices.centre(vertices);\n    var vertex, delta;\n\n    for (var i = 0; i < vertices.length; i++) {\n      vertex = vertices[i];\n      delta = Vector.sub(vertex, point);\n      vertices[i].x = point.x + delta.x * scaleX;\n      vertices[i].y = point.y + delta.y * scaleY;\n    }\n\n    return vertices;\n  };\n  /**\r\n   * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.\r\n   * The radius parameter is a single number or an array to specify the radius for each vertex.\r\n   * @method chamfer\r\n   * @param {vertices} vertices\r\n   * @param {number[]} radius\r\n   * @param {number} quality\r\n   * @param {number} qualityMin\r\n   * @param {number} qualityMax\r\n   */\n\n\n  Vertices.chamfer = function (vertices, radius, quality, qualityMin, qualityMax) {\n    if (typeof radius === 'number') {\n      radius = [radius];\n    } else {\n      radius = radius || [8];\n    } // quality defaults to -1, which is auto\n\n\n    quality = typeof quality !== 'undefined' ? quality : -1;\n    qualityMin = qualityMin || 2;\n    qualityMax = qualityMax || 14;\n    var newVertices = [];\n\n    for (var i = 0; i < vertices.length; i++) {\n      var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1],\n          vertex = vertices[i],\n          nextVertex = vertices[(i + 1) % vertices.length],\n          currentRadius = radius[i < radius.length ? i : radius.length - 1];\n\n      if (currentRadius === 0) {\n        newVertices.push(vertex);\n        continue;\n      }\n\n      var prevNormal = Vector.normalise({\n        x: vertex.y - prevVertex.y,\n        y: prevVertex.x - vertex.x\n      });\n      var nextNormal = Vector.normalise({\n        x: nextVertex.y - vertex.y,\n        y: vertex.x - nextVertex.x\n      });\n      var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)),\n          radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius),\n          midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)),\n          scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));\n      var precision = quality;\n\n      if (quality === -1) {\n        // automatically decide precision\n        precision = Math.pow(currentRadius, 0.32) * 1.75;\n      }\n\n      precision = Common.clamp(precision, qualityMin, qualityMax); // use an even value for precision, more likely to reduce axes by using symmetry\n\n      if (precision % 2 === 1) precision += 1;\n      var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)),\n          theta = alpha / precision;\n\n      for (var j = 0; j < precision; j++) {\n        newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));\n      }\n    }\n\n    return newVertices;\n  };\n  /**\r\n   * Sorts the input vertices into clockwise order in place.\r\n   * @method clockwiseSort\r\n   * @param {vertices} vertices\r\n   * @return {vertices} vertices\r\n   */\n\n\n  Vertices.clockwiseSort = function (vertices) {\n    var centre = Vertices.mean(vertices);\n    vertices.sort(function (vertexA, vertexB) {\n      return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);\n    });\n    return vertices;\n  };\n  /**\r\n   * Returns true if the vertices form a convex shape (vertices must be in clockwise order).\r\n   * @method isConvex\r\n   * @param {vertices} vertices\r\n   * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).\r\n   */\n\n\n  Vertices.isConvex = function (vertices) {\n    // http://paulbourke.net/geometry/polygonmesh/\n    // Copyright (c) Paul Bourke (use permitted)\n    var flag = 0,\n        n = vertices.length,\n        i,\n        j,\n        k,\n        z;\n    if (n < 3) return null;\n\n    for (i = 0; i < n; i++) {\n      j = (i + 1) % n;\n      k = (i + 2) % n;\n      z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);\n      z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);\n\n      if (z < 0) {\n        flag |= 1;\n      } else if (z > 0) {\n        flag |= 2;\n      }\n\n      if (flag === 3) {\n        return false;\n      }\n    }\n\n    if (flag !== 0) {\n      return true;\n    } else {\n      return null;\n    }\n  };\n  /**\r\n   * Returns the convex hull of the input vertices as a new array of points.\r\n   * @method hull\r\n   * @param {vertices} vertices\r\n   * @return [vertex] vertices\r\n   */\n\n\n  Vertices.hull = function (vertices) {\n    // http://geomalgorithms.com/a10-_hull-1.html\n    var upper = [],\n        lower = [],\n        vertex,\n        i; // sort vertices on x-axis (y-axis for ties)\n\n    vertices = vertices.slice(0);\n    vertices.sort(function (vertexA, vertexB) {\n      var dx = vertexA.x - vertexB.x;\n      return dx !== 0 ? dx : vertexA.y - vertexB.y;\n    }); // build lower hull\n\n    for (i = 0; i < vertices.length; i += 1) {\n      vertex = vertices[i];\n\n      while (lower.length >= 2 && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {\n        lower.pop();\n      }\n\n      lower.push(vertex);\n    } // build upper hull\n\n\n    for (i = vertices.length - 1; i >= 0; i -= 1) {\n      vertex = vertices[i];\n\n      while (upper.length >= 2 && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {\n        upper.pop();\n      }\n\n      upper.push(vertex);\n    } // concatenation of the lower and upper hulls gives the convex hull\n    // omit last points because they are repeated at the beginning of the other list\n\n\n    upper.pop();\n    lower.pop();\n    return upper.concat(lower);\n  };\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/lib/geometry/Vertices.js"],"names":["Vertices","module","exports","Vector","require","Common","create","points","body","vertices","i","length","point","vertex","x","y","index","isInternal","contact","offset","normalImpulse","tangentImpulse","push","fromPath","path","pathPattern","replace","match","parseFloat","centre","area","cross","temp","j","mult","add","div","mean","average","signed","Math","abs","inertia","mass","numerator","denominator","v","n","dot","translate","vector","scalar","rotate","angle","cos","sin","vertice","dx","dy","contains","nextVertice","scale","scaleX","scaleY","delta","sub","chamfer","radius","quality","qualityMin","qualityMax","newVertices","prevVertex","nextVertex","currentRadius","prevNormal","normalise","nextNormal","diagonalRadius","sqrt","pow","radiusVector","clone","midNormal","scaledVertex","precision","clamp","alpha","acos","theta","clockwiseSort","sort","vertexA","vertexB","isConvex","flag","k","z","hull","upper","lower","slice","cross3","pop","concat"],"mappings":"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","sourcesContent":["/**\r\n* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.\r\n* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.\r\n* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Vertices\r\n*/\r\n\r\nvar Vertices = {};\r\n\r\nmodule.exports = Vertices;\r\n\r\nvar Vector = require('../geometry/Vector');\r\nvar Common = require('../core/Common');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new set of `Matter.Body` compatible vertices.\r\n     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:\r\n     *\r\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\r\n     *\r\n     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,\r\n     * but with some additional references required for efficient collision detection routines.\r\n     *\r\n     * Vertices must be specified in clockwise order.\r\n     *\r\n     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.\r\n     *\r\n     * @method create\r\n     * @param {vector[]} points\r\n     * @param {body} body\r\n     */\r\n    Vertices.create = function(points, body) {\r\n        var vertices = [];\r\n\r\n        for (var i = 0; i < points.length; i++) {\r\n            var point = points[i],\r\n                vertex = {\r\n                    x: point.x,\r\n                    y: point.y,\r\n                    index: i,\r\n                    body: body,\r\n                    isInternal: false,\r\n                    contact: null,\r\n                    offset: null\r\n                };\r\n\r\n            vertex.contact = {\r\n                vertex: vertex,\r\n                normalImpulse: 0,\r\n                tangentImpulse: 0\r\n            };\r\n\r\n            vertices.push(vertex);\r\n        }\r\n\r\n        return vertices;\r\n    };\r\n\r\n    /**\r\n     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), \r\n     * into a `Matter.Vertices` object for the given `Matter.Body`.\r\n     * For parsing SVG paths, see `Svg.pathToVertices`.\r\n     * @method fromPath\r\n     * @param {string} path\r\n     * @param {body} body\r\n     * @return {vertices} vertices\r\n     */\r\n    Vertices.fromPath = function(path, body) {\r\n        var pathPattern = /L?\\s*([-\\d.e]+)[\\s,]*([-\\d.e]+)*/ig,\r\n            points = [];\r\n\r\n        path.replace(pathPattern, function(match, x, y) {\r\n            points.push({ x: parseFloat(x), y: parseFloat(y) });\r\n        });\r\n\r\n        return Vertices.create(points, body);\r\n    };\r\n\r\n    /**\r\n     * Returns the centre (centroid) of the set of vertices.\r\n     * @method centre\r\n     * @param {vertices} vertices\r\n     * @return {vector} The centre point\r\n     */\r\n    Vertices.centre = function(vertices) {\r\n        var area = Vertices.area(vertices, true),\r\n            centre = { x: 0, y: 0 },\r\n            cross,\r\n            temp,\r\n            j;\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            j = (i + 1) % vertices.length;\r\n            cross = Vector.cross(vertices[i], vertices[j]);\r\n            temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);\r\n            centre = Vector.add(centre, temp);\r\n        }\r\n\r\n        return Vector.div(centre, 6 * area);\r\n    };\r\n\r\n    /**\r\n     * Returns the average (mean) of the set of vertices.\r\n     * @method mean\r\n     * @param {vertices} vertices\r\n     * @return {vector} The average point\r\n     */\r\n    Vertices.mean = function(vertices) {\r\n        var average = { x: 0, y: 0 };\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            average.x += vertices[i].x;\r\n            average.y += vertices[i].y;\r\n        }\r\n\r\n        return Vector.div(average, vertices.length);\r\n    };\r\n\r\n    /**\r\n     * Returns the area of the set of vertices.\r\n     * @method area\r\n     * @param {vertices} vertices\r\n     * @param {bool} signed\r\n     * @return {number} The area\r\n     */\r\n    Vertices.area = function(vertices, signed) {\r\n        var area = 0,\r\n            j = vertices.length - 1;\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);\r\n            j = i;\r\n        }\r\n\r\n        if (signed)\r\n            return area / 2;\r\n\r\n        return Math.abs(area) / 2;\r\n    };\r\n\r\n    /**\r\n     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.\r\n     * @method inertia\r\n     * @param {vertices} vertices\r\n     * @param {number} mass\r\n     * @return {number} The polygon's moment of inertia\r\n     */\r\n    Vertices.inertia = function(vertices, mass) {\r\n        var numerator = 0,\r\n            denominator = 0,\r\n            v = vertices,\r\n            cross,\r\n            j;\r\n\r\n        // find the polygon's moment of inertia, using second moment of area\r\n        // from equations at http://www.physicsforums.com/showthread.php?t=25293\r\n        for (var n = 0; n < v.length; n++) {\r\n            j = (n + 1) % v.length;\r\n            cross = Math.abs(Vector.cross(v[j], v[n]));\r\n            numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));\r\n            denominator += cross;\r\n        }\r\n\r\n        return (mass / 6) * (numerator / denominator);\r\n    };\r\n\r\n    /**\r\n     * Translates the set of vertices in-place.\r\n     * @method translate\r\n     * @param {vertices} vertices\r\n     * @param {vector} vector\r\n     * @param {number} scalar\r\n     */\r\n    Vertices.translate = function(vertices, vector, scalar) {\r\n        var i;\r\n        if (scalar) {\r\n            for (i = 0; i < vertices.length; i++) {\r\n                vertices[i].x += vector.x * scalar;\r\n                vertices[i].y += vector.y * scalar;\r\n            }\r\n        } else {\r\n            for (i = 0; i < vertices.length; i++) {\r\n                vertices[i].x += vector.x;\r\n                vertices[i].y += vector.y;\r\n            }\r\n        }\r\n\r\n        return vertices;\r\n    };\r\n\r\n    /**\r\n     * Rotates the set of vertices in-place.\r\n     * @method rotate\r\n     * @param {vertices} vertices\r\n     * @param {number} angle\r\n     * @param {vector} point\r\n     */\r\n    Vertices.rotate = function(vertices, angle, point) {\r\n        if (angle === 0)\r\n            return;\r\n\r\n        var cos = Math.cos(angle),\r\n            sin = Math.sin(angle);\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            var vertice = vertices[i],\r\n                dx = vertice.x - point.x,\r\n                dy = vertice.y - point.y;\r\n                \r\n            vertice.x = point.x + (dx * cos - dy * sin);\r\n            vertice.y = point.y + (dx * sin + dy * cos);\r\n        }\r\n\r\n        return vertices;\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if the `point` is inside the set of `vertices`.\r\n     * @method contains\r\n     * @param {vertices} vertices\r\n     * @param {vector} point\r\n     * @return {boolean} True if the vertices contains point, otherwise false\r\n     */\r\n    Vertices.contains = function(vertices, point) {\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            var vertice = vertices[i],\r\n                nextVertice = vertices[(i + 1) % vertices.length];\r\n            if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Scales the vertices from a point (default is centre) in-place.\r\n     * @method scale\r\n     * @param {vertices} vertices\r\n     * @param {number} scaleX\r\n     * @param {number} scaleY\r\n     * @param {vector} point\r\n     */\r\n    Vertices.scale = function(vertices, scaleX, scaleY, point) {\r\n        if (scaleX === 1 && scaleY === 1)\r\n            return vertices;\r\n\r\n        point = point || Vertices.centre(vertices);\r\n\r\n        var vertex,\r\n            delta;\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            vertex = vertices[i];\r\n            delta = Vector.sub(vertex, point);\r\n            vertices[i].x = point.x + delta.x * scaleX;\r\n            vertices[i].y = point.y + delta.y * scaleY;\r\n        }\r\n\r\n        return vertices;\r\n    };\r\n\r\n    /**\r\n     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.\r\n     * The radius parameter is a single number or an array to specify the radius for each vertex.\r\n     * @method chamfer\r\n     * @param {vertices} vertices\r\n     * @param {number[]} radius\r\n     * @param {number} quality\r\n     * @param {number} qualityMin\r\n     * @param {number} qualityMax\r\n     */\r\n    Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {\r\n        if (typeof radius === 'number') {\r\n            radius = [radius];\r\n        } else {\r\n            radius = radius || [8];\r\n        }\r\n\r\n        // quality defaults to -1, which is auto\r\n        quality = (typeof quality !== 'undefined') ? quality : -1;\r\n        qualityMin = qualityMin || 2;\r\n        qualityMax = qualityMax || 14;\r\n\r\n        var newVertices = [];\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1],\r\n                vertex = vertices[i],\r\n                nextVertex = vertices[(i + 1) % vertices.length],\r\n                currentRadius = radius[i < radius.length ? i : radius.length - 1];\r\n\r\n            if (currentRadius === 0) {\r\n                newVertices.push(vertex);\r\n                continue;\r\n            }\r\n\r\n            var prevNormal = Vector.normalise({ \r\n                x: vertex.y - prevVertex.y, \r\n                y: prevVertex.x - vertex.x\r\n            });\r\n\r\n            var nextNormal = Vector.normalise({ \r\n                x: nextVertex.y - vertex.y, \r\n                y: vertex.x - nextVertex.x\r\n            });\r\n\r\n            var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)),\r\n                radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius),\r\n                midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)),\r\n                scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));\r\n\r\n            var precision = quality;\r\n\r\n            if (quality === -1) {\r\n                // automatically decide precision\r\n                precision = Math.pow(currentRadius, 0.32) * 1.75;\r\n            }\r\n\r\n            precision = Common.clamp(precision, qualityMin, qualityMax);\r\n\r\n            // use an even value for precision, more likely to reduce axes by using symmetry\r\n            if (precision % 2 === 1)\r\n                precision += 1;\r\n\r\n            var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)),\r\n                theta = alpha / precision;\r\n\r\n            for (var j = 0; j < precision; j++) {\r\n                newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));\r\n            }\r\n        }\r\n\r\n        return newVertices;\r\n    };\r\n\r\n    /**\r\n     * Sorts the input vertices into clockwise order in place.\r\n     * @method clockwiseSort\r\n     * @param {vertices} vertices\r\n     * @return {vertices} vertices\r\n     */\r\n    Vertices.clockwiseSort = function(vertices) {\r\n        var centre = Vertices.mean(vertices);\r\n\r\n        vertices.sort(function(vertexA, vertexB) {\r\n            return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);\r\n        });\r\n\r\n        return vertices;\r\n    };\r\n\r\n    /**\r\n     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).\r\n     * @method isConvex\r\n     * @param {vertices} vertices\r\n     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).\r\n     */\r\n    Vertices.isConvex = function(vertices) {\r\n        // http://paulbourke.net/geometry/polygonmesh/\r\n        // Copyright (c) Paul Bourke (use permitted)\r\n\r\n        var flag = 0,\r\n            n = vertices.length,\r\n            i,\r\n            j,\r\n            k,\r\n            z;\r\n\r\n        if (n < 3)\r\n            return null;\r\n\r\n        for (i = 0; i < n; i++) {\r\n            j = (i + 1) % n;\r\n            k = (i + 2) % n;\r\n            z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);\r\n            z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);\r\n\r\n            if (z < 0) {\r\n                flag |= 1;\r\n            } else if (z > 0) {\r\n                flag |= 2;\r\n            }\r\n\r\n            if (flag === 3) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (flag !== 0){\r\n            return true;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns the convex hull of the input vertices as a new array of points.\r\n     * @method hull\r\n     * @param {vertices} vertices\r\n     * @return [vertex] vertices\r\n     */\r\n    Vertices.hull = function(vertices) {\r\n        // http://geomalgorithms.com/a10-_hull-1.html\r\n\r\n        var upper = [],\r\n            lower = [], \r\n            vertex,\r\n            i;\r\n\r\n        // sort vertices on x-axis (y-axis for ties)\r\n        vertices = vertices.slice(0);\r\n        vertices.sort(function(vertexA, vertexB) {\r\n            var dx = vertexA.x - vertexB.x;\r\n            return dx !== 0 ? dx : vertexA.y - vertexB.y;\r\n        });\r\n\r\n        // build lower hull\r\n        for (i = 0; i < vertices.length; i += 1) {\r\n            vertex = vertices[i];\r\n\r\n            while (lower.length >= 2 \r\n                   && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {\r\n                lower.pop();\r\n            }\r\n\r\n            lower.push(vertex);\r\n        }\r\n\r\n        // build upper hull\r\n        for (i = vertices.length - 1; i >= 0; i -= 1) {\r\n            vertex = vertices[i];\r\n\r\n            while (upper.length >= 2 \r\n                   && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {\r\n                upper.pop();\r\n            }\r\n\r\n            upper.push(vertex);\r\n        }\r\n\r\n        // concatenation of the lower and upper hulls gives the convex hull\r\n        // omit last points because they are repeated at the beginning of the other list\r\n        upper.pop();\r\n        lower.pop();\r\n\r\n        return upper.concat(lower);\r\n    };\r\n\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}