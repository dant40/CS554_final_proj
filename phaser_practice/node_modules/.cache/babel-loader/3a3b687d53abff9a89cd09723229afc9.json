{"ast":null,"code":"/**\r\n* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.\r\n*\r\n* @class Grid\r\n*/\nvar Grid = {};\nmodule.exports = Grid;\n\nvar Pair = require('./Pair');\n\nvar Detector = require('./Detector');\n\nvar Common = require('../core/Common');\n\n(function () {\n  /**\r\n   * Creates a new grid.\r\n   * @method create\r\n   * @param {} options\r\n   * @return {grid} A new grid\r\n   */\n  Grid.create = function (options) {\n    var defaults = {\n      controller: Grid,\n      detector: Detector.collisions,\n      buckets: {},\n      pairs: {},\n      pairsList: [],\n      bucketWidth: 48,\n      bucketHeight: 48\n    };\n    return Common.extend(defaults, options);\n  };\n  /**\r\n   * The width of a single grid bucket.\r\n   *\r\n   * @property bucketWidth\r\n   * @type number\r\n   * @default 48\r\n   */\n\n  /**\r\n   * The height of a single grid bucket.\r\n   *\r\n   * @property bucketHeight\r\n   * @type number\r\n   * @default 48\r\n   */\n\n  /**\r\n   * Updates the grid.\r\n   * @method update\r\n   * @param {grid} grid\r\n   * @param {body[]} bodies\r\n   * @param {engine} engine\r\n   * @param {boolean} forceUpdate\r\n   */\n\n\n  Grid.update = function (grid, bodies, engine, forceUpdate) {\n    var i,\n        col,\n        row,\n        world = engine.world,\n        buckets = grid.buckets,\n        bucket,\n        bucketId,\n        gridChanged = false; // @if DEBUG\n\n    var metrics = engine.metrics;\n    metrics.broadphaseTests = 0; // @endif\n\n    for (i = 0; i < bodies.length; i++) {\n      var body = bodies[i];\n      if (body.isSleeping && !forceUpdate) continue; // don't update out of world bodies\n\n      if (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y) continue;\n\n      var newRegion = Grid._getRegion(grid, body); // if the body has changed grid region\n\n\n      if (!body.region || newRegion.id !== body.region.id || forceUpdate) {\n        // @if DEBUG\n        metrics.broadphaseTests += 1; // @endif\n\n        if (!body.region || forceUpdate) body.region = newRegion;\n\n        var union = Grid._regionUnion(newRegion, body.region); // update grid buckets affected by region change\n        // iterate over the union of both regions\n\n\n        for (col = union.startCol; col <= union.endCol; col++) {\n          for (row = union.startRow; row <= union.endRow; row++) {\n            bucketId = Grid._getBucketId(col, row);\n            bucket = buckets[bucketId];\n            var isInsideNewRegion = col >= newRegion.startCol && col <= newRegion.endCol && row >= newRegion.startRow && row <= newRegion.endRow;\n            var isInsideOldRegion = col >= body.region.startCol && col <= body.region.endCol && row >= body.region.startRow && row <= body.region.endRow; // remove from old region buckets\n\n            if (!isInsideNewRegion && isInsideOldRegion) {\n              if (isInsideOldRegion) {\n                if (bucket) Grid._bucketRemoveBody(grid, bucket, body);\n              }\n            } // add to new region buckets\n\n\n            if (body.region === newRegion || isInsideNewRegion && !isInsideOldRegion || forceUpdate) {\n              if (!bucket) bucket = Grid._createBucket(buckets, bucketId);\n\n              Grid._bucketAddBody(grid, bucket, body);\n            }\n          }\n        } // set the new region\n\n\n        body.region = newRegion; // flag changes so we can update pairs\n\n        gridChanged = true;\n      }\n    } // update pairs list only if pairs changed (i.e. a body changed region)\n\n\n    if (gridChanged) grid.pairsList = Grid._createActivePairsList(grid);\n  };\n  /**\r\n   * Clears the grid.\r\n   * @method clear\r\n   * @param {grid} grid\r\n   */\n\n\n  Grid.clear = function (grid) {\n    grid.buckets = {};\n    grid.pairs = {};\n    grid.pairsList = [];\n  };\n  /**\r\n   * Finds the union of two regions.\r\n   * @method _regionUnion\r\n   * @private\r\n   * @param {} regionA\r\n   * @param {} regionB\r\n   * @return {} region\r\n   */\n\n\n  Grid._regionUnion = function (regionA, regionB) {\n    var startCol = Math.min(regionA.startCol, regionB.startCol),\n        endCol = Math.max(regionA.endCol, regionB.endCol),\n        startRow = Math.min(regionA.startRow, regionB.startRow),\n        endRow = Math.max(regionA.endRow, regionB.endRow);\n    return Grid._createRegion(startCol, endCol, startRow, endRow);\n  };\n  /**\r\n   * Gets the region a given body falls in for a given grid.\r\n   * @method _getRegion\r\n   * @private\r\n   * @param {} grid\r\n   * @param {} body\r\n   * @return {} region\r\n   */\n\n\n  Grid._getRegion = function (grid, body) {\n    var bounds = body.bounds,\n        startCol = Math.floor(bounds.min.x / grid.bucketWidth),\n        endCol = Math.floor(bounds.max.x / grid.bucketWidth),\n        startRow = Math.floor(bounds.min.y / grid.bucketHeight),\n        endRow = Math.floor(bounds.max.y / grid.bucketHeight);\n    return Grid._createRegion(startCol, endCol, startRow, endRow);\n  };\n  /**\r\n   * Creates a region.\r\n   * @method _createRegion\r\n   * @private\r\n   * @param {} startCol\r\n   * @param {} endCol\r\n   * @param {} startRow\r\n   * @param {} endRow\r\n   * @return {} region\r\n   */\n\n\n  Grid._createRegion = function (startCol, endCol, startRow, endRow) {\n    return {\n      id: startCol + ',' + endCol + ',' + startRow + ',' + endRow,\n      startCol: startCol,\n      endCol: endCol,\n      startRow: startRow,\n      endRow: endRow\n    };\n  };\n  /**\r\n   * Gets the bucket id at the given position.\r\n   * @method _getBucketId\r\n   * @private\r\n   * @param {} column\r\n   * @param {} row\r\n   * @return {string} bucket id\r\n   */\n\n\n  Grid._getBucketId = function (column, row) {\n    return 'C' + column + 'R' + row;\n  };\n  /**\r\n   * Creates a bucket.\r\n   * @method _createBucket\r\n   * @private\r\n   * @param {} buckets\r\n   * @param {} bucketId\r\n   * @return {} bucket\r\n   */\n\n\n  Grid._createBucket = function (buckets, bucketId) {\n    var bucket = buckets[bucketId] = [];\n    return bucket;\n  };\n  /**\r\n   * Adds a body to a bucket.\r\n   * @method _bucketAddBody\r\n   * @private\r\n   * @param {} grid\r\n   * @param {} bucket\r\n   * @param {} body\r\n   */\n\n\n  Grid._bucketAddBody = function (grid, bucket, body) {\n    // add new pairs\n    for (var i = 0; i < bucket.length; i++) {\n      var bodyB = bucket[i];\n      if (body.id === bodyB.id || body.isStatic && bodyB.isStatic) continue; // keep track of the number of buckets the pair exists in\n      // important for Grid.update to work\n\n      var pairId = Pair.id(body, bodyB),\n          pair = grid.pairs[pairId];\n\n      if (pair) {\n        pair[2] += 1;\n      } else {\n        grid.pairs[pairId] = [body, bodyB, 1];\n      }\n    } // add to bodies (after pairs, otherwise pairs with self)\n\n\n    bucket.push(body);\n  };\n  /**\r\n   * Removes a body from a bucket.\r\n   * @method _bucketRemoveBody\r\n   * @private\r\n   * @param {} grid\r\n   * @param {} bucket\r\n   * @param {} body\r\n   */\n\n\n  Grid._bucketRemoveBody = function (grid, bucket, body) {\n    // remove from bucket\n    bucket.splice(bucket.indexOf(body), 1); // update pair counts\n\n    for (var i = 0; i < bucket.length; i++) {\n      // keep track of the number of buckets the pair exists in\n      // important for _createActivePairsList to work\n      var bodyB = bucket[i],\n          pairId = Pair.id(body, bodyB),\n          pair = grid.pairs[pairId];\n      if (pair) pair[2] -= 1;\n    }\n  };\n  /**\r\n   * Generates a list of the active pairs in the grid.\r\n   * @method _createActivePairsList\r\n   * @private\r\n   * @param {} grid\r\n   * @return [] pairs\r\n   */\n\n\n  Grid._createActivePairsList = function (grid) {\n    var pairKeys,\n        pair,\n        pairs = []; // grid.pairs is used as a hashmap\n\n    pairKeys = Common.keys(grid.pairs); // iterate over grid.pairs\n\n    for (var k = 0; k < pairKeys.length; k++) {\n      pair = grid.pairs[pairKeys[k]]; // if pair exists in at least one bucket\n      // it is a pair that needs further collision testing so push it\n\n      if (pair[2] > 0) {\n        pairs.push(pair);\n      } else {\n        delete grid.pairs[pairKeys[k]];\n      }\n    }\n\n    return pairs;\n  };\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/lib/collision/Grid.js"],"names":["Grid","module","exports","Pair","require","Detector","Common","create","options","defaults","controller","detector","collisions","buckets","pairs","pairsList","bucketWidth","bucketHeight","extend","update","grid","bodies","engine","forceUpdate","i","col","row","world","bucket","bucketId","gridChanged","metrics","broadphaseTests","length","body","isSleeping","bounds","max","x","min","y","newRegion","_getRegion","region","id","union","_regionUnion","startCol","endCol","startRow","endRow","_getBucketId","isInsideNewRegion","isInsideOldRegion","_bucketRemoveBody","_createBucket","_bucketAddBody","_createActivePairsList","clear","regionA","regionB","Math","_createRegion","floor","column","bodyB","isStatic","pairId","pair","push","splice","indexOf","pairKeys","keys","k"],"mappings":"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","sourcesContent":["/**\r\n* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.\r\n*\r\n* @class Grid\r\n*/\r\n\r\nvar Grid = {};\r\n\r\nmodule.exports = Grid;\r\n\r\nvar Pair = require('./Pair');\r\nvar Detector = require('./Detector');\r\nvar Common = require('../core/Common');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new grid.\r\n     * @method create\r\n     * @param {} options\r\n     * @return {grid} A new grid\r\n     */\r\n    Grid.create = function(options) {\r\n        var defaults = {\r\n            controller: Grid,\r\n            detector: Detector.collisions,\r\n            buckets: {},\r\n            pairs: {},\r\n            pairsList: [],\r\n            bucketWidth: 48,\r\n            bucketHeight: 48\r\n        };\r\n\r\n        return Common.extend(defaults, options);\r\n    };\r\n\r\n    /**\r\n     * The width of a single grid bucket.\r\n     *\r\n     * @property bucketWidth\r\n     * @type number\r\n     * @default 48\r\n     */\r\n\r\n    /**\r\n     * The height of a single grid bucket.\r\n     *\r\n     * @property bucketHeight\r\n     * @type number\r\n     * @default 48\r\n     */\r\n\r\n    /**\r\n     * Updates the grid.\r\n     * @method update\r\n     * @param {grid} grid\r\n     * @param {body[]} bodies\r\n     * @param {engine} engine\r\n     * @param {boolean} forceUpdate\r\n     */\r\n    Grid.update = function(grid, bodies, engine, forceUpdate) {\r\n        var i, col, row,\r\n            world = engine.world,\r\n            buckets = grid.buckets,\r\n            bucket,\r\n            bucketId,\r\n            gridChanged = false;\r\n\r\n        // @if DEBUG\r\n        var metrics = engine.metrics;\r\n        metrics.broadphaseTests = 0;\r\n        // @endif\r\n\r\n        for (i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n\r\n            if (body.isSleeping && !forceUpdate)\r\n                continue;\r\n\r\n            // don't update out of world bodies\r\n            if (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x\r\n                || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y)\r\n                continue;\r\n\r\n            var newRegion = Grid._getRegion(grid, body);\r\n\r\n            // if the body has changed grid region\r\n            if (!body.region || newRegion.id !== body.region.id || forceUpdate) {\r\n\r\n                // @if DEBUG\r\n                metrics.broadphaseTests += 1;\r\n                // @endif\r\n\r\n                if (!body.region || forceUpdate)\r\n                    body.region = newRegion;\r\n\r\n                var union = Grid._regionUnion(newRegion, body.region);\r\n\r\n                // update grid buckets affected by region change\r\n                // iterate over the union of both regions\r\n                for (col = union.startCol; col <= union.endCol; col++) {\r\n                    for (row = union.startRow; row <= union.endRow; row++) {\r\n                        bucketId = Grid._getBucketId(col, row);\r\n                        bucket = buckets[bucketId];\r\n\r\n                        var isInsideNewRegion = (col >= newRegion.startCol && col <= newRegion.endCol\r\n                                                && row >= newRegion.startRow && row <= newRegion.endRow);\r\n\r\n                        var isInsideOldRegion = (col >= body.region.startCol && col <= body.region.endCol\r\n                                                && row >= body.region.startRow && row <= body.region.endRow);\r\n\r\n                        // remove from old region buckets\r\n                        if (!isInsideNewRegion && isInsideOldRegion) {\r\n                            if (isInsideOldRegion) {\r\n                                if (bucket)\r\n                                    Grid._bucketRemoveBody(grid, bucket, body);\r\n                            }\r\n                        }\r\n\r\n                        // add to new region buckets\r\n                        if (body.region === newRegion || (isInsideNewRegion && !isInsideOldRegion) || forceUpdate) {\r\n                            if (!bucket)\r\n                                bucket = Grid._createBucket(buckets, bucketId);\r\n                            Grid._bucketAddBody(grid, bucket, body);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // set the new region\r\n                body.region = newRegion;\r\n\r\n                // flag changes so we can update pairs\r\n                gridChanged = true;\r\n            }\r\n        }\r\n\r\n        // update pairs list only if pairs changed (i.e. a body changed region)\r\n        if (gridChanged)\r\n            grid.pairsList = Grid._createActivePairsList(grid);\r\n    };\r\n\r\n    /**\r\n     * Clears the grid.\r\n     * @method clear\r\n     * @param {grid} grid\r\n     */\r\n    Grid.clear = function(grid) {\r\n        grid.buckets = {};\r\n        grid.pairs = {};\r\n        grid.pairsList = [];\r\n    };\r\n\r\n    /**\r\n     * Finds the union of two regions.\r\n     * @method _regionUnion\r\n     * @private\r\n     * @param {} regionA\r\n     * @param {} regionB\r\n     * @return {} region\r\n     */\r\n    Grid._regionUnion = function(regionA, regionB) {\r\n        var startCol = Math.min(regionA.startCol, regionB.startCol),\r\n            endCol = Math.max(regionA.endCol, regionB.endCol),\r\n            startRow = Math.min(regionA.startRow, regionB.startRow),\r\n            endRow = Math.max(regionA.endRow, regionB.endRow);\r\n\r\n        return Grid._createRegion(startCol, endCol, startRow, endRow);\r\n    };\r\n\r\n    /**\r\n     * Gets the region a given body falls in for a given grid.\r\n     * @method _getRegion\r\n     * @private\r\n     * @param {} grid\r\n     * @param {} body\r\n     * @return {} region\r\n     */\r\n    Grid._getRegion = function(grid, body) {\r\n        var bounds = body.bounds,\r\n            startCol = Math.floor(bounds.min.x / grid.bucketWidth),\r\n            endCol = Math.floor(bounds.max.x / grid.bucketWidth),\r\n            startRow = Math.floor(bounds.min.y / grid.bucketHeight),\r\n            endRow = Math.floor(bounds.max.y / grid.bucketHeight);\r\n\r\n        return Grid._createRegion(startCol, endCol, startRow, endRow);\r\n    };\r\n\r\n    /**\r\n     * Creates a region.\r\n     * @method _createRegion\r\n     * @private\r\n     * @param {} startCol\r\n     * @param {} endCol\r\n     * @param {} startRow\r\n     * @param {} endRow\r\n     * @return {} region\r\n     */\r\n    Grid._createRegion = function(startCol, endCol, startRow, endRow) {\r\n        return { \r\n            id: startCol + ',' + endCol + ',' + startRow + ',' + endRow,\r\n            startCol: startCol, \r\n            endCol: endCol, \r\n            startRow: startRow, \r\n            endRow: endRow \r\n        };\r\n    };\r\n\r\n    /**\r\n     * Gets the bucket id at the given position.\r\n     * @method _getBucketId\r\n     * @private\r\n     * @param {} column\r\n     * @param {} row\r\n     * @return {string} bucket id\r\n     */\r\n    Grid._getBucketId = function(column, row) {\r\n        return 'C' + column + 'R' + row;\r\n    };\r\n\r\n    /**\r\n     * Creates a bucket.\r\n     * @method _createBucket\r\n     * @private\r\n     * @param {} buckets\r\n     * @param {} bucketId\r\n     * @return {} bucket\r\n     */\r\n    Grid._createBucket = function(buckets, bucketId) {\r\n        var bucket = buckets[bucketId] = [];\r\n        return bucket;\r\n    };\r\n\r\n    /**\r\n     * Adds a body to a bucket.\r\n     * @method _bucketAddBody\r\n     * @private\r\n     * @param {} grid\r\n     * @param {} bucket\r\n     * @param {} body\r\n     */\r\n    Grid._bucketAddBody = function(grid, bucket, body) {\r\n        // add new pairs\r\n        for (var i = 0; i < bucket.length; i++) {\r\n            var bodyB = bucket[i];\r\n\r\n            if (body.id === bodyB.id || (body.isStatic && bodyB.isStatic))\r\n                continue;\r\n\r\n            // keep track of the number of buckets the pair exists in\r\n            // important for Grid.update to work\r\n            var pairId = Pair.id(body, bodyB),\r\n                pair = grid.pairs[pairId];\r\n\r\n            if (pair) {\r\n                pair[2] += 1;\r\n            } else {\r\n                grid.pairs[pairId] = [body, bodyB, 1];\r\n            }\r\n        }\r\n\r\n        // add to bodies (after pairs, otherwise pairs with self)\r\n        bucket.push(body);\r\n    };\r\n\r\n    /**\r\n     * Removes a body from a bucket.\r\n     * @method _bucketRemoveBody\r\n     * @private\r\n     * @param {} grid\r\n     * @param {} bucket\r\n     * @param {} body\r\n     */\r\n    Grid._bucketRemoveBody = function(grid, bucket, body) {\r\n        // remove from bucket\r\n        bucket.splice(bucket.indexOf(body), 1);\r\n\r\n        // update pair counts\r\n        for (var i = 0; i < bucket.length; i++) {\r\n            // keep track of the number of buckets the pair exists in\r\n            // important for _createActivePairsList to work\r\n            var bodyB = bucket[i],\r\n                pairId = Pair.id(body, bodyB),\r\n                pair = grid.pairs[pairId];\r\n\r\n            if (pair)\r\n                pair[2] -= 1;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Generates a list of the active pairs in the grid.\r\n     * @method _createActivePairsList\r\n     * @private\r\n     * @param {} grid\r\n     * @return [] pairs\r\n     */\r\n    Grid._createActivePairsList = function(grid) {\r\n        var pairKeys,\r\n            pair,\r\n            pairs = [];\r\n\r\n        // grid.pairs is used as a hashmap\r\n        pairKeys = Common.keys(grid.pairs);\r\n\r\n        // iterate over grid.pairs\r\n        for (var k = 0; k < pairKeys.length; k++) {\r\n            pair = grid.pairs[pairKeys[k]];\r\n\r\n            // if pair exists in at least one bucket\r\n            // it is a pair that needs further collision testing so push it\r\n            if (pair[2] > 0) {\r\n                pairs.push(pair);\r\n            } else {\r\n                delete grid.pairs[pairKeys[k]];\r\n            }\r\n        }\r\n\r\n        return pairs;\r\n    };\r\n    \r\n})();\r\n"]},"metadata":{},"sourceType":"script"}