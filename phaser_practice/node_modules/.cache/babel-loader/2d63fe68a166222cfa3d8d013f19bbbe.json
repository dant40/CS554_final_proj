{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Rectangle = require('../../geom/rectangle/Rectangle');\n\nvar RotateAround = require('../../math/RotateAround');\n\nvar Vector2 = require('../../math/Vector2');\n/**\r\n * Provides methods used for obtaining the bounds of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @namespace Phaser.GameObjects.Components.GetBounds\r\n * @since 3.0.0\r\n */\n\n\nvar GetBounds = {\n  /**\r\n   * Processes the bounds output vector before returning it.\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#prepareBoundsOutput\r\n   * @private\r\n   * @since 3.18.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Math.Vector2|object)} output - An object to store the values in. If not provided a new Vector2 will be created.\r\n   * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n   *\r\n   * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n   */\n  prepareBoundsOutput: function (output, includeParent) {\n    if (includeParent === undefined) {\n      includeParent = false;\n    }\n\n    if (this.rotation !== 0) {\n      RotateAround(output, this.x, this.y, this.rotation);\n    }\n\n    if (includeParent && this.parentContainer) {\n      var parentMatrix = this.parentContainer.getBoundsTransformMatrix();\n      parentMatrix.transformPoint(output.x, output.y, output);\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Gets the center coordinate of this Game Object, regardless of origin.\r\n   * The returned point is calculated in local space and does not factor in any parent containers\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#getCenter\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n   *\r\n   * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n   */\n  getCenter: function (output) {\n    if (output === undefined) {\n      output = new Vector2();\n    }\n\n    output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;\n    output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;\n    return output;\n  },\n\n  /**\r\n   * Gets the top-left corner coordinate of this Game Object, regardless of origin.\r\n   * The returned point is calculated in local space and does not factor in any parent containers\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#getTopLeft\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n   * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n   *\r\n   * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n   */\n  getTopLeft: function (output, includeParent) {\n    if (!output) {\n      output = new Vector2();\n    }\n\n    output.x = this.x - this.displayWidth * this.originX;\n    output.y = this.y - this.displayHeight * this.originY;\n    return this.prepareBoundsOutput(output, includeParent);\n  },\n\n  /**\r\n   * Gets the top-center coordinate of this Game Object, regardless of origin.\r\n   * The returned point is calculated in local space and does not factor in any parent containers\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#getTopCenter\r\n   * @since 3.18.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n   * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n   *\r\n   * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n   */\n  getTopCenter: function (output, includeParent) {\n    if (!output) {\n      output = new Vector2();\n    }\n\n    output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;\n    output.y = this.y - this.displayHeight * this.originY;\n    return this.prepareBoundsOutput(output, includeParent);\n  },\n\n  /**\r\n   * Gets the top-right corner coordinate of this Game Object, regardless of origin.\r\n   * The returned point is calculated in local space and does not factor in any parent containers\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#getTopRight\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n   * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n   *\r\n   * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n   */\n  getTopRight: function (output, includeParent) {\n    if (!output) {\n      output = new Vector2();\n    }\n\n    output.x = this.x - this.displayWidth * this.originX + this.displayWidth;\n    output.y = this.y - this.displayHeight * this.originY;\n    return this.prepareBoundsOutput(output, includeParent);\n  },\n\n  /**\r\n   * Gets the left-center coordinate of this Game Object, regardless of origin.\r\n   * The returned point is calculated in local space and does not factor in any parent containers\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#getLeftCenter\r\n   * @since 3.18.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n   * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n   *\r\n   * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n   */\n  getLeftCenter: function (output, includeParent) {\n    if (!output) {\n      output = new Vector2();\n    }\n\n    output.x = this.x - this.displayWidth * this.originX;\n    output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;\n    return this.prepareBoundsOutput(output, includeParent);\n  },\n\n  /**\r\n   * Gets the right-center coordinate of this Game Object, regardless of origin.\r\n   * The returned point is calculated in local space and does not factor in any parent containers\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#getRightCenter\r\n   * @since 3.18.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n   * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n   *\r\n   * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n   */\n  getRightCenter: function (output, includeParent) {\n    if (!output) {\n      output = new Vector2();\n    }\n\n    output.x = this.x - this.displayWidth * this.originX + this.displayWidth;\n    output.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2;\n    return this.prepareBoundsOutput(output, includeParent);\n  },\n\n  /**\r\n   * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.\r\n   * The returned point is calculated in local space and does not factor in any parent containers\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#getBottomLeft\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n   * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n   *\r\n   * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n   */\n  getBottomLeft: function (output, includeParent) {\n    if (!output) {\n      output = new Vector2();\n    }\n\n    output.x = this.x - this.displayWidth * this.originX;\n    output.y = this.y - this.displayHeight * this.originY + this.displayHeight;\n    return this.prepareBoundsOutput(output, includeParent);\n  },\n\n  /**\r\n   * Gets the bottom-center coordinate of this Game Object, regardless of origin.\r\n   * The returned point is calculated in local space and does not factor in any parent containers\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#getBottomCenter\r\n   * @since 3.18.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n   * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n   *\r\n   * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n   */\n  getBottomCenter: function (output, includeParent) {\n    if (!output) {\n      output = new Vector2();\n    }\n\n    output.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2;\n    output.y = this.y - this.displayHeight * this.originY + this.displayHeight;\n    return this.prepareBoundsOutput(output, includeParent);\n  },\n\n  /**\r\n   * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.\r\n   * The returned point is calculated in local space and does not factor in any parent containers\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#getBottomRight\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n   * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n   *\r\n   * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n   */\n  getBottomRight: function (output, includeParent) {\n    if (!output) {\n      output = new Vector2();\n    }\n\n    output.x = this.x - this.displayWidth * this.originX + this.displayWidth;\n    output.y = this.y - this.displayHeight * this.originY + this.displayHeight;\n    return this.prepareBoundsOutput(output, includeParent);\n  },\n\n  /**\r\n   * Gets the bounds of this Game Object, regardless of origin.\r\n   * The values are stored and returned in a Rectangle, or Rectangle-like, object.\r\n   *\r\n   * @method Phaser.GameObjects.Components.GetBounds#getBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Geom.Rectangle} O - [output,$return]\r\n   *\r\n   * @param {(Phaser.Geom.Rectangle|object)} [output] - An object to store the values in. If not provided a new Rectangle will be created.\r\n   *\r\n   * @return {(Phaser.Geom.Rectangle|object)} The values stored in the output object.\r\n   */\n  getBounds: function (output) {\n    if (output === undefined) {\n      output = new Rectangle();\n    } //  We can use the output object to temporarily store the x/y coords in:\n\n\n    var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy; // Instead of doing a check if parent container is \n    // defined per corner we only do it once.\n\n    if (this.parentContainer) {\n      var parentMatrix = this.parentContainer.getBoundsTransformMatrix();\n      this.getTopLeft(output);\n      parentMatrix.transformPoint(output.x, output.y, output);\n      TLx = output.x;\n      TLy = output.y;\n      this.getTopRight(output);\n      parentMatrix.transformPoint(output.x, output.y, output);\n      TRx = output.x;\n      TRy = output.y;\n      this.getBottomLeft(output);\n      parentMatrix.transformPoint(output.x, output.y, output);\n      BLx = output.x;\n      BLy = output.y;\n      this.getBottomRight(output);\n      parentMatrix.transformPoint(output.x, output.y, output);\n      BRx = output.x;\n      BRy = output.y;\n    } else {\n      this.getTopLeft(output);\n      TLx = output.x;\n      TLy = output.y;\n      this.getTopRight(output);\n      TRx = output.x;\n      TRy = output.y;\n      this.getBottomLeft(output);\n      BLx = output.x;\n      BLy = output.y;\n      this.getBottomRight(output);\n      BRx = output.x;\n      BRy = output.y;\n    }\n\n    output.x = Math.min(TLx, TRx, BLx, BRx);\n    output.y = Math.min(TLy, TRy, BLy, BRy);\n    output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;\n    output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;\n    return output;\n  }\n};\nmodule.exports = GetBounds;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/components/GetBounds.js"],"names":["Rectangle","require","RotateAround","Vector2","GetBounds","prepareBoundsOutput","output","includeParent","undefined","rotation","x","y","parentContainer","parentMatrix","getBoundsTransformMatrix","transformPoint","getCenter","displayWidth","originX","displayHeight","originY","getTopLeft","getTopCenter","getTopRight","getLeftCenter","getRightCenter","getBottomLeft","getBottomCenter","getBottomRight","getBounds","TLx","TLy","TRx","TRy","BLx","BLy","BRx","BRy","Math","min","width","max","height","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar RotateAround = require('../../math/RotateAround');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Provides methods used for obtaining the bounds of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @namespace Phaser.GameObjects.Components.GetBounds\r\n * @since 3.0.0\r\n */\r\n\r\nvar GetBounds = {\r\n\r\n    /**\r\n     * Processes the bounds output vector before returning it.\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#prepareBoundsOutput\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} output - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    prepareBoundsOutput: function (output, includeParent)\r\n    {\r\n        if (includeParent === undefined) { includeParent = false; }\r\n\r\n        if (this.rotation !== 0)\r\n        {\r\n            RotateAround(output, this.x, this.y, this.rotation);\r\n        }\r\n\r\n        if (includeParent && this.parentContainer)\r\n        {\r\n            var parentMatrix = this.parentContainer.getBoundsTransformMatrix();\r\n\r\n            parentMatrix.transformPoint(output.x, output.y, output);\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Gets the center coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getCenter\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getCenter: function (output)\r\n    {\r\n        if (output === undefined) { output = new Vector2(); }\r\n\r\n        output.x = this.x - (this.displayWidth * this.originX) + (this.displayWidth / 2);\r\n        output.y = this.y - (this.displayHeight * this.originY) + (this.displayHeight / 2);\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Gets the top-left corner coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getTopLeft\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getTopLeft: function (output, includeParent)\r\n    {\r\n        if (!output) { output = new Vector2(); }\r\n\r\n        output.x = this.x - (this.displayWidth * this.originX);\r\n        output.y = this.y - (this.displayHeight * this.originY);\r\n\r\n        return this.prepareBoundsOutput(output, includeParent);\r\n    },\r\n\r\n    /**\r\n     * Gets the top-center coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getTopCenter\r\n     * @since 3.18.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getTopCenter: function (output, includeParent)\r\n    {\r\n        if (!output) { output = new Vector2(); }\r\n\r\n        output.x = (this.x - (this.displayWidth * this.originX)) + (this.displayWidth / 2);\r\n        output.y = this.y - (this.displayHeight * this.originY);\r\n\r\n        return this.prepareBoundsOutput(output, includeParent);\r\n    },\r\n\r\n    /**\r\n     * Gets the top-right corner coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getTopRight\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getTopRight: function (output, includeParent)\r\n    {\r\n        if (!output) { output = new Vector2(); }\r\n\r\n        output.x = (this.x - (this.displayWidth * this.originX)) + this.displayWidth;\r\n        output.y = this.y - (this.displayHeight * this.originY);\r\n\r\n        return this.prepareBoundsOutput(output, includeParent);\r\n    },\r\n\r\n    /**\r\n     * Gets the left-center coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getLeftCenter\r\n     * @since 3.18.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getLeftCenter: function (output, includeParent)\r\n    {\r\n        if (!output) { output = new Vector2(); }\r\n\r\n        output.x = this.x - (this.displayWidth * this.originX);\r\n        output.y = (this.y - (this.displayHeight * this.originY)) + (this.displayHeight / 2);\r\n\r\n        return this.prepareBoundsOutput(output, includeParent);\r\n    },\r\n\r\n    /**\r\n     * Gets the right-center coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getRightCenter\r\n     * @since 3.18.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getRightCenter: function (output, includeParent)\r\n    {\r\n        if (!output) { output = new Vector2(); }\r\n\r\n        output.x = (this.x - (this.displayWidth * this.originX)) + this.displayWidth;\r\n        output.y = (this.y - (this.displayHeight * this.originY)) + (this.displayHeight / 2);\r\n\r\n        return this.prepareBoundsOutput(output, includeParent);\r\n    },\r\n\r\n    /**\r\n     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getBottomLeft\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getBottomLeft: function (output, includeParent)\r\n    {\r\n        if (!output) { output = new Vector2(); }\r\n\r\n        output.x = this.x - (this.displayWidth * this.originX);\r\n        output.y = (this.y - (this.displayHeight * this.originY)) + this.displayHeight;\r\n\r\n        return this.prepareBoundsOutput(output, includeParent);\r\n    },\r\n\r\n    /**\r\n     * Gets the bottom-center coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getBottomCenter\r\n     * @since 3.18.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getBottomCenter: function (output, includeParent)\r\n    {\r\n        if (!output) { output = new Vector2(); }\r\n\r\n        output.x = (this.x - (this.displayWidth * this.originX)) + (this.displayWidth / 2);\r\n        output.y = (this.y - (this.displayHeight * this.originY)) + this.displayHeight;\r\n\r\n        return this.prepareBoundsOutput(output, includeParent);\r\n    },\r\n\r\n    /**\r\n     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getBottomRight\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getBottomRight: function (output, includeParent)\r\n    {\r\n        if (!output) { output = new Vector2(); }\r\n\r\n        output.x = (this.x - (this.displayWidth * this.originX)) + this.displayWidth;\r\n        output.y = (this.y - (this.displayHeight * this.originY)) + this.displayHeight;\r\n\r\n        return this.prepareBoundsOutput(output, includeParent);\r\n    },\r\n\r\n    /**\r\n     * Gets the bounds of this Game Object, regardless of origin.\r\n     * The values are stored and returned in a Rectangle, or Rectangle-like, object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Rectangle} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Geom.Rectangle|object)} [output] - An object to store the values in. If not provided a new Rectangle will be created.\r\n     *\r\n     * @return {(Phaser.Geom.Rectangle|object)} The values stored in the output object.\r\n     */\r\n    getBounds: function (output)\r\n    {\r\n        if (output === undefined) { output = new Rectangle(); }\r\n\r\n        //  We can use the output object to temporarily store the x/y coords in:\r\n\r\n        var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy;\r\n\r\n        // Instead of doing a check if parent container is \r\n        // defined per corner we only do it once.\r\n        if (this.parentContainer)\r\n        {\r\n            var parentMatrix = this.parentContainer.getBoundsTransformMatrix();\r\n\r\n            this.getTopLeft(output);\r\n            parentMatrix.transformPoint(output.x, output.y, output);\r\n\r\n            TLx = output.x;\r\n            TLy = output.y;\r\n\r\n            this.getTopRight(output);\r\n            parentMatrix.transformPoint(output.x, output.y, output);\r\n\r\n            TRx = output.x;\r\n            TRy = output.y;\r\n\r\n            this.getBottomLeft(output);\r\n            parentMatrix.transformPoint(output.x, output.y, output);\r\n\r\n            BLx = output.x;\r\n            BLy = output.y;\r\n\r\n            this.getBottomRight(output);\r\n            parentMatrix.transformPoint(output.x, output.y, output);\r\n\r\n            BRx = output.x;\r\n            BRy = output.y;\r\n        }\r\n        else\r\n        {\r\n            this.getTopLeft(output);\r\n\r\n            TLx = output.x;\r\n            TLy = output.y;\r\n\r\n            this.getTopRight(output);\r\n\r\n            TRx = output.x;\r\n            TRy = output.y;\r\n\r\n            this.getBottomLeft(output);\r\n\r\n            BLx = output.x;\r\n            BLy = output.y;\r\n\r\n            this.getBottomRight(output);\r\n\r\n            BRx = output.x;\r\n            BRy = output.y;\r\n        }\r\n\r\n        output.x = Math.min(TLx, TRx, BLx, BRx);\r\n        output.y = Math.min(TLy, TRy, BLy, BRy);\r\n        output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;\r\n        output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;\r\n\r\n        return output;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = GetBounds;\r\n"]},"metadata":{},"sourceType":"script"}