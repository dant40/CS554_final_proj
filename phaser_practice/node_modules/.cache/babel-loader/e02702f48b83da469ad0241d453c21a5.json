{"ast":null,"code":"/**\r\n * @author       Vladimir Agafonkin\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar quickselect = require('../utils/array/QuickSelect');\n/**\r\n * @classdesc\r\n * RBush is a high-performance JavaScript library for 2D spatial indexing of points and rectangles.\r\n * It's based on an optimized R-tree data structure with bulk insertion support.\r\n *\r\n * Spatial index is a special data structure for points and rectangles that allows you to perform queries like\r\n * \"all items within this bounding box\" very efficiently (e.g. hundreds of times faster than looping over all items).\r\n *\r\n * This version of RBush uses a fixed min/max accessor structure of `[ '.left', '.top', '.right', '.bottom' ]`.\r\n * This is to avoid the eval like function creation that the original library used, which caused CSP policy violations.\r\n * \r\n * rbush is forked from https://github.com/mourner/rbush by Vladimir Agafonkin\r\n *\r\n * @class RTree\r\n * @memberof Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n */\n\n\nfunction rbush(maxEntries) {\n  var format = ['.left', '.top', '.right', '.bottom'];\n  if (!(this instanceof rbush)) return new rbush(maxEntries, format); // max entries in a node is 9 by default; min node fill is 40% for best performance\n\n  this._maxEntries = Math.max(4, maxEntries || 9);\n  this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n  this.clear();\n}\n\nrbush.prototype = {\n  all: function () {\n    return this._all(this.data, []);\n  },\n  search: function (bbox) {\n    var node = this.data,\n        result = [],\n        toBBox = this.toBBox;\n    if (!intersects(bbox, node)) return result;\n    var nodesToSearch = [],\n        i,\n        len,\n        child,\n        childBBox;\n\n    while (node) {\n      for (i = 0, len = node.children.length; i < len; i++) {\n        child = node.children[i];\n        childBBox = node.leaf ? toBBox(child) : child;\n\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);\n        }\n      }\n\n      node = nodesToSearch.pop();\n    }\n\n    return result;\n  },\n  collides: function (bbox) {\n    var node = this.data,\n        toBBox = this.toBBox;\n    if (!intersects(bbox, node)) return false;\n    var nodesToSearch = [],\n        i,\n        len,\n        child,\n        childBBox;\n\n    while (node) {\n      for (i = 0, len = node.children.length; i < len; i++) {\n        child = node.children[i];\n        childBBox = node.leaf ? toBBox(child) : child;\n\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf || contains(bbox, childBBox)) return true;\n          nodesToSearch.push(child);\n        }\n      }\n\n      node = nodesToSearch.pop();\n    }\n\n    return false;\n  },\n  load: function (data) {\n    if (!(data && data.length)) return this;\n\n    if (data.length < this._minEntries) {\n      for (var i = 0, len = data.length; i < len; i++) {\n        this.insert(data[i]);\n      }\n\n      return this;\n    } // recursively build the tree with the given data from scratch using OMT algorithm\n\n\n    var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n    if (!this.data.children.length) {\n      // save as is if tree is empty\n      this.data = node;\n    } else if (this.data.height === node.height) {\n      // split root if trees have the same height\n      this._splitRoot(this.data, node);\n    } else {\n      if (this.data.height < node.height) {\n        // swap trees if inserted one is bigger\n        var tmpNode = this.data;\n        this.data = node;\n        node = tmpNode;\n      } // insert the small tree into the large tree at appropriate level\n\n\n      this._insert(node, this.data.height - node.height - 1, true);\n    }\n\n    return this;\n  },\n  insert: function (item) {\n    if (item) this._insert(item, this.data.height - 1);\n    return this;\n  },\n  clear: function () {\n    this.data = createNode([]);\n    return this;\n  },\n  remove: function (item, equalsFn) {\n    if (!item) return this;\n    var node = this.data,\n        bbox = this.toBBox(item),\n        path = [],\n        indexes = [],\n        i,\n        parent,\n        index,\n        goingUp; // depth-first iterative tree traversal\n\n    while (node || path.length) {\n      if (!node) {\n        // go up\n        node = path.pop();\n        parent = path[path.length - 1];\n        i = indexes.pop();\n        goingUp = true;\n      }\n\n      if (node.leaf) {\n        // check current node\n        index = findItem(item, node.children, equalsFn);\n\n        if (index !== -1) {\n          // item found, remove the item and condense tree upwards\n          node.children.splice(index, 1);\n          path.push(node);\n\n          this._condense(path);\n\n          return this;\n        }\n      }\n\n      if (!goingUp && !node.leaf && contains(node, bbox)) {\n        // go down\n        path.push(node);\n        indexes.push(i);\n        i = 0;\n        parent = node;\n        node = node.children[0];\n      } else if (parent) {\n        // go right\n        i++;\n        node = parent.children[i];\n        goingUp = false;\n      } else node = null; // nothing found\n\n    }\n\n    return this;\n  },\n  toBBox: function (item) {\n    return item;\n  },\n  compareMinX: compareNodeMinX,\n  compareMinY: compareNodeMinY,\n  toJSON: function () {\n    return this.data;\n  },\n  fromJSON: function (data) {\n    this.data = data;\n    return this;\n  },\n  _all: function (node, result) {\n    var nodesToSearch = [];\n\n    while (node) {\n      if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);\n      node = nodesToSearch.pop();\n    }\n\n    return result;\n  },\n  _build: function (items, left, right, height) {\n    var N = right - left + 1,\n        M = this._maxEntries,\n        node;\n\n    if (N <= M) {\n      // reached leaf level; return leaf\n      node = createNode(items.slice(left, right + 1));\n      calcBBox(node, this.toBBox);\n      return node;\n    }\n\n    if (!height) {\n      // target height of the bulk-loaded tree\n      height = Math.ceil(Math.log(N) / Math.log(M)); // target number of root entries to maximize storage utilization\n\n      M = Math.ceil(N / Math.pow(M, height - 1));\n    }\n\n    node = createNode([]);\n    node.leaf = false;\n    node.height = height; // split the items into M mostly square tiles\n\n    var N2 = Math.ceil(N / M),\n        N1 = N2 * Math.ceil(Math.sqrt(M)),\n        i,\n        j,\n        right2,\n        right3;\n    multiSelect(items, left, right, N1, this.compareMinX);\n\n    for (i = left; i <= right; i += N1) {\n      right2 = Math.min(i + N1 - 1, right);\n      multiSelect(items, i, right2, N2, this.compareMinY);\n\n      for (j = i; j <= right2; j += N2) {\n        right3 = Math.min(j + N2 - 1, right2); // pack each entry recursively\n\n        node.children.push(this._build(items, j, right3, height - 1));\n      }\n    }\n\n    calcBBox(node, this.toBBox);\n    return node;\n  },\n  _chooseSubtree: function (bbox, node, level, path) {\n    var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n    while (true) {\n      path.push(node);\n      if (node.leaf || path.length - 1 === level) break;\n      minArea = minEnlargement = Infinity;\n\n      for (i = 0, len = node.children.length; i < len; i++) {\n        child = node.children[i];\n        area = bboxArea(child);\n        enlargement = enlargedArea(bbox, child) - area; // choose entry with the least area enlargement\n\n        if (enlargement < minEnlargement) {\n          minEnlargement = enlargement;\n          minArea = area < minArea ? area : minArea;\n          targetNode = child;\n        } else if (enlargement === minEnlargement) {\n          // otherwise choose one with the smallest area\n          if (area < minArea) {\n            minArea = area;\n            targetNode = child;\n          }\n        }\n      }\n\n      node = targetNode || node.children[0];\n    }\n\n    return node;\n  },\n  _insert: function (item, level, isNode) {\n    var toBBox = this.toBBox,\n        bbox = isNode ? item : toBBox(item),\n        insertPath = []; // find the best node for accommodating the item, saving all nodes along the path too\n\n    var node = this._chooseSubtree(bbox, this.data, level, insertPath); // put the item into the node\n\n\n    node.children.push(item);\n    extend(node, bbox); // split on node overflow; propagate upwards if necessary\n\n    while (level >= 0) {\n      if (insertPath[level].children.length > this._maxEntries) {\n        this._split(insertPath, level);\n\n        level--;\n      } else break;\n    } // adjust bboxes along the insertion path\n\n\n    this._adjustParentBBoxes(bbox, insertPath, level);\n  },\n  // split overflowed node into two\n  _split: function (insertPath, level) {\n    var node = insertPath[level],\n        M = node.children.length,\n        m = this._minEntries;\n\n    this._chooseSplitAxis(node, m, M);\n\n    var splitIndex = this._chooseSplitIndex(node, m, M);\n\n    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n    newNode.height = node.height;\n    newNode.leaf = node.leaf;\n    calcBBox(node, this.toBBox);\n    calcBBox(newNode, this.toBBox);\n    if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);\n  },\n  _splitRoot: function (node, newNode) {\n    // split root node\n    this.data = createNode([node, newNode]);\n    this.data.height = node.height + 1;\n    this.data.leaf = false;\n    calcBBox(this.data, this.toBBox);\n  },\n  _chooseSplitIndex: function (node, m, M) {\n    var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n    minOverlap = minArea = Infinity;\n\n    for (i = m; i <= M - m; i++) {\n      bbox1 = distBBox(node, 0, i, this.toBBox);\n      bbox2 = distBBox(node, i, M, this.toBBox);\n      overlap = intersectionArea(bbox1, bbox2);\n      area = bboxArea(bbox1) + bboxArea(bbox2); // choose distribution with minimum overlap\n\n      if (overlap < minOverlap) {\n        minOverlap = overlap;\n        index = i;\n        minArea = area < minArea ? area : minArea;\n      } else if (overlap === minOverlap) {\n        // otherwise choose distribution with minimum area\n        if (area < minArea) {\n          minArea = area;\n          index = i;\n        }\n      }\n    }\n\n    return index;\n  },\n  // sorts node children by the best axis for split\n  _chooseSplitAxis: function (node, m, M) {\n    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n        compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n        xMargin = this._allDistMargin(node, m, M, compareMinX),\n        yMargin = this._allDistMargin(node, m, M, compareMinY); // if total distributions margin value is minimal for x, sort by minX,\n    // otherwise it's already sorted by minY\n\n\n    if (xMargin < yMargin) node.children.sort(compareMinX);\n  },\n  // total margin of all possible split distributions where each node is at least m full\n  _allDistMargin: function (node, m, M, compare) {\n    node.children.sort(compare);\n    var toBBox = this.toBBox,\n        leftBBox = distBBox(node, 0, m, toBBox),\n        rightBBox = distBBox(node, M - m, M, toBBox),\n        margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n        i,\n        child;\n\n    for (i = m; i < M - m; i++) {\n      child = node.children[i];\n      extend(leftBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(leftBBox);\n    }\n\n    for (i = M - m - 1; i >= m; i--) {\n      child = node.children[i];\n      extend(rightBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(rightBBox);\n    }\n\n    return margin;\n  },\n  _adjustParentBBoxes: function (bbox, path, level) {\n    // adjust bboxes along the given tree path\n    for (var i = level; i >= 0; i--) {\n      extend(path[i], bbox);\n    }\n  },\n  _condense: function (path) {\n    // go through the path, removing empty nodes and updating bboxes\n    for (var i = path.length - 1, siblings; i >= 0; i--) {\n      if (path[i].children.length === 0) {\n        if (i > 0) {\n          siblings = path[i - 1].children;\n          siblings.splice(siblings.indexOf(path[i]), 1);\n        } else this.clear();\n      } else calcBBox(path[i], this.toBBox);\n    }\n  },\n  compareMinX: function (a, b) {\n    return a.left - b.left;\n  },\n  compareMinY: function (a, b) {\n    return a.top - b.top;\n  },\n  toBBox: function (a) {\n    return {\n      minX: a.left,\n      minY: a.top,\n      maxX: a.right,\n      maxY: a.bottom\n    };\n  }\n};\n\nfunction findItem(item, items, equalsFn) {\n  if (!equalsFn) return items.indexOf(item);\n\n  for (var i = 0; i < items.length; i++) {\n    if (equalsFn(item, items[i])) return i;\n  }\n\n  return -1;\n} // calculate node's bbox from bboxes of its children\n\n\nfunction calcBBox(node, toBBox) {\n  distBBox(node, 0, node.children.length, toBBox, node);\n} // min bounding rectangle of node children from k to p-1\n\n\nfunction distBBox(node, k, p, toBBox, destNode) {\n  if (!destNode) destNode = createNode(null);\n  destNode.minX = Infinity;\n  destNode.minY = Infinity;\n  destNode.maxX = -Infinity;\n  destNode.maxY = -Infinity;\n\n  for (var i = k, child; i < p; i++) {\n    child = node.children[i];\n    extend(destNode, node.leaf ? toBBox(child) : child);\n  }\n\n  return destNode;\n}\n\nfunction extend(a, b) {\n  a.minX = Math.min(a.minX, b.minX);\n  a.minY = Math.min(a.minY, b.minY);\n  a.maxX = Math.max(a.maxX, b.maxX);\n  a.maxY = Math.max(a.maxY, b.maxY);\n  return a;\n}\n\nfunction compareNodeMinX(a, b) {\n  return a.minX - b.minX;\n}\n\nfunction compareNodeMinY(a, b) {\n  return a.minY - b.minY;\n}\n\nfunction bboxArea(a) {\n  return (a.maxX - a.minX) * (a.maxY - a.minY);\n}\n\nfunction bboxMargin(a) {\n  return a.maxX - a.minX + (a.maxY - a.minY);\n}\n\nfunction enlargedArea(a, b) {\n  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n  var minX = Math.max(a.minX, b.minX),\n      minY = Math.max(a.minY, b.minY),\n      maxX = Math.min(a.maxX, b.maxX),\n      maxY = Math.min(a.maxY, b.maxY);\n  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n  return {\n    children: children,\n    height: 1,\n    leaf: true,\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  };\n} // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\n\nfunction multiSelect(arr, left, right, n, compare) {\n  var stack = [left, right],\n      mid;\n\n  while (stack.length) {\n    right = stack.pop();\n    left = stack.pop();\n    if (right - left <= n) continue;\n    mid = left + Math.ceil((right - left) / n / 2) * n;\n    quickselect(arr, mid, left, right, compare);\n    stack.push(left, mid, mid, right);\n  }\n}\n\nmodule.exports = rbush;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/structs/RTree.js"],"names":["quickselect","require","rbush","maxEntries","format","_maxEntries","Math","max","_minEntries","ceil","clear","prototype","all","_all","data","search","bbox","node","result","toBBox","intersects","nodesToSearch","i","len","child","childBBox","children","length","leaf","push","contains","pop","collides","load","insert","_build","slice","height","_splitRoot","tmpNode","_insert","item","createNode","remove","equalsFn","path","indexes","parent","index","goingUp","findItem","splice","_condense","compareMinX","compareNodeMinX","compareMinY","compareNodeMinY","toJSON","fromJSON","apply","items","left","right","N","M","calcBBox","log","pow","N2","N1","sqrt","j","right2","right3","multiSelect","min","_chooseSubtree","level","targetNode","area","enlargement","minArea","minEnlargement","Infinity","bboxArea","enlargedArea","isNode","insertPath","extend","_split","_adjustParentBBoxes","m","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","distBBox","intersectionArea","xMargin","_allDistMargin","yMargin","sort","compare","leftBBox","rightBBox","margin","bboxMargin","siblings","indexOf","a","b","top","minX","minY","maxX","maxY","bottom","k","p","destNode","arr","n","stack","mid","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Vladimir Agafonkin\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar quickselect = require('../utils/array/QuickSelect');\r\n\r\n/**\r\n * @classdesc\r\n * RBush is a high-performance JavaScript library for 2D spatial indexing of points and rectangles.\r\n * It's based on an optimized R-tree data structure with bulk insertion support.\r\n *\r\n * Spatial index is a special data structure for points and rectangles that allows you to perform queries like\r\n * \"all items within this bounding box\" very efficiently (e.g. hundreds of times faster than looping over all items).\r\n *\r\n * This version of RBush uses a fixed min/max accessor structure of `[ '.left', '.top', '.right', '.bottom' ]`.\r\n * This is to avoid the eval like function creation that the original library used, which caused CSP policy violations.\r\n * \r\n * rbush is forked from https://github.com/mourner/rbush by Vladimir Agafonkin\r\n *\r\n * @class RTree\r\n * @memberof Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n */\r\n\r\nfunction rbush (maxEntries)\r\n{\r\n    var format = [ '.left', '.top', '.right', '.bottom' ];\r\n\r\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\r\n\r\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\r\n    this._maxEntries = Math.max(4, maxEntries || 9);\r\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\r\n\r\n    this.clear();\r\n}\r\n\r\nrbush.prototype = {\r\n\r\n    all: function ()\r\n    {\r\n        return this._all(this.data, []);\r\n    },\r\n\r\n    search: function (bbox)\r\n    {\r\n        var node = this.data,\r\n            result = [],\r\n            toBBox = this.toBBox;\r\n\r\n        if (!intersects(bbox, node)) return result;\r\n\r\n        var nodesToSearch = [],\r\n            i, len, child, childBBox;\r\n\r\n        while (node) {\r\n            for (i = 0, len = node.children.length; i < len; i++) {\r\n\r\n                child = node.children[i];\r\n                childBBox = node.leaf ? toBBox(child) : child;\r\n\r\n                if (intersects(bbox, childBBox)) {\r\n                    if (node.leaf) result.push(child);\r\n                    else if (contains(bbox, childBBox)) this._all(child, result);\r\n                    else nodesToSearch.push(child);\r\n                }\r\n            }\r\n            node = nodesToSearch.pop();\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    collides: function (bbox)\r\n    {\r\n        var node = this.data,\r\n            toBBox = this.toBBox;\r\n\r\n        if (!intersects(bbox, node)) return false;\r\n\r\n        var nodesToSearch = [],\r\n            i, len, child, childBBox;\r\n\r\n        while (node) {\r\n            for (i = 0, len = node.children.length; i < len; i++) {\r\n\r\n                child = node.children[i];\r\n                childBBox = node.leaf ? toBBox(child) : child;\r\n\r\n                if (intersects(bbox, childBBox)) {\r\n                    if (node.leaf || contains(bbox, childBBox)) return true;\r\n                    nodesToSearch.push(child);\r\n                }\r\n            }\r\n            node = nodesToSearch.pop();\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    load: function (data)\r\n    {\r\n        if (!(data && data.length)) return this;\r\n\r\n        if (data.length < this._minEntries) {\r\n            for (var i = 0, len = data.length; i < len; i++) {\r\n                this.insert(data[i]);\r\n            }\r\n            return this;\r\n        }\r\n\r\n        // recursively build the tree with the given data from scratch using OMT algorithm\r\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\r\n\r\n        if (!this.data.children.length) {\r\n            // save as is if tree is empty\r\n            this.data = node;\r\n\r\n        } else if (this.data.height === node.height) {\r\n            // split root if trees have the same height\r\n            this._splitRoot(this.data, node);\r\n\r\n        } else {\r\n            if (this.data.height < node.height) {\r\n                // swap trees if inserted one is bigger\r\n                var tmpNode = this.data;\r\n                this.data = node;\r\n                node = tmpNode;\r\n            }\r\n\r\n            // insert the small tree into the large tree at appropriate level\r\n            this._insert(node, this.data.height - node.height - 1, true);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    insert: function (item)\r\n    {\r\n        if (item) this._insert(item, this.data.height - 1);\r\n        return this;\r\n    },\r\n\r\n    clear: function ()\r\n    {\r\n        this.data = createNode([]);\r\n        return this;\r\n    },\r\n\r\n    remove: function (item, equalsFn)\r\n    {\r\n        if (!item) return this;\r\n\r\n        var node = this.data,\r\n            bbox = this.toBBox(item),\r\n            path = [],\r\n            indexes = [],\r\n            i, parent, index, goingUp;\r\n\r\n        // depth-first iterative tree traversal\r\n        while (node || path.length) {\r\n\r\n            if (!node) { // go up\r\n                node = path.pop();\r\n                parent = path[path.length - 1];\r\n                i = indexes.pop();\r\n                goingUp = true;\r\n            }\r\n\r\n            if (node.leaf) { // check current node\r\n                index = findItem(item, node.children, equalsFn);\r\n\r\n                if (index !== -1) {\r\n                    // item found, remove the item and condense tree upwards\r\n                    node.children.splice(index, 1);\r\n                    path.push(node);\r\n                    this._condense(path);\r\n                    return this;\r\n                }\r\n            }\r\n\r\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\r\n                path.push(node);\r\n                indexes.push(i);\r\n                i = 0;\r\n                parent = node;\r\n                node = node.children[0];\r\n\r\n            } else if (parent) { // go right\r\n                i++;\r\n                node = parent.children[i];\r\n                goingUp = false;\r\n\r\n            } else node = null; // nothing found\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    toBBox: function (item) { return item; },\r\n\r\n    compareMinX: compareNodeMinX,\r\n    compareMinY: compareNodeMinY,\r\n\r\n    toJSON: function () { return this.data; },\r\n\r\n    fromJSON: function (data)\r\n    {\r\n        this.data = data;\r\n        return this;\r\n    },\r\n\r\n    _all: function (node, result)\r\n    {\r\n        var nodesToSearch = [];\r\n        while (node) {\r\n            if (node.leaf) result.push.apply(result, node.children);\r\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\r\n\r\n            node = nodesToSearch.pop();\r\n        }\r\n        return result;\r\n    },\r\n\r\n    _build: function (items, left, right, height)\r\n    {\r\n        var N = right - left + 1,\r\n            M = this._maxEntries,\r\n            node;\r\n\r\n        if (N <= M) {\r\n            // reached leaf level; return leaf\r\n            node = createNode(items.slice(left, right + 1));\r\n            calcBBox(node, this.toBBox);\r\n            return node;\r\n        }\r\n\r\n        if (!height) {\r\n            // target height of the bulk-loaded tree\r\n            height = Math.ceil(Math.log(N) / Math.log(M));\r\n\r\n            // target number of root entries to maximize storage utilization\r\n            M = Math.ceil(N / Math.pow(M, height - 1));\r\n        }\r\n\r\n        node = createNode([]);\r\n        node.leaf = false;\r\n        node.height = height;\r\n\r\n        // split the items into M mostly square tiles\r\n\r\n        var N2 = Math.ceil(N / M),\r\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\r\n            i, j, right2, right3;\r\n\r\n        multiSelect(items, left, right, N1, this.compareMinX);\r\n\r\n        for (i = left; i <= right; i += N1) {\r\n\r\n            right2 = Math.min(i + N1 - 1, right);\r\n\r\n            multiSelect(items, i, right2, N2, this.compareMinY);\r\n\r\n            for (j = i; j <= right2; j += N2) {\r\n\r\n                right3 = Math.min(j + N2 - 1, right2);\r\n\r\n                // pack each entry recursively\r\n                node.children.push(this._build(items, j, right3, height - 1));\r\n            }\r\n        }\r\n\r\n        calcBBox(node, this.toBBox);\r\n\r\n        return node;\r\n    },\r\n\r\n    _chooseSubtree: function (bbox, node, level, path)\r\n    {\r\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\r\n\r\n        while (true) {\r\n            path.push(node);\r\n\r\n            if (node.leaf || path.length - 1 === level) break;\r\n\r\n            minArea = minEnlargement = Infinity;\r\n\r\n            for (i = 0, len = node.children.length; i < len; i++) {\r\n                child = node.children[i];\r\n                area = bboxArea(child);\r\n                enlargement = enlargedArea(bbox, child) - area;\r\n\r\n                // choose entry with the least area enlargement\r\n                if (enlargement < minEnlargement) {\r\n                    minEnlargement = enlargement;\r\n                    minArea = area < minArea ? area : minArea;\r\n                    targetNode = child;\r\n\r\n                } else if (enlargement === minEnlargement) {\r\n                    // otherwise choose one with the smallest area\r\n                    if (area < minArea) {\r\n                        minArea = area;\r\n                        targetNode = child;\r\n                    }\r\n                }\r\n            }\r\n\r\n            node = targetNode || node.children[0];\r\n        }\r\n\r\n        return node;\r\n    },\r\n\r\n    _insert: function (item, level, isNode)\r\n    {\r\n        var toBBox = this.toBBox,\r\n            bbox = isNode ? item : toBBox(item),\r\n            insertPath = [];\r\n\r\n        // find the best node for accommodating the item, saving all nodes along the path too\r\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\r\n\r\n        // put the item into the node\r\n        node.children.push(item);\r\n        extend(node, bbox);\r\n\r\n        // split on node overflow; propagate upwards if necessary\r\n        while (level >= 0) {\r\n            if (insertPath[level].children.length > this._maxEntries) {\r\n                this._split(insertPath, level);\r\n                level--;\r\n            } else break;\r\n        }\r\n\r\n        // adjust bboxes along the insertion path\r\n        this._adjustParentBBoxes(bbox, insertPath, level);\r\n    },\r\n\r\n    // split overflowed node into two\r\n    _split: function (insertPath, level)\r\n    {\r\n        var node = insertPath[level],\r\n            M = node.children.length,\r\n            m = this._minEntries;\r\n\r\n        this._chooseSplitAxis(node, m, M);\r\n\r\n        var splitIndex = this._chooseSplitIndex(node, m, M);\r\n\r\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\r\n        newNode.height = node.height;\r\n        newNode.leaf = node.leaf;\r\n\r\n        calcBBox(node, this.toBBox);\r\n        calcBBox(newNode, this.toBBox);\r\n\r\n        if (level) insertPath[level - 1].children.push(newNode);\r\n        else this._splitRoot(node, newNode);\r\n    },\r\n\r\n    _splitRoot: function (node, newNode)\r\n    {\r\n        // split root node\r\n        this.data = createNode([node, newNode]);\r\n        this.data.height = node.height + 1;\r\n        this.data.leaf = false;\r\n        calcBBox(this.data, this.toBBox);\r\n    },\r\n\r\n    _chooseSplitIndex: function (node, m, M)\r\n    {\r\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\r\n\r\n        minOverlap = minArea = Infinity;\r\n\r\n        for (i = m; i <= M - m; i++) {\r\n            bbox1 = distBBox(node, 0, i, this.toBBox);\r\n            bbox2 = distBBox(node, i, M, this.toBBox);\r\n\r\n            overlap = intersectionArea(bbox1, bbox2);\r\n            area = bboxArea(bbox1) + bboxArea(bbox2);\r\n\r\n            // choose distribution with minimum overlap\r\n            if (overlap < minOverlap) {\r\n                minOverlap = overlap;\r\n                index = i;\r\n\r\n                minArea = area < minArea ? area : minArea;\r\n\r\n            } else if (overlap === minOverlap) {\r\n                // otherwise choose distribution with minimum area\r\n                if (area < minArea) {\r\n                    minArea = area;\r\n                    index = i;\r\n                }\r\n            }\r\n        }\r\n\r\n        return index;\r\n    },\r\n\r\n    // sorts node children by the best axis for split\r\n    _chooseSplitAxis: function (node, m, M)\r\n    {\r\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\r\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\r\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\r\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\r\n\r\n        // if total distributions margin value is minimal for x, sort by minX,\r\n        // otherwise it's already sorted by minY\r\n        if (xMargin < yMargin) node.children.sort(compareMinX);\r\n    },\r\n\r\n    // total margin of all possible split distributions where each node is at least m full\r\n    _allDistMargin: function (node, m, M, compare)\r\n    {\r\n        node.children.sort(compare);\r\n\r\n        var toBBox = this.toBBox,\r\n            leftBBox = distBBox(node, 0, m, toBBox),\r\n            rightBBox = distBBox(node, M - m, M, toBBox),\r\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\r\n            i, child;\r\n\r\n        for (i = m; i < M - m; i++) {\r\n            child = node.children[i];\r\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\r\n            margin += bboxMargin(leftBBox);\r\n        }\r\n\r\n        for (i = M - m - 1; i >= m; i--) {\r\n            child = node.children[i];\r\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\r\n            margin += bboxMargin(rightBBox);\r\n        }\r\n\r\n        return margin;\r\n    },\r\n\r\n    _adjustParentBBoxes: function (bbox, path, level)\r\n    {\r\n        // adjust bboxes along the given tree path\r\n        for (var i = level; i >= 0; i--) {\r\n            extend(path[i], bbox);\r\n        }\r\n    },\r\n\r\n    _condense: function (path)\r\n    {\r\n        // go through the path, removing empty nodes and updating bboxes\r\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\r\n            if (path[i].children.length === 0) {\r\n                if (i > 0) {\r\n                    siblings = path[i - 1].children;\r\n                    siblings.splice(siblings.indexOf(path[i]), 1);\r\n\r\n                } else this.clear();\r\n\r\n            } else calcBBox(path[i], this.toBBox);\r\n        }\r\n    },\r\n\r\n    compareMinX: function (a, b)\r\n    {\r\n        return a.left - b.left;\r\n    },\r\n\r\n    compareMinY: function (a, b)\r\n    {\r\n        return a.top - b.top;\r\n    },\r\n\r\n    toBBox: function (a)\r\n    {\r\n        return {\r\n            minX: a.left,\r\n            minY: a.top,\r\n            maxX: a.right,\r\n            maxY: a.bottom\r\n        };\r\n    }\r\n};\r\n\r\nfunction findItem (item, items, equalsFn)\r\n{\r\n    if (!equalsFn) return items.indexOf(item);\r\n\r\n    for (var i = 0; i < items.length; i++) {\r\n        if (equalsFn(item, items[i])) return i;\r\n    }\r\n    return -1;\r\n}\r\n\r\n// calculate node's bbox from bboxes of its children\r\nfunction calcBBox (node, toBBox)\r\n{\r\n    distBBox(node, 0, node.children.length, toBBox, node);\r\n}\r\n\r\n// min bounding rectangle of node children from k to p-1\r\nfunction distBBox (node, k, p, toBBox, destNode)\r\n{\r\n    if (!destNode) destNode = createNode(null);\r\n    destNode.minX = Infinity;\r\n    destNode.minY = Infinity;\r\n    destNode.maxX = -Infinity;\r\n    destNode.maxY = -Infinity;\r\n\r\n    for (var i = k, child; i < p; i++) {\r\n        child = node.children[i];\r\n        extend(destNode, node.leaf ? toBBox(child) : child);\r\n    }\r\n\r\n    return destNode;\r\n}\r\n\r\nfunction extend (a, b)\r\n{\r\n    a.minX = Math.min(a.minX, b.minX);\r\n    a.minY = Math.min(a.minY, b.minY);\r\n    a.maxX = Math.max(a.maxX, b.maxX);\r\n    a.maxY = Math.max(a.maxY, b.maxY);\r\n    return a;\r\n}\r\n\r\nfunction compareNodeMinX (a, b) { return a.minX - b.minX; }\r\nfunction compareNodeMinY (a, b) { return a.minY - b.minY; }\r\n\r\nfunction bboxArea (a) { return (a.maxX - a.minX) * (a.maxY - a.minY); }\r\nfunction bboxMargin (a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\r\n\r\nfunction enlargedArea (a, b)\r\n{\r\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\r\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\r\n}\r\n\r\nfunction intersectionArea (a, b)\r\n{\r\n    var minX = Math.max(a.minX, b.minX),\r\n        minY = Math.max(a.minY, b.minY),\r\n        maxX = Math.min(a.maxX, b.maxX),\r\n        maxY = Math.min(a.maxY, b.maxY);\r\n\r\n    return Math.max(0, maxX - minX) *\r\n           Math.max(0, maxY - minY);\r\n}\r\n\r\nfunction contains (a, b)\r\n{\r\n    return a.minX <= b.minX &&\r\n           a.minY <= b.minY &&\r\n           b.maxX <= a.maxX &&\r\n           b.maxY <= a.maxY;\r\n}\r\n\r\nfunction intersects (a, b)\r\n{\r\n    return b.minX <= a.maxX &&\r\n           b.minY <= a.maxY &&\r\n           b.maxX >= a.minX &&\r\n           b.maxY >= a.minY;\r\n}\r\n\r\nfunction createNode (children)\r\n{\r\n    return {\r\n        children: children,\r\n        height: 1,\r\n        leaf: true,\r\n        minX: Infinity,\r\n        minY: Infinity,\r\n        maxX: -Infinity,\r\n        maxY: -Infinity\r\n    };\r\n}\r\n\r\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\r\n// combines selection algorithm with binary divide & conquer approach\r\n\r\nfunction multiSelect (arr, left, right, n, compare)\r\n{\r\n    var stack = [left, right],\r\n        mid;\r\n\r\n    while (stack.length)\r\n    {\r\n        right = stack.pop();\r\n        left = stack.pop();\r\n\r\n        if (right - left <= n) continue;\r\n\r\n        mid = left + Math.ceil((right - left) / n / 2) * n;\r\n        quickselect(arr, mid, left, right, compare);\r\n\r\n        stack.push(left, mid, mid, right);\r\n    }\r\n}\r\n\r\nmodule.exports = rbush;"]},"metadata":{},"sourceType":"script"}