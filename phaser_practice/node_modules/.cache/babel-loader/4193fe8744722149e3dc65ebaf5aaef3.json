{"ast":null,"code":"/**\r\n* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).\r\n*\r\n* @class Bounds\r\n*/\nvar Bounds = {};\nmodule.exports = Bounds;\n\n(function () {\n  /**\r\n   * Creates a new axis-aligned bounding box (AABB) for the given vertices.\r\n   * @method create\r\n   * @param {vertices} vertices\r\n   * @return {bounds} A new bounds object\r\n   */\n  Bounds.create = function (vertices) {\n    var bounds = {\n      min: {\n        x: 0,\n        y: 0\n      },\n      max: {\n        x: 0,\n        y: 0\n      }\n    };\n    if (vertices) Bounds.update(bounds, vertices);\n    return bounds;\n  };\n  /**\r\n   * Updates bounds using the given vertices and extends the bounds given a velocity.\r\n   * @method update\r\n   * @param {bounds} bounds\r\n   * @param {vertices} vertices\r\n   * @param {vector} velocity\r\n   */\n\n\n  Bounds.update = function (bounds, vertices, velocity) {\n    bounds.min.x = Infinity;\n    bounds.max.x = -Infinity;\n    bounds.min.y = Infinity;\n    bounds.max.y = -Infinity;\n\n    for (var i = 0; i < vertices.length; i++) {\n      var vertex = vertices[i];\n      if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;\n      if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;\n      if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;\n      if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;\n    }\n\n    if (velocity) {\n      if (velocity.x > 0) {\n        bounds.max.x += velocity.x;\n      } else {\n        bounds.min.x += velocity.x;\n      }\n\n      if (velocity.y > 0) {\n        bounds.max.y += velocity.y;\n      } else {\n        bounds.min.y += velocity.y;\n      }\n    }\n  };\n  /**\r\n   * Returns true if the bounds contains the given point.\r\n   * @method contains\r\n   * @param {bounds} bounds\r\n   * @param {vector} point\r\n   * @return {boolean} True if the bounds contain the point, otherwise false\r\n   */\n\n\n  Bounds.contains = function (bounds, point) {\n    return point.x >= bounds.min.x && point.x <= bounds.max.x && point.y >= bounds.min.y && point.y <= bounds.max.y;\n  };\n  /**\r\n   * Returns true if the two bounds intersect.\r\n   * @method overlaps\r\n   * @param {bounds} boundsA\r\n   * @param {bounds} boundsB\r\n   * @return {boolean} True if the bounds overlap, otherwise false\r\n   */\n\n\n  Bounds.overlaps = function (boundsA, boundsB) {\n    return boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y;\n  };\n  /**\r\n   * Translates the bounds by the given vector.\r\n   * @method translate\r\n   * @param {bounds} bounds\r\n   * @param {vector} vector\r\n   */\n\n\n  Bounds.translate = function (bounds, vector) {\n    bounds.min.x += vector.x;\n    bounds.max.x += vector.x;\n    bounds.min.y += vector.y;\n    bounds.max.y += vector.y;\n  };\n  /**\r\n   * Shifts the bounds to the given position.\r\n   * @method shift\r\n   * @param {bounds} bounds\r\n   * @param {vector} position\r\n   */\n\n\n  Bounds.shift = function (bounds, position) {\n    var deltaX = bounds.max.x - bounds.min.x,\n        deltaY = bounds.max.y - bounds.min.y;\n    bounds.min.x = position.x;\n    bounds.max.x = position.x + deltaX;\n    bounds.min.y = position.y;\n    bounds.max.y = position.y + deltaY;\n  };\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/lib/geometry/Bounds.js"],"names":["Bounds","module","exports","create","vertices","bounds","min","x","y","max","update","velocity","Infinity","i","length","vertex","contains","point","overlaps","boundsA","boundsB","translate","vector","shift","position","deltaX","deltaY"],"mappings":"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","sourcesContent":["/**\r\n* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).\r\n*\r\n* @class Bounds\r\n*/\r\n\r\nvar Bounds = {};\r\n\r\nmodule.exports = Bounds;\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new axis-aligned bounding box (AABB) for the given vertices.\r\n     * @method create\r\n     * @param {vertices} vertices\r\n     * @return {bounds} A new bounds object\r\n     */\r\n    Bounds.create = function(vertices) {\r\n        var bounds = { \r\n            min: { x: 0, y: 0 }, \r\n            max: { x: 0, y: 0 }\r\n        };\r\n\r\n        if (vertices)\r\n            Bounds.update(bounds, vertices);\r\n        \r\n        return bounds;\r\n    };\r\n\r\n    /**\r\n     * Updates bounds using the given vertices and extends the bounds given a velocity.\r\n     * @method update\r\n     * @param {bounds} bounds\r\n     * @param {vertices} vertices\r\n     * @param {vector} velocity\r\n     */\r\n    Bounds.update = function(bounds, vertices, velocity) {\r\n        bounds.min.x = Infinity;\r\n        bounds.max.x = -Infinity;\r\n        bounds.min.y = Infinity;\r\n        bounds.max.y = -Infinity;\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            var vertex = vertices[i];\r\n            if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;\r\n            if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;\r\n            if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;\r\n            if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;\r\n        }\r\n        \r\n        if (velocity) {\r\n            if (velocity.x > 0) {\r\n                bounds.max.x += velocity.x;\r\n            } else {\r\n                bounds.min.x += velocity.x;\r\n            }\r\n            \r\n            if (velocity.y > 0) {\r\n                bounds.max.y += velocity.y;\r\n            } else {\r\n                bounds.min.y += velocity.y;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns true if the bounds contains the given point.\r\n     * @method contains\r\n     * @param {bounds} bounds\r\n     * @param {vector} point\r\n     * @return {boolean} True if the bounds contain the point, otherwise false\r\n     */\r\n    Bounds.contains = function(bounds, point) {\r\n        return point.x >= bounds.min.x && point.x <= bounds.max.x \r\n               && point.y >= bounds.min.y && point.y <= bounds.max.y;\r\n    };\r\n\r\n    /**\r\n     * Returns true if the two bounds intersect.\r\n     * @method overlaps\r\n     * @param {bounds} boundsA\r\n     * @param {bounds} boundsB\r\n     * @return {boolean} True if the bounds overlap, otherwise false\r\n     */\r\n    Bounds.overlaps = function(boundsA, boundsB) {\r\n        return (boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x\r\n                && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y);\r\n    };\r\n\r\n    /**\r\n     * Translates the bounds by the given vector.\r\n     * @method translate\r\n     * @param {bounds} bounds\r\n     * @param {vector} vector\r\n     */\r\n    Bounds.translate = function(bounds, vector) {\r\n        bounds.min.x += vector.x;\r\n        bounds.max.x += vector.x;\r\n        bounds.min.y += vector.y;\r\n        bounds.max.y += vector.y;\r\n    };\r\n\r\n    /**\r\n     * Shifts the bounds to the given position.\r\n     * @method shift\r\n     * @param {bounds} bounds\r\n     * @param {vector} position\r\n     */\r\n    Bounds.shift = function(bounds, position) {\r\n        var deltaX = bounds.max.x - bounds.min.x,\r\n            deltaY = bounds.max.y - bounds.min.y;\r\n            \r\n        bounds.min.x = position.x;\r\n        bounds.max.x = position.x + deltaX;\r\n        bounds.min.y = position.y;\r\n        bounds.max.y = position.y + deltaY;\r\n    };\r\n    \r\n})();\r\n"]},"metadata":{},"sourceType":"script"}