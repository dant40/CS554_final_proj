{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Bodies = require('./lib/factory/Bodies');\n\nvar Body = require('./lib/body/Body');\n\nvar Class = require('../../utils/Class');\n\nvar Common = require('./lib/core/Common');\n\nvar Composite = require('./lib/body/Composite');\n\nvar Engine = require('./lib/core/Engine');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar GetFastValue = require('../../utils/object/GetFastValue');\n\nvar GetValue = require('../../utils/object/GetValue');\n\nvar MatterBody = require('./lib/body/Body');\n\nvar MatterEvents = require('./lib/core/Events');\n\nvar MatterTileBody = require('./MatterTileBody');\n\nvar MatterWorld = require('./lib/body/World');\n\nvar Vector = require('./lib/geometry/Vector');\n/**\r\n * @classdesc\r\n * The Matter World class is responsible for managing one single instance of a Matter Physics World for Phaser.\r\n * \r\n * Access this via `this.matter.world` from within a Scene.\r\n * \r\n * This class creates a Matter JS World Composite along with the Matter JS Engine during instantiation. It also\r\n * handles delta timing, bounds, body and constraint creation and debug drawing.\r\n * \r\n * If you wish to access the Matter JS World object directly, see the `localWorld` property.\r\n * If you wish to access the Matter Engine directly, see the `engine` property.\r\n * \r\n * This class is an Event Emitter and will proxy _all_ Matter JS events, as they are received.\r\n *\r\n * @class World\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Matter World instance belongs.\r\n * @param {Phaser.Types.Physics.Matter.MatterWorldConfig} config - The Matter World configuration object.\r\n */\n\n\nvar World = new Class({\n  Extends: EventEmitter,\n  initialize: function World(scene, config) {\n    EventEmitter.call(this);\n    /**\r\n     * The Scene to which this Matter World instance belongs.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n\n    this.scene = scene;\n    /**\r\n     * An instance of the MatterJS Engine.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#engine\r\n     * @type {MatterJS.Engine}\r\n     * @since 3.0.0\r\n     */\n\n    this.engine = Engine.create(config);\n    /**\r\n     * A `World` composite object that will contain all simulated bodies and constraints.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#localWorld\r\n     * @type {MatterJS.World}\r\n     * @since 3.0.0\r\n     */\n\n    this.localWorld = this.engine.world;\n    var gravity = GetValue(config, 'gravity', null);\n\n    if (gravity) {\n      this.setGravity(gravity.x, gravity.y, gravity.scale);\n    } else if (gravity === false) {\n      this.setGravity(0, 0, 0);\n    }\n    /**\r\n     * An object containing the 4 wall bodies that bound the physics world.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#walls\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n\n    this.walls = {\n      left: null,\n      right: null,\n      top: null,\n      bottom: null\n    };\n    /**\r\n     * A flag that toggles if the world is enabled or not.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#enabled\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.enabled = GetValue(config, 'enabled', true);\n    /**\r\n     * The correction argument is an optional Number that specifies the time correction factor to apply to the update.\r\n     * This can help improve the accuracy of the simulation in cases where delta is changing between updates.\r\n     * The value of correction is defined as delta / lastDelta, i.e. the percentage change of delta over the last step.\r\n     * Therefore the value is always 1 (no correction) when delta is constant (or when no correction is desired, which is the default).\r\n     * See the paper on Time Corrected Verlet for more information.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#correction\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.4.0\r\n     */\n\n    this.correction = GetValue(config, 'correction', 1);\n    /**\r\n     * This function is called every time the core game loop steps, which is bound to the\r\n     * Request Animation Frame frequency unless otherwise modified.\r\n     * \r\n     * The function is passed two values: `time` and `delta`, both of which come from the game step values.\r\n     * \r\n     * It must return a number. This number is used as the delta value passed to Matter.Engine.update.\r\n     * \r\n     * You can override this function with your own to define your own timestep.\r\n     * \r\n     * If you need to update the Engine multiple times in a single game step then call\r\n     * `World.update` as many times as required. Each call will trigger the `getDelta` function.\r\n     * If you wish to have full control over when the Engine updates then see the property `autoUpdate`.\r\n     *\r\n     * You can also adjust the number of iterations that Engine.update performs.\r\n     * Use the Scene Matter Physics config object to set the following properties:\r\n     *\r\n     * positionIterations (defaults to 6)\r\n     * velocityIterations (defaults to 4)\r\n     * constraintIterations (defaults to 2)\r\n     *\r\n     * Adjusting these values can help performance in certain situations, depending on the physics requirements\r\n     * of your game.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#getDelta\r\n     * @type {function}\r\n     * @since 3.4.0\r\n     */\n\n    this.getDelta = GetValue(config, 'getDelta', this.update60Hz);\n    var runnerConfig = GetFastValue(config, 'runner', {});\n    var hasFPS = GetFastValue(runnerConfig, 'fps', false);\n    var fps = GetFastValue(runnerConfig, 'fps', 60);\n    var delta = GetFastValue(runnerConfig, 'delta', 1000 / fps);\n    var deltaMin = GetFastValue(runnerConfig, 'deltaMin', 1000 / fps);\n    var deltaMax = GetFastValue(runnerConfig, 'deltaMax', 1000 / (fps * 0.5));\n\n    if (!hasFPS) {\n      fps = 1000 / delta;\n    }\n    /**\r\n     * The Matter JS Runner Configuration object.\r\n     * \r\n     * This object is populated via the Matter Configuration object's `runner` property and is\r\n     * updated constantly during the game step.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#runner\r\n     * @type {Phaser.Types.Physics.Matter.MatterRunnerConfig}\r\n     * @since 3.22.0\r\n     */\n\n\n    this.runner = {\n      fps: fps,\n      correction: GetFastValue(runnerConfig, 'correction', 1),\n      deltaSampleSize: GetFastValue(runnerConfig, 'deltaSampleSize', 60),\n      counterTimestamp: 0,\n      frameCounter: 0,\n      deltaHistory: [],\n      timePrev: null,\n      timeScalePrev: 1,\n      frameRequestId: null,\n      isFixed: GetFastValue(runnerConfig, 'isFixed', false),\n      delta: delta,\n      deltaMin: deltaMin,\n      deltaMax: deltaMax\n    };\n    /**\r\n     * Automatically call Engine.update every time the game steps.\r\n     * If you disable this then you are responsible for calling `World.step` directly from your game.\r\n     * If you call `set60Hz` or `set30Hz` then `autoUpdate` is reset to `true`.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#autoUpdate\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.4.0\r\n     */\n\n    this.autoUpdate = GetValue(config, 'autoUpdate', true);\n    var debugConfig = GetValue(config, 'debug', false);\n    /**\r\n     * A flag that controls if the debug graphics will be drawn to or not.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#drawDebug\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.drawDebug = typeof debugConfig === 'object' ? true : debugConfig;\n    /**\r\n     * An instance of the Graphics object the debug bodies are drawn to, if enabled.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#debugGraphic\r\n     * @type {Phaser.GameObjects.Graphics}\r\n     * @since 3.0.0\r\n     */\n\n    this.debugGraphic;\n    /**\r\n     * The debug configuration object.\r\n     * \r\n     * The values stored in this object are read from the Matter World Config `debug` property.\r\n     * \r\n     * When a new Body or Constraint is _added to the World_, they are given the values stored in this object,\r\n     * unless they have their own `render` object set that will override them.\r\n     * \r\n     * Note that while you can modify the values of properties in this object at run-time, it will not change\r\n     * any of the Matter objects _already added_. It will only impact objects newly added to the world, or one\r\n     * that is removed and then re-added at a later time.\r\n     *\r\n     * @name Phaser.Physics.Matter.World#debugConfig\r\n     * @type {Phaser.Types.Physics.Matter.MatterDebugConfig}\r\n     * @since 3.22.0\r\n     */\n\n    this.debugConfig = {\n      showAxes: GetFastValue(debugConfig, 'showAxes', false),\n      showAngleIndicator: GetFastValue(debugConfig, 'showAngleIndicator', false),\n      angleColor: GetFastValue(debugConfig, 'angleColor', 0xe81153),\n      showBroadphase: GetFastValue(debugConfig, 'showBroadphase', false),\n      broadphaseColor: GetFastValue(debugConfig, 'broadphaseColor', 0xffb400),\n      showBounds: GetFastValue(debugConfig, 'showBounds', false),\n      boundsColor: GetFastValue(debugConfig, 'boundsColor', 0xffffff),\n      showVelocity: GetFastValue(debugConfig, 'showVelocity', false),\n      velocityColor: GetFastValue(debugConfig, 'velocityColor', 0x00aeef),\n      showCollisions: GetFastValue(debugConfig, 'showCollisions', false),\n      collisionColor: GetFastValue(debugConfig, 'collisionColor', 0xf5950c),\n      showSeparations: GetFastValue(debugConfig, 'showSeparations', false),\n      separationColor: GetFastValue(debugConfig, 'separationColor', 0xffa500),\n      showBody: GetFastValue(debugConfig, 'showBody', true),\n      showStaticBody: GetFastValue(debugConfig, 'showStaticBody', true),\n      showInternalEdges: GetFastValue(debugConfig, 'showInternalEdges', false),\n      renderFill: GetFastValue(debugConfig, 'renderFill', false),\n      renderLine: GetFastValue(debugConfig, 'renderLine', true),\n      fillColor: GetFastValue(debugConfig, 'fillColor', 0x106909),\n      fillOpacity: GetFastValue(debugConfig, 'fillOpacity', 1),\n      lineColor: GetFastValue(debugConfig, 'lineColor', 0x28de19),\n      lineOpacity: GetFastValue(debugConfig, 'lineOpacity', 1),\n      lineThickness: GetFastValue(debugConfig, 'lineThickness', 1),\n      staticFillColor: GetFastValue(debugConfig, 'staticFillColor', 0x0d177b),\n      staticLineColor: GetFastValue(debugConfig, 'staticLineColor', 0x1327e4),\n      showSleeping: GetFastValue(debugConfig, 'showSleeping', false),\n      staticBodySleepOpacity: GetFastValue(debugConfig, 'staticBodySleepOpacity', 0.7),\n      sleepFillColor: GetFastValue(debugConfig, 'sleepFillColor', 0x464646),\n      sleepLineColor: GetFastValue(debugConfig, 'sleepLineColor', 0x999a99),\n      showSensors: GetFastValue(debugConfig, 'showSensors', true),\n      sensorFillColor: GetFastValue(debugConfig, 'sensorFillColor', 0x0d177b),\n      sensorLineColor: GetFastValue(debugConfig, 'sensorLineColor', 0x1327e4),\n      showPositions: GetFastValue(debugConfig, 'showPositions', true),\n      positionSize: GetFastValue(debugConfig, 'positionSize', 4),\n      positionColor: GetFastValue(debugConfig, 'positionColor', 0xe042da),\n      showJoint: GetFastValue(debugConfig, 'showJoint', true),\n      jointColor: GetFastValue(debugConfig, 'jointColor', 0xe0e042),\n      jointLineOpacity: GetFastValue(debugConfig, 'jointLineOpacity', 1),\n      jointLineThickness: GetFastValue(debugConfig, 'jointLineThickness', 2),\n      pinSize: GetFastValue(debugConfig, 'pinSize', 4),\n      pinColor: GetFastValue(debugConfig, 'pinColor', 0x42e0e0),\n      springColor: GetFastValue(debugConfig, 'springColor', 0xe042e0),\n      anchorColor: GetFastValue(debugConfig, 'anchorColor', 0xefefef),\n      anchorSize: GetFastValue(debugConfig, 'anchorSize', 4),\n      showConvexHulls: GetFastValue(debugConfig, 'showConvexHulls', false),\n      hullColor: GetFastValue(debugConfig, 'hullColor', 0xd703d0)\n    };\n\n    if (this.drawDebug) {\n      this.createDebugGraphic();\n    }\n\n    this.setEventsProxy(); //  Create the walls\n\n    if (GetFastValue(config, 'setBounds', false)) {\n      var boundsConfig = config['setBounds'];\n\n      if (typeof boundsConfig === 'boolean') {\n        this.setBounds();\n      } else {\n        var x = GetFastValue(boundsConfig, 'x', 0);\n        var y = GetFastValue(boundsConfig, 'y', 0);\n        var width = GetFastValue(boundsConfig, 'width', scene.sys.scale.width);\n        var height = GetFastValue(boundsConfig, 'height', scene.sys.scale.height);\n        var thickness = GetFastValue(boundsConfig, 'thickness', 64);\n        var left = GetFastValue(boundsConfig, 'left', true);\n        var right = GetFastValue(boundsConfig, 'right', true);\n        var top = GetFastValue(boundsConfig, 'top', true);\n        var bottom = GetFastValue(boundsConfig, 'bottom', true);\n        this.setBounds(x, y, width, height, thickness, left, right, top, bottom);\n      }\n    }\n  },\n\n  /**\r\n   * Sets the debug render style for the children of the given Matter Composite.\r\n   * \r\n   * Composites themselves do not render, but they can contain bodies, constraints and other composites that may do.\r\n   * So the children of this composite are passed to the `setBodyRenderStyle`, `setCompositeRenderStyle` and\r\n   * `setConstraintRenderStyle` methods accordingly.\r\n   * \r\n   * @method Phaser.Physics.Matter.World#setCompositeRenderStyle\r\n   * @since 3.22.0\r\n   *\r\n   * @param {MatterJS.CompositeType} composite - The Matter Composite to set the render style on.\r\n   * \r\n   * @return {this} This Matter World instance for method chaining.\r\n   */\n  setCompositeRenderStyle: function (composite) {\n    var bodies = composite.bodies;\n    var constraints = composite.constraints;\n    var composites = composite.composites;\n    var i;\n    var obj;\n    var render;\n\n    for (i = 0; i < bodies.length; i++) {\n      obj = bodies[i];\n      render = obj.render;\n      this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);\n    }\n\n    for (i = 0; i < constraints.length; i++) {\n      obj = constraints[i];\n      render = obj.render;\n      this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);\n    }\n\n    for (i = 0; i < composites.length; i++) {\n      obj = composites[i];\n      this.setCompositeRenderStyle(obj);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the debug render style for the given Matter Body.\r\n   * \r\n   * If you are using this on a Phaser Game Object, such as a Matter Sprite, then pass in the body property\r\n   * to this method, not the Game Object itself.\r\n   * \r\n   * If you wish to skip a parameter, so it retains its current value, pass `false` for it.\r\n   * \r\n   * If you wish to reset the Body render colors to the defaults found in the World Debug Config, then call\r\n   * this method with just the `body` parameter provided and no others.\r\n   * \r\n   * @method Phaser.Physics.Matter.World#setBodyRenderStyle\r\n   * @since 3.22.0\r\n   *\r\n   * @param {MatterJS.BodyType} body - The Matter Body to set the render style on.\r\n   * @param {number} [lineColor] - The line color. If `null` it will use the World Debug Config value.\r\n   * @param {number} [lineOpacity] - The line opacity, between 0 and 1. If `null` it will use the World Debug Config value.\r\n   * @param {number} [lineThickness] - The line thickness. If `null` it will use the World Debug Config value.\r\n   * @param {number} [fillColor] - The fill color. If `null` it will use the World Debug Config value.\r\n   * @param {number} [fillOpacity] - The fill opacity, between 0 and 1. If `null` it will use the World Debug Config value.\r\n   * \r\n   * @return {this} This Matter World instance for method chaining.\r\n   */\n  setBodyRenderStyle: function (body, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity) {\n    var render = body.render;\n    var config = this.debugConfig;\n\n    if (!render) {\n      return this;\n    }\n\n    if (lineColor === undefined || lineColor === null) {\n      lineColor = body.isStatic ? config.staticLineColor : config.lineColor;\n    }\n\n    if (lineOpacity === undefined || lineOpacity === null) {\n      lineOpacity = config.lineOpacity;\n    }\n\n    if (lineThickness === undefined || lineThickness === null) {\n      lineThickness = config.lineThickness;\n    }\n\n    if (fillColor === undefined || fillColor === null) {\n      fillColor = body.isStatic ? config.staticFillColor : config.fillColor;\n    }\n\n    if (fillOpacity === undefined || fillOpacity === null) {\n      fillOpacity = config.fillOpacity;\n    }\n\n    if (lineColor !== false) {\n      render.lineColor = lineColor;\n    }\n\n    if (lineOpacity !== false) {\n      render.lineOpacity = lineOpacity;\n    }\n\n    if (lineThickness !== false) {\n      render.lineThickness = lineThickness;\n    }\n\n    if (fillColor !== false) {\n      render.fillColor = fillColor;\n    }\n\n    if (fillOpacity !== false) {\n      render.fillOpacity = fillOpacity;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the debug render style for the given Matter Constraint.\r\n   * \r\n   * If you are using this on a Phaser Game Object, then pass in the body property\r\n   * to this method, not the Game Object itself.\r\n   * \r\n   * If you wish to skip a parameter, so it retains its current value, pass `false` for it.\r\n   * \r\n   * If you wish to reset the Constraint render colors to the defaults found in the World Debug Config, then call\r\n   * this method with just the `constraint` parameter provided and no others.\r\n   * \r\n   * @method Phaser.Physics.Matter.World#setConstraintRenderStyle\r\n   * @since 3.22.0\r\n   *\r\n   * @param {MatterJS.ConstraintType} constraint - The Matter Constraint to set the render style on.\r\n   * @param {number} [lineColor] - The line color. If `null` it will use the World Debug Config value.\r\n   * @param {number} [lineOpacity] - The line opacity, between 0 and 1. If `null` it will use the World Debug Config value.\r\n   * @param {number} [lineThickness] - The line thickness. If `null` it will use the World Debug Config value.\r\n   * @param {number} [pinSize] - If this constraint is a pin, this sets the size of the pin circle. If `null` it will use the World Debug Config value.\r\n   * @param {number} [anchorColor] - The color used when rendering this constraints anchors.  If `null` it will use the World Debug Config value.\r\n   * @param {number} [anchorSize] - The size of the anchor circle, if this constraint has anchors. If `null` it will use the World Debug Config value.\r\n   * \r\n   * @return {this} This Matter World instance for method chaining.\r\n   */\n  setConstraintRenderStyle: function (constraint, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize) {\n    var render = constraint.render;\n    var config = this.debugConfig;\n\n    if (!render) {\n      return this;\n    } //  Reset them\n\n\n    if (lineColor === undefined || lineColor === null) {\n      var type = render.type;\n\n      if (type === 'line') {\n        lineColor = config.jointColor;\n      } else if (type === 'pin') {\n        lineColor = config.pinColor;\n      } else if (type === 'spring') {\n        lineColor = config.springColor;\n      }\n    }\n\n    if (lineOpacity === undefined || lineOpacity === null) {\n      lineOpacity = config.jointLineOpacity;\n    }\n\n    if (lineThickness === undefined || lineThickness === null) {\n      lineThickness = config.jointLineThickness;\n    }\n\n    if (pinSize === undefined || pinSize === null) {\n      pinSize = config.pinSize;\n    }\n\n    if (anchorColor === undefined || anchorColor === null) {\n      anchorColor = config.anchorColor;\n    }\n\n    if (anchorSize === undefined || anchorSize === null) {\n      anchorSize = config.anchorSize;\n    }\n\n    if (lineColor !== false) {\n      render.lineColor = lineColor;\n    }\n\n    if (lineOpacity !== false) {\n      render.lineOpacity = lineOpacity;\n    }\n\n    if (lineThickness !== false) {\n      render.lineThickness = lineThickness;\n    }\n\n    if (pinSize !== false) {\n      render.pinSize = pinSize;\n    }\n\n    if (anchorColor !== false) {\n      render.anchorColor = anchorColor;\n    }\n\n    if (anchorSize !== false) {\n      render.anchorSize = anchorSize;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * This internal method acts as a proxy between all of the Matter JS events and then re-emits them\r\n   * via this class.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#setEventsProxy\r\n   * @since 3.0.0\r\n   */\n  setEventsProxy: function () {\n    var _this = this;\n\n    var engine = this.engine;\n    var world = this.localWorld; //  Inject debug styles\n\n    if (this.drawDebug) {\n      MatterEvents.on(world, 'compositeModified', function (composite) {\n        _this.setCompositeRenderStyle(composite);\n      });\n      MatterEvents.on(world, 'beforeAdd', function (event) {\n        var objects = [].concat(event.object);\n\n        for (var i = 0; i < objects.length; i++) {\n          var obj = objects[i];\n          var render = obj.render;\n\n          if (obj.type === 'body') {\n            _this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);\n          } else if (obj.type === 'composite') {\n            _this.setCompositeRenderStyle(obj);\n          } else if (obj.type === 'constraint') {\n            _this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);\n          }\n        }\n      });\n    }\n\n    MatterEvents.on(world, 'beforeAdd', function (event) {\n      _this.emit(Events.BEFORE_ADD, event);\n    });\n    MatterEvents.on(world, 'afterAdd', function (event) {\n      _this.emit(Events.AFTER_ADD, event);\n    });\n    MatterEvents.on(world, 'beforeRemove', function (event) {\n      _this.emit(Events.BEFORE_REMOVE, event);\n    });\n    MatterEvents.on(world, 'afterRemove', function (event) {\n      _this.emit(Events.AFTER_REMOVE, event);\n    });\n    MatterEvents.on(engine, 'beforeUpdate', function (event) {\n      _this.emit(Events.BEFORE_UPDATE, event);\n    });\n    MatterEvents.on(engine, 'afterUpdate', function (event) {\n      _this.emit(Events.AFTER_UPDATE, event);\n    });\n    MatterEvents.on(engine, 'collisionStart', function (event) {\n      var pairs = event.pairs;\n      var bodyA;\n      var bodyB;\n\n      if (pairs.length > 0) {\n        bodyA = pairs[0].bodyA;\n        bodyB = pairs[0].bodyB;\n      }\n\n      _this.emit(Events.COLLISION_START, event, bodyA, bodyB);\n    });\n    MatterEvents.on(engine, 'collisionActive', function (event) {\n      var pairs = event.pairs;\n      var bodyA;\n      var bodyB;\n\n      if (pairs.length > 0) {\n        bodyA = pairs[0].bodyA;\n        bodyB = pairs[0].bodyB;\n      }\n\n      _this.emit(Events.COLLISION_ACTIVE, event, bodyA, bodyB);\n    });\n    MatterEvents.on(engine, 'collisionEnd', function (event) {\n      var pairs = event.pairs;\n      var bodyA;\n      var bodyB;\n\n      if (pairs.length > 0) {\n        bodyA = pairs[0].bodyA;\n        bodyB = pairs[0].bodyB;\n      }\n\n      _this.emit(Events.COLLISION_END, event, bodyA, bodyB);\n    });\n  },\n\n  /**\r\n   * Sets the bounds of the Physics world to match the given world pixel dimensions.\r\n   * You can optionally set which 'walls' to create: left, right, top or bottom.\r\n   * If none of the walls are given it will default to use the walls settings it had previously.\r\n   * I.e. if you previously told it to not have the left or right walls, and you then adjust the world size\r\n   * the newly created bounds will also not have the left and right walls.\r\n   * Explicitly state them in the parameters to override this.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#setBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [x=0] - The x coordinate of the top-left corner of the bounds.\r\n   * @param {number} [y=0] - The y coordinate of the top-left corner of the bounds.\r\n   * @param {number} [width] - The width of the bounds.\r\n   * @param {number} [height] - The height of the bounds.\r\n   * @param {number} [thickness=64] - The thickness of each wall, in pixels.\r\n   * @param {boolean} [left=true] - If true will create the left bounds wall.\r\n   * @param {boolean} [right=true] - If true will create the right bounds wall.\r\n   * @param {boolean} [top=true] - If true will create the top bounds wall.\r\n   * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.\r\n   *\r\n   * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n   */\n  setBounds: function (x, y, width, height, thickness, left, right, top, bottom) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = this.scene.sys.scale.width;\n    }\n\n    if (height === undefined) {\n      height = this.scene.sys.scale.height;\n    }\n\n    if (thickness === undefined) {\n      thickness = 64;\n    }\n\n    if (left === undefined) {\n      left = true;\n    }\n\n    if (right === undefined) {\n      right = true;\n    }\n\n    if (top === undefined) {\n      top = true;\n    }\n\n    if (bottom === undefined) {\n      bottom = true;\n    }\n\n    this.updateWall(left, 'left', x - thickness, y - thickness, thickness, height + thickness * 2);\n    this.updateWall(right, 'right', x + width, y - thickness, thickness, height + thickness * 2);\n    this.updateWall(top, 'top', x, y - thickness, width, thickness);\n    this.updateWall(bottom, 'bottom', x, y + height, width, thickness);\n    return this;\n  },\n\n  /**\r\n   * Updates the 4 rectangle bodies that were created, if `setBounds` was set in the Matter config, to use\r\n   * the new positions and sizes. This method is usually only called internally via the `setBounds` method.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#updateWall\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} add - `true` if the walls are being added or updated, `false` to remove them from the world.\r\n   * @param {string} [position] - Either `left`, `right`, `top` or `bottom`. Only optional if `add` is `false`.\r\n   * @param {number} [x] - The horizontal position to place the walls at. Only optional if `add` is `false`.\r\n   * @param {number} [y] - The vertical position to place the walls at. Only optional if `add` is `false`.\r\n   * @param {number} [width] - The width of the walls, in pixels. Only optional if `add` is `false`.\r\n   * @param {number} [height] - The height of the walls, in pixels. Only optional if `add` is `false`.\r\n   */\n  updateWall: function (add, position, x, y, width, height) {\n    var wall = this.walls[position];\n\n    if (add) {\n      if (wall) {\n        MatterWorld.remove(this.localWorld, wall);\n      } //  adjust center\n\n\n      x += width / 2;\n      y += height / 2;\n      this.walls[position] = this.create(x, y, width, height, {\n        isStatic: true,\n        friction: 0,\n        frictionStatic: 0\n      });\n    } else {\n      if (wall) {\n        MatterWorld.remove(this.localWorld, wall);\n      }\n\n      this.walls[position] = null;\n    }\n  },\n\n  /**\r\n   * Creates a Phaser.GameObjects.Graphics object that is used to render all of the debug bodies and joints to.\r\n   * \r\n   * This method is called automatically by the constructor, if debugging has been enabled.\r\n   * \r\n   * The created Graphics object is automatically added to the Scene at 0x0 and given a depth of `Number.MAX_VALUE`,\r\n   * so it renders above all else in the Scene.\r\n   * \r\n   * The Graphics object is assigned to the `debugGraphic` property of this class and `drawDebug` is enabled.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#createDebugGraphic\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.GameObjects.Graphics} The newly created Graphics object.\r\n   */\n  createDebugGraphic: function () {\n    var graphic = this.scene.sys.add.graphics({\n      x: 0,\n      y: 0\n    });\n    graphic.setDepth(Number.MAX_VALUE);\n    this.debugGraphic = graphic;\n    this.drawDebug = true;\n    return graphic;\n  },\n\n  /**\r\n   * Sets the world gravity and gravity scale to 0.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#disableGravity\r\n   * @since 3.0.0\r\n   *\r\n   * @return {this} This Matter World object.\r\n   */\n  disableGravity: function () {\n    this.localWorld.gravity.x = 0;\n    this.localWorld.gravity.y = 0;\n    this.localWorld.gravity.scale = 0;\n    return this;\n  },\n\n  /**\r\n   * Sets the worlds gravity to the values given.\r\n   * \r\n   * Gravity effects all bodies in the world, unless they have the `ignoreGravity` flag set.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#setGravity\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [x=0] - The world gravity x component.\r\n   * @param {number} [y=1] - The world gravity y component.\r\n   * @param {number} [scale=0.001] - The gravity scale factor.\r\n   *\r\n   * @return {this} This Matter World object.\r\n   */\n  setGravity: function (x, y, scale) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 1;\n    }\n\n    this.localWorld.gravity.x = x;\n    this.localWorld.gravity.y = y;\n\n    if (scale !== undefined) {\n      this.localWorld.gravity.scale = scale;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Creates a rectangle Matter body and adds it to the world.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#create\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The horizontal position of the body in the world.\r\n   * @param {number} y - The vertical position of the body in the world.\r\n   * @param {number} width - The width of the body.\r\n   * @param {number} height - The height of the body.\r\n   * @param {object} options - Optional Matter configuration object.\r\n   *\r\n   * @return {MatterJS.BodyType} The Matter.js body that was created.\r\n   */\n  create: function (x, y, width, height, options) {\n    var body = Bodies.rectangle(x, y, width, height, options);\n    MatterWorld.add(this.localWorld, body);\n    return body;\n  },\n\n  /**\r\n   * Adds a Matter JS object, or array of objects, to the world.\r\n   * \r\n   * The objects should be valid Matter JS entities, such as a Body, Composite or Constraint.\r\n   * \r\n   * Triggers `beforeAdd` and `afterAdd` events.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#add\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(object|object[])} object - Can be single object, or an array, and can be a body, composite or constraint.\r\n   *\r\n   * @return {this} This Matter World object.\r\n   */\n  add: function (object) {\n    MatterWorld.add(this.localWorld, object);\n    return this;\n  },\n\n  /**\r\n   * Removes a Matter JS object, or array of objects, from the world.\r\n   * \r\n   * The objects should be valid Matter JS entities, such as a Body, Composite or Constraint.\r\n   * \r\n   * Triggers `beforeRemove` and `afterRemove` events.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#remove\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(object|object[])} object - Can be single object, or an array, and can be a body, composite or constraint.\r\n   * @param {boolean} [deep=false] - Optionally search the objects children and recursively remove those as well.\r\n   *\r\n   * @return {this} This Matter World object.\r\n   */\n  remove: function (object, deep) {\n    if (!Array.isArray(object)) {\n      object = [object];\n    }\n\n    for (var i = 0; i < object.length; i++) {\n      var entity = object[i];\n      var body = entity.body ? entity.body : entity;\n      Composite.remove(this.localWorld, body, deep);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes a Matter JS constraint, or array of constraints, from the world.\r\n   * \r\n   * Triggers `beforeRemove` and `afterRemove` events.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#removeConstraint\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(MatterJS.ConstraintType|MatterJS.ConstraintType[])} constraint - A Matter JS Constraint, or an array of constraints, to be removed.\r\n   * @param {boolean} [deep=false] - Optionally search the objects children and recursively remove those as well.\r\n   *\r\n   * @return {this} This Matter World object.\r\n   */\n  removeConstraint: function (constraint, deep) {\n    Composite.remove(this.localWorld, constraint, deep);\n    return this;\n  },\n\n  /**\r\n   * Adds `MatterTileBody` instances for all the colliding tiles within the given tilemap layer.\r\n   * \r\n   * Set the appropriate tiles in your layer to collide before calling this method!\r\n   *\r\n   * @method Phaser.Physics.Matter.World#convertTilemapLayer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer -\r\n   * An array of tiles.\r\n   * @param {object} [options] - Options to be passed to the MatterTileBody constructor. {@see Phaser.Physics.Matter.TileBody}\r\n   *\r\n   * @return {this} This Matter World object.\r\n   */\n  convertTilemapLayer: function (tilemapLayer, options) {\n    var layerData = tilemapLayer.layer;\n    var tiles = tilemapLayer.getTilesWithin(0, 0, layerData.width, layerData.height, {\n      isColliding: true\n    });\n    this.convertTiles(tiles, options);\n    return this;\n  },\n\n  /**\r\n   * Adds `MatterTileBody` instances for the given tiles. This adds bodies regardless of whether the\r\n   * tiles are set to collide or not.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#convertTiles\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Tilemaps.Tile[]} tiles - An array of tiles.\r\n   * @param {object} [options] - Options to be passed to the MatterTileBody constructor. {@see Phaser.Physics.Matter.TileBody}\r\n   *\r\n   * @return {this} This Matter World object.\r\n   */\n  convertTiles: function (tiles, options) {\n    if (tiles.length === 0) {\n      return this;\n    }\n\n    for (var i = 0; i < tiles.length; i++) {\n      new MatterTileBody(this, tiles[i], options);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Returns the next unique group index for which bodies will collide.\r\n   * If `isNonColliding` is `true`, returns the next unique group index for which bodies will not collide.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#nextGroup\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [isNonColliding=false] - If `true`, returns the next unique group index for which bodies will _not_ collide.\r\n   *\r\n   * @return {number} Unique category bitfield\r\n   */\n  nextGroup: function (isNonColliding) {\n    return MatterBody.nextGroup(isNonColliding);\n  },\n\n  /**\r\n   * Returns the next unique category bitfield (starting after the initial default category 0x0001).\r\n   * There are 32 available.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#nextCategory\r\n   * @since 3.0.0\r\n   *\r\n   * @return {number} Unique category bitfield\r\n   */\n  nextCategory: function () {\n    return MatterBody.nextCategory();\n  },\n\n  /**\r\n   * Pauses this Matter World instance and sets `enabled` to `false`.\r\n   * \r\n   * A paused world will not run any simulations for the duration it is paused.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#pause\r\n   * @fires Phaser.Physics.Matter.Events#PAUSE\r\n   * @since 3.0.0\r\n   *\r\n   * @return {this} This Matter World object.\r\n   */\n  pause: function () {\n    this.enabled = false;\n    this.emit(Events.PAUSE);\n    return this;\n  },\n\n  /**\r\n   * Resumes this Matter World instance from a paused state and sets `enabled` to `true`.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#resume\r\n   * @fires Phaser.Physics.Matter.Events#RESUME\r\n   * @since 3.0.0\r\n   *\r\n   * @return {this} This Matter World object.\r\n   */\n  resume: function () {\n    this.enabled = true;\n    this.emit(Events.RESUME);\n    return this;\n  },\n\n  /**\r\n   * The internal update method. This is called automatically by the parent Scene.\r\n   * \r\n   * Moves the simulation forward in time by delta ms. Uses `World.correction` value as an optional number that\r\n   * specifies the time correction factor to apply to the update. This can help improve the accuracy of the\r\n   * simulation in cases where delta is changing between updates. The value of correction is defined as `delta / lastDelta`,\r\n   * i.e. the percentage change of delta over the last step. Therefore the value is always 1 (no correction) when\r\n   * delta is constant (or when no correction is desired, which is the default).\r\n   * See the paper on Time Corrected Verlet for more information.\r\n   * \r\n   * Triggers `beforeUpdate` and `afterUpdate` events. Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.\r\n   * \r\n   * If the World is paused, `update` is still run, but exits early and does not update the Matter Engine.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#update\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n   * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n   */\n  update: function (time, delta) {\n    if (!this.enabled || !this.autoUpdate) {\n      return;\n    }\n\n    var engine = this.engine;\n    var runner = this.runner;\n    var timing = engine.timing;\n    var correction = this.correction;\n\n    if (runner.isFixed) {\n      //  fixed timestep\n      delta = this.getDelta(time, delta);\n    } else {\n      //  dynamic timestep based on wall clock between calls\n      delta = time - runner.timePrev || runner.delta;\n      runner.timePrev = time; // optimistically filter delta over a few frames, to improve stability\n\n      runner.deltaHistory.push(delta);\n      runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);\n      delta = Math.min.apply(null, runner.deltaHistory); // limit delta\n\n      delta = delta < runner.deltaMin ? runner.deltaMin : delta;\n      delta = delta > runner.deltaMax ? runner.deltaMax : delta; // correction for delta\n\n      correction = delta / runner.delta; // update engine timing object\n\n      runner.delta = delta;\n    } // time correction for time scaling\n\n\n    if (runner.timeScalePrev !== 0) {\n      correction *= timing.timeScale / runner.timeScalePrev;\n    }\n\n    if (timing.timeScale === 0) {\n      correction = 0;\n    }\n\n    runner.timeScalePrev = timing.timeScale;\n    runner.correction = correction; // fps counter\n\n    runner.frameCounter += 1;\n\n    if (time - runner.counterTimestamp >= 1000) {\n      runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1000);\n      runner.counterTimestamp = time;\n      runner.frameCounter = 0;\n    }\n\n    Engine.update(engine, delta, correction);\n  },\n\n  /**\r\n   * Manually advances the physics simulation by one iteration.\r\n   * \r\n   * You can optionally pass in the `delta` and `correction` values to be used by Engine.update.\r\n   * If undefined they use the Matter defaults of 60Hz and no correction.\r\n   * \r\n   * Calling `step` directly bypasses any checks of `enabled` or `autoUpdate`.\r\n   * \r\n   * It also ignores any custom `getDelta` functions, as you should be passing the delta\r\n   * value in to this call.\r\n   *\r\n   * You can adjust the number of iterations that Engine.update performs internally.\r\n   * Use the Scene Matter Physics config object to set the following properties:\r\n   *\r\n   * positionIterations (defaults to 6)\r\n   * velocityIterations (defaults to 4)\r\n   * constraintIterations (defaults to 2)\r\n   *\r\n   * Adjusting these values can help performance in certain situations, depending on the physics requirements\r\n   * of your game.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#step\r\n   * @since 3.4.0\r\n   *\r\n   * @param {number} [delta=16.666] - The delta value.\r\n   * @param {number} [correction=1] - Optional delta correction value.\r\n   */\n  step: function (delta, correction) {\n    Engine.update(this.engine, delta, correction);\n  },\n\n  /**\r\n   * Runs the Matter Engine.update at a fixed timestep of 60Hz.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#update60Hz\r\n   * @since 3.4.0\r\n   *\r\n   * @return {number} The delta value to be passed to Engine.update.\r\n   */\n  update60Hz: function () {\n    return 1000 / 60;\n  },\n\n  /**\r\n   * Runs the Matter Engine.update at a fixed timestep of 30Hz.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#update30Hz\r\n   * @since 3.4.0\r\n   *\r\n   * @return {number} The delta value to be passed to Engine.update.\r\n   */\n  update30Hz: function () {\n    return 1000 / 30;\n  },\n\n  /**\r\n   * Returns `true` if the given body can be found within the World.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#has\r\n   * @since 3.22.0\r\n   * \r\n   * @param {(MatterJS.Body|Phaser.GameObjects.GameObject)} body - The Matter Body, or Game Object, to search for within the world.\r\n   * \r\n   * @return {MatterJS.BodyType[]} An array of all the Matter JS Bodies in this World.\r\n   */\n  has: function (body) {\n    var src = body.hasOwnProperty('body') ? body.body : body;\n    return Composite.get(this.localWorld, src.id, src.type) !== null;\n  },\n\n  /**\r\n   * Returns all the bodies in the Matter World, including all bodies in children, recursively.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#getAllBodies\r\n   * @since 3.22.0\r\n   * \r\n   * @return {MatterJS.BodyType[]} An array of all the Matter JS Bodies in this World.\r\n   */\n  getAllBodies: function () {\n    return Composite.allBodies(this.localWorld);\n  },\n\n  /**\r\n   * Returns all the constraints in the Matter World, including all constraints in children, recursively.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#getAllConstraints\r\n   * @since 3.22.0\r\n   * \r\n   * @return {MatterJS.ConstraintType[]} An array of all the Matter JS Constraints in this World.\r\n   */\n  getAllConstraints: function () {\n    return Composite.allConstraints(this.localWorld);\n  },\n\n  /**\r\n   * Returns all the composites in the Matter World, including all composites in children, recursively.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#getAllComposites\r\n   * @since 3.22.0\r\n   * \r\n   * @return {MatterJS.CompositeType[]} An array of all the Matter JS Composites in this World.\r\n   */\n  getAllComposites: function () {\n    return Composite.allComposites(this.localWorld);\n  },\n\n  /**\r\n   * Handles the rendering of bodies and debug information to the debug Graphics object, if enabled.\r\n   * \r\n   * This method is called automatically by the Scene after all processing has taken place.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#postUpdate\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  postUpdate: function () {\n    if (!this.drawDebug) {\n      return;\n    }\n\n    var config = this.debugConfig;\n    var engine = this.engine;\n    var graphics = this.debugGraphic;\n    var bodies = Composite.allBodies(this.localWorld);\n    this.debugGraphic.clear();\n\n    if (config.showBroadphase && engine.broadphase.controller) {\n      this.renderGrid(engine.broadphase, graphics, config.broadphaseColor, 0.5);\n    }\n\n    if (config.showBounds) {\n      this.renderBodyBounds(bodies, graphics, config.boundsColor, 0.5);\n    }\n\n    if (config.showBody || config.showStaticBody) {\n      this.renderBodies(bodies);\n    }\n\n    if (config.showJoint) {\n      this.renderJoints();\n    }\n\n    if (config.showAxes || config.showAngleIndicator) {\n      this.renderBodyAxes(bodies, graphics, config.showAxes, config.angleColor, 0.5);\n    }\n\n    if (config.showVelocity) {\n      this.renderBodyVelocity(bodies, graphics, config.velocityColor, 1, 2);\n    }\n\n    if (config.showSeparations) {\n      this.renderSeparations(engine.pairs.list, graphics, config.separationColor);\n    }\n\n    if (config.showCollisions) {\n      this.renderCollisions(engine.pairs.list, graphics, config.collisionColor);\n    }\n  },\n\n  /**\r\n   * Renders the Engine Broadphase Controller Grid to the given Graphics instance.\r\n   * \r\n   * The debug renderer calls this method if the `showBroadphase` config value is set.\r\n   * \r\n   * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n   * you wish to render the Grid to your own Graphics instance.\r\n   * \r\n   * @method Phaser.Physics.Matter.World#renderGrid\r\n   * @since 3.22.0\r\n   * \r\n   * @param {MatterJS.Grid} grid - The Matter Grid to be rendered.\r\n   * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n   * @param {number} lineColor - The line color.\r\n   * @param {number} lineOpacity - The line opacity, between 0 and 1.\r\n   * \r\n   * @return {this} This Matter World instance for method chaining.\r\n   */\n  renderGrid: function (grid, graphics, lineColor, lineOpacity) {\n    graphics.lineStyle(1, lineColor, lineOpacity);\n    var bucketKeys = Common.keys(grid.buckets);\n\n    for (var i = 0; i < bucketKeys.length; i++) {\n      var bucketId = bucketKeys[i];\n\n      if (grid.buckets[bucketId].length < 2) {\n        continue;\n      }\n\n      var region = bucketId.split(/C|R/);\n      graphics.strokeRect(parseInt(region[1], 10) * grid.bucketWidth, parseInt(region[2], 10) * grid.bucketHeight, grid.bucketWidth, grid.bucketHeight);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Renders the list of Pair separations to the given Graphics instance.\r\n   * \r\n   * The debug renderer calls this method if the `showSeparations` config value is set.\r\n   * \r\n   * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n   * you wish to render the Grid to your own Graphics instance.\r\n   * \r\n   * @method Phaser.Physics.Matter.World#renderSeparations\r\n   * @since 3.22.0\r\n   * \r\n   * @param {MatterJS.Pair[]} pairs - An array of Matter Pairs to be rendered.\r\n   * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n   * @param {number} lineColor - The line color.\r\n   * \r\n   * @return {this} This Matter World instance for method chaining.\r\n   */\n  renderSeparations: function (pairs, graphics, lineColor) {\n    graphics.lineStyle(1, lineColor, 1);\n\n    for (var i = 0; i < pairs.length; i++) {\n      var pair = pairs[i];\n\n      if (!pair.isActive) {\n        continue;\n      }\n\n      var collision = pair.collision;\n      var bodyA = collision.bodyA;\n      var bodyB = collision.bodyB;\n      var posA = bodyA.position;\n      var posB = bodyB.position;\n      var penetration = collision.penetration;\n      var k = !bodyA.isStatic && !bodyB.isStatic ? 4 : 1;\n\n      if (bodyB.isStatic) {\n        k = 0;\n      }\n\n      graphics.lineBetween(posB.x, posB.y, posB.x - penetration.x * k, posB.y - penetration.y * k);\n      k = !bodyA.isStatic && !bodyB.isStatic ? 4 : 1;\n\n      if (bodyA.isStatic) {\n        k = 0;\n      }\n\n      graphics.lineBetween(posA.x, posA.y, posA.x - penetration.x * k, posA.y - penetration.y * k);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Renders the list of collision points and normals to the given Graphics instance.\r\n   * \r\n   * The debug renderer calls this method if the `showCollisions` config value is set.\r\n   * \r\n   * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n   * you wish to render the Grid to your own Graphics instance.\r\n   * \r\n   * @method Phaser.Physics.Matter.World#renderCollisions\r\n   * @since 3.22.0\r\n   * \r\n   * @param {MatterJS.Pair[]} pairs - An array of Matter Pairs to be rendered.\r\n   * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n   * @param {number} lineColor - The line color.\r\n   * \r\n   * @return {this} This Matter World instance for method chaining.\r\n   */\n  renderCollisions: function (pairs, graphics, lineColor) {\n    graphics.lineStyle(1, lineColor, 0.5);\n    graphics.fillStyle(lineColor, 1);\n    var i;\n    var pair; //  Collision Positions\n\n    for (i = 0; i < pairs.length; i++) {\n      pair = pairs[i];\n\n      if (!pair.isActive) {\n        continue;\n      }\n\n      for (var j = 0; j < pair.activeContacts.length; j++) {\n        var contact = pair.activeContacts[j];\n        var vertex = contact.vertex;\n        graphics.fillRect(vertex.x - 2, vertex.y - 2, 5, 5);\n      }\n    } //  Collision Normals\n\n\n    for (i = 0; i < pairs.length; i++) {\n      pair = pairs[i];\n\n      if (!pair.isActive) {\n        continue;\n      }\n\n      var collision = pair.collision;\n      var contacts = pair.activeContacts;\n\n      if (contacts.length > 0) {\n        var normalPosX = contacts[0].vertex.x;\n        var normalPosY = contacts[0].vertex.y;\n\n        if (contacts.length === 2) {\n          normalPosX = (contacts[0].vertex.x + contacts[1].vertex.x) / 2;\n          normalPosY = (contacts[0].vertex.y + contacts[1].vertex.y) / 2;\n        }\n\n        if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic) {\n          graphics.lineBetween(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8, normalPosX, normalPosY);\n        } else {\n          graphics.lineBetween(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8, normalPosX, normalPosY);\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Renders the bounds of an array of Bodies to the given Graphics instance.\r\n   * \r\n   * If the body is a compound body, it will render the bounds for the parent compound.\r\n   * \r\n   * The debug renderer calls this method if the `showBounds` config value is set.\r\n   * \r\n   * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n   * you wish to render bounds to your own Graphics instance.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#renderBodyBounds\r\n   * @since 3.22.0\r\n   * \r\n   * @param {array} bodies - An array of bodies from the localWorld.\r\n   * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n   * @param {number} lineColor - The line color.\r\n   * @param {number} lineOpacity - The line opacity, between 0 and 1.\r\n   */\n  renderBodyBounds: function (bodies, graphics, lineColor, lineOpacity) {\n    graphics.lineStyle(1, lineColor, lineOpacity);\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i]; //  1) Don't show invisible bodies\n\n      if (!body.render.visible) {\n        continue;\n      }\n\n      var bounds = body.bounds;\n\n      if (bounds) {\n        graphics.strokeRect(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\n      } else {\n        var parts = body.parts;\n\n        for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n          var part = parts[j];\n          graphics.strokeRect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Renders either all axes, or a single axis indicator, for an array of Bodies, to the given Graphics instance.\r\n   * \r\n   * The debug renderer calls this method if the `showAxes` or `showAngleIndicator` config values are set.\r\n   * \r\n   * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n   * you wish to render bounds to your own Graphics instance.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#renderBodyAxes\r\n   * @since 3.22.0\r\n   * \r\n   * @param {array} bodies - An array of bodies from the localWorld.\r\n   * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n   * @param {boolean} showAxes - If `true` it will render all body axes. If `false` it will render a single axis indicator.\r\n   * @param {number} lineColor - The line color.\r\n   * @param {number} lineOpacity - The line opacity, between 0 and 1.\r\n   */\n  renderBodyAxes: function (bodies, graphics, showAxes, lineColor, lineOpacity) {\n    graphics.lineStyle(1, lineColor, lineOpacity);\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i];\n      var parts = body.parts; //  1) Don't show invisible bodies\n\n      if (!body.render.visible) {\n        continue;\n      }\n\n      var part;\n      var j;\n      var k;\n\n      if (showAxes) {\n        for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n          part = parts[j];\n\n          for (k = 0; k < part.axes.length; k++) {\n            var axis = part.axes[k];\n            graphics.lineBetween(part.position.x, part.position.y, part.position.x + axis.x * 20, part.position.y + axis.y * 20);\n          }\n        }\n      } else {\n        for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n          part = parts[j];\n\n          for (k = 0; k < part.axes.length; k++) {\n            graphics.lineBetween(part.position.x, part.position.y, (part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2, (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2);\n          }\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Renders a velocity indicator for an array of Bodies, to the given Graphics instance.\r\n   * \r\n   * The debug renderer calls this method if the `showVelocity` config value is set.\r\n   * \r\n   * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n   * you wish to render bounds to your own Graphics instance.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#renderBodyVelocity\r\n   * @since 3.22.0\r\n   * \r\n   * @param {array} bodies - An array of bodies from the localWorld.\r\n   * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n   * @param {number} lineColor - The line color.\r\n   * @param {number} lineOpacity - The line opacity, between 0 and 1.\r\n   * @param {number} lineThickness - The line thickness.\r\n   */\n  renderBodyVelocity: function (bodies, graphics, lineColor, lineOpacity, lineThickness) {\n    graphics.lineStyle(lineThickness, lineColor, lineOpacity);\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i]; //  1) Don't show invisible bodies\n\n      if (!body.render.visible) {\n        continue;\n      }\n\n      graphics.lineBetween(body.position.x, body.position.y, body.position.x + (body.position.x - body.positionPrev.x) * 2, body.position.y + (body.position.y - body.positionPrev.y) * 2);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Renders the given array of Bodies to the debug graphics instance.\r\n   * \r\n   * Called automatically by the `postUpdate` method.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#renderBodies\r\n   * @private\r\n   * @since 3.14.0\r\n   * \r\n   * @param {array} bodies - An array of bodies from the localWorld.\r\n   */\n  renderBodies: function (bodies) {\n    var graphics = this.debugGraphic;\n    var config = this.debugConfig;\n    var showBody = config.showBody;\n    var showStaticBody = config.showStaticBody;\n    var showSleeping = config.showSleeping;\n    var showInternalEdges = config.showInternalEdges;\n    var showConvexHulls = config.showConvexHulls;\n    var renderFill = config.renderFill;\n    var renderLine = config.renderLine;\n    var staticBodySleepOpacity = config.staticBodySleepOpacity;\n    var sleepFillColor = config.sleepFillColor;\n    var sleepLineColor = config.sleepLineColor;\n    var hullColor = config.hullColor;\n\n    for (var i = 0; i < bodies.length; i++) {\n      var body = bodies[i]; //  1) Don't show invisible bodies\n\n      if (!body.render.visible) {\n        continue;\n      } //  2) Don't show static bodies, OR\n      //  3) Don't show dynamic bodies\n\n\n      if (!showStaticBody && body.isStatic || !showBody && !body.isStatic) {\n        continue;\n      }\n\n      var lineColor = body.render.lineColor;\n      var lineOpacity = body.render.lineOpacity;\n      var lineThickness = body.render.lineThickness;\n      var fillColor = body.render.fillColor;\n      var fillOpacity = body.render.fillOpacity;\n\n      if (showSleeping && body.isSleeping) {\n        if (body.isStatic) {\n          lineOpacity *= staticBodySleepOpacity;\n          fillOpacity *= staticBodySleepOpacity;\n        } else {\n          lineColor = sleepLineColor;\n          fillColor = sleepFillColor;\n        }\n      }\n\n      if (!renderFill) {\n        fillColor = null;\n      }\n\n      if (!renderLine) {\n        lineColor = null;\n      }\n\n      this.renderBody(body, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity);\n      var partsLength = body.parts.length;\n\n      if (showConvexHulls && partsLength > 1) {\n        this.renderConvexHull(body, graphics, hullColor, lineThickness);\n      }\n    }\n  },\n\n  /**\r\n   * Renders a single Matter Body to the given Phaser Graphics Game Object.\r\n   * \r\n   * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n   * you wish to render a Body to your own Graphics instance.\r\n   * \r\n   * If you don't wish to render a line around the body, set the `lineColor` parameter to `null`.\r\n   * Equally, if you don't wish to render a fill, set the `fillColor` parameter to `null`.\r\n   * \r\n   * @method Phaser.Physics.Matter.World#renderBody\r\n   * @since 3.22.0\r\n   * \r\n   * @param {MatterJS.BodyType} body - The Matter Body to be rendered.\r\n   * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n   * @param {boolean} showInternalEdges - Render internal edges of the polygon?\r\n   * @param {number} [lineColor] - The line color.\r\n   * @param {number} [lineOpacity] - The line opacity, between 0 and 1.\r\n   * @param {number} [lineThickness=1] - The line thickness.\r\n   * @param {number} [fillColor] - The fill color.\r\n   * @param {number} [fillOpacity] - The fill opacity, between 0 and 1.\r\n   * \r\n   * @return {this} This Matter World instance for method chaining.\r\n   */\n  renderBody: function (body, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity) {\n    if (lineColor === undefined) {\n      lineColor = null;\n    }\n\n    if (lineOpacity === undefined) {\n      lineOpacity = null;\n    }\n\n    if (lineThickness === undefined) {\n      lineThickness = 1;\n    }\n\n    if (fillColor === undefined) {\n      fillColor = null;\n    }\n\n    if (fillOpacity === undefined) {\n      fillOpacity = null;\n    }\n\n    var config = this.debugConfig;\n    var sensorFillColor = config.sensorFillColor;\n    var sensorLineColor = config.sensorLineColor; //  Handle compound parts\n\n    var parts = body.parts;\n    var partsLength = parts.length;\n\n    for (var k = partsLength > 1 ? 1 : 0; k < partsLength; k++) {\n      var part = parts[k];\n      var render = part.render;\n      var opacity = render.opacity;\n\n      if (!render.visible || opacity === 0 || part.isSensor && !config.showSensors) {\n        continue;\n      } //  Part polygon\n\n\n      var circleRadius = part.circleRadius;\n      graphics.beginPath();\n\n      if (part.isSensor) {\n        if (fillColor !== null) {\n          graphics.fillStyle(sensorFillColor, fillOpacity * opacity);\n        }\n\n        if (lineColor !== null) {\n          graphics.lineStyle(lineThickness, sensorLineColor, lineOpacity * opacity);\n        }\n      } else {\n        if (fillColor !== null) {\n          graphics.fillStyle(fillColor, fillOpacity * opacity);\n        }\n\n        if (lineColor !== null) {\n          graphics.lineStyle(lineThickness, lineColor, lineOpacity * opacity);\n        }\n      }\n\n      if (circleRadius) {\n        graphics.arc(part.position.x, part.position.y, circleRadius, 0, 2 * Math.PI);\n      } else {\n        var vertices = part.vertices;\n        var vertLength = vertices.length;\n        graphics.moveTo(vertices[0].x, vertices[0].y);\n\n        for (var j = 1; j < vertLength; j++) {\n          var vert = vertices[j];\n\n          if (!vertices[j - 1].isInternal || showInternalEdges) {\n            graphics.lineTo(vert.x, vert.y);\n          } else {\n            graphics.moveTo(vert.x, vert.y);\n          }\n\n          if (j < vertLength && vert.isInternal && !showInternalEdges) {\n            var nextIndex = (j + 1) % vertLength;\n            graphics.moveTo(vertices[nextIndex].x, vertices[nextIndex].y);\n          }\n        }\n\n        graphics.closePath();\n      }\n\n      if (fillColor !== null) {\n        graphics.fillPath();\n      }\n\n      if (lineColor !== null) {\n        graphics.strokePath();\n      }\n    }\n\n    if (config.showPositions && !body.isStatic) {\n      var px = body.position.x;\n      var py = body.position.y;\n      var hs = Math.ceil(config.positionSize / 2);\n      graphics.fillStyle(config.positionColor, 1);\n      graphics.fillRect(px - hs, py - hs, config.positionSize, config.positionSize);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Renders the Convex Hull for a single Matter Body to the given Phaser Graphics Game Object.\r\n   * \r\n   * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n   * you wish to render a Body hull to your own Graphics instance.\r\n   * \r\n   * @method Phaser.Physics.Matter.World#renderConvexHull\r\n   * @since 3.22.0\r\n   * \r\n   * @param {MatterJS.BodyType} body - The Matter Body to be rendered.\r\n   * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n   * @param {number} hullColor - The color used to render the hull.\r\n   * @param {number} [lineThickness=1] - The hull line thickness.\r\n   * \r\n   * @return {this} This Matter World instance for method chaining.\r\n   */\n  renderConvexHull: function (body, graphics, hullColor, lineThickness) {\n    if (lineThickness === undefined) {\n      lineThickness = 1;\n    }\n\n    var parts = body.parts;\n    var partsLength = parts.length; //  Render Convex Hulls\n\n    if (partsLength > 1) {\n      var verts = body.vertices;\n      graphics.lineStyle(lineThickness, hullColor);\n      graphics.beginPath();\n      graphics.moveTo(verts[0].x, verts[0].y);\n\n      for (var v = 1; v < verts.length; v++) {\n        graphics.lineTo(verts[v].x, verts[v].y);\n      }\n\n      graphics.lineTo(verts[0].x, verts[0].y);\n      graphics.strokePath();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Renders all of the constraints in the world (unless they are specifically set to invisible).\r\n   * \r\n   * Called automatically by the `postUpdate` method.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#renderJoints\r\n   * @private\r\n   * @since 3.14.0\r\n   */\n  renderJoints: function () {\n    var graphics = this.debugGraphic; // Render constraints \n\n    var constraints = Composite.allConstraints(this.localWorld);\n\n    for (var i = 0; i < constraints.length; i++) {\n      var config = constraints[i].render;\n      var lineColor = config.lineColor;\n      var lineOpacity = config.lineOpacity;\n      var lineThickness = config.lineThickness;\n      var pinSize = config.pinSize;\n      var anchorColor = config.anchorColor;\n      var anchorSize = config.anchorSize;\n      this.renderConstraint(constraints[i], graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize);\n    }\n  },\n\n  /**\r\n   * Renders a single Matter Constraint, such as a Pin or a Spring, to the given Phaser Graphics Game Object.\r\n   * \r\n   * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n   * you wish to render a Constraint to your own Graphics instance.\r\n   * \r\n   * @method Phaser.Physics.Matter.World#renderConstraint\r\n   * @since 3.22.0\r\n   * \r\n   * @param {MatterJS.ConstraintType} constraint - The Matter Constraint to render.\r\n   * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n   * @param {number} lineColor - The line color.\r\n   * @param {number} lineOpacity - The line opacity, between 0 and 1.\r\n   * @param {number} lineThickness - The line thickness.\r\n   * @param {number} pinSize - If this constraint is a pin, this sets the size of the pin circle.\r\n   * @param {number} anchorColor - The color used when rendering this constraints anchors. Set to `null` to not render anchors.\r\n   * @param {number} anchorSize - The size of the anchor circle, if this constraint has anchors and is rendering them.\r\n   * \r\n   * @return {this} This Matter World instance for method chaining.\r\n   */\n  renderConstraint: function (constraint, graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize) {\n    var render = constraint.render;\n\n    if (!render.visible || !constraint.pointA || !constraint.pointB) {\n      return this;\n    }\n\n    graphics.lineStyle(lineThickness, lineColor, lineOpacity);\n    var bodyA = constraint.bodyA;\n    var bodyB = constraint.bodyB;\n    var start;\n    var end;\n\n    if (bodyA) {\n      start = Vector.add(bodyA.position, constraint.pointA);\n    } else {\n      start = constraint.pointA;\n    }\n\n    if (render.type === 'pin') {\n      graphics.strokeCircle(start.x, start.y, pinSize);\n    } else {\n      if (bodyB) {\n        end = Vector.add(bodyB.position, constraint.pointB);\n      } else {\n        end = constraint.pointB;\n      }\n\n      graphics.beginPath();\n      graphics.moveTo(start.x, start.y);\n\n      if (render.type === 'spring') {\n        var delta = Vector.sub(end, start);\n        var normal = Vector.perp(Vector.normalise(delta));\n        var coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20));\n        var offset;\n\n        for (var j = 1; j < coils; j += 1) {\n          offset = j % 2 === 0 ? 1 : -1;\n          graphics.lineTo(start.x + delta.x * (j / coils) + normal.x * offset * 4, start.y + delta.y * (j / coils) + normal.y * offset * 4);\n        }\n      }\n\n      graphics.lineTo(end.x, end.y);\n    }\n\n    graphics.strokePath();\n\n    if (render.anchors && anchorSize > 0) {\n      graphics.fillStyle(anchorColor);\n      graphics.fillCircle(start.x, start.y, anchorSize);\n      graphics.fillCircle(end.x, end.y, anchorSize);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Resets the internal collision IDs that Matter.JS uses for Body collision groups.\r\n   * \r\n   * You should call this before destroying your game if you need to restart the game\r\n   * again on the same page, without first reloading the page. Or, if you wish to\r\n   * consistently destroy a Scene that contains Matter.js and then run it again\r\n   * later in the same game.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#resetCollisionIDs\r\n   * @since 3.17.0\r\n   */\n  resetCollisionIDs: function () {\n    Body._nextCollidingGroupId = 1;\n    Body._nextNonCollidingGroupId = -1;\n    Body._nextCategory = 0x0001;\n    return this;\n  },\n\n  /**\r\n   * Will remove all Matter physics event listeners and clear the matter physics world,\r\n   * engine and any debug graphics, if any.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#shutdown\r\n   * @since 3.0.0\r\n   */\n  shutdown: function () {\n    MatterEvents.off(this.engine);\n    this.removeAllListeners();\n    MatterWorld.clear(this.localWorld, false);\n    Engine.clear(this.engine);\n\n    if (this.drawDebug) {\n      this.debugGraphic.destroy();\n    }\n  },\n\n  /**\r\n   * Will remove all Matter physics event listeners and clear the matter physics world,\r\n   * engine and any debug graphics, if any.\r\n   *\r\n   * After destroying the world it cannot be re-used again.\r\n   *\r\n   * @method Phaser.Physics.Matter.World#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.shutdown();\n  }\n});\nmodule.exports = World;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/World.js"],"names":["Bodies","require","Body","Class","Common","Composite","Engine","EventEmitter","Events","GetFastValue","GetValue","MatterBody","MatterEvents","MatterTileBody","MatterWorld","Vector","World","Extends","initialize","scene","config","call","engine","create","localWorld","world","gravity","setGravity","x","y","scale","walls","left","right","top","bottom","enabled","correction","getDelta","update60Hz","runnerConfig","hasFPS","fps","delta","deltaMin","deltaMax","runner","deltaSampleSize","counterTimestamp","frameCounter","deltaHistory","timePrev","timeScalePrev","frameRequestId","isFixed","autoUpdate","debugConfig","drawDebug","debugGraphic","showAxes","showAngleIndicator","angleColor","showBroadphase","broadphaseColor","showBounds","boundsColor","showVelocity","velocityColor","showCollisions","collisionColor","showSeparations","separationColor","showBody","showStaticBody","showInternalEdges","renderFill","renderLine","fillColor","fillOpacity","lineColor","lineOpacity","lineThickness","staticFillColor","staticLineColor","showSleeping","staticBodySleepOpacity","sleepFillColor","sleepLineColor","showSensors","sensorFillColor","sensorLineColor","showPositions","positionSize","positionColor","showJoint","jointColor","jointLineOpacity","jointLineThickness","pinSize","pinColor","springColor","anchorColor","anchorSize","showConvexHulls","hullColor","createDebugGraphic","setEventsProxy","boundsConfig","setBounds","width","sys","height","thickness","setCompositeRenderStyle","composite","bodies","constraints","composites","i","obj","render","length","setBodyRenderStyle","setConstraintRenderStyle","body","undefined","isStatic","constraint","type","_this","on","event","objects","concat","object","emit","BEFORE_ADD","AFTER_ADD","BEFORE_REMOVE","AFTER_REMOVE","BEFORE_UPDATE","AFTER_UPDATE","pairs","bodyA","bodyB","COLLISION_START","COLLISION_ACTIVE","COLLISION_END","updateWall","add","position","wall","remove","friction","frictionStatic","graphic","graphics","setDepth","Number","MAX_VALUE","disableGravity","options","rectangle","deep","Array","isArray","entity","removeConstraint","convertTilemapLayer","tilemapLayer","layerData","layer","tiles","getTilesWithin","isColliding","convertTiles","nextGroup","isNonColliding","nextCategory","pause","PAUSE","resume","RESUME","update","time","timing","push","slice","Math","min","apply","timeScale","step","update30Hz","has","src","hasOwnProperty","get","id","getAllBodies","allBodies","getAllConstraints","allConstraints","getAllComposites","allComposites","postUpdate","clear","broadphase","controller","renderGrid","renderBodyBounds","renderBodies","renderJoints","renderBodyAxes","renderBodyVelocity","renderSeparations","list","renderCollisions","grid","lineStyle","bucketKeys","keys","buckets","bucketId","region","split","strokeRect","parseInt","bucketWidth","bucketHeight","pair","isActive","collision","posA","posB","penetration","k","lineBetween","fillStyle","j","activeContacts","contact","vertex","fillRect","contacts","normalPosX","normalPosY","supports","normal","visible","bounds","max","parts","part","axes","axis","vertices","positionPrev","isSleeping","renderBody","partsLength","renderConvexHull","opacity","isSensor","circleRadius","beginPath","arc","PI","vertLength","moveTo","vert","isInternal","lineTo","nextIndex","closePath","fillPath","strokePath","px","py","hs","ceil","verts","v","renderConstraint","pointA","pointB","start","end","strokeCircle","sub","perp","normalise","coils","clamp","offset","anchors","fillCircle","resetCollisionIDs","_nextCollidingGroupId","_nextNonCollidingGroupId","_nextCategory","shutdown","off","removeAllListeners","destroy","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Bodies = require('./lib/factory/Bodies');\r\nvar Body = require('./lib/body/Body');\r\nvar Class = require('../../utils/Class');\r\nvar Common = require('./lib/core/Common');\r\nvar Composite = require('./lib/body/Composite');\r\nvar Engine = require('./lib/core/Engine');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar MatterBody = require('./lib/body/Body');\r\nvar MatterEvents = require('./lib/core/Events');\r\nvar MatterTileBody = require('./MatterTileBody');\r\nvar MatterWorld = require('./lib/body/World');\r\nvar Vector = require('./lib/geometry/Vector');\r\n\r\n/**\r\n * @classdesc\r\n * The Matter World class is responsible for managing one single instance of a Matter Physics World for Phaser.\r\n * \r\n * Access this via `this.matter.world` from within a Scene.\r\n * \r\n * This class creates a Matter JS World Composite along with the Matter JS Engine during instantiation. It also\r\n * handles delta timing, bounds, body and constraint creation and debug drawing.\r\n * \r\n * If you wish to access the Matter JS World object directly, see the `localWorld` property.\r\n * If you wish to access the Matter Engine directly, see the `engine` property.\r\n * \r\n * This class is an Event Emitter and will proxy _all_ Matter JS events, as they are received.\r\n *\r\n * @class World\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Matter World instance belongs.\r\n * @param {Phaser.Types.Physics.Matter.MatterWorldConfig} config - The Matter World configuration object.\r\n */\r\nvar World = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function World (scene, config)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The Scene to which this Matter World instance belongs.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * An instance of the MatterJS Engine.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#engine\r\n         * @type {MatterJS.Engine}\r\n         * @since 3.0.0\r\n         */\r\n        this.engine = Engine.create(config);\r\n\r\n        /**\r\n         * A `World` composite object that will contain all simulated bodies and constraints.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#localWorld\r\n         * @type {MatterJS.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.localWorld = this.engine.world;\r\n\r\n        var gravity = GetValue(config, 'gravity', null);\r\n\r\n        if (gravity)\r\n        {\r\n            this.setGravity(gravity.x, gravity.y, gravity.scale);\r\n        }\r\n        else if (gravity === false)\r\n        {\r\n            this.setGravity(0, 0, 0);\r\n        }\r\n\r\n        /**\r\n         * An object containing the 4 wall bodies that bound the physics world.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#walls\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.walls = { left: null, right: null, top: null, bottom: null };\r\n\r\n        /**\r\n         * A flag that toggles if the world is enabled or not.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enabled = GetValue(config, 'enabled', true);\r\n\r\n        /**\r\n         * The correction argument is an optional Number that specifies the time correction factor to apply to the update.\r\n         * This can help improve the accuracy of the simulation in cases where delta is changing between updates.\r\n         * The value of correction is defined as delta / lastDelta, i.e. the percentage change of delta over the last step.\r\n         * Therefore the value is always 1 (no correction) when delta is constant (or when no correction is desired, which is the default).\r\n         * See the paper on Time Corrected Verlet for more information.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#correction\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.4.0\r\n         */\r\n        this.correction = GetValue(config, 'correction', 1);\r\n\r\n        /**\r\n         * This function is called every time the core game loop steps, which is bound to the\r\n         * Request Animation Frame frequency unless otherwise modified.\r\n         * \r\n         * The function is passed two values: `time` and `delta`, both of which come from the game step values.\r\n         * \r\n         * It must return a number. This number is used as the delta value passed to Matter.Engine.update.\r\n         * \r\n         * You can override this function with your own to define your own timestep.\r\n         * \r\n         * If you need to update the Engine multiple times in a single game step then call\r\n         * `World.update` as many times as required. Each call will trigger the `getDelta` function.\r\n         * If you wish to have full control over when the Engine updates then see the property `autoUpdate`.\r\n         *\r\n         * You can also adjust the number of iterations that Engine.update performs.\r\n         * Use the Scene Matter Physics config object to set the following properties:\r\n         *\r\n         * positionIterations (defaults to 6)\r\n         * velocityIterations (defaults to 4)\r\n         * constraintIterations (defaults to 2)\r\n         *\r\n         * Adjusting these values can help performance in certain situations, depending on the physics requirements\r\n         * of your game.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#getDelta\r\n         * @type {function}\r\n         * @since 3.4.0\r\n         */\r\n        this.getDelta = GetValue(config, 'getDelta', this.update60Hz);\r\n\r\n        var runnerConfig = GetFastValue(config, 'runner', {});\r\n\r\n        var hasFPS = GetFastValue(runnerConfig, 'fps', false);\r\n\r\n        var fps = GetFastValue(runnerConfig, 'fps', 60);\r\n\r\n        var delta = GetFastValue(runnerConfig, 'delta', 1000 / fps);\r\n        var deltaMin = GetFastValue(runnerConfig, 'deltaMin', 1000 / fps);\r\n        var deltaMax = GetFastValue(runnerConfig, 'deltaMax', 1000 / (fps * 0.5));\r\n\r\n        if (!hasFPS)\r\n        {\r\n            fps = 1000 / delta;\r\n        }\r\n\r\n        /**\r\n         * The Matter JS Runner Configuration object.\r\n         * \r\n         * This object is populated via the Matter Configuration object's `runner` property and is\r\n         * updated constantly during the game step.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#runner\r\n         * @type {Phaser.Types.Physics.Matter.MatterRunnerConfig}\r\n         * @since 3.22.0\r\n         */\r\n        this.runner = {\r\n            fps: fps,\r\n            correction: GetFastValue(runnerConfig, 'correction', 1),\r\n            deltaSampleSize: GetFastValue(runnerConfig, 'deltaSampleSize', 60),\r\n            counterTimestamp: 0,\r\n            frameCounter: 0,\r\n            deltaHistory: [],\r\n            timePrev: null,\r\n            timeScalePrev: 1,\r\n            frameRequestId: null,\r\n            isFixed: GetFastValue(runnerConfig, 'isFixed', false),\r\n            delta: delta,\r\n            deltaMin: deltaMin,\r\n            deltaMax: deltaMax\r\n        };\r\n\r\n        /**\r\n         * Automatically call Engine.update every time the game steps.\r\n         * If you disable this then you are responsible for calling `World.step` directly from your game.\r\n         * If you call `set60Hz` or `set30Hz` then `autoUpdate` is reset to `true`.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#autoUpdate\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.4.0\r\n         */\r\n        this.autoUpdate = GetValue(config, 'autoUpdate', true);\r\n\r\n        var debugConfig = GetValue(config, 'debug', false);\r\n\r\n        /**\r\n         * A flag that controls if the debug graphics will be drawn to or not.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#drawDebug\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.drawDebug = (typeof(debugConfig) === 'object') ? true : debugConfig;\r\n\r\n        /**\r\n         * An instance of the Graphics object the debug bodies are drawn to, if enabled.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#debugGraphic\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugGraphic;\r\n\r\n        /**\r\n         * The debug configuration object.\r\n         * \r\n         * The values stored in this object are read from the Matter World Config `debug` property.\r\n         * \r\n         * When a new Body or Constraint is _added to the World_, they are given the values stored in this object,\r\n         * unless they have their own `render` object set that will override them.\r\n         * \r\n         * Note that while you can modify the values of properties in this object at run-time, it will not change\r\n         * any of the Matter objects _already added_. It will only impact objects newly added to the world, or one\r\n         * that is removed and then re-added at a later time.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#debugConfig\r\n         * @type {Phaser.Types.Physics.Matter.MatterDebugConfig}\r\n         * @since 3.22.0\r\n         */\r\n        this.debugConfig = {\r\n            showAxes: GetFastValue(debugConfig, 'showAxes', false),\r\n            showAngleIndicator: GetFastValue(debugConfig, 'showAngleIndicator', false),\r\n            angleColor: GetFastValue(debugConfig, 'angleColor', 0xe81153),\r\n\r\n            showBroadphase: GetFastValue(debugConfig, 'showBroadphase', false),\r\n            broadphaseColor: GetFastValue(debugConfig, 'broadphaseColor', 0xffb400),\r\n\r\n            showBounds: GetFastValue(debugConfig, 'showBounds', false),\r\n            boundsColor: GetFastValue(debugConfig, 'boundsColor', 0xffffff),\r\n\r\n            showVelocity: GetFastValue(debugConfig, 'showVelocity', false),\r\n            velocityColor: GetFastValue(debugConfig, 'velocityColor', 0x00aeef),\r\n\r\n            showCollisions: GetFastValue(debugConfig, 'showCollisions', false),\r\n            collisionColor: GetFastValue(debugConfig, 'collisionColor', 0xf5950c),\r\n\r\n            showSeparations: GetFastValue(debugConfig, 'showSeparations', false),\r\n            separationColor: GetFastValue(debugConfig, 'separationColor', 0xffa500),\r\n\r\n            showBody: GetFastValue(debugConfig, 'showBody', true),\r\n            showStaticBody: GetFastValue(debugConfig, 'showStaticBody', true),\r\n            showInternalEdges: GetFastValue(debugConfig, 'showInternalEdges', false),\r\n\r\n            renderFill: GetFastValue(debugConfig, 'renderFill', false),\r\n            renderLine: GetFastValue(debugConfig, 'renderLine', true),\r\n\r\n            fillColor: GetFastValue(debugConfig, 'fillColor', 0x106909),\r\n            fillOpacity: GetFastValue(debugConfig, 'fillOpacity', 1),\r\n            lineColor: GetFastValue(debugConfig, 'lineColor', 0x28de19),\r\n            lineOpacity: GetFastValue(debugConfig, 'lineOpacity', 1),\r\n            lineThickness: GetFastValue(debugConfig, 'lineThickness', 1),\r\n\r\n            staticFillColor: GetFastValue(debugConfig, 'staticFillColor', 0x0d177b),\r\n            staticLineColor: GetFastValue(debugConfig, 'staticLineColor', 0x1327e4),\r\n\r\n            showSleeping: GetFastValue(debugConfig, 'showSleeping', false),\r\n            staticBodySleepOpacity: GetFastValue(debugConfig, 'staticBodySleepOpacity', 0.7),\r\n            sleepFillColor: GetFastValue(debugConfig, 'sleepFillColor', 0x464646),\r\n            sleepLineColor: GetFastValue(debugConfig, 'sleepLineColor', 0x999a99),\r\n\r\n            showSensors: GetFastValue(debugConfig, 'showSensors', true),\r\n            sensorFillColor: GetFastValue(debugConfig, 'sensorFillColor', 0x0d177b),\r\n            sensorLineColor: GetFastValue(debugConfig, 'sensorLineColor', 0x1327e4),\r\n\r\n            showPositions: GetFastValue(debugConfig, 'showPositions', true),\r\n            positionSize: GetFastValue(debugConfig, 'positionSize', 4),\r\n            positionColor: GetFastValue(debugConfig, 'positionColor', 0xe042da),\r\n\r\n            showJoint: GetFastValue(debugConfig, 'showJoint', true),\r\n            jointColor: GetFastValue(debugConfig, 'jointColor', 0xe0e042),\r\n            jointLineOpacity: GetFastValue(debugConfig, 'jointLineOpacity', 1),\r\n            jointLineThickness: GetFastValue(debugConfig, 'jointLineThickness', 2),\r\n\r\n            pinSize: GetFastValue(debugConfig, 'pinSize', 4),\r\n            pinColor: GetFastValue(debugConfig, 'pinColor', 0x42e0e0),\r\n\r\n            springColor: GetFastValue(debugConfig, 'springColor', 0xe042e0),\r\n\r\n            anchorColor: GetFastValue(debugConfig, 'anchorColor', 0xefefef),\r\n            anchorSize: GetFastValue(debugConfig, 'anchorSize', 4),\r\n\r\n            showConvexHulls: GetFastValue(debugConfig, 'showConvexHulls', false),\r\n            hullColor: GetFastValue(debugConfig, 'hullColor', 0xd703d0)\r\n        };\r\n\r\n        if (this.drawDebug)\r\n        {\r\n            this.createDebugGraphic();\r\n        }\r\n\r\n        this.setEventsProxy();\r\n\r\n        //  Create the walls\r\n\r\n        if (GetFastValue(config, 'setBounds', false))\r\n        {\r\n            var boundsConfig = config['setBounds'];\r\n\r\n            if (typeof boundsConfig === 'boolean')\r\n            {\r\n                this.setBounds();\r\n            }\r\n            else\r\n            {\r\n                var x = GetFastValue(boundsConfig, 'x', 0);\r\n                var y = GetFastValue(boundsConfig, 'y', 0);\r\n                var width = GetFastValue(boundsConfig, 'width', scene.sys.scale.width);\r\n                var height = GetFastValue(boundsConfig, 'height', scene.sys.scale.height);\r\n                var thickness = GetFastValue(boundsConfig, 'thickness', 64);\r\n                var left = GetFastValue(boundsConfig, 'left', true);\r\n                var right = GetFastValue(boundsConfig, 'right', true);\r\n                var top = GetFastValue(boundsConfig, 'top', true);\r\n                var bottom = GetFastValue(boundsConfig, 'bottom', true);\r\n\r\n                this.setBounds(x, y, width, height, thickness, left, right, top, bottom);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the debug render style for the children of the given Matter Composite.\r\n     * \r\n     * Composites themselves do not render, but they can contain bodies, constraints and other composites that may do.\r\n     * So the children of this composite are passed to the `setBodyRenderStyle`, `setCompositeRenderStyle` and\r\n     * `setConstraintRenderStyle` methods accordingly.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#setCompositeRenderStyle\r\n     * @since 3.22.0\r\n     *\r\n     * @param {MatterJS.CompositeType} composite - The Matter Composite to set the render style on.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    setCompositeRenderStyle: function (composite)\r\n    {\r\n        var bodies = composite.bodies;\r\n        var constraints = composite.constraints;\r\n        var composites = composite.composites;\r\n\r\n        var i;\r\n        var obj;\r\n        var render;\r\n\r\n        for (i = 0; i < bodies.length; i++)\r\n        {\r\n            obj = bodies[i];\r\n            render = obj.render;\r\n\r\n            this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);\r\n        }\r\n\r\n        for (i = 0; i < constraints.length; i++)\r\n        {\r\n            obj = constraints[i];\r\n            render = obj.render;\r\n\r\n            this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);\r\n        }\r\n\r\n        for (i = 0; i < composites.length; i++)\r\n        {\r\n            obj = composites[i];\r\n\r\n            this.setCompositeRenderStyle(obj);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the debug render style for the given Matter Body.\r\n     * \r\n     * If you are using this on a Phaser Game Object, such as a Matter Sprite, then pass in the body property\r\n     * to this method, not the Game Object itself.\r\n     * \r\n     * If you wish to skip a parameter, so it retains its current value, pass `false` for it.\r\n     * \r\n     * If you wish to reset the Body render colors to the defaults found in the World Debug Config, then call\r\n     * this method with just the `body` parameter provided and no others.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#setBodyRenderStyle\r\n     * @since 3.22.0\r\n     *\r\n     * @param {MatterJS.BodyType} body - The Matter Body to set the render style on.\r\n     * @param {number} [lineColor] - The line color. If `null` it will use the World Debug Config value.\r\n     * @param {number} [lineOpacity] - The line opacity, between 0 and 1. If `null` it will use the World Debug Config value.\r\n     * @param {number} [lineThickness] - The line thickness. If `null` it will use the World Debug Config value.\r\n     * @param {number} [fillColor] - The fill color. If `null` it will use the World Debug Config value.\r\n     * @param {number} [fillOpacity] - The fill opacity, between 0 and 1. If `null` it will use the World Debug Config value.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    setBodyRenderStyle: function (body, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity)\r\n    {\r\n        var render = body.render;\r\n        var config = this.debugConfig;\r\n\r\n        if (!render)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (lineColor === undefined || lineColor === null)\r\n        {\r\n            lineColor = (body.isStatic) ? config.staticLineColor : config.lineColor;\r\n        }\r\n\r\n        if (lineOpacity === undefined || lineOpacity === null)\r\n        {\r\n            lineOpacity = config.lineOpacity;\r\n        }\r\n\r\n        if (lineThickness === undefined || lineThickness === null)\r\n        {\r\n            lineThickness = config.lineThickness;\r\n        }\r\n\r\n        if (fillColor === undefined || fillColor === null)\r\n        {\r\n            fillColor = (body.isStatic) ? config.staticFillColor : config.fillColor;\r\n        }\r\n\r\n        if (fillOpacity === undefined || fillOpacity === null)\r\n        {\r\n            fillOpacity = config.fillOpacity;\r\n        }\r\n\r\n        if (lineColor !== false)\r\n        {\r\n            render.lineColor = lineColor;\r\n        }\r\n\r\n        if (lineOpacity !== false)\r\n        {\r\n            render.lineOpacity = lineOpacity;\r\n        }\r\n\r\n        if (lineThickness !== false)\r\n        {\r\n            render.lineThickness = lineThickness;\r\n        }\r\n\r\n        if (fillColor !== false)\r\n        {\r\n            render.fillColor = fillColor;\r\n        }\r\n\r\n        if (fillOpacity !== false)\r\n        {\r\n            render.fillOpacity = fillOpacity;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the debug render style for the given Matter Constraint.\r\n     * \r\n     * If you are using this on a Phaser Game Object, then pass in the body property\r\n     * to this method, not the Game Object itself.\r\n     * \r\n     * If you wish to skip a parameter, so it retains its current value, pass `false` for it.\r\n     * \r\n     * If you wish to reset the Constraint render colors to the defaults found in the World Debug Config, then call\r\n     * this method with just the `constraint` parameter provided and no others.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#setConstraintRenderStyle\r\n     * @since 3.22.0\r\n     *\r\n     * @param {MatterJS.ConstraintType} constraint - The Matter Constraint to set the render style on.\r\n     * @param {number} [lineColor] - The line color. If `null` it will use the World Debug Config value.\r\n     * @param {number} [lineOpacity] - The line opacity, between 0 and 1. If `null` it will use the World Debug Config value.\r\n     * @param {number} [lineThickness] - The line thickness. If `null` it will use the World Debug Config value.\r\n     * @param {number} [pinSize] - If this constraint is a pin, this sets the size of the pin circle. If `null` it will use the World Debug Config value.\r\n     * @param {number} [anchorColor] - The color used when rendering this constraints anchors.  If `null` it will use the World Debug Config value.\r\n     * @param {number} [anchorSize] - The size of the anchor circle, if this constraint has anchors. If `null` it will use the World Debug Config value.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    setConstraintRenderStyle: function (constraint, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize)\r\n    {\r\n        var render = constraint.render;\r\n        var config = this.debugConfig;\r\n\r\n        if (!render)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        //  Reset them\r\n        if (lineColor === undefined || lineColor === null)\r\n        {\r\n            var type = render.type;\r\n\r\n            if (type === 'line')\r\n            {\r\n                lineColor = config.jointColor;\r\n            }\r\n            else if (type === 'pin')\r\n            {\r\n                lineColor = config.pinColor;\r\n            }\r\n            else if (type === 'spring')\r\n            {\r\n                lineColor = config.springColor;\r\n            }\r\n        }\r\n\r\n        if (lineOpacity === undefined || lineOpacity === null)\r\n        {\r\n            lineOpacity = config.jointLineOpacity;\r\n        }\r\n\r\n        if (lineThickness === undefined || lineThickness === null)\r\n        {\r\n            lineThickness = config.jointLineThickness;\r\n        }\r\n\r\n        if (pinSize === undefined || pinSize === null)\r\n        {\r\n            pinSize = config.pinSize;\r\n        }\r\n\r\n        if (anchorColor === undefined || anchorColor === null)\r\n        {\r\n            anchorColor = config.anchorColor;\r\n        }\r\n\r\n        if (anchorSize === undefined || anchorSize === null)\r\n        {\r\n            anchorSize = config.anchorSize;\r\n        }\r\n\r\n        if (lineColor !== false)\r\n        {\r\n            render.lineColor = lineColor;\r\n        }\r\n\r\n        if (lineOpacity !== false)\r\n        {\r\n            render.lineOpacity = lineOpacity;\r\n        }\r\n\r\n        if (lineThickness !== false)\r\n        {\r\n            render.lineThickness = lineThickness;\r\n        }\r\n\r\n        if (pinSize !== false)\r\n        {\r\n            render.pinSize = pinSize;\r\n        }\r\n\r\n        if (anchorColor !== false)\r\n        {\r\n            render.anchorColor = anchorColor;\r\n        }\r\n\r\n        if (anchorSize !== false)\r\n        {\r\n            render.anchorSize = anchorSize;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This internal method acts as a proxy between all of the Matter JS events and then re-emits them\r\n     * via this class.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#setEventsProxy\r\n     * @since 3.0.0\r\n     */\r\n    setEventsProxy: function ()\r\n    {\r\n        var _this = this;\r\n        var engine = this.engine;\r\n        var world = this.localWorld;\r\n\r\n        //  Inject debug styles\r\n\r\n        if (this.drawDebug)\r\n        {\r\n            MatterEvents.on(world, 'compositeModified', function (composite)\r\n            {\r\n                _this.setCompositeRenderStyle(composite);\r\n            });\r\n\r\n            MatterEvents.on(world, 'beforeAdd', function (event)\r\n            {\r\n                var objects = [].concat(event.object);\r\n    \r\n                for (var i = 0; i < objects.length; i++)\r\n                {\r\n                    var obj = objects[i];\r\n                    var render = obj.render;\r\n    \r\n                    if (obj.type === 'body')\r\n                    {\r\n                        _this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);\r\n                    }\r\n                    else if (obj.type === 'composite')\r\n                    {\r\n                        _this.setCompositeRenderStyle(obj);\r\n                    }\r\n                    else if (obj.type === 'constraint')\r\n                    {\r\n                        _this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        MatterEvents.on(world, 'beforeAdd', function (event)\r\n        {\r\n            _this.emit(Events.BEFORE_ADD, event);\r\n        });\r\n\r\n        MatterEvents.on(world, 'afterAdd', function (event)\r\n        {\r\n            _this.emit(Events.AFTER_ADD, event);\r\n        });\r\n\r\n        MatterEvents.on(world, 'beforeRemove', function (event)\r\n        {\r\n            _this.emit(Events.BEFORE_REMOVE, event);\r\n        });\r\n\r\n        MatterEvents.on(world, 'afterRemove', function (event)\r\n        {\r\n            _this.emit(Events.AFTER_REMOVE, event);\r\n        });\r\n\r\n        MatterEvents.on(engine, 'beforeUpdate', function (event)\r\n        {\r\n            _this.emit(Events.BEFORE_UPDATE, event);\r\n        });\r\n\r\n        MatterEvents.on(engine, 'afterUpdate', function (event)\r\n        {\r\n            _this.emit(Events.AFTER_UPDATE, event);\r\n        });\r\n\r\n        MatterEvents.on(engine, 'collisionStart', function (event)\r\n        {\r\n            var pairs = event.pairs;\r\n            var bodyA;\r\n            var bodyB;\r\n\r\n            if (pairs.length > 0)\r\n            {\r\n                bodyA = pairs[0].bodyA;\r\n                bodyB = pairs[0].bodyB;\r\n            }\r\n\r\n            _this.emit(Events.COLLISION_START, event, bodyA, bodyB);\r\n        });\r\n\r\n        MatterEvents.on(engine, 'collisionActive', function (event)\r\n        {\r\n            var pairs = event.pairs;\r\n            var bodyA;\r\n            var bodyB;\r\n\r\n            if (pairs.length > 0)\r\n            {\r\n                bodyA = pairs[0].bodyA;\r\n                bodyB = pairs[0].bodyB;\r\n            }\r\n\r\n            _this.emit(Events.COLLISION_ACTIVE, event, bodyA, bodyB);\r\n        });\r\n\r\n        MatterEvents.on(engine, 'collisionEnd', function (event)\r\n        {\r\n            var pairs = event.pairs;\r\n            var bodyA;\r\n            var bodyB;\r\n\r\n            if (pairs.length > 0)\r\n            {\r\n                bodyA = pairs[0].bodyA;\r\n                bodyB = pairs[0].bodyB;\r\n            }\r\n\r\n            _this.emit(Events.COLLISION_END, event, bodyA, bodyB);\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Sets the bounds of the Physics world to match the given world pixel dimensions.\r\n     * You can optionally set which 'walls' to create: left, right, top or bottom.\r\n     * If none of the walls are given it will default to use the walls settings it had previously.\r\n     * I.e. if you previously told it to not have the left or right walls, and you then adjust the world size\r\n     * the newly created bounds will also not have the left and right walls.\r\n     * Explicitly state them in the parameters to override this.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#setBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The x coordinate of the top-left corner of the bounds.\r\n     * @param {number} [y=0] - The y coordinate of the top-left corner of the bounds.\r\n     * @param {number} [width] - The width of the bounds.\r\n     * @param {number} [height] - The height of the bounds.\r\n     * @param {number} [thickness=64] - The thickness of each wall, in pixels.\r\n     * @param {boolean} [left=true] - If true will create the left bounds wall.\r\n     * @param {boolean} [right=true] - If true will create the right bounds wall.\r\n     * @param {boolean} [top=true] - If true will create the top bounds wall.\r\n     * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.\r\n     *\r\n     * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n     */\r\n    setBounds: function (x, y, width, height, thickness, left, right, top, bottom)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.scene.sys.scale.width; }\r\n        if (height === undefined) { height = this.scene.sys.scale.height; }\r\n        if (thickness === undefined) { thickness = 64; }\r\n        if (left === undefined) { left = true; }\r\n        if (right === undefined) { right = true; }\r\n        if (top === undefined) { top = true; }\r\n        if (bottom === undefined) { bottom = true; }\r\n\r\n        this.updateWall(left, 'left', x - thickness, y - thickness, thickness, height + (thickness * 2));\r\n        this.updateWall(right, 'right', x + width, y - thickness, thickness, height + (thickness * 2));\r\n        this.updateWall(top, 'top', x, y - thickness, width, thickness);\r\n        this.updateWall(bottom, 'bottom', x, y + height, width, thickness);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Updates the 4 rectangle bodies that were created, if `setBounds` was set in the Matter config, to use\r\n     * the new positions and sizes. This method is usually only called internally via the `setBounds` method.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#updateWall\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} add - `true` if the walls are being added or updated, `false` to remove them from the world.\r\n     * @param {string} [position] - Either `left`, `right`, `top` or `bottom`. Only optional if `add` is `false`.\r\n     * @param {number} [x] - The horizontal position to place the walls at. Only optional if `add` is `false`.\r\n     * @param {number} [y] - The vertical position to place the walls at. Only optional if `add` is `false`.\r\n     * @param {number} [width] - The width of the walls, in pixels. Only optional if `add` is `false`.\r\n     * @param {number} [height] - The height of the walls, in pixels. Only optional if `add` is `false`.\r\n     */\r\n    updateWall: function (add, position, x, y, width, height)\r\n    {\r\n        var wall = this.walls[position];\r\n\r\n        if (add)\r\n        {\r\n            if (wall)\r\n            {\r\n                MatterWorld.remove(this.localWorld, wall);\r\n            }\r\n\r\n            //  adjust center\r\n            x += (width / 2);\r\n            y += (height / 2);\r\n\r\n            this.walls[position] = this.create(x, y, width, height, { isStatic: true, friction: 0, frictionStatic: 0 });\r\n        }\r\n        else\r\n        {\r\n            if (wall)\r\n            {\r\n                MatterWorld.remove(this.localWorld, wall);\r\n            }\r\n\r\n            this.walls[position] = null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a Phaser.GameObjects.Graphics object that is used to render all of the debug bodies and joints to.\r\n     * \r\n     * This method is called automatically by the constructor, if debugging has been enabled.\r\n     * \r\n     * The created Graphics object is automatically added to the Scene at 0x0 and given a depth of `Number.MAX_VALUE`,\r\n     * so it renders above all else in the Scene.\r\n     * \r\n     * The Graphics object is assigned to the `debugGraphic` property of this class and `drawDebug` is enabled.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#createDebugGraphic\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The newly created Graphics object.\r\n     */\r\n    createDebugGraphic: function ()\r\n    {\r\n        var graphic = this.scene.sys.add.graphics({ x: 0, y: 0 });\r\n\r\n        graphic.setDepth(Number.MAX_VALUE);\r\n\r\n        this.debugGraphic = graphic;\r\n\r\n        this.drawDebug = true;\r\n\r\n        return graphic;\r\n    },\r\n\r\n    /**\r\n     * Sets the world gravity and gravity scale to 0.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#disableGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    disableGravity: function ()\r\n    {\r\n        this.localWorld.gravity.x = 0;\r\n        this.localWorld.gravity.y = 0;\r\n        this.localWorld.gravity.scale = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the worlds gravity to the values given.\r\n     * \r\n     * Gravity effects all bodies in the world, unless they have the `ignoreGravity` flag set.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#setGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The world gravity x component.\r\n     * @param {number} [y=1] - The world gravity y component.\r\n     * @param {number} [scale=0.001] - The gravity scale factor.\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    setGravity: function (x, y, scale)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 1; }\r\n\r\n        this.localWorld.gravity.x = x;\r\n        this.localWorld.gravity.y = y;\r\n\r\n        if (scale !== undefined)\r\n        {\r\n            this.localWorld.gravity.scale = scale;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a rectangle Matter body and adds it to the world.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of the body in the world.\r\n     * @param {number} y - The vertical position of the body in the world.\r\n     * @param {number} width - The width of the body.\r\n     * @param {number} height - The height of the body.\r\n     * @param {object} options - Optional Matter configuration object.\r\n     *\r\n     * @return {MatterJS.BodyType} The Matter.js body that was created.\r\n     */\r\n    create: function (x, y, width, height, options)\r\n    {\r\n        var body = Bodies.rectangle(x, y, width, height, options);\r\n\r\n        MatterWorld.add(this.localWorld, body);\r\n\r\n        return body;\r\n    },\r\n\r\n    /**\r\n     * Adds a Matter JS object, or array of objects, to the world.\r\n     * \r\n     * The objects should be valid Matter JS entities, such as a Body, Composite or Constraint.\r\n     * \r\n     * Triggers `beforeAdd` and `afterAdd` events.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(object|object[])} object - Can be single object, or an array, and can be a body, composite or constraint.\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    add: function (object)\r\n    {\r\n        MatterWorld.add(this.localWorld, object);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a Matter JS object, or array of objects, from the world.\r\n     * \r\n     * The objects should be valid Matter JS entities, such as a Body, Composite or Constraint.\r\n     * \r\n     * Triggers `beforeRemove` and `afterRemove` events.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(object|object[])} object - Can be single object, or an array, and can be a body, composite or constraint.\r\n     * @param {boolean} [deep=false] - Optionally search the objects children and recursively remove those as well.\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    remove: function (object, deep)\r\n    {\r\n        if (!Array.isArray(object))\r\n        {\r\n            object = [ object ];\r\n        }\r\n\r\n        for (var i = 0; i < object.length; i++)\r\n        {\r\n            var entity = object[i];\r\n\r\n            var body = (entity.body) ? entity.body : entity;\r\n\r\n            Composite.remove(this.localWorld, body, deep);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a Matter JS constraint, or array of constraints, from the world.\r\n     * \r\n     * Triggers `beforeRemove` and `afterRemove` events.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#removeConstraint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(MatterJS.ConstraintType|MatterJS.ConstraintType[])} constraint - A Matter JS Constraint, or an array of constraints, to be removed.\r\n     * @param {boolean} [deep=false] - Optionally search the objects children and recursively remove those as well.\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    removeConstraint: function (constraint, deep)\r\n    {\r\n        Composite.remove(this.localWorld, constraint, deep);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds `MatterTileBody` instances for all the colliding tiles within the given tilemap layer.\r\n     * \r\n     * Set the appropriate tiles in your layer to collide before calling this method!\r\n     *\r\n     * @method Phaser.Physics.Matter.World#convertTilemapLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer -\r\n     * An array of tiles.\r\n     * @param {object} [options] - Options to be passed to the MatterTileBody constructor. {@see Phaser.Physics.Matter.TileBody}\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    convertTilemapLayer: function (tilemapLayer, options)\r\n    {\r\n        var layerData = tilemapLayer.layer;\r\n        var tiles = tilemapLayer.getTilesWithin(0, 0, layerData.width, layerData.height, { isColliding: true });\r\n\r\n        this.convertTiles(tiles, options);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds `MatterTileBody` instances for the given tiles. This adds bodies regardless of whether the\r\n     * tiles are set to collide or not.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#convertTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of tiles.\r\n     * @param {object} [options] - Options to be passed to the MatterTileBody constructor. {@see Phaser.Physics.Matter.TileBody}\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    convertTiles: function (tiles, options)\r\n    {\r\n        if (tiles.length === 0)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        for (var i = 0; i < tiles.length; i++)\r\n        {\r\n            new MatterTileBody(this, tiles[i], options);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the next unique group index for which bodies will collide.\r\n     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will not collide.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#nextGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [isNonColliding=false] - If `true`, returns the next unique group index for which bodies will _not_ collide.\r\n     *\r\n     * @return {number} Unique category bitfield\r\n     */\r\n    nextGroup: function (isNonColliding)\r\n    {\r\n        return MatterBody.nextGroup(isNonColliding);\r\n    },\r\n\r\n    /**\r\n     * Returns the next unique category bitfield (starting after the initial default category 0x0001).\r\n     * There are 32 available.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#nextCategory\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} Unique category bitfield\r\n     */\r\n    nextCategory: function ()\r\n    {\r\n        return MatterBody.nextCategory();\r\n    },\r\n\r\n    /**\r\n     * Pauses this Matter World instance and sets `enabled` to `false`.\r\n     * \r\n     * A paused world will not run any simulations for the duration it is paused.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#pause\r\n     * @fires Phaser.Physics.Matter.Events#PAUSE\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    pause: function ()\r\n    {\r\n        this.enabled = false;\r\n\r\n        this.emit(Events.PAUSE);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resumes this Matter World instance from a paused state and sets `enabled` to `true`.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#resume\r\n     * @fires Phaser.Physics.Matter.Events#RESUME\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    resume: function ()\r\n    {\r\n        this.enabled = true;\r\n\r\n        this.emit(Events.RESUME);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The internal update method. This is called automatically by the parent Scene.\r\n     * \r\n     * Moves the simulation forward in time by delta ms. Uses `World.correction` value as an optional number that\r\n     * specifies the time correction factor to apply to the update. This can help improve the accuracy of the\r\n     * simulation in cases where delta is changing between updates. The value of correction is defined as `delta / lastDelta`,\r\n     * i.e. the percentage change of delta over the last step. Therefore the value is always 1 (no correction) when\r\n     * delta is constant (or when no correction is desired, which is the default).\r\n     * See the paper on Time Corrected Verlet for more information.\r\n     * \r\n     * Triggers `beforeUpdate` and `afterUpdate` events. Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.\r\n     * \r\n     * If the World is paused, `update` is still run, but exits early and does not update the Matter Engine.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        if (!this.enabled || !this.autoUpdate)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var engine = this.engine;\r\n        var runner = this.runner;\r\n\r\n        var timing = engine.timing;\r\n        var correction = this.correction;\r\n\r\n        if (runner.isFixed)\r\n        {\r\n            //  fixed timestep\r\n            delta = this.getDelta(time, delta);\r\n        }\r\n        else\r\n        {\r\n            //  dynamic timestep based on wall clock between calls\r\n            delta = (time - runner.timePrev) || runner.delta;\r\n            runner.timePrev = time;\r\n\r\n            // optimistically filter delta over a few frames, to improve stability\r\n            runner.deltaHistory.push(delta);\r\n            runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);\r\n            delta = Math.min.apply(null, runner.deltaHistory);\r\n            \r\n            // limit delta\r\n            delta = delta < runner.deltaMin ? runner.deltaMin : delta;\r\n            delta = delta > runner.deltaMax ? runner.deltaMax : delta;\r\n\r\n            // correction for delta\r\n            correction = delta / runner.delta;\r\n\r\n            // update engine timing object\r\n            runner.delta = delta;\r\n        }\r\n\r\n        // time correction for time scaling\r\n        if (runner.timeScalePrev !== 0)\r\n        {\r\n            correction *= timing.timeScale / runner.timeScalePrev;\r\n        }\r\n\r\n        if (timing.timeScale === 0)\r\n        {\r\n            correction = 0;\r\n        }\r\n\r\n        runner.timeScalePrev = timing.timeScale;\r\n        runner.correction = correction;\r\n\r\n        // fps counter\r\n        runner.frameCounter += 1;\r\n\r\n        if (time - runner.counterTimestamp >= 1000)\r\n        {\r\n            runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1000);\r\n            runner.counterTimestamp = time;\r\n            runner.frameCounter = 0;\r\n        }\r\n\r\n        Engine.update(engine, delta, correction);\r\n    },\r\n\r\n    /**\r\n     * Manually advances the physics simulation by one iteration.\r\n     * \r\n     * You can optionally pass in the `delta` and `correction` values to be used by Engine.update.\r\n     * If undefined they use the Matter defaults of 60Hz and no correction.\r\n     * \r\n     * Calling `step` directly bypasses any checks of `enabled` or `autoUpdate`.\r\n     * \r\n     * It also ignores any custom `getDelta` functions, as you should be passing the delta\r\n     * value in to this call.\r\n     *\r\n     * You can adjust the number of iterations that Engine.update performs internally.\r\n     * Use the Scene Matter Physics config object to set the following properties:\r\n     *\r\n     * positionIterations (defaults to 6)\r\n     * velocityIterations (defaults to 4)\r\n     * constraintIterations (defaults to 2)\r\n     *\r\n     * Adjusting these values can help performance in certain situations, depending on the physics requirements\r\n     * of your game.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#step\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} [delta=16.666] - The delta value.\r\n     * @param {number} [correction=1] - Optional delta correction value.\r\n     */\r\n    step: function (delta, correction)\r\n    {\r\n        Engine.update(this.engine, delta, correction);\r\n    },\r\n\r\n    /**\r\n     * Runs the Matter Engine.update at a fixed timestep of 60Hz.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#update60Hz\r\n     * @since 3.4.0\r\n     *\r\n     * @return {number} The delta value to be passed to Engine.update.\r\n     */\r\n    update60Hz: function ()\r\n    {\r\n        return 1000 / 60;\r\n    },\r\n\r\n    /**\r\n     * Runs the Matter Engine.update at a fixed timestep of 30Hz.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#update30Hz\r\n     * @since 3.4.0\r\n     *\r\n     * @return {number} The delta value to be passed to Engine.update.\r\n     */\r\n    update30Hz: function ()\r\n    {\r\n        return 1000 / 30;\r\n    },\r\n\r\n    /**\r\n     * Returns `true` if the given body can be found within the World.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#has\r\n     * @since 3.22.0\r\n     * \r\n     * @param {(MatterJS.Body|Phaser.GameObjects.GameObject)} body - The Matter Body, or Game Object, to search for within the world.\r\n     * \r\n     * @return {MatterJS.BodyType[]} An array of all the Matter JS Bodies in this World.\r\n     */\r\n    has: function (body)\r\n    {\r\n        var src = (body.hasOwnProperty('body')) ? body.body : body;\r\n\r\n        return (Composite.get(this.localWorld, src.id, src.type) !== null);\r\n    },\r\n\r\n    /**\r\n     * Returns all the bodies in the Matter World, including all bodies in children, recursively.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#getAllBodies\r\n     * @since 3.22.0\r\n     * \r\n     * @return {MatterJS.BodyType[]} An array of all the Matter JS Bodies in this World.\r\n     */\r\n    getAllBodies: function ()\r\n    {\r\n        return Composite.allBodies(this.localWorld);\r\n    },\r\n\r\n    /**\r\n     * Returns all the constraints in the Matter World, including all constraints in children, recursively.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#getAllConstraints\r\n     * @since 3.22.0\r\n     * \r\n     * @return {MatterJS.ConstraintType[]} An array of all the Matter JS Constraints in this World.\r\n     */\r\n    getAllConstraints: function ()\r\n    {\r\n        return Composite.allConstraints(this.localWorld);\r\n    },\r\n\r\n    /**\r\n     * Returns all the composites in the Matter World, including all composites in children, recursively.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#getAllComposites\r\n     * @since 3.22.0\r\n     * \r\n     * @return {MatterJS.CompositeType[]} An array of all the Matter JS Composites in this World.\r\n     */\r\n    getAllComposites: function ()\r\n    {\r\n        return Composite.allComposites(this.localWorld);\r\n    },\r\n\r\n    /**\r\n     * Handles the rendering of bodies and debug information to the debug Graphics object, if enabled.\r\n     * \r\n     * This method is called automatically by the Scene after all processing has taken place.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#postUpdate\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    postUpdate: function ()\r\n    {\r\n        if (!this.drawDebug)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var config = this.debugConfig;\r\n        var engine = this.engine;\r\n        var graphics = this.debugGraphic;\r\n\r\n        var bodies = Composite.allBodies(this.localWorld);\r\n\r\n        this.debugGraphic.clear();\r\n\r\n        if (config.showBroadphase && engine.broadphase.controller)\r\n        {\r\n            this.renderGrid(engine.broadphase, graphics, config.broadphaseColor, 0.5);\r\n        }\r\n\r\n        if (config.showBounds)\r\n        {\r\n            this.renderBodyBounds(bodies, graphics, config.boundsColor, 0.5);\r\n        }\r\n\r\n        if (config.showBody || config.showStaticBody)\r\n        {\r\n            this.renderBodies(bodies);\r\n        }\r\n\r\n        if (config.showJoint)\r\n        {\r\n            this.renderJoints();\r\n        }\r\n\r\n        if (config.showAxes || config.showAngleIndicator)\r\n        {\r\n            this.renderBodyAxes(bodies, graphics, config.showAxes, config.angleColor, 0.5);\r\n        }\r\n\r\n        if (config.showVelocity)\r\n        {\r\n            this.renderBodyVelocity(bodies, graphics, config.velocityColor, 1, 2);\r\n        }\r\n\r\n        if (config.showSeparations)\r\n        {\r\n            this.renderSeparations(engine.pairs.list, graphics, config.separationColor);\r\n        }\r\n\r\n        if (config.showCollisions)\r\n        {\r\n            this.renderCollisions(engine.pairs.list, graphics, config.collisionColor);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Renders the Engine Broadphase Controller Grid to the given Graphics instance.\r\n     * \r\n     * The debug renderer calls this method if the `showBroadphase` config value is set.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render the Grid to your own Graphics instance.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#renderGrid\r\n     * @since 3.22.0\r\n     * \r\n     * @param {MatterJS.Grid} grid - The Matter Grid to be rendered.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {number} lineColor - The line color.\r\n     * @param {number} lineOpacity - The line opacity, between 0 and 1.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    renderGrid: function (grid, graphics, lineColor, lineOpacity)\r\n    {\r\n        graphics.lineStyle(1, lineColor, lineOpacity);\r\n\r\n        var bucketKeys = Common.keys(grid.buckets);\r\n\r\n        for (var i = 0; i < bucketKeys.length; i++)\r\n        {\r\n            var bucketId = bucketKeys[i];\r\n\r\n            if (grid.buckets[bucketId].length < 2)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var region = bucketId.split(/C|R/);\r\n\r\n            graphics.strokeRect(\r\n                parseInt(region[1], 10) * grid.bucketWidth,\r\n                parseInt(region[2], 10) * grid.bucketHeight,\r\n                grid.bucketWidth,\r\n                grid.bucketHeight\r\n            );\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders the list of Pair separations to the given Graphics instance.\r\n     * \r\n     * The debug renderer calls this method if the `showSeparations` config value is set.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render the Grid to your own Graphics instance.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#renderSeparations\r\n     * @since 3.22.0\r\n     * \r\n     * @param {MatterJS.Pair[]} pairs - An array of Matter Pairs to be rendered.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {number} lineColor - The line color.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    renderSeparations: function (pairs, graphics, lineColor)\r\n    {\r\n        graphics.lineStyle(1, lineColor, 1);\r\n\r\n        for (var i = 0; i < pairs.length; i++)\r\n        {\r\n            var pair = pairs[i];\r\n\r\n            if (!pair.isActive)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var collision = pair.collision;\r\n            var bodyA = collision.bodyA;\r\n            var bodyB = collision.bodyB;\r\n            var posA = bodyA.position;\r\n            var posB = bodyB.position;\r\n            var penetration = collision.penetration;\r\n\r\n            var k = (!bodyA.isStatic && !bodyB.isStatic) ? 4 : 1;\r\n            \r\n            if (bodyB.isStatic)\r\n            {\r\n                k = 0;\r\n            }\r\n\r\n            graphics.lineBetween(\r\n                posB.x,\r\n                posB.y,\r\n                posB.x - (penetration.x * k),\r\n                posB.y - (penetration.y * k)\r\n            );\r\n\r\n            k = (!bodyA.isStatic && !bodyB.isStatic) ? 4 : 1;\r\n\r\n            if (bodyA.isStatic)\r\n            {\r\n                k = 0;\r\n            }\r\n\r\n            graphics.lineBetween(\r\n                posA.x,\r\n                posA.y,\r\n                posA.x - (penetration.x * k),\r\n                posA.y - (penetration.y * k)\r\n            );\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders the list of collision points and normals to the given Graphics instance.\r\n     * \r\n     * The debug renderer calls this method if the `showCollisions` config value is set.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render the Grid to your own Graphics instance.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#renderCollisions\r\n     * @since 3.22.0\r\n     * \r\n     * @param {MatterJS.Pair[]} pairs - An array of Matter Pairs to be rendered.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {number} lineColor - The line color.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    renderCollisions: function (pairs, graphics, lineColor)\r\n    {\r\n        graphics.lineStyle(1, lineColor, 0.5);\r\n        graphics.fillStyle(lineColor, 1);\r\n\r\n        var i;\r\n        var pair;\r\n\r\n        //  Collision Positions\r\n\r\n        for (i = 0; i < pairs.length; i++)\r\n        {\r\n            pair = pairs[i];\r\n\r\n            if (!pair.isActive)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            for (var j = 0; j < pair.activeContacts.length; j++)\r\n            {\r\n                var contact = pair.activeContacts[j];\r\n                var vertex = contact.vertex;\r\n\r\n                graphics.fillRect(vertex.x - 2, vertex.y - 2, 5, 5);\r\n            }\r\n        }\r\n\r\n        //  Collision Normals\r\n\r\n        for (i = 0; i < pairs.length; i++)\r\n        {\r\n            pair = pairs[i];\r\n\r\n            if (!pair.isActive)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var collision = pair.collision;\r\n            var contacts = pair.activeContacts;\r\n\r\n            if (contacts.length > 0)\r\n            {\r\n                var normalPosX = contacts[0].vertex.x;\r\n                var normalPosY = contacts[0].vertex.y;\r\n\r\n                if (contacts.length === 2)\r\n                {\r\n                    normalPosX = (contacts[0].vertex.x + contacts[1].vertex.x) / 2;\r\n                    normalPosY = (contacts[0].vertex.y + contacts[1].vertex.y) / 2;\r\n                }\r\n\r\n                if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic)\r\n                {\r\n                    graphics.lineBetween(\r\n                        normalPosX - collision.normal.x * 8,\r\n                        normalPosY - collision.normal.y * 8,\r\n                        normalPosX,\r\n                        normalPosY\r\n                    );\r\n                }\r\n                else\r\n                {\r\n                    graphics.lineBetween(\r\n                        normalPosX + collision.normal.x * 8,\r\n                        normalPosY + collision.normal.y * 8,\r\n                        normalPosX,\r\n                        normalPosY\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders the bounds of an array of Bodies to the given Graphics instance.\r\n     * \r\n     * If the body is a compound body, it will render the bounds for the parent compound.\r\n     * \r\n     * The debug renderer calls this method if the `showBounds` config value is set.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render bounds to your own Graphics instance.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#renderBodyBounds\r\n     * @since 3.22.0\r\n     * \r\n     * @param {array} bodies - An array of bodies from the localWorld.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {number} lineColor - The line color.\r\n     * @param {number} lineOpacity - The line opacity, between 0 and 1.\r\n     */\r\n    renderBodyBounds: function (bodies, graphics, lineColor, lineOpacity)\r\n    {\r\n        graphics.lineStyle(1, lineColor, lineOpacity);\r\n\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            var body = bodies[i];\r\n\r\n            //  1) Don't show invisible bodies\r\n            if (!body.render.visible)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var bounds = body.bounds;\r\n\r\n            if (bounds)\r\n            {\r\n                graphics.strokeRect(\r\n                    bounds.min.x,\r\n                    bounds.min.y,\r\n                    bounds.max.x - bounds.min.x,\r\n                    bounds.max.y - bounds.min.y\r\n                );\r\n            }\r\n            else\r\n            {\r\n                var parts = body.parts;\r\n\r\n                for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++)\r\n                {\r\n                    var part = parts[j];\r\n    \r\n                    graphics.strokeRect(\r\n                        part.bounds.min.x,\r\n                        part.bounds.min.y,\r\n                        part.bounds.max.x - part.bounds.min.x,\r\n                        part.bounds.max.y - part.bounds.min.y\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders either all axes, or a single axis indicator, for an array of Bodies, to the given Graphics instance.\r\n     * \r\n     * The debug renderer calls this method if the `showAxes` or `showAngleIndicator` config values are set.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render bounds to your own Graphics instance.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#renderBodyAxes\r\n     * @since 3.22.0\r\n     * \r\n     * @param {array} bodies - An array of bodies from the localWorld.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {boolean} showAxes - If `true` it will render all body axes. If `false` it will render a single axis indicator.\r\n     * @param {number} lineColor - The line color.\r\n     * @param {number} lineOpacity - The line opacity, between 0 and 1.\r\n     */\r\n    renderBodyAxes: function (bodies, graphics, showAxes, lineColor, lineOpacity)\r\n    {\r\n        graphics.lineStyle(1, lineColor, lineOpacity);\r\n\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            var body = bodies[i];\r\n            var parts = body.parts;\r\n\r\n            //  1) Don't show invisible bodies\r\n            if (!body.render.visible)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var part;\r\n            var j;\r\n            var k;\r\n\r\n            if (showAxes)\r\n            {\r\n                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++)\r\n                {\r\n                    part = parts[j];\r\n    \r\n                    for (k = 0; k < part.axes.length; k++)\r\n                    {\r\n                        var axis = part.axes[k];\r\n\r\n                        graphics.lineBetween(\r\n                            part.position.x,\r\n                            part.position.y,\r\n                            part.position.x + axis.x * 20,\r\n                            part.position.y + axis.y * 20\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++)\r\n                {\r\n                    part = parts[j];\r\n    \r\n                    for (k = 0; k < part.axes.length; k++)\r\n                    {\r\n                        graphics.lineBetween(\r\n                            part.position.x,\r\n                            part.position.y,\r\n                            (part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2,\r\n                            (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders a velocity indicator for an array of Bodies, to the given Graphics instance.\r\n     * \r\n     * The debug renderer calls this method if the `showVelocity` config value is set.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render bounds to your own Graphics instance.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#renderBodyVelocity\r\n     * @since 3.22.0\r\n     * \r\n     * @param {array} bodies - An array of bodies from the localWorld.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {number} lineColor - The line color.\r\n     * @param {number} lineOpacity - The line opacity, between 0 and 1.\r\n     * @param {number} lineThickness - The line thickness.\r\n     */\r\n    renderBodyVelocity: function (bodies, graphics, lineColor, lineOpacity, lineThickness)\r\n    {\r\n        graphics.lineStyle(lineThickness, lineColor, lineOpacity);\r\n\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            var body = bodies[i];\r\n\r\n            //  1) Don't show invisible bodies\r\n            if (!body.render.visible)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            graphics.lineBetween(\r\n                body.position.x,\r\n                body.position.y,\r\n                body.position.x + (body.position.x - body.positionPrev.x) * 2,\r\n                body.position.y + (body.position.y - body.positionPrev.y) * 2\r\n            );\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders the given array of Bodies to the debug graphics instance.\r\n     * \r\n     * Called automatically by the `postUpdate` method.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#renderBodies\r\n     * @private\r\n     * @since 3.14.0\r\n     * \r\n     * @param {array} bodies - An array of bodies from the localWorld.\r\n     */\r\n    renderBodies: function (bodies)\r\n    {\r\n        var graphics = this.debugGraphic;\r\n\r\n        var config = this.debugConfig;\r\n\r\n        var showBody = config.showBody;\r\n        var showStaticBody = config.showStaticBody;\r\n        var showSleeping = config.showSleeping;\r\n        var showInternalEdges = config.showInternalEdges;\r\n        var showConvexHulls = config.showConvexHulls;\r\n\r\n        var renderFill = config.renderFill;\r\n        var renderLine = config.renderLine;\r\n\r\n        var staticBodySleepOpacity = config.staticBodySleepOpacity;\r\n        var sleepFillColor = config.sleepFillColor;\r\n        var sleepLineColor = config.sleepLineColor;\r\n\r\n        var hullColor = config.hullColor;\r\n\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            var body = bodies[i];\r\n\r\n            //  1) Don't show invisible bodies\r\n            if (!body.render.visible)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            //  2) Don't show static bodies, OR\r\n            //  3) Don't show dynamic bodies\r\n            if ((!showStaticBody && body.isStatic) || (!showBody && !body.isStatic))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var lineColor = body.render.lineColor;\r\n            var lineOpacity = body.render.lineOpacity;\r\n            var lineThickness = body.render.lineThickness;\r\n            var fillColor = body.render.fillColor;\r\n            var fillOpacity = body.render.fillOpacity;\r\n\r\n            if (showSleeping && body.isSleeping)\r\n            {\r\n                if (body.isStatic)\r\n                {\r\n                    lineOpacity *= staticBodySleepOpacity;\r\n                    fillOpacity *= staticBodySleepOpacity;\r\n                }\r\n                else\r\n                {\r\n                    lineColor = sleepLineColor;\r\n                    fillColor = sleepFillColor;\r\n                }\r\n            }\r\n\r\n            if (!renderFill)\r\n            {\r\n                fillColor = null;\r\n            }\r\n\r\n            if (!renderLine)\r\n            {\r\n                lineColor = null;\r\n            }\r\n\r\n            this.renderBody(body, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity);\r\n\r\n            var partsLength = body.parts.length;\r\n\r\n            if (showConvexHulls && partsLength > 1)\r\n            {\r\n                this.renderConvexHull(body, graphics, hullColor, lineThickness);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Renders a single Matter Body to the given Phaser Graphics Game Object.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render a Body to your own Graphics instance.\r\n     * \r\n     * If you don't wish to render a line around the body, set the `lineColor` parameter to `null`.\r\n     * Equally, if you don't wish to render a fill, set the `fillColor` parameter to `null`.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#renderBody\r\n     * @since 3.22.0\r\n     * \r\n     * @param {MatterJS.BodyType} body - The Matter Body to be rendered.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {boolean} showInternalEdges - Render internal edges of the polygon?\r\n     * @param {number} [lineColor] - The line color.\r\n     * @param {number} [lineOpacity] - The line opacity, between 0 and 1.\r\n     * @param {number} [lineThickness=1] - The line thickness.\r\n     * @param {number} [fillColor] - The fill color.\r\n     * @param {number} [fillOpacity] - The fill opacity, between 0 and 1.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    renderBody: function (body, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity)\r\n    {\r\n        if (lineColor === undefined) { lineColor = null; }\r\n        if (lineOpacity === undefined) { lineOpacity = null; }\r\n        if (lineThickness === undefined) { lineThickness = 1; }\r\n        if (fillColor === undefined) { fillColor = null; }\r\n        if (fillOpacity === undefined) { fillOpacity = null; }\r\n\r\n        var config = this.debugConfig;\r\n\r\n        var sensorFillColor = config.sensorFillColor;\r\n        var sensorLineColor = config.sensorLineColor;\r\n\r\n        //  Handle compound parts\r\n        var parts = body.parts;\r\n        var partsLength = parts.length;\r\n\r\n        for (var k = (partsLength > 1) ? 1 : 0; k < partsLength; k++)\r\n        {\r\n            var part = parts[k];\r\n            var render = part.render;\r\n            var opacity = render.opacity;\r\n\r\n            if (!render.visible || opacity === 0 || (part.isSensor && !config.showSensors))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            //  Part polygon\r\n            var circleRadius = part.circleRadius;\r\n\r\n            graphics.beginPath();\r\n\r\n            if (part.isSensor)\r\n            {\r\n                if (fillColor !== null)\r\n                {\r\n                    graphics.fillStyle(sensorFillColor, fillOpacity * opacity);\r\n                }\r\n    \r\n                if (lineColor !== null)\r\n                {\r\n                    graphics.lineStyle(lineThickness, sensorLineColor, lineOpacity * opacity);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if (fillColor !== null)\r\n                {\r\n                    graphics.fillStyle(fillColor, fillOpacity * opacity);\r\n                }\r\n    \r\n                if (lineColor !== null)\r\n                {\r\n                    graphics.lineStyle(lineThickness, lineColor, lineOpacity * opacity);\r\n                }\r\n            }\r\n\r\n            if (circleRadius)\r\n            {\r\n                graphics.arc(part.position.x, part.position.y, circleRadius, 0, 2 * Math.PI);\r\n            }\r\n            else\r\n            {\r\n                var vertices = part.vertices;\r\n                var vertLength = vertices.length;\r\n\r\n                graphics.moveTo(vertices[0].x, vertices[0].y);\r\n\r\n                for (var j = 1; j < vertLength; j++)\r\n                {\r\n                    var vert = vertices[j];\r\n\r\n                    if (!vertices[j - 1].isInternal || showInternalEdges)\r\n                    {\r\n                        graphics.lineTo(vert.x, vert.y);\r\n                    }\r\n                    else\r\n                    {\r\n                        graphics.moveTo(vert.x, vert.y);\r\n                    }\r\n\r\n                    if (j < vertLength && vert.isInternal && !showInternalEdges)\r\n                    {\r\n                        var nextIndex = (j + 1) % vertLength;\r\n\r\n                        graphics.moveTo(vertices[nextIndex].x, vertices[nextIndex].y);\r\n                    }\r\n                }\r\n                \r\n                graphics.closePath();\r\n            }\r\n\r\n            if (fillColor !== null)\r\n            {\r\n                graphics.fillPath();\r\n            }\r\n\r\n            if (lineColor !== null)\r\n            {\r\n                graphics.strokePath();\r\n            }\r\n        }\r\n\r\n        if (config.showPositions && !body.isStatic)\r\n        {\r\n            var px = body.position.x;\r\n            var py = body.position.y;\r\n            var hs = Math.ceil(config.positionSize / 2);\r\n\r\n            graphics.fillStyle(config.positionColor, 1);\r\n            graphics.fillRect(px - hs, py - hs, config.positionSize, config.positionSize);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders the Convex Hull for a single Matter Body to the given Phaser Graphics Game Object.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render a Body hull to your own Graphics instance.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#renderConvexHull\r\n     * @since 3.22.0\r\n     * \r\n     * @param {MatterJS.BodyType} body - The Matter Body to be rendered.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {number} hullColor - The color used to render the hull.\r\n     * @param {number} [lineThickness=1] - The hull line thickness.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    renderConvexHull: function (body, graphics, hullColor, lineThickness)\r\n    {\r\n        if (lineThickness === undefined) { lineThickness = 1; }\r\n\r\n        var parts = body.parts;\r\n        var partsLength = parts.length;\r\n\r\n        //  Render Convex Hulls\r\n        if (partsLength > 1)\r\n        {\r\n            var verts = body.vertices;\r\n\r\n            graphics.lineStyle(lineThickness, hullColor);\r\n\r\n            graphics.beginPath();\r\n\r\n            graphics.moveTo(verts[0].x, verts[0].y);\r\n\r\n            for (var v = 1; v < verts.length; v++)\r\n            {\r\n                graphics.lineTo(verts[v].x, verts[v].y);\r\n            }\r\n            \r\n            graphics.lineTo(verts[0].x, verts[0].y);\r\n\r\n            graphics.strokePath();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders all of the constraints in the world (unless they are specifically set to invisible).\r\n     * \r\n     * Called automatically by the `postUpdate` method.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#renderJoints\r\n     * @private\r\n     * @since 3.14.0\r\n     */\r\n    renderJoints: function ()\r\n    {\r\n        var graphics = this.debugGraphic;\r\n\r\n        // Render constraints \r\n        var constraints = Composite.allConstraints(this.localWorld);\r\n\r\n        for (var i = 0; i < constraints.length; i++)\r\n        {\r\n            var config = constraints[i].render;\r\n\r\n            var lineColor = config.lineColor;\r\n            var lineOpacity = config.lineOpacity;\r\n            var lineThickness = config.lineThickness;\r\n            var pinSize = config.pinSize;\r\n            var anchorColor = config.anchorColor;\r\n            var anchorSize = config.anchorSize;\r\n\r\n            this.renderConstraint(constraints[i], graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Renders a single Matter Constraint, such as a Pin or a Spring, to the given Phaser Graphics Game Object.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render a Constraint to your own Graphics instance.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#renderConstraint\r\n     * @since 3.22.0\r\n     * \r\n     * @param {MatterJS.ConstraintType} constraint - The Matter Constraint to render.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {number} lineColor - The line color.\r\n     * @param {number} lineOpacity - The line opacity, between 0 and 1.\r\n     * @param {number} lineThickness - The line thickness.\r\n     * @param {number} pinSize - If this constraint is a pin, this sets the size of the pin circle.\r\n     * @param {number} anchorColor - The color used when rendering this constraints anchors. Set to `null` to not render anchors.\r\n     * @param {number} anchorSize - The size of the anchor circle, if this constraint has anchors and is rendering them.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    renderConstraint: function (constraint, graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize)\r\n    {\r\n        var render = constraint.render;\r\n\r\n        if (!render.visible || !constraint.pointA || !constraint.pointB)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        graphics.lineStyle(lineThickness, lineColor, lineOpacity);\r\n\r\n        var bodyA = constraint.bodyA;\r\n        var bodyB = constraint.bodyB;\r\n        var start;\r\n        var end;\r\n\r\n        if (bodyA)\r\n        {\r\n            start = Vector.add(bodyA.position, constraint.pointA);\r\n        }\r\n        else\r\n        {\r\n            start = constraint.pointA;\r\n        }\r\n\r\n        if (render.type === 'pin')\r\n        {\r\n            graphics.strokeCircle(start.x, start.y, pinSize);\r\n        }\r\n        else\r\n        {\r\n            if (bodyB)\r\n            {\r\n                end = Vector.add(bodyB.position, constraint.pointB);\r\n            }\r\n            else\r\n            {\r\n                end = constraint.pointB;\r\n            }\r\n\r\n            graphics.beginPath();\r\n            graphics.moveTo(start.x, start.y);\r\n\r\n            if (render.type === 'spring')\r\n            {\r\n                var delta = Vector.sub(end, start);\r\n                var normal = Vector.perp(Vector.normalise(delta));\r\n                var coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20));\r\n                var offset;\r\n\r\n                for (var j = 1; j < coils; j += 1)\r\n                {\r\n                    offset = (j % 2 === 0) ? 1 : -1;\r\n\r\n                    graphics.lineTo(\r\n                        start.x + delta.x * (j / coils) + normal.x * offset * 4,\r\n                        start.y + delta.y * (j / coils) + normal.y * offset * 4\r\n                    );\r\n                }\r\n            }\r\n\r\n            graphics.lineTo(end.x, end.y);\r\n        }\r\n\r\n        graphics.strokePath();\r\n\r\n        if (render.anchors && anchorSize > 0)\r\n        {\r\n            graphics.fillStyle(anchorColor);\r\n            graphics.fillCircle(start.x, start.y, anchorSize);\r\n            graphics.fillCircle(end.x, end.y, anchorSize);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets the internal collision IDs that Matter.JS uses for Body collision groups.\r\n     * \r\n     * You should call this before destroying your game if you need to restart the game\r\n     * again on the same page, without first reloading the page. Or, if you wish to\r\n     * consistently destroy a Scene that contains Matter.js and then run it again\r\n     * later in the same game.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#resetCollisionIDs\r\n     * @since 3.17.0\r\n     */\r\n    resetCollisionIDs: function ()\r\n    {\r\n        Body._nextCollidingGroupId = 1;\r\n        Body._nextNonCollidingGroupId = -1;\r\n        Body._nextCategory = 0x0001;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Will remove all Matter physics event listeners and clear the matter physics world,\r\n     * engine and any debug graphics, if any.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#shutdown\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        MatterEvents.off(this.engine);\r\n\r\n        this.removeAllListeners();\r\n\r\n        MatterWorld.clear(this.localWorld, false);\r\n\r\n        Engine.clear(this.engine);\r\n\r\n        if (this.drawDebug)\r\n        {\r\n            this.debugGraphic.destroy();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Will remove all Matter physics event listeners and clear the matter physics world,\r\n     * engine and any debug graphics, if any.\r\n     *\r\n     * After destroying the world it cannot be re-used again.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = World;\r\n"]},"metadata":{},"sourceType":"script"}