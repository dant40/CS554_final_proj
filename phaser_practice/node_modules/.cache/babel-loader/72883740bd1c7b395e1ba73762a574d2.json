{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar ComponentsToJSON = require('./components/ToJSON');\n\nvar DataManager = require('../data/DataManager');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n/**\r\n * @classdesc\r\n * The base class that all Game Objects extend.\r\n * You don't create GameObjects directly and they cannot be added to the display list.\r\n * Instead, use them as the base for your own custom classes.\r\n *\r\n * @class GameObject\r\n * @memberof Phaser.GameObjects\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs.\r\n * @param {string} type - A textual representation of the type of Game Object, i.e. `sprite`.\r\n */\n\n\nvar GameObject = new Class({\n  Extends: EventEmitter,\n  initialize: function GameObject(scene, type) {\n    EventEmitter.call(this);\n    /**\r\n     * The Scene to which this Game Object belongs.\r\n     * Game Objects can only belong to one Scene.\r\n     *\r\n     * @name Phaser.GameObjects.GameObject#scene\r\n     * @type {Phaser.Scene}\r\n     * @protected\r\n     * @since 3.0.0\r\n     */\n\n    this.scene = scene;\n    /**\r\n     * A textual representation of this Game Object, i.e. `sprite`.\r\n     * Used internally by Phaser but is available for your own custom classes to populate.\r\n     *\r\n     * @name Phaser.GameObjects.GameObject#type\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\n\n    this.type = type;\n    /**\r\n     * The current state of this Game Object.\r\n     * \r\n     * Phaser itself will never modify this value, although plugins may do so.\r\n     * \r\n     * Use this property to track the state of a Game Object during its lifetime. For example, it could change from\r\n     * a state of 'moving', to 'attacking', to 'dead'. The state value should be an integer (ideally mapped to a constant\r\n     * in your game code), or a string. These are recommended to keep it light and simple, with fast comparisons.\r\n     * If you need to store complex data about your Game Object, look at using the Data Component instead.\r\n     *\r\n     * @name Phaser.GameObjects.GameObject#state\r\n     * @type {(integer|string)}\r\n     * @since 3.16.0\r\n     */\n\n    this.state = 0;\n    /**\r\n     * The parent Container of this Game Object, if it has one.\r\n     *\r\n     * @name Phaser.GameObjects.GameObject#parentContainer\r\n     * @type {Phaser.GameObjects.Container}\r\n     * @since 3.4.0\r\n     */\n\n    this.parentContainer = null;\n    /**\r\n     * The name of this Game Object.\r\n     * Empty by default and never populated by Phaser, this is left for developers to use.\r\n     *\r\n     * @name Phaser.GameObjects.GameObject#name\r\n     * @type {string}\r\n     * @default ''\r\n     * @since 3.0.0\r\n     */\n\n    this.name = '';\n    /**\r\n     * The active state of this Game Object.\r\n     * A Game Object with an active state of `true` is processed by the Scenes UpdateList, if added to it.\r\n     * An active object is one which is having its logic and internal systems updated.\r\n     *\r\n     * @name Phaser.GameObjects.GameObject#active\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.active = true;\n    /**\r\n     * The Tab Index of the Game Object.\r\n     * Reserved for future use by plugins and the Input Manager.\r\n     *\r\n     * @name Phaser.GameObjects.GameObject#tabIndex\r\n     * @type {integer}\r\n     * @default -1\r\n     * @since 3.0.0\r\n     */\n\n    this.tabIndex = -1;\n    /**\r\n     * A Data Manager.\r\n     * It allows you to store, query and get key/value paired information specific to this Game Object.\r\n     * `null` by default. Automatically created if you use `getData` or `setData` or `setDataEnabled`.\r\n     *\r\n     * @name Phaser.GameObjects.GameObject#data\r\n     * @type {Phaser.Data.DataManager}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.data = null;\n    /**\r\n     * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.\r\n     * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.\r\n     * If those components are not used by your custom class then you can use this bitmask as you wish.\r\n     *\r\n     * @name Phaser.GameObjects.GameObject#renderFlags\r\n     * @type {integer}\r\n     * @default 15\r\n     * @since 3.0.0\r\n     */\n\n    this.renderFlags = 15;\n    /**\r\n     * A bitmask that controls if this Game Object is drawn by a Camera or not.\r\n     * Not usually set directly, instead call `Camera.ignore`, however you can\r\n     * set this property directly using the Camera.id property:\r\n     *\r\n     * @example\r\n     * this.cameraFilter |= camera.id\r\n     *\r\n     * @name Phaser.GameObjects.GameObject#cameraFilter\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.cameraFilter = 0;\n    /**\r\n     * If this Game Object is enabled for input then this property will contain an InteractiveObject instance.\r\n     * Not usually set directly. Instead call `GameObject.setInteractive()`.\r\n     *\r\n     * @name Phaser.GameObjects.GameObject#input\r\n     * @type {?Phaser.Types.Input.InteractiveObject}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.input = null;\n    /**\r\n     * If this Game Object is enabled for physics then this property will contain a reference to a Physics Body.\r\n     *\r\n     * @name Phaser.GameObjects.GameObject#body\r\n     * @type {?(object|Phaser.Physics.Arcade.Body|Phaser.Physics.Impact.Body)}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\n\n    this.body = null;\n    /**\r\n     * This Game Object will ignore all calls made to its destroy method if this flag is set to `true`.\r\n     * This includes calls that may come from a Group, Container or the Scene itself.\r\n     * While it allows you to persist a Game Object across Scenes, please understand you are entirely\r\n     * responsible for managing references to and from this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.GameObject#ignoreDestroy\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.5.0\r\n     */\n\n    this.ignoreDestroy = false; //  Tell the Scene to re-sort the children\n\n    scene.sys.queueDepthSort();\n  },\n\n  /**\r\n   * Sets the `active` property of this Game Object and returns this Game Object for further chaining.\r\n   * A Game Object with its `active` property set to `true` will be updated by the Scenes UpdateList.\r\n   *\r\n   * @method Phaser.GameObjects.GameObject#setActive\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - True if this Game Object should be set as active, false if not.\r\n   *\r\n   * @return {this} This GameObject.\r\n   */\n  setActive: function (value) {\n    this.active = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the `name` property of this Game Object and returns this Game Object for further chaining.\r\n   * The `name` property is not populated by Phaser and is presented for your own use.\r\n   *\r\n   * @method Phaser.GameObjects.GameObject#setName\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} value - The name to be given to this Game Object.\r\n   *\r\n   * @return {this} This GameObject.\r\n   */\n  setName: function (value) {\n    this.name = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the current state of this Game Object.\r\n   * \r\n   * Phaser itself will never modify the State of a Game Object, although plugins may do so.\r\n   * \r\n   * For example, a Game Object could change from a state of 'moving', to 'attacking', to 'dead'.\r\n   * The state value should typically be an integer (ideally mapped to a constant\r\n   * in your game code), but could also be a string. It is recommended to keep it light and simple.\r\n   * If you need to store complex data about your Game Object, look at using the Data Component instead.\r\n   *\r\n   * @method Phaser.GameObjects.GameObject#setState\r\n   * @since 3.16.0\r\n   *\r\n   * @param {(integer|string)} value - The state of the Game Object.\r\n   *\r\n   * @return {this} This GameObject.\r\n   */\n  setState: function (value) {\n    this.state = value;\n    return this;\n  },\n\n  /**\r\n   * Adds a Data Manager component to this Game Object.\r\n   *\r\n   * @method Phaser.GameObjects.GameObject#setDataEnabled\r\n   * @since 3.0.0\r\n   * @see Phaser.Data.DataManager\r\n   *\r\n   * @return {this} This GameObject.\r\n   */\n  setDataEnabled: function () {\n    if (!this.data) {\n      this.data = new DataManager(this);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Allows you to store a key value pair within this Game Objects Data Manager.\r\n   *\r\n   * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled\r\n   * before setting the value.\r\n   *\r\n   * If the key doesn't already exist in the Data Manager then it is created.\r\n   *\r\n   * ```javascript\r\n   * sprite.setData('name', 'Red Gem Stone');\r\n   * ```\r\n   *\r\n   * You can also pass in an object of key value pairs as the first argument:\r\n   *\r\n   * ```javascript\r\n   * sprite.setData({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });\r\n   * ```\r\n   *\r\n   * To get a value back again you can call `getData`:\r\n   *\r\n   * ```javascript\r\n   * sprite.getData('gold');\r\n   * ```\r\n   *\r\n   * Or you can access the value directly via the `values` property, where it works like any other variable:\r\n   *\r\n   * ```javascript\r\n   * sprite.data.values.gold += 50;\r\n   * ```\r\n   *\r\n   * When the value is first set, a `setdata` event is emitted from this Game Object.\r\n   *\r\n   * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.\r\n   * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.\r\n   * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.\r\n   *\r\n   * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.\r\n   * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\r\n   *\r\n   * @method Phaser.GameObjects.GameObject#setData\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|object)} key - The key to set the value for. Or an object of key value pairs. If an object the `data` argument is ignored.\r\n   * @param {*} [data] - The value to set for the given key. If an object is provided as the key this argument is ignored.\r\n   *\r\n   * @return {this} This GameObject.\r\n   */\n  setData: function (key, value) {\n    if (!this.data) {\n      this.data = new DataManager(this);\n    }\n\n    this.data.set(key, value);\n    return this;\n  },\n\n  /**\r\n   * Retrieves the value for the given key in this Game Objects Data Manager, or undefined if it doesn't exist.\r\n   *\r\n   * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:\r\n   *\r\n   * ```javascript\r\n   * sprite.getData('gold');\r\n   * ```\r\n   *\r\n   * Or access the value directly:\r\n   *\r\n   * ```javascript\r\n   * sprite.data.values.gold;\r\n   * ```\r\n   *\r\n   * You can also pass in an array of keys, in which case an array of values will be returned:\r\n   *\r\n   * ```javascript\r\n   * sprite.getData([ 'gold', 'armor', 'health' ]);\r\n   * ```\r\n   *\r\n   * This approach is useful for destructuring arrays in ES6.\r\n   *\r\n   * @method Phaser.GameObjects.GameObject#getData\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|string[])} key - The key of the value to retrieve, or an array of keys.\r\n   *\r\n   * @return {*} The value belonging to the given key, or an array of values, the order of which will match the input array.\r\n   */\n  getData: function (key) {\n    if (!this.data) {\n      this.data = new DataManager(this);\n    }\n\n    return this.data.get(key);\n  },\n\n  /**\r\n   * Pass this Game Object to the Input Manager to enable it for Input.\r\n   *\r\n   * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area\r\n   * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced\r\n   * input detection.\r\n   *\r\n   * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If\r\n   * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific\r\n   * shape for it to use.\r\n   *\r\n   * You can also provide an Input Configuration Object as the only argument to this method.\r\n   *\r\n   * @method Phaser.GameObjects.GameObject#setInteractive\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.Types.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n   * @param {Phaser.Types.Input.HitAreaCallback} [callback] - A callback to be invoked when the Game Object is interacted with. If you provide a shape you must also provide a callback.\r\n   * @param {boolean} [dropZone=false] - Should this Game Object be treated as a drop zone target?\r\n   *\r\n   * @return {this} This GameObject.\r\n   */\n  setInteractive: function (shape, callback, dropZone) {\n    this.scene.sys.input.enable(this, shape, callback, dropZone);\n    return this;\n  },\n\n  /**\r\n   * If this Game Object has previously been enabled for input, this will disable it.\r\n   *\r\n   * An object that is disabled for input stops processing or being considered for\r\n   * input events, but can be turned back on again at any time by simply calling\r\n   * `setInteractive()` with no arguments provided.\r\n   *\r\n   * If want to completely remove interaction from this Game Object then use `removeInteractive` instead.\r\n   *\r\n   * @method Phaser.GameObjects.GameObject#disableInteractive\r\n   * @since 3.7.0\r\n   *\r\n   * @return {this} This GameObject.\r\n   */\n  disableInteractive: function () {\n    if (this.input) {\n      this.input.enabled = false;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * If this Game Object has previously been enabled for input, this will queue it\r\n   * for removal, causing it to no longer be interactive. The removal happens on\r\n   * the next game step, it is not immediate.\r\n   *\r\n   * The Interactive Object that was assigned to this Game Object will be destroyed,\r\n   * removed from the Input Manager and cleared from this Game Object.\r\n   *\r\n   * If you wish to re-enable this Game Object at a later date you will need to\r\n   * re-create its InteractiveObject by calling `setInteractive` again.\r\n   *\r\n   * If you wish to only temporarily stop an object from receiving input then use\r\n   * `disableInteractive` instead, as that toggles the interactive state, where-as\r\n   * this erases it completely.\r\n   * \r\n   * If you wish to resize a hit area, don't remove and then set it as being\r\n   * interactive. Instead, access the hitarea object directly and resize the shape\r\n   * being used. I.e.: `sprite.input.hitArea.setSize(width, height)` (assuming the\r\n   * shape is a Rectangle, which it is by default.)\r\n   *\r\n   * @method Phaser.GameObjects.GameObject#removeInteractive\r\n   * @since 3.7.0\r\n   *\r\n   * @return {this} This GameObject.\r\n   */\n  removeInteractive: function () {\n    this.scene.sys.input.clear(this);\n    this.input = undefined;\n    return this;\n  },\n\n  /**\r\n   * To be overridden by custom GameObjects. Allows base objects to be used in a Pool.\r\n   *\r\n   * @method Phaser.GameObjects.GameObject#update\r\n   * @since 3.0.0\r\n   *\r\n   * @param {...*} [args] - args\r\n   */\n  update: function () {},\n\n  /**\r\n   * Returns a JSON representation of the Game Object.\r\n   *\r\n   * @method Phaser.GameObjects.GameObject#toJSON\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.\r\n   */\n  toJSON: function () {\n    return ComponentsToJSON(this);\n  },\n\n  /**\r\n   * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n   * Also checks the Game Object against the given Cameras exclusion list.\r\n   *\r\n   * @method Phaser.GameObjects.GameObject#willRender\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.\r\n   *\r\n   * @return {boolean} True if the Game Object should be rendered, otherwise false.\r\n   */\n  willRender: function (camera) {\n    return !(GameObject.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & camera.id);\n  },\n\n  /**\r\n   * Returns an array containing the display list index of either this Game Object, or if it has one,\r\n   * its parent Container. It then iterates up through all of the parent containers until it hits the\r\n   * root of the display list (which is index 0 in the returned array).\r\n   *\r\n   * Used internally by the InputPlugin but also useful if you wish to find out the display depth of\r\n   * this Game Object and all of its ancestors.\r\n   *\r\n   * @method Phaser.GameObjects.GameObject#getIndexList\r\n   * @since 3.4.0\r\n   *\r\n   * @return {integer[]} An array of display list position indexes.\r\n   */\n  getIndexList: function () {\n    // eslint-disable-next-line consistent-this\n    var child = this;\n    var parent = this.parentContainer;\n    var indexes = [];\n\n    while (parent) {\n      // indexes.unshift([parent.getIndex(child), parent.name]);\n      indexes.unshift(parent.getIndex(child));\n      child = parent;\n\n      if (!parent.parentContainer) {\n        break;\n      } else {\n        parent = parent.parentContainer;\n      }\n    } // indexes.unshift([this.scene.sys.displayList.getIndex(child), 'root']);\n\n\n    indexes.unshift(this.scene.sys.displayList.getIndex(child));\n    return indexes;\n  },\n\n  /**\r\n   * Destroys this Game Object removing it from the Display List and Update List and\r\n   * severing all ties to parent resources.\r\n   *\r\n   * Also removes itself from the Input Manager and Physics Manager if previously enabled.\r\n   *\r\n   * Use this to remove a Game Object from your game if you don't ever plan to use it again.\r\n   * As long as no reference to it exists within your own code it should become free for\r\n   * garbage collection by the browser.\r\n   *\r\n   * If you just want to temporarily disable an object then look at using the\r\n   * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.\r\n   *\r\n   * @method Phaser.GameObjects.GameObject#destroy\r\n   * @fires Phaser.GameObjects.Events#DESTROY\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} [fromScene=false] - Is this Game Object being destroyed as the result of a Scene shutdown?\r\n   */\n  destroy: function (fromScene) {\n    if (fromScene === undefined) {\n      fromScene = false;\n    } //  This Game Object has already been destroyed\n\n\n    if (!this.scene || this.ignoreDestroy) {\n      return;\n    }\n\n    if (this.preDestroy) {\n      this.preDestroy.call(this);\n    }\n\n    this.emit(Events.DESTROY, this);\n    var sys = this.scene.sys;\n\n    if (!fromScene) {\n      sys.displayList.remove(this);\n      sys.updateList.remove(this);\n    }\n\n    if (this.input) {\n      sys.input.clear(this);\n      this.input = undefined;\n    }\n\n    if (this.data) {\n      this.data.destroy();\n      this.data = undefined;\n    }\n\n    if (this.body) {\n      this.body.destroy();\n      this.body = undefined;\n    } //  Tell the Scene to re-sort the children\n\n\n    if (!fromScene) {\n      sys.queueDepthSort();\n    }\n\n    this.active = false;\n    this.visible = false;\n    this.scene = undefined;\n    this.parentContainer = undefined;\n    this.removeAllListeners();\n  }\n});\n/**\r\n * The bitmask that `GameObject.renderFlags` is compared against to determine if the Game Object will render or not.\r\n *\r\n * @constant {integer} RENDER_MASK\r\n * @memberof Phaser.GameObjects.GameObject\r\n * @default\r\n */\n\nGameObject.RENDER_MASK = 15;\nmodule.exports = GameObject;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/GameObject.js"],"names":["Class","require","ComponentsToJSON","DataManager","EventEmitter","Events","GameObject","Extends","initialize","scene","type","call","state","parentContainer","name","active","tabIndex","data","renderFlags","cameraFilter","input","body","ignoreDestroy","sys","queueDepthSort","setActive","value","setName","setState","setDataEnabled","setData","key","set","getData","get","setInteractive","shape","callback","dropZone","enable","disableInteractive","enabled","removeInteractive","clear","undefined","update","toJSON","willRender","camera","RENDER_MASK","id","getIndexList","child","parent","indexes","unshift","getIndex","displayList","destroy","fromScene","preDestroy","emit","DESTROY","remove","updateList","visible","removeAllListeners","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar ComponentsToJSON = require('./components/ToJSON');\r\nvar DataManager = require('../data/DataManager');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\n\r\n/**\r\n * @classdesc\r\n * The base class that all Game Objects extend.\r\n * You don't create GameObjects directly and they cannot be added to the display list.\r\n * Instead, use them as the base for your own custom classes.\r\n *\r\n * @class GameObject\r\n * @memberof Phaser.GameObjects\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs.\r\n * @param {string} type - A textual representation of the type of Game Object, i.e. `sprite`.\r\n */\r\nvar GameObject = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function GameObject (scene, type)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The Scene to which this Game Object belongs.\r\n         * Game Objects can only belong to one Scene.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#scene\r\n         * @type {Phaser.Scene}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A textual representation of this Game Object, i.e. `sprite`.\r\n         * Used internally by Phaser but is available for your own custom classes to populate.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * The current state of this Game Object.\r\n         * \r\n         * Phaser itself will never modify this value, although plugins may do so.\r\n         * \r\n         * Use this property to track the state of a Game Object during its lifetime. For example, it could change from\r\n         * a state of 'moving', to 'attacking', to 'dead'. The state value should be an integer (ideally mapped to a constant\r\n         * in your game code), or a string. These are recommended to keep it light and simple, with fast comparisons.\r\n         * If you need to store complex data about your Game Object, look at using the Data Component instead.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#state\r\n         * @type {(integer|string)}\r\n         * @since 3.16.0\r\n         */\r\n        this.state = 0;\r\n\r\n        /**\r\n         * The parent Container of this Game Object, if it has one.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#parentContainer\r\n         * @type {Phaser.GameObjects.Container}\r\n         * @since 3.4.0\r\n         */\r\n        this.parentContainer = null;\r\n\r\n        /**\r\n         * The name of this Game Object.\r\n         * Empty by default and never populated by Phaser, this is left for developers to use.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.name = '';\r\n\r\n        /**\r\n         * The active state of this Game Object.\r\n         * A Game Object with an active state of `true` is processed by the Scenes UpdateList, if added to it.\r\n         * An active object is one which is having its logic and internal systems updated.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * The Tab Index of the Game Object.\r\n         * Reserved for future use by plugins and the Input Manager.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#tabIndex\r\n         * @type {integer}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.tabIndex = -1;\r\n\r\n        /**\r\n         * A Data Manager.\r\n         * It allows you to store, query and get key/value paired information specific to this Game Object.\r\n         * `null` by default. Automatically created if you use `getData` or `setData` or `setDataEnabled`.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#data\r\n         * @type {Phaser.Data.DataManager}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.data = null;\r\n\r\n        /**\r\n         * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.\r\n         * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.\r\n         * If those components are not used by your custom class then you can use this bitmask as you wish.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#renderFlags\r\n         * @type {integer}\r\n         * @default 15\r\n         * @since 3.0.0\r\n         */\r\n        this.renderFlags = 15;\r\n\r\n        /**\r\n         * A bitmask that controls if this Game Object is drawn by a Camera or not.\r\n         * Not usually set directly, instead call `Camera.ignore`, however you can\r\n         * set this property directly using the Camera.id property:\r\n         *\r\n         * @example\r\n         * this.cameraFilter |= camera.id\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#cameraFilter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.cameraFilter = 0;\r\n\r\n        /**\r\n         * If this Game Object is enabled for input then this property will contain an InteractiveObject instance.\r\n         * Not usually set directly. Instead call `GameObject.setInteractive()`.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#input\r\n         * @type {?Phaser.Types.Input.InteractiveObject}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.input = null;\r\n\r\n        /**\r\n         * If this Game Object is enabled for physics then this property will contain a reference to a Physics Body.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#body\r\n         * @type {?(object|Phaser.Physics.Arcade.Body|Phaser.Physics.Impact.Body)}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.body = null;\r\n\r\n        /**\r\n         * This Game Object will ignore all calls made to its destroy method if this flag is set to `true`.\r\n         * This includes calls that may come from a Group, Container or the Scene itself.\r\n         * While it allows you to persist a Game Object across Scenes, please understand you are entirely\r\n         * responsible for managing references to and from this Game Object.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#ignoreDestroy\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.5.0\r\n         */\r\n        this.ignoreDestroy = false;\r\n\r\n        //  Tell the Scene to re-sort the children\r\n        scene.sys.queueDepthSort();\r\n    },\r\n\r\n    /**\r\n     * Sets the `active` property of this Game Object and returns this Game Object for further chaining.\r\n     * A Game Object with its `active` property set to `true` will be updated by the Scenes UpdateList.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - True if this Game Object should be set as active, false if not.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setActive: function (value)\r\n    {\r\n        this.active = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the `name` property of this Game Object and returns this Game Object for further chaining.\r\n     * The `name` property is not populated by Phaser and is presented for your own use.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setName\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} value - The name to be given to this Game Object.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setName: function (value)\r\n    {\r\n        this.name = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current state of this Game Object.\r\n     * \r\n     * Phaser itself will never modify the State of a Game Object, although plugins may do so.\r\n     * \r\n     * For example, a Game Object could change from a state of 'moving', to 'attacking', to 'dead'.\r\n     * The state value should typically be an integer (ideally mapped to a constant\r\n     * in your game code), but could also be a string. It is recommended to keep it light and simple.\r\n     * If you need to store complex data about your Game Object, look at using the Data Component instead.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setState\r\n     * @since 3.16.0\r\n     *\r\n     * @param {(integer|string)} value - The state of the Game Object.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setState: function (value)\r\n    {\r\n        this.state = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a Data Manager component to this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setDataEnabled\r\n     * @since 3.0.0\r\n     * @see Phaser.Data.DataManager\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setDataEnabled: function ()\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Allows you to store a key value pair within this Game Objects Data Manager.\r\n     *\r\n     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled\r\n     * before setting the value.\r\n     *\r\n     * If the key doesn't already exist in the Data Manager then it is created.\r\n     *\r\n     * ```javascript\r\n     * sprite.setData('name', 'Red Gem Stone');\r\n     * ```\r\n     *\r\n     * You can also pass in an object of key value pairs as the first argument:\r\n     *\r\n     * ```javascript\r\n     * sprite.setData({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });\r\n     * ```\r\n     *\r\n     * To get a value back again you can call `getData`:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData('gold');\r\n     * ```\r\n     *\r\n     * Or you can access the value directly via the `values` property, where it works like any other variable:\r\n     *\r\n     * ```javascript\r\n     * sprite.data.values.gold += 50;\r\n     * ```\r\n     *\r\n     * When the value is first set, a `setdata` event is emitted from this Game Object.\r\n     *\r\n     * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.\r\n     * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.\r\n     * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.\r\n     *\r\n     * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.\r\n     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|object)} key - The key to set the value for. Or an object of key value pairs. If an object the `data` argument is ignored.\r\n     * @param {*} [data] - The value to set for the given key. If an object is provided as the key this argument is ignored.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setData: function (key, value)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        this.data.set(key, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieves the value for the given key in this Game Objects Data Manager, or undefined if it doesn't exist.\r\n     *\r\n     * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData('gold');\r\n     * ```\r\n     *\r\n     * Or access the value directly:\r\n     *\r\n     * ```javascript\r\n     * sprite.data.values.gold;\r\n     * ```\r\n     *\r\n     * You can also pass in an array of keys, in which case an array of values will be returned:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData([ 'gold', 'armor', 'health' ]);\r\n     * ```\r\n     *\r\n     * This approach is useful for destructuring arrays in ES6.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#getData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} key - The key of the value to retrieve, or an array of keys.\r\n     *\r\n     * @return {*} The value belonging to the given key, or an array of values, the order of which will match the input array.\r\n     */\r\n    getData: function (key)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        return this.data.get(key);\r\n    },\r\n\r\n    /**\r\n     * Pass this Game Object to the Input Manager to enable it for Input.\r\n     *\r\n     * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area\r\n     * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced\r\n     * input detection.\r\n     *\r\n     * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If\r\n     * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific\r\n     * shape for it to use.\r\n     *\r\n     * You can also provide an Input Configuration Object as the only argument to this method.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setInteractive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Types.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - A callback to be invoked when the Game Object is interacted with. If you provide a shape you must also provide a callback.\r\n     * @param {boolean} [dropZone=false] - Should this Game Object be treated as a drop zone target?\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setInteractive: function (shape, callback, dropZone)\r\n    {\r\n        this.scene.sys.input.enable(this, shape, callback, dropZone);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * If this Game Object has previously been enabled for input, this will disable it.\r\n     *\r\n     * An object that is disabled for input stops processing or being considered for\r\n     * input events, but can be turned back on again at any time by simply calling\r\n     * `setInteractive()` with no arguments provided.\r\n     *\r\n     * If want to completely remove interaction from this Game Object then use `removeInteractive` instead.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#disableInteractive\r\n     * @since 3.7.0\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    disableInteractive: function ()\r\n    {\r\n        if (this.input)\r\n        {\r\n            this.input.enabled = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * If this Game Object has previously been enabled for input, this will queue it\r\n     * for removal, causing it to no longer be interactive. The removal happens on\r\n     * the next game step, it is not immediate.\r\n     *\r\n     * The Interactive Object that was assigned to this Game Object will be destroyed,\r\n     * removed from the Input Manager and cleared from this Game Object.\r\n     *\r\n     * If you wish to re-enable this Game Object at a later date you will need to\r\n     * re-create its InteractiveObject by calling `setInteractive` again.\r\n     *\r\n     * If you wish to only temporarily stop an object from receiving input then use\r\n     * `disableInteractive` instead, as that toggles the interactive state, where-as\r\n     * this erases it completely.\r\n     * \r\n     * If you wish to resize a hit area, don't remove and then set it as being\r\n     * interactive. Instead, access the hitarea object directly and resize the shape\r\n     * being used. I.e.: `sprite.input.hitArea.setSize(width, height)` (assuming the\r\n     * shape is a Rectangle, which it is by default.)\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#removeInteractive\r\n     * @since 3.7.0\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    removeInteractive: function ()\r\n    {\r\n        this.scene.sys.input.clear(this);\r\n\r\n        this.input = undefined;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * To be overridden by custom GameObjects. Allows base objects to be used in a Pool.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {...*} [args] - args\r\n     */\r\n    update: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Returns a JSON representation of the Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return ComponentsToJSON(this);\r\n    },\r\n\r\n    /**\r\n     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n     * Also checks the Game Object against the given Cameras exclusion list.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#willRender\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.\r\n     *\r\n     * @return {boolean} True if the Game Object should be rendered, otherwise false.\r\n     */\r\n    willRender: function (camera)\r\n    {\r\n        return !(GameObject.RENDER_MASK !== this.renderFlags || (this.cameraFilter !== 0 && (this.cameraFilter & camera.id)));\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing the display list index of either this Game Object, or if it has one,\r\n     * its parent Container. It then iterates up through all of the parent containers until it hits the\r\n     * root of the display list (which is index 0 in the returned array).\r\n     *\r\n     * Used internally by the InputPlugin but also useful if you wish to find out the display depth of\r\n     * this Game Object and all of its ancestors.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#getIndexList\r\n     * @since 3.4.0\r\n     *\r\n     * @return {integer[]} An array of display list position indexes.\r\n     */\r\n    getIndexList: function ()\r\n    {\r\n        // eslint-disable-next-line consistent-this\r\n        var child = this;\r\n        var parent = this.parentContainer;\r\n\r\n        var indexes = [];\r\n\r\n        while (parent)\r\n        {\r\n            // indexes.unshift([parent.getIndex(child), parent.name]);\r\n            indexes.unshift(parent.getIndex(child));\r\n\r\n            child = parent;\r\n\r\n            if (!parent.parentContainer)\r\n            {\r\n                break;\r\n            }\r\n            else\r\n            {\r\n                parent = parent.parentContainer;\r\n            }\r\n        }\r\n\r\n        // indexes.unshift([this.scene.sys.displayList.getIndex(child), 'root']);\r\n        indexes.unshift(this.scene.sys.displayList.getIndex(child));\r\n\r\n        return indexes;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Game Object removing it from the Display List and Update List and\r\n     * severing all ties to parent resources.\r\n     *\r\n     * Also removes itself from the Input Manager and Physics Manager if previously enabled.\r\n     *\r\n     * Use this to remove a Game Object from your game if you don't ever plan to use it again.\r\n     * As long as no reference to it exists within your own code it should become free for\r\n     * garbage collection by the browser.\r\n     *\r\n     * If you just want to temporarily disable an object then look at using the\r\n     * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#destroy\r\n     * @fires Phaser.GameObjects.Events#DESTROY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [fromScene=false] - Is this Game Object being destroyed as the result of a Scene shutdown?\r\n     */\r\n    destroy: function (fromScene)\r\n    {\r\n        if (fromScene === undefined) { fromScene = false; }\r\n\r\n        //  This Game Object has already been destroyed\r\n        if (!this.scene || this.ignoreDestroy)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (this.preDestroy)\r\n        {\r\n            this.preDestroy.call(this);\r\n        }\r\n\r\n        this.emit(Events.DESTROY, this);\r\n\r\n        var sys = this.scene.sys;\r\n\r\n        if (!fromScene)\r\n        {\r\n            sys.displayList.remove(this);\r\n            sys.updateList.remove(this);\r\n        }\r\n\r\n        if (this.input)\r\n        {\r\n            sys.input.clear(this);\r\n            this.input = undefined;\r\n        }\r\n\r\n        if (this.data)\r\n        {\r\n            this.data.destroy();\r\n\r\n            this.data = undefined;\r\n        }\r\n\r\n        if (this.body)\r\n        {\r\n            this.body.destroy();\r\n            this.body = undefined;\r\n        }\r\n\r\n        //  Tell the Scene to re-sort the children\r\n        if (!fromScene)\r\n        {\r\n            sys.queueDepthSort();\r\n        }\r\n\r\n        this.active = false;\r\n        this.visible = false;\r\n\r\n        this.scene = undefined;\r\n\r\n        this.parentContainer = undefined;\r\n\r\n        this.removeAllListeners();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * The bitmask that `GameObject.renderFlags` is compared against to determine if the Game Object will render or not.\r\n *\r\n * @constant {integer} RENDER_MASK\r\n * @memberof Phaser.GameObjects.GameObject\r\n * @default\r\n */\r\nGameObject.RENDER_MASK = 15;\r\n\r\nmodule.exports = GameObject;\r\n"]},"metadata":{},"sourceType":"script"}