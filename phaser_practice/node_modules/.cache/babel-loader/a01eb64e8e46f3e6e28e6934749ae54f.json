{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar ArcRender = require('./ArcRender');\n\nvar Class = require('../../../utils/Class');\n\nvar DegToRad = require('../../../math/DegToRad');\n\nvar Earcut = require('../../../geom/polygon/Earcut');\n\nvar GeomCircle = require('../../../geom/circle/Circle');\n\nvar MATH_CONST = require('../../../math/const');\n\nvar Shape = require('../Shape');\n/**\r\n * @classdesc\r\n * The Arc Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * When it renders it displays an arc shape. You can control the start and end angles of the arc,\r\n * as well as if the angles are winding clockwise or anti-clockwise. With the default settings\r\n * it renders as a complete circle. By changing the angles you can create other arc shapes,\r\n * such as half-circles.\r\n * \r\n * Arcs also have an `iterations` property and corresponding `setIterations` method. This allows\r\n * you to control how smooth the shape renders in WebGL, by controlling the number of iterations\r\n * that take place during construction.\r\n *\r\n * @class Arc\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [radius=128] - The radius of the arc.\r\n * @param {integer} [startAngle=0] - The start angle of the arc, in degrees.\r\n * @param {integer} [endAngle=360] - The end angle of the arc, in degrees.\r\n * @param {boolean} [anticlockwise=false] - The winding order of the start and end angles.\r\n * @param {number} [fillColor] - The color the arc will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the arc will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n */\n\n\nvar Arc = new Class({\n  Extends: Shape,\n  Mixins: [ArcRender],\n  initialize: function Arc(scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (radius === undefined) {\n      radius = 128;\n    }\n\n    if (startAngle === undefined) {\n      startAngle = 0;\n    }\n\n    if (endAngle === undefined) {\n      endAngle = 360;\n    }\n\n    if (anticlockwise === undefined) {\n      anticlockwise = false;\n    }\n\n    Shape.call(this, scene, 'Arc', new GeomCircle(0, 0, radius));\n    /**\r\n     * Private internal value. Holds the start angle in degrees.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#_startAngle\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.13.0\r\n     */\n\n    this._startAngle = startAngle;\n    /**\r\n     * Private internal value. Holds the end angle in degrees.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#_endAngle\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.13.0\r\n     */\n\n    this._endAngle = endAngle;\n    /**\r\n     * Private internal value. Holds the winding order of the start and end angles.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#_anticlockwise\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.13.0\r\n     */\n\n    this._anticlockwise = anticlockwise;\n    /**\r\n     * Private internal value. Holds the number of iterations used when drawing the arc.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#_iterations\r\n     * @type {number}\r\n     * @default 0.01\r\n     * @private\r\n     * @since 3.13.0\r\n     */\n\n    this._iterations = 0.01;\n    this.setPosition(x, y);\n    var diameter = this.geom.radius * 2;\n    this.setSize(diameter, diameter);\n\n    if (fillColor !== undefined) {\n      this.setFillStyle(fillColor, fillAlpha);\n    }\n\n    this.updateDisplayOrigin();\n    this.updateData();\n  },\n\n  /**\r\n   * The number of iterations used when drawing the arc.\r\n   * Increase this value for smoother arcs, at the cost of more polygons being rendered.\r\n   * Modify this value by small amounts, such as 0.01.\r\n   *\r\n   * @name Phaser.GameObjects.Arc#iterations\r\n   * @type {number}\r\n   * @default 0.01\r\n   * @since 3.13.0\r\n   */\n  iterations: {\n    get: function () {\n      return this._iterations;\n    },\n    set: function (value) {\n      this._iterations = value;\n      this.updateData();\n    }\n  },\n\n  /**\r\n   * The radius of the arc.\r\n   *\r\n   * @name Phaser.GameObjects.Arc#radius\r\n   * @type {number}\r\n   * @since 3.13.0\r\n   */\n  radius: {\n    get: function () {\n      return this.geom.radius;\n    },\n    set: function (value) {\n      this.geom.radius = value;\n      var diameter = value * 2;\n      this.setSize(diameter, diameter);\n      this.updateDisplayOrigin();\n      this.updateData();\n    }\n  },\n\n  /**\r\n   * The start angle of the arc, in degrees.\r\n   *\r\n   * @name Phaser.GameObjects.Arc#startAngle\r\n   * @type {integer}\r\n   * @since 3.13.0\r\n   */\n  startAngle: {\n    get: function () {\n      return this._startAngle;\n    },\n    set: function (value) {\n      this._startAngle = value;\n      this.updateData();\n    }\n  },\n\n  /**\r\n   * The end angle of the arc, in degrees.\r\n   *\r\n   * @name Phaser.GameObjects.Arc#endAngle\r\n   * @type {integer}\r\n   * @since 3.13.0\r\n   */\n  endAngle: {\n    get: function () {\n      return this._endAngle;\n    },\n    set: function (value) {\n      this._endAngle = value;\n      this.updateData();\n    }\n  },\n\n  /**\r\n   * The winding order of the start and end angles.\r\n   *\r\n   * @name Phaser.GameObjects.Arc#anticlockwise\r\n   * @type {boolean}\r\n   * @since 3.13.0\r\n   */\n  anticlockwise: {\n    get: function () {\n      return this._anticlockwise;\n    },\n    set: function (value) {\n      this._anticlockwise = value;\n      this.updateData();\n    }\n  },\n\n  /**\r\n   * Sets the radius of the arc.\r\n   * This call can be chained.\r\n   *\r\n   * @method Phaser.GameObjects.Arc#setRadius\r\n   * @since 3.13.0\r\n   * \r\n   * @param {number} value - The value to set the radius to.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setRadius: function (value) {\n    this.radius = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the number of iterations used when drawing the arc.\r\n   * Increase this value for smoother arcs, at the cost of more polygons being rendered.\r\n   * Modify this value by small amounts, such as 0.01.\r\n   * This call can be chained.\r\n   *\r\n   * @method Phaser.GameObjects.Arc#setIterations\r\n   * @since 3.13.0\r\n   * \r\n   * @param {number} value - The value to set the iterations to.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setIterations: function (value) {\n    if (value === undefined) {\n      value = 0.01;\n    }\n\n    this.iterations = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the starting angle of the arc, in degrees.\r\n   * This call can be chained.\r\n   *\r\n   * @method Phaser.GameObjects.Arc#setStartAngle\r\n   * @since 3.13.0\r\n   * \r\n   * @param {integer} value - The value to set the starting angle to.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setStartAngle: function (angle, anticlockwise) {\n    this._startAngle = angle;\n\n    if (anticlockwise !== undefined) {\n      this._anticlockwise = anticlockwise;\n    }\n\n    return this.updateData();\n  },\n\n  /**\r\n   * Sets the ending angle of the arc, in degrees.\r\n   * This call can be chained.\r\n   *\r\n   * @method Phaser.GameObjects.Arc#setEndAngle\r\n   * @since 3.13.0\r\n   * \r\n   * @param {integer} value - The value to set the ending angle to.\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  setEndAngle: function (angle, anticlockwise) {\n    this._endAngle = angle;\n\n    if (anticlockwise !== undefined) {\n      this._anticlockwise = anticlockwise;\n    }\n\n    return this.updateData();\n  },\n\n  /**\r\n   * Internal method that updates the data and path values.\r\n   *\r\n   * @method Phaser.GameObjects.Arc#updateData\r\n   * @private\r\n   * @since 3.13.0\r\n   *\r\n   * @return {this} This Game Object instance.\r\n   */\n  updateData: function () {\n    var step = this._iterations;\n    var iteration = step;\n    var radius = this.geom.radius;\n    var startAngle = DegToRad(this._startAngle);\n    var endAngle = DegToRad(this._endAngle);\n    var anticlockwise = this._anticlockwise;\n    var x = radius;\n    var y = radius;\n    endAngle -= startAngle;\n\n    if (anticlockwise) {\n      if (endAngle < -MATH_CONST.PI2) {\n        endAngle = -MATH_CONST.PI2;\n      } else if (endAngle > 0) {\n        endAngle = -MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;\n      }\n    } else if (endAngle > MATH_CONST.PI2) {\n      endAngle = MATH_CONST.PI2;\n    } else if (endAngle < 0) {\n      endAngle = MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;\n    }\n\n    var path = [x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius];\n    var ta;\n\n    while (iteration < 1) {\n      ta = endAngle * iteration + startAngle;\n      path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);\n      iteration += step;\n    }\n\n    ta = endAngle + startAngle;\n    path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);\n    path.push(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius);\n    this.pathIndexes = Earcut(path);\n    this.pathData = path;\n    return this;\n  }\n});\nmodule.exports = Arc;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/shape/arc/Arc.js"],"names":["ArcRender","require","Class","DegToRad","Earcut","GeomCircle","MATH_CONST","Shape","Arc","Extends","Mixins","initialize","scene","x","y","radius","startAngle","endAngle","anticlockwise","fillColor","fillAlpha","undefined","call","_startAngle","_endAngle","_anticlockwise","_iterations","setPosition","diameter","geom","setSize","setFillStyle","updateDisplayOrigin","updateData","iterations","get","set","value","setRadius","setIterations","setStartAngle","angle","setEndAngle","step","iteration","PI2","path","Math","cos","sin","ta","push","pathIndexes","pathData","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ArcRender = require('./ArcRender');\r\nvar Class = require('../../../utils/Class');\r\nvar DegToRad = require('../../../math/DegToRad');\r\nvar Earcut = require('../../../geom/polygon/Earcut');\r\nvar GeomCircle = require('../../../geom/circle/Circle');\r\nvar MATH_CONST = require('../../../math/const');\r\nvar Shape = require('../Shape');\r\n\r\n/**\r\n * @classdesc\r\n * The Arc Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * When it renders it displays an arc shape. You can control the start and end angles of the arc,\r\n * as well as if the angles are winding clockwise or anti-clockwise. With the default settings\r\n * it renders as a complete circle. By changing the angles you can create other arc shapes,\r\n * such as half-circles.\r\n * \r\n * Arcs also have an `iterations` property and corresponding `setIterations` method. This allows\r\n * you to control how smooth the shape renders in WebGL, by controlling the number of iterations\r\n * that take place during construction.\r\n *\r\n * @class Arc\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [radius=128] - The radius of the arc.\r\n * @param {integer} [startAngle=0] - The start angle of the arc, in degrees.\r\n * @param {integer} [endAngle=360] - The end angle of the arc, in degrees.\r\n * @param {boolean} [anticlockwise=false] - The winding order of the start and end angles.\r\n * @param {number} [fillColor] - The color the arc will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the arc will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n */\r\nvar Arc = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        ArcRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Arc (scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (radius === undefined) { radius = 128; }\r\n        if (startAngle === undefined) { startAngle = 0; }\r\n        if (endAngle === undefined) { endAngle = 360; }\r\n        if (anticlockwise === undefined) { anticlockwise = false; }\r\n\r\n        Shape.call(this, scene, 'Arc', new GeomCircle(0, 0, radius));\r\n\r\n        /**\r\n         * Private internal value. Holds the start angle in degrees.\r\n         *\r\n         * @name Phaser.GameObjects.Arc#_startAngle\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._startAngle = startAngle;\r\n\r\n        /**\r\n         * Private internal value. Holds the end angle in degrees.\r\n         *\r\n         * @name Phaser.GameObjects.Arc#_endAngle\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._endAngle = endAngle;\r\n\r\n        /**\r\n         * Private internal value. Holds the winding order of the start and end angles.\r\n         *\r\n         * @name Phaser.GameObjects.Arc#_anticlockwise\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._anticlockwise = anticlockwise;\r\n\r\n        /**\r\n         * Private internal value. Holds the number of iterations used when drawing the arc.\r\n         *\r\n         * @name Phaser.GameObjects.Arc#_iterations\r\n         * @type {number}\r\n         * @default 0.01\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._iterations = 0.01;\r\n\r\n        this.setPosition(x, y);\r\n\r\n        var diameter = this.geom.radius * 2;\r\n        this.setSize(diameter, diameter);\r\n\r\n        if (fillColor !== undefined)\r\n        {\r\n            this.setFillStyle(fillColor, fillAlpha);\r\n        }\r\n\r\n        this.updateDisplayOrigin();\r\n        this.updateData();\r\n    },\r\n\r\n    /**\r\n     * The number of iterations used when drawing the arc.\r\n     * Increase this value for smoother arcs, at the cost of more polygons being rendered.\r\n     * Modify this value by small amounts, such as 0.01.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#iterations\r\n     * @type {number}\r\n     * @default 0.01\r\n     * @since 3.13.0\r\n     */\r\n    iterations: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._iterations;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._iterations = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The radius of the arc.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#radius\r\n     * @type {number}\r\n     * @since 3.13.0\r\n     */\r\n    radius: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.geom.radius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.geom.radius = value;\r\n\r\n            var diameter = value * 2;\r\n            this.setSize(diameter, diameter);\r\n            this.updateDisplayOrigin();\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The start angle of the arc, in degrees.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#startAngle\r\n     * @type {integer}\r\n     * @since 3.13.0\r\n     */\r\n    startAngle: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._startAngle;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._startAngle = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The end angle of the arc, in degrees.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#endAngle\r\n     * @type {integer}\r\n     * @since 3.13.0\r\n     */\r\n    endAngle: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._endAngle;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._endAngle = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The winding order of the start and end angles.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#anticlockwise\r\n     * @type {boolean}\r\n     * @since 3.13.0\r\n     */\r\n    anticlockwise: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._anticlockwise;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._anticlockwise = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the radius of the arc.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Arc#setRadius\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the radius to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setRadius: function (value)\r\n    {\r\n        this.radius = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the number of iterations used when drawing the arc.\r\n     * Increase this value for smoother arcs, at the cost of more polygons being rendered.\r\n     * Modify this value by small amounts, such as 0.01.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Arc#setIterations\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the iterations to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setIterations: function (value)\r\n    {\r\n        if (value === undefined) { value = 0.01; }\r\n\r\n        this.iterations = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the starting angle of the arc, in degrees.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Arc#setStartAngle\r\n     * @since 3.13.0\r\n     * \r\n     * @param {integer} value - The value to set the starting angle to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setStartAngle: function (angle, anticlockwise)\r\n    {\r\n        this._startAngle = angle;\r\n\r\n        if (anticlockwise !== undefined)\r\n        {\r\n            this._anticlockwise = anticlockwise;\r\n        }\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Sets the ending angle of the arc, in degrees.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Arc#setEndAngle\r\n     * @since 3.13.0\r\n     * \r\n     * @param {integer} value - The value to set the ending angle to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setEndAngle: function (angle, anticlockwise)\r\n    {\r\n        this._endAngle = angle;\r\n\r\n        if (anticlockwise !== undefined)\r\n        {\r\n            this._anticlockwise = anticlockwise;\r\n        }\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Internal method that updates the data and path values.\r\n     *\r\n     * @method Phaser.GameObjects.Arc#updateData\r\n     * @private\r\n     * @since 3.13.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateData: function ()\r\n    {\r\n        var step = this._iterations;\r\n        var iteration = step;\r\n\r\n        var radius = this.geom.radius;\r\n        var startAngle = DegToRad(this._startAngle);\r\n        var endAngle = DegToRad(this._endAngle);\r\n        var anticlockwise = this._anticlockwise;\r\n\r\n        var x = radius;\r\n        var y = radius;\r\n\r\n        endAngle -= startAngle;\r\n\r\n        if (anticlockwise)\r\n        {\r\n            if (endAngle < -MATH_CONST.PI2)\r\n            {\r\n                endAngle = -MATH_CONST.PI2;\r\n            }\r\n            else if (endAngle > 0)\r\n            {\r\n                endAngle = -MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;\r\n            }\r\n        }\r\n        else if (endAngle > MATH_CONST.PI2)\r\n        {\r\n            endAngle = MATH_CONST.PI2;\r\n        }\r\n        else if (endAngle < 0)\r\n        {\r\n            endAngle = MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;\r\n        }\r\n\r\n        var path = [ x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius ];\r\n\r\n        var ta;\r\n\r\n        while (iteration < 1)\r\n        {\r\n            ta = endAngle * iteration + startAngle;\r\n\r\n            path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);\r\n\r\n            iteration += step;\r\n        }\r\n\r\n        ta = endAngle + startAngle;\r\n\r\n        path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);\r\n\r\n        path.push(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius);\r\n\r\n        this.pathIndexes = Earcut(path);\r\n        this.pathData = path;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Arc;\r\n"]},"metadata":{},"sourceType":"script"}