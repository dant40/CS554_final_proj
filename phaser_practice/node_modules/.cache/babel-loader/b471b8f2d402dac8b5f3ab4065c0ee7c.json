{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar DegToRad = require('../../math/DegToRad');\n\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\n\nvar DistanceSquared = require('../../math/distance/DistanceSquared');\n\nvar Factory = require('./Factory');\n\nvar GetFastValue = require('../../utils/object/GetFastValue');\n\nvar Merge = require('../../utils/object/Merge');\n\nvar OverlapCirc = require('./components/OverlapCirc');\n\nvar OverlapRect = require('./components/OverlapRect');\n\nvar PluginCache = require('../../plugins/PluginCache');\n\nvar SceneEvents = require('../../scene/events');\n\nvar Vector2 = require('../../math/Vector2');\n\nvar World = require('./World');\n/**\r\n * @classdesc\r\n * The Arcade Physics Plugin belongs to a Scene and sets up and manages the Scene's physics simulation.\r\n * It also holds some useful methods for moving and rotating Arcade Physics Bodies.\r\n *\r\n * You can access it from within a Scene using `this.physics`.\r\n *\r\n * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\r\n * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\r\n * The separation that stops two objects penetrating may create a new penetration against a different object. If you\r\n * require a high level of stability please consider using an alternative physics system, such as Matter.js.\r\n *\r\n * @class ArcadePhysics\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that this Plugin belongs to.\r\n */\n\n\nvar ArcadePhysics = new Class({\n  initialize: function ArcadePhysics(scene) {\n    /**\r\n     * The Scene that this Plugin belongs to.\r\n     *\r\n     * @name Phaser.Physics.Arcade.ArcadePhysics#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n    this.scene = scene;\n    /**\r\n     * The Scene's Systems.\r\n     *\r\n     * @name Phaser.Physics.Arcade.ArcadePhysics#systems\r\n     * @type {Phaser.Scenes.Systems}\r\n     * @since 3.0.0\r\n     */\n\n    this.systems = scene.sys;\n    /**\r\n     * A configuration object. Union of the `physics.arcade.*` properties of the GameConfig and SceneConfig objects.\r\n     *\r\n     * @name Phaser.Physics.Arcade.ArcadePhysics#config\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.config = this.getConfig();\n    /**\r\n     * The physics simulation.\r\n     *\r\n     * @name Phaser.Physics.Arcade.ArcadePhysics#world\r\n     * @type {Phaser.Physics.Arcade.World}\r\n     * @since 3.0.0\r\n     */\n\n    this.world;\n    /**\r\n     * An object holding the Arcade Physics factory methods.\r\n     *\r\n     * @name Phaser.Physics.Arcade.ArcadePhysics#add\r\n     * @type {Phaser.Physics.Arcade.Factory}\r\n     * @since 3.0.0\r\n     */\n\n    this.add;\n    scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\n    scene.sys.events.on(SceneEvents.START, this.start, this);\n  },\n\n  /**\r\n   * This method is called automatically, only once, when the Scene is first created.\r\n   * Do not invoke it directly.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#boot\r\n   * @private\r\n   * @since 3.5.1\r\n   */\n  boot: function () {\n    this.world = new World(this.scene, this.config);\n    this.add = new Factory(this.world);\n    this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\n  },\n\n  /**\r\n   * This method is called automatically by the Scene when it is starting up.\r\n   * It is responsible for creating local systems, properties and listening for Scene events.\r\n   * Do not invoke it directly.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#start\r\n   * @private\r\n   * @since 3.5.0\r\n   */\n  start: function () {\n    if (!this.world) {\n      this.world = new World(this.scene, this.config);\n      this.add = new Factory(this.world);\n    }\n\n    var eventEmitter = this.systems.events;\n    eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);\n    eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);\n    eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\n  },\n\n  /**\r\n   * Creates the physics configuration for the current Scene.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#getConfig\r\n   * @since 3.0.0\r\n   *\r\n   * @return {object} The physics configuration.\r\n   */\n  getConfig: function () {\n    var gameConfig = this.systems.game.config.physics;\n    var sceneConfig = this.systems.settings.physics;\n    var config = Merge(GetFastValue(sceneConfig, 'arcade', {}), GetFastValue(gameConfig, 'arcade', {}));\n    return config;\n  },\n\n  /**\r\n   * Tests if Game Objects overlap. See {@link Phaser.Physics.Arcade.World#overlap}\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#overlap\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n   *\r\n   * @return {boolean} True if at least one Game Object overlaps another.\r\n   *\r\n   * @see Phaser.Physics.Arcade.World#overlap\r\n   */\n  overlap: function (object1, object2, overlapCallback, processCallback, callbackContext) {\n    if (overlapCallback === undefined) {\n      overlapCallback = null;\n    }\n\n    if (processCallback === undefined) {\n      processCallback = null;\n    }\n\n    if (callbackContext === undefined) {\n      callbackContext = overlapCallback;\n    }\n\n    return this.world.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);\n  },\n\n  /**\r\n   * Performs a collision check and separation between the two physics enabled objects given, which can be single\r\n   * Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups.\r\n   *\r\n   * If you don't require separation then use {@link #overlap} instead.\r\n   *\r\n   * If two Groups or arrays are passed, each member of one will be tested against each member of the other.\r\n   *\r\n   * If **only** one Group is passed (as `object1`), each member of the Group will be collided against the other members.\r\n   *\r\n   * If **only** one Array is passed, the array is iterated and every element in it is tested against the others.\r\n   *\r\n   * Two callbacks can be provided. The `collideCallback` is invoked if a collision occurs and the two colliding\r\n   * objects are passed to it.\r\n   *\r\n   * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\r\n   * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\r\n   * The separation that stops two objects penetrating may create a new penetration against a different object. If you\r\n   * require a high level of stability please consider using an alternative physics system, such as Matter.js.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#collide\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\r\n   * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n   *\r\n   * @return {boolean} True if any overlapping Game Objects were separated, otherwise false.\r\n   *\r\n   * @see Phaser.Physics.Arcade.World#collide\r\n   */\n  collide: function (object1, object2, collideCallback, processCallback, callbackContext) {\n    if (collideCallback === undefined) {\n      collideCallback = null;\n    }\n\n    if (processCallback === undefined) {\n      processCallback = null;\n    }\n\n    if (callbackContext === undefined) {\n      callbackContext = collideCallback;\n    }\n\n    return this.world.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);\n  },\n\n  /**\r\n   * This advanced method is specifically for testing for collision between a single Sprite and an array of Tile objects.\r\n   *\r\n   * You should generally use the `collide` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\r\n   * tile filtering and culling for you, as well as handle the interesting face collision automatically.\r\n   *\r\n   * This method is offered for those who would like to check for collision with specific Tiles in a layer, without\r\n   * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic collisions\r\n   * on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\r\n   * you should filter them before passing them to this method.\r\n   *\r\n   * Important: Use of this method skips the `interesting faces` system that Tilemap Layers use. This means if you have\r\n   * say a row or column of tiles, and you jump into, or walk over them, it's possible to get stuck on the edges of the\r\n   * tiles as the interesting face calculations are skipped. However, for quick-fire small collision set tests on\r\n   * dynamic maps, this method can prove very useful.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#collideTiles\r\n   * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\r\n   * @since 3.17.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n   * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  collideTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext) {\n    return this.world.collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext);\n  },\n\n  /**\r\n   * This advanced method is specifically for testing for overlaps between a single Sprite and an array of Tile objects.\r\n   *\r\n   * You should generally use the `overlap` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\r\n   * tile filtering and culling for you, as well as handle the interesting face collision automatically.\r\n   *\r\n   * This method is offered for those who would like to check for overlaps with specific Tiles in a layer, without\r\n   * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic overlap\r\n   * tests on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\r\n   * you should filter them before passing them to this method.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#overlapTiles\r\n   * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\r\n   * @since 3.17.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n   * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\r\n   * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects overlap.\r\n   * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n   * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n   *\r\n   * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n   */\n  overlapTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext) {\n    return this.world.overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext);\n  },\n\n  /**\r\n   * Pauses the simulation.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#pause\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Arcade.World} The simulation.\r\n   */\n  pause: function () {\n    return this.world.pause();\n  },\n\n  /**\r\n   * Resumes the simulation (if paused).\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#resume\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Physics.Arcade.World} The simulation.\r\n   */\n  resume: function () {\n    return this.world.resume();\n  },\n\n  /**\r\n   * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)\r\n   *\r\n   * You must give a maximum speed value, beyond which the game object won't go any faster.\r\n   *\r\n   * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\r\n   * Note: The game object doesn't stop moving once it reaches the destination coordinates.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateTo\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n   * @param {number} x - The x coordinate to accelerate towards.\r\n   * @param {number} y - The y coordinate to accelerate towards.\r\n   * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.\r\n   * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\r\n   * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\r\n   *\r\n   * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n   */\n  accelerateTo: function (gameObject, x, y, speed, xSpeedMax, ySpeedMax) {\n    if (speed === undefined) {\n      speed = 60;\n    }\n\n    var angle = Math.atan2(y - gameObject.y, x - gameObject.x);\n    gameObject.body.acceleration.setToPolar(angle, speed);\n\n    if (xSpeedMax !== undefined && ySpeedMax !== undefined) {\n      gameObject.body.maxVelocity.set(xSpeedMax, ySpeedMax);\n    }\n\n    return angle;\n  },\n\n  /**\r\n   * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)\r\n   *\r\n   * You must give a maximum speed value, beyond which the game object won't go any faster.\r\n   *\r\n   * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\r\n   * Note: The game object doesn't stop moving once it reaches the destination coordinates.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateToObject\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n   * @param {Phaser.GameObjects.GameObject} destination - The Game Object to move towards. Can be any object but must have visible x/y properties.\r\n   * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.\r\n   * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\r\n   * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\r\n   *\r\n   * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n   */\n  accelerateToObject: function (gameObject, destination, speed, xSpeedMax, ySpeedMax) {\n    return this.accelerateTo(gameObject, destination.x, destination.y, speed, xSpeedMax, ySpeedMax);\n  },\n\n  /**\r\n   * Finds the Body or Game Object closest to a source point or object.\r\n   *\r\n   * If a `targets` argument is passed, this method finds the closest of those.\r\n   * The targets can be Arcade Physics Game Objects, Dynamic Bodies, or Static Bodies.\r\n   *\r\n   * If no `targets` argument is passed, this method finds the closest Dynamic Body.\r\n   *\r\n   * If two or more targets are the exact same distance from the source point, only the first target\r\n   * is returned.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#closest\r\n   * @since 3.0.0\r\n   *\r\n   * @param {any} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n   * @param {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[]|Phaser.GameObjects.GameObject[])} [targets] - The targets.\r\n   *\r\n   * @return {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody|Phaser.GameObjects.GameObject)} The target closest to the given source point.\r\n   */\n  closest: function (source, targets) {\n    if (!targets) {\n      targets = this.world.bodies.entries;\n    }\n\n    var min = Number.MAX_VALUE;\n    var closest = null;\n    var x = source.x;\n    var y = source.y;\n    var len = targets.length;\n\n    for (var i = 0; i < len; i++) {\n      var target = targets[i];\n      var body = target.body || target;\n\n      if (source === target || source === body || source === body.gameObject || source === body.center) {\n        continue;\n      }\n\n      var distance = DistanceSquared(x, y, body.center.x, body.center.y);\n\n      if (distance < min) {\n        closest = target;\n        min = distance;\n      }\n    }\n\n    return closest;\n  },\n\n  /**\r\n   * Finds the Body or Game Object farthest from a source point or object.\r\n   *\r\n   * If a `targets` argument is passed, this method finds the farthest of those.\r\n   * The targets can be Arcade Physics Game Objects, Dynamic Bodies, or Static Bodies.\r\n   *\r\n   * If no `targets` argument is passed, this method finds the farthest Dynamic Body.\r\n   *\r\n   * If two or more targets are the exact same distance from the source point, only the first target\r\n   * is returned.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#furthest\r\n   * @since 3.0.0\r\n   *\r\n   * @param {any} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n   * @param {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[]|Phaser.GameObjects.GameObject[])} [targets] - The targets.\r\n   *\r\n   * @return {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody|Phaser.GameObjects.GameObject)} The target farthest from the given source point.\r\n   */\n  furthest: function (source, targets) {\n    if (!targets) {\n      targets = this.world.bodies.entries;\n    }\n\n    var max = -1;\n    var farthest = null;\n    var x = source.x;\n    var y = source.y;\n    var len = targets.length;\n\n    for (var i = 0; i < len; i++) {\n      var target = targets[i];\n      var body = target.body || target;\n\n      if (source === target || source === body || source === body.gameObject || source === body.center) {\n        continue;\n      }\n\n      var distance = DistanceSquared(x, y, body.center.x, body.center.y);\n\n      if (distance > max) {\n        farthest = target;\n        max = distance;\n      }\n    }\n\n    return farthest;\n  },\n\n  /**\r\n   * Move the given display object towards the x/y coordinates at a steady velocity.\r\n   * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\r\n   * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\r\n   * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\r\n   * Note: The display object doesn't stop moving once it reaches the destination coordinates.\r\n   * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#moveTo\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n   * @param {number} x - The x coordinate to move towards.\r\n   * @param {number} y - The y coordinate to move towards.\r\n   * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\r\n   * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\r\n   *\r\n   * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n   */\n  moveTo: function (gameObject, x, y, speed, maxTime) {\n    if (speed === undefined) {\n      speed = 60;\n    }\n\n    if (maxTime === undefined) {\n      maxTime = 0;\n    }\n\n    var angle = Math.atan2(y - gameObject.y, x - gameObject.x);\n\n    if (maxTime > 0) {\n      //  We know how many pixels we need to move, but how fast?\n      speed = DistanceBetween(gameObject.x, gameObject.y, x, y) / (maxTime / 1000);\n    }\n\n    gameObject.body.velocity.setToPolar(angle, speed);\n    return angle;\n  },\n\n  /**\r\n   * Move the given display object towards the destination object at a steady velocity.\r\n   * If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.\r\n   * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\r\n   * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\r\n   * Note: The display object doesn't stop moving once it reaches the destination coordinates.\r\n   * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#moveToObject\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n   * @param {object} destination - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n   * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\r\n   * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\r\n   *\r\n   * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n   */\n  moveToObject: function (gameObject, destination, speed, maxTime) {\n    return this.moveTo(gameObject, destination.x, destination.y, speed, maxTime);\n  },\n\n  /**\r\n   * Given the angle (in degrees) and speed calculate the velocity and return it as a vector, or set it to the given vector object.\r\n   * One way to use this is: velocityFromAngle(angle, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromAngle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} angle - The angle in degrees calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)\r\n   * @param {number} [speed=60] - The speed it will move, in pixels per second squared.\r\n   * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\r\n   */\n  velocityFromAngle: function (angle, speed, vec2) {\n    if (speed === undefined) {\n      speed = 60;\n    }\n\n    if (vec2 === undefined) {\n      vec2 = new Vector2();\n    }\n\n    return vec2.setToPolar(DegToRad(angle), speed);\n  },\n\n  /**\r\n   * Given the rotation (in radians) and speed calculate the velocity and return it as a vector, or set it to the given vector object.\r\n   * One way to use this is: velocityFromRotation(rotation, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromRotation\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} rotation - The angle in radians.\r\n   * @param {number} [speed=60] - The speed it will move, in pixels per second squared\r\n   * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\r\n   */\n  velocityFromRotation: function (rotation, speed, vec2) {\n    if (speed === undefined) {\n      speed = 60;\n    }\n\n    if (vec2 === undefined) {\n      vec2 = new Vector2();\n    }\n\n    return vec2.setToPolar(rotation, speed);\n  },\n\n  /**\r\n   * This method will search the given rectangular area and return an array of all physics bodies that\r\n   * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.\r\n   *\r\n   * A body only has to intersect with the search area to be considered, it doesn't have to be fully\r\n   * contained within it.\r\n   *\r\n   * If Arcade Physics is set to use the RTree (which it is by default) then the search for is extremely fast,\r\n   * otherwise the search is O(N) for Dynamic Bodies.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#overlapRect\r\n   * @since 3.17.0\r\n   *\r\n   * @param {number} x - The top-left x coordinate of the area to search within.\r\n   * @param {number} y - The top-left y coordinate of the area to search within.\r\n   * @param {number} width - The width of the area to search within.\r\n   * @param {number} height - The height of the area to search within.\r\n   * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?\r\n   * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?\r\n   *\r\n   * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.\r\n   */\n  overlapRect: function (x, y, width, height, includeDynamic, includeStatic) {\n    return OverlapRect(this.world, x, y, width, height, includeDynamic, includeStatic);\n  },\n\n  /**\r\n   * This method will search the given circular area and return an array of all physics bodies that\r\n   * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.\r\n   *\r\n   * A body only has to intersect with the search area to be considered, it doesn't have to be fully\r\n   * contained within it.\r\n   *\r\n   * If Arcade Physics is set to use the RTree (which it is by default) then the search is rather fast,\r\n   * otherwise the search is O(N) for Dynamic Bodies.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#overlapCirc\r\n   * @since 3.21.0\r\n   *\r\n   * @param {number} x - The x coordinate of the center of the area to search within.\r\n   * @param {number} y - The y coordinate of the center of the area to search within.\r\n   * @param {number} radius - The radius of the area to search within.\r\n   * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?\r\n   * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?\r\n   *\r\n   * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.\r\n   */\n  overlapCirc: function (x, y, radius, includeDynamic, includeStatic) {\n    return OverlapCirc(this.world, x, y, radius, includeDynamic, includeStatic);\n  },\n\n  /**\r\n   * The Scene that owns this plugin is shutting down.\r\n   * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#shutdown\r\n   * @since 3.0.0\r\n   */\n  shutdown: function () {\n    if (!this.world) {\n      //  Already destroyed\n      return;\n    }\n\n    var eventEmitter = this.systems.events;\n    eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);\n    eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);\n    eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\n    this.add.destroy();\n    this.world.destroy();\n    this.add = null;\n    this.world = null;\n  },\n\n  /**\r\n   * The Scene that owns this plugin is being destroyed.\r\n   * We need to shutdown and then kill off all external references.\r\n   *\r\n   * @method Phaser.Physics.Arcade.ArcadePhysics#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.shutdown();\n    this.scene.sys.events.off(SceneEvents.START, this.start, this);\n    this.scene = null;\n    this.systems = null;\n  }\n});\nPluginCache.register('ArcadePhysics', ArcadePhysics, 'arcadePhysics');\nmodule.exports = ArcadePhysics;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/arcade/ArcadePhysics.js"],"names":["Class","require","DegToRad","DistanceBetween","DistanceSquared","Factory","GetFastValue","Merge","OverlapCirc","OverlapRect","PluginCache","SceneEvents","Vector2","World","ArcadePhysics","initialize","scene","systems","sys","config","getConfig","world","add","events","once","BOOT","boot","on","START","start","DESTROY","destroy","eventEmitter","UPDATE","update","POST_UPDATE","postUpdate","SHUTDOWN","shutdown","gameConfig","game","physics","sceneConfig","settings","overlap","object1","object2","overlapCallback","processCallback","callbackContext","undefined","collideObjects","collide","collideCallback","collideTiles","sprite","tiles","overlapTiles","pause","resume","accelerateTo","gameObject","x","y","speed","xSpeedMax","ySpeedMax","angle","Math","atan2","body","acceleration","setToPolar","maxVelocity","set","accelerateToObject","destination","closest","source","targets","bodies","entries","min","Number","MAX_VALUE","len","length","i","target","center","distance","furthest","max","farthest","moveTo","maxTime","velocity","moveToObject","velocityFromAngle","vec2","velocityFromRotation","rotation","overlapRect","width","height","includeDynamic","includeStatic","overlapCirc","radius","off","register","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar DegToRad = require('../../math/DegToRad');\r\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\r\nvar DistanceSquared = require('../../math/distance/DistanceSquared');\r\nvar Factory = require('./Factory');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Merge = require('../../utils/object/Merge');\r\nvar OverlapCirc = require('./components/OverlapCirc');\r\nvar OverlapRect = require('./components/OverlapRect');\r\nvar PluginCache = require('../../plugins/PluginCache');\r\nvar SceneEvents = require('../../scene/events');\r\nvar Vector2 = require('../../math/Vector2');\r\nvar World = require('./World');\r\n\r\n/**\r\n * @classdesc\r\n * The Arcade Physics Plugin belongs to a Scene and sets up and manages the Scene's physics simulation.\r\n * It also holds some useful methods for moving and rotating Arcade Physics Bodies.\r\n *\r\n * You can access it from within a Scene using `this.physics`.\r\n *\r\n * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\r\n * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\r\n * The separation that stops two objects penetrating may create a new penetration against a different object. If you\r\n * require a high level of stability please consider using an alternative physics system, such as Matter.js.\r\n *\r\n * @class ArcadePhysics\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that this Plugin belongs to.\r\n */\r\nvar ArcadePhysics = new Class({\r\n\r\n    initialize:\r\n\r\n    function ArcadePhysics (scene)\r\n    {\r\n        /**\r\n         * The Scene that this Plugin belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The Scene's Systems.\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * A configuration object. Union of the `physics.arcade.*` properties of the GameConfig and SceneConfig objects.\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#config\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = this.getConfig();\r\n\r\n        /**\r\n         * The physics simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world;\r\n\r\n        /**\r\n         * An object holding the Arcade Physics factory methods.\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#add\r\n         * @type {Phaser.Physics.Arcade.Factory}\r\n         * @since 3.0.0\r\n         */\r\n        this.add;\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        scene.sys.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.world = new World(this.scene, this.config);\r\n        this.add = new Factory(this.world);\r\n\r\n        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#start\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        if (!this.world)\r\n        {\r\n            this.world = new World(this.scene, this.config);\r\n            this.add = new Factory(this.world);\r\n        }\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);\r\n        eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);\r\n        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * Creates the physics configuration for the current Scene.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#getConfig\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} The physics configuration.\r\n     */\r\n    getConfig: function ()\r\n    {\r\n        var gameConfig = this.systems.game.config.physics;\r\n        var sceneConfig = this.systems.settings.physics;\r\n\r\n        var config = Merge(\r\n            GetFastValue(sceneConfig, 'arcade', {}),\r\n            GetFastValue(gameConfig, 'arcade', {})\r\n        );\r\n\r\n        return config;\r\n    },\r\n\r\n    /**\r\n     * Tests if Game Objects overlap. See {@link Phaser.Physics.Arcade.World#overlap}\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if at least one Game Object overlaps another.\r\n     *\r\n     * @see Phaser.Physics.Arcade.World#overlap\r\n     */\r\n    overlap: function (object1, object2, overlapCallback, processCallback, callbackContext)\r\n    {\r\n        if (overlapCallback === undefined) { overlapCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = overlapCallback; }\r\n\r\n        return this.world.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);\r\n    },\r\n\r\n    /**\r\n     * Performs a collision check and separation between the two physics enabled objects given, which can be single\r\n     * Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups.\r\n     *\r\n     * If you don't require separation then use {@link #overlap} instead.\r\n     *\r\n     * If two Groups or arrays are passed, each member of one will be tested against each member of the other.\r\n     *\r\n     * If **only** one Group is passed (as `object1`), each member of the Group will be collided against the other members.\r\n     *\r\n     * If **only** one Array is passed, the array is iterated and every element in it is tested against the others.\r\n     *\r\n     * Two callbacks can be provided. The `collideCallback` is invoked if a collision occurs and the two colliding\r\n     * objects are passed to it.\r\n     *\r\n     * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\r\n     * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\r\n     * The separation that stops two objects penetrating may create a new penetration against a different object. If you\r\n     * require a high level of stability please consider using an alternative physics system, such as Matter.js.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#collide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if any overlapping Game Objects were separated, otherwise false.\r\n     *\r\n     * @see Phaser.Physics.Arcade.World#collide\r\n     */\r\n    collide: function (object1, object2, collideCallback, processCallback, callbackContext)\r\n    {\r\n        if (collideCallback === undefined) { collideCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = collideCallback; }\r\n\r\n        return this.world.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);\r\n    },\r\n\r\n    /**\r\n     * This advanced method is specifically for testing for collision between a single Sprite and an array of Tile objects.\r\n     *\r\n     * You should generally use the `collide` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\r\n     * tile filtering and culling for you, as well as handle the interesting face collision automatically.\r\n     *\r\n     * This method is offered for those who would like to check for collision with specific Tiles in a layer, without\r\n     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic collisions\r\n     * on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\r\n     * you should filter them before passing them to this method.\r\n     *\r\n     * Important: Use of this method skips the `interesting faces` system that Tilemap Layers use. This means if you have\r\n     * say a row or column of tiles, and you jump into, or walk over them, it's possible to get stuck on the edges of the\r\n     * tiles as the interesting face calculations are skipped. However, for quick-fire small collision set tests on\r\n     * dynamic maps, this method can prove very useful.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#collideTiles\r\n     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext)\r\n    {\r\n        return this.world.collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext);\r\n    },\r\n\r\n    /**\r\n     * This advanced method is specifically for testing for overlaps between a single Sprite and an array of Tile objects.\r\n     *\r\n     * You should generally use the `overlap` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\r\n     * tile filtering and culling for you, as well as handle the interesting face collision automatically.\r\n     *\r\n     * This method is offered for those who would like to check for overlaps with specific Tiles in a layer, without\r\n     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic overlap\r\n     * tests on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\r\n     * you should filter them before passing them to this method.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlapTiles\r\n     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects overlap.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    overlapTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext)\r\n    {\r\n        return this.world.overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext);\r\n    },\r\n\r\n    /**\r\n     * Pauses the simulation.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} The simulation.\r\n     */\r\n    pause: function ()\r\n    {\r\n        return this.world.pause();\r\n    },\r\n\r\n    /**\r\n     * Resumes the simulation (if paused).\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} The simulation.\r\n     */\r\n    resume: function ()\r\n    {\r\n        return this.world.resume();\r\n    },\r\n\r\n    /**\r\n     * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)\r\n     *\r\n     * You must give a maximum speed value, beyond which the game object won't go any faster.\r\n     *\r\n     * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\r\n     * Note: The game object doesn't stop moving once it reaches the destination coordinates.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n     * @param {number} x - The x coordinate to accelerate towards.\r\n     * @param {number} y - The y coordinate to accelerate towards.\r\n     * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.\r\n     * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\r\n     * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\r\n     *\r\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n     */\r\n    accelerateTo: function (gameObject, x, y, speed, xSpeedMax, ySpeedMax)\r\n    {\r\n        if (speed === undefined) { speed = 60; }\r\n\r\n        var angle = Math.atan2(y - gameObject.y, x - gameObject.x);\r\n\r\n        gameObject.body.acceleration.setToPolar(angle, speed);\r\n\r\n        if (xSpeedMax !== undefined && ySpeedMax !== undefined)\r\n        {\r\n            gameObject.body.maxVelocity.set(xSpeedMax, ySpeedMax);\r\n        }\r\n\r\n        return angle;\r\n    },\r\n\r\n    /**\r\n     * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)\r\n     *\r\n     * You must give a maximum speed value, beyond which the game object won't go any faster.\r\n     *\r\n     * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\r\n     * Note: The game object doesn't stop moving once it reaches the destination coordinates.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateToObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n     * @param {Phaser.GameObjects.GameObject} destination - The Game Object to move towards. Can be any object but must have visible x/y properties.\r\n     * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.\r\n     * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\r\n     * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\r\n     *\r\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n     */\r\n    accelerateToObject: function (gameObject, destination, speed, xSpeedMax, ySpeedMax)\r\n    {\r\n        return this.accelerateTo(gameObject, destination.x, destination.y, speed, xSpeedMax, ySpeedMax);\r\n    },\r\n\r\n    /**\r\n     * Finds the Body or Game Object closest to a source point or object.\r\n     *\r\n     * If a `targets` argument is passed, this method finds the closest of those.\r\n     * The targets can be Arcade Physics Game Objects, Dynamic Bodies, or Static Bodies.\r\n     *\r\n     * If no `targets` argument is passed, this method finds the closest Dynamic Body.\r\n     *\r\n     * If two or more targets are the exact same distance from the source point, only the first target\r\n     * is returned.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#closest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {any} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n     * @param {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[]|Phaser.GameObjects.GameObject[])} [targets] - The targets.\r\n     *\r\n     * @return {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody|Phaser.GameObjects.GameObject)} The target closest to the given source point.\r\n     */\r\n    closest: function (source, targets)\r\n    {\r\n        if (!targets)\r\n        {\r\n            targets = this.world.bodies.entries;\r\n        }\r\n\r\n        var min = Number.MAX_VALUE;\r\n        var closest = null;\r\n        var x = source.x;\r\n        var y = source.y;\r\n        var len = targets.length;\r\n\r\n        for (var i = 0; i < len; i++)\r\n        {\r\n            var target = targets[i];\r\n            var body = target.body || target;\r\n\r\n            if (source === target || source === body || source === body.gameObject || source === body.center)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var distance = DistanceSquared(x, y, body.center.x, body.center.y);\r\n\r\n            if (distance < min)\r\n            {\r\n                closest = target;\r\n                min = distance;\r\n            }\r\n        }\r\n\r\n        return closest;\r\n    },\r\n\r\n    /**\r\n     * Finds the Body or Game Object farthest from a source point or object.\r\n     *\r\n     * If a `targets` argument is passed, this method finds the farthest of those.\r\n     * The targets can be Arcade Physics Game Objects, Dynamic Bodies, or Static Bodies.\r\n     *\r\n     * If no `targets` argument is passed, this method finds the farthest Dynamic Body.\r\n     *\r\n     * If two or more targets are the exact same distance from the source point, only the first target\r\n     * is returned.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#furthest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {any} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n     * @param {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[]|Phaser.GameObjects.GameObject[])} [targets] - The targets.\r\n     *\r\n     * @return {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody|Phaser.GameObjects.GameObject)} The target farthest from the given source point.\r\n     */\r\n    furthest: function (source, targets)\r\n    {\r\n        if (!targets)\r\n        {\r\n            targets = this.world.bodies.entries;\r\n        }\r\n\r\n        var max = -1;\r\n        var farthest = null;\r\n        var x = source.x;\r\n        var y = source.y;\r\n        var len = targets.length;\r\n\r\n        for (var i = 0; i < len; i++)\r\n        {\r\n            var target = targets[i];\r\n            var body = target.body || target;\r\n\r\n            if (source === target || source === body || source === body.gameObject || source === body.center)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var distance = DistanceSquared(x, y, body.center.x, body.center.y);\r\n\r\n            if (distance > max)\r\n            {\r\n                farthest = target;\r\n                max = distance;\r\n            }\r\n\r\n        }\r\n\r\n        return farthest;\r\n    },\r\n\r\n    /**\r\n     * Move the given display object towards the x/y coordinates at a steady velocity.\r\n     * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\r\n     * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\r\n     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\r\n     * Note: The display object doesn't stop moving once it reaches the destination coordinates.\r\n     * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#moveTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n     * @param {number} x - The x coordinate to move towards.\r\n     * @param {number} y - The y coordinate to move towards.\r\n     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\r\n     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\r\n     *\r\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n     */\r\n    moveTo: function (gameObject, x, y, speed, maxTime)\r\n    {\r\n        if (speed === undefined) { speed = 60; }\r\n        if (maxTime === undefined) { maxTime = 0; }\r\n\r\n        var angle = Math.atan2(y - gameObject.y, x - gameObject.x);\r\n\r\n        if (maxTime > 0)\r\n        {\r\n            //  We know how many pixels we need to move, but how fast?\r\n            speed = DistanceBetween(gameObject.x, gameObject.y, x, y) / (maxTime / 1000);\r\n        }\r\n\r\n        gameObject.body.velocity.setToPolar(angle, speed);\r\n\r\n        return angle;\r\n    },\r\n\r\n    /**\r\n     * Move the given display object towards the destination object at a steady velocity.\r\n     * If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.\r\n     * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\r\n     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\r\n     * Note: The display object doesn't stop moving once it reaches the destination coordinates.\r\n     * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#moveToObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n     * @param {object} destination - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\r\n     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\r\n     *\r\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n     */\r\n    moveToObject: function (gameObject, destination, speed, maxTime)\r\n    {\r\n        return this.moveTo(gameObject, destination.x, destination.y, speed, maxTime);\r\n    },\r\n\r\n    /**\r\n     * Given the angle (in degrees) and speed calculate the velocity and return it as a vector, or set it to the given vector object.\r\n     * One way to use this is: velocityFromAngle(angle, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} angle - The angle in degrees calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)\r\n     * @param {number} [speed=60] - The speed it will move, in pixels per second squared.\r\n     * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\r\n     */\r\n    velocityFromAngle: function (angle, speed, vec2)\r\n    {\r\n        if (speed === undefined) { speed = 60; }\r\n        if (vec2 === undefined) { vec2 = new Vector2(); }\r\n\r\n        return vec2.setToPolar(DegToRad(angle), speed);\r\n    },\r\n\r\n    /**\r\n     * Given the rotation (in radians) and speed calculate the velocity and return it as a vector, or set it to the given vector object.\r\n     * One way to use this is: velocityFromRotation(rotation, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rotation - The angle in radians.\r\n     * @param {number} [speed=60] - The speed it will move, in pixels per second squared\r\n     * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\r\n     */\r\n    velocityFromRotation: function (rotation, speed, vec2)\r\n    {\r\n        if (speed === undefined) { speed = 60; }\r\n        if (vec2 === undefined) { vec2 = new Vector2(); }\r\n\r\n        return vec2.setToPolar(rotation, speed);\r\n    },\r\n\r\n    /**\r\n     * This method will search the given rectangular area and return an array of all physics bodies that\r\n     * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.\r\n     *\r\n     * A body only has to intersect with the search area to be considered, it doesn't have to be fully\r\n     * contained within it.\r\n     *\r\n     * If Arcade Physics is set to use the RTree (which it is by default) then the search for is extremely fast,\r\n     * otherwise the search is O(N) for Dynamic Bodies.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlapRect\r\n     * @since 3.17.0\r\n     *\r\n     * @param {number} x - The top-left x coordinate of the area to search within.\r\n     * @param {number} y - The top-left y coordinate of the area to search within.\r\n     * @param {number} width - The width of the area to search within.\r\n     * @param {number} height - The height of the area to search within.\r\n     * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?\r\n     * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?\r\n     *\r\n     * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.\r\n     */\r\n    overlapRect: function (x, y, width, height, includeDynamic, includeStatic)\r\n    {\r\n        return OverlapRect(this.world, x, y, width, height, includeDynamic, includeStatic);\r\n    },\r\n\r\n    /**\r\n     * This method will search the given circular area and return an array of all physics bodies that\r\n     * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.\r\n     *\r\n     * A body only has to intersect with the search area to be considered, it doesn't have to be fully\r\n     * contained within it.\r\n     *\r\n     * If Arcade Physics is set to use the RTree (which it is by default) then the search is rather fast,\r\n     * otherwise the search is O(N) for Dynamic Bodies.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlapCirc\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} x - The x coordinate of the center of the area to search within.\r\n     * @param {number} y - The y coordinate of the center of the area to search within.\r\n     * @param {number} radius - The radius of the area to search within.\r\n     * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?\r\n     * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?\r\n     *\r\n     * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.\r\n     */\r\n    overlapCirc: function (x, y, radius, includeDynamic, includeStatic)\r\n    {\r\n        return OverlapCirc(this.world, x, y, radius, includeDynamic, includeStatic);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#shutdown\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        if (!this.world)\r\n        {\r\n            //  Already destroyed\r\n            return;\r\n        }\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);\r\n        eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);\r\n        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n\r\n        this.add.destroy();\r\n        this.world.destroy();\r\n\r\n        this.add = null;\r\n        this.world = null;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene.sys.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('ArcadePhysics', ArcadePhysics, 'arcadePhysics');\r\n\r\nmodule.exports = ArcadePhysics;\r\n"]},"metadata":{},"sourceType":"script"}