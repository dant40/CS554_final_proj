{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar TileToWorldX = require('./TileToWorldX');\n\nvar TileToWorldY = require('./TileToWorldY');\n\nvar GetTilesWithin = require('./GetTilesWithin');\n\nvar ReplaceByIndex = require('./ReplaceByIndex');\n/**\r\n * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n *\r\n * @function Phaser.Tilemaps.Components.CreateFromTiles\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {(integer|array)} indexes - The tile index, or array of indexes, to create Sprites from.\r\n * @param {(integer|array)} replacements - The tile index, or array of indexes, to change a converted tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a one-to-one mapping with the indexes array.\r\n * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e. scene.make.sprite).\r\n * @param {Phaser.Scene} [scene=scene the map is within] - The Scene to create the Sprites within.\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when determining the world XY\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.\r\n */\n\n\nvar CreateFromTiles = function (indexes, replacements, spriteConfig, scene, camera, layer) {\n  if (spriteConfig === undefined) {\n    spriteConfig = {};\n  }\n\n  if (!Array.isArray(indexes)) {\n    indexes = [indexes];\n  }\n\n  var tilemapLayer = layer.tilemapLayer;\n\n  if (scene === undefined) {\n    scene = tilemapLayer.scene;\n  }\n\n  if (camera === undefined) {\n    camera = scene.cameras.main;\n  }\n\n  var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);\n  var sprites = [];\n  var i;\n\n  for (i = 0; i < tiles.length; i++) {\n    var tile = tiles[i];\n\n    if (indexes.indexOf(tile.index) !== -1) {\n      spriteConfig.x = TileToWorldX(tile.x, camera, layer);\n      spriteConfig.y = TileToWorldY(tile.y, camera, layer);\n      var sprite = scene.make.sprite(spriteConfig);\n      sprites.push(sprite);\n    }\n  }\n\n  if (typeof replacements === 'number') {\n    //  Assume 1 replacement for all types of tile given\n    for (i = 0; i < indexes.length; i++) {\n      ReplaceByIndex(indexes[i], replacements, 0, 0, layer.width, layer.height, layer);\n    }\n  } else if (Array.isArray(replacements)) {\n    //  Assume 1 to 1 mapping with indexes array\n    for (i = 0; i < indexes.length; i++) {\n      ReplaceByIndex(indexes[i], replacements[i], 0, 0, layer.width, layer.height, layer);\n    }\n  }\n\n  return sprites;\n};\n\nmodule.exports = CreateFromTiles;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/tilemaps/components/CreateFromTiles.js"],"names":["TileToWorldX","require","TileToWorldY","GetTilesWithin","ReplaceByIndex","CreateFromTiles","indexes","replacements","spriteConfig","scene","camera","layer","undefined","Array","isArray","tilemapLayer","cameras","main","tiles","width","height","sprites","i","length","tile","indexOf","index","x","y","sprite","make","push","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TileToWorldX = require('./TileToWorldX');\r\nvar TileToWorldY = require('./TileToWorldY');\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar ReplaceByIndex = require('./ReplaceByIndex');\r\n\r\n/**\r\n * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n *\r\n * @function Phaser.Tilemaps.Components.CreateFromTiles\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {(integer|array)} indexes - The tile index, or array of indexes, to create Sprites from.\r\n * @param {(integer|array)} replacements - The tile index, or array of indexes, to change a converted tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a one-to-one mapping with the indexes array.\r\n * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e. scene.make.sprite).\r\n * @param {Phaser.Scene} [scene=scene the map is within] - The Scene to create the Sprites within.\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera=main camera] - The Camera to use when determining the world XY\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.\r\n */\r\nvar CreateFromTiles = function (indexes, replacements, spriteConfig, scene, camera, layer)\r\n{\r\n    if (spriteConfig === undefined) { spriteConfig = {}; }\r\n\r\n    if (!Array.isArray(indexes)) { indexes = [ indexes ]; }\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n    if (scene === undefined) { scene = tilemapLayer.scene; }\r\n    if (camera === undefined) { camera = scene.cameras.main; }\r\n\r\n    var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);\r\n    var sprites = [];\r\n    var i;\r\n\r\n    for (i = 0; i < tiles.length; i++)\r\n    {\r\n        var tile = tiles[i];\r\n\r\n        if (indexes.indexOf(tile.index) !== -1)\r\n        {\r\n            spriteConfig.x = TileToWorldX(tile.x, camera, layer);\r\n            spriteConfig.y = TileToWorldY(tile.y, camera, layer);\r\n\r\n            var sprite = scene.make.sprite(spriteConfig);\r\n            sprites.push(sprite);\r\n        }\r\n    }\r\n\r\n    if (typeof replacements === 'number')\r\n    {\r\n        //  Assume 1 replacement for all types of tile given\r\n        for (i = 0; i < indexes.length; i++)\r\n        {\r\n            ReplaceByIndex(indexes[i], replacements, 0, 0, layer.width, layer.height, layer);\r\n        }\r\n    }\r\n    else if (Array.isArray(replacements))\r\n    {\r\n        //  Assume 1 to 1 mapping with indexes array\r\n        for (i = 0; i < indexes.length; i++)\r\n        {\r\n            ReplaceByIndex(indexes[i], replacements[i], 0, 0, layer.width, layer.height, layer);\r\n        }\r\n    }\r\n\r\n    return sprites;\r\n};\r\n\r\nmodule.exports = CreateFromTiles;\r\n"]},"metadata":{},"sourceType":"script"}