{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\n//! stable.js 0.1.6, https://github.com/Two-Screen/stable\n//! © 2017 Angry Bytes and contributors. MIT licensed.\n\n/**\r\n * @namespace Phaser.Utils.Array.StableSortFunctions\r\n */\n(function () {\n  /**\r\n  * A stable array sort, because `Array#sort()` is not guaranteed stable.\r\n  * This is an implementation of merge sort, without recursion.\r\n  *\r\n  * @function Phaser.Utils.Array.StableSort\r\n  * @since 3.0.0\r\n  *\r\n  * @param {array} arr - The input array to be sorted.\r\n  * @param {function} comp - The comparison handler.\r\n  *\r\n  * @return {array} The sorted result.\r\n  */\n  var stable = function (arr, comp) {\n    return exec(arr.slice(), comp);\n  };\n  /**\r\n  * Sort the input array and simply copy it back if the result isn't in the original array, which happens on an odd number of passes.\r\n  *\r\n  * @function Phaser.Utils.Array.StableSortFunctions.inplace\r\n  * @memberof Phaser.Utils.Array.StableSortFunctions\r\n  * @since 3.0.0\r\n  *\r\n  * @param {array} arr - The input array.\r\n  * @param {function} comp - The comparison handler.\r\n  *\r\n  * @return {array} The sorted array.\r\n  */\n\n\n  stable.inplace = function (arr, comp) {\n    var result = exec(arr, comp); // This simply copies back if the result isn't in the original array,\n    // which happens on an odd number of passes.\n\n    if (result !== arr) {\n      pass(result, null, arr.length, arr);\n    }\n\n    return arr;\n  }; // Execute the sort using the input array and a second buffer as work space.\n  // Returns one of those two, containing the final result.\n\n\n  function exec(arr, comp) {\n    if (typeof comp !== 'function') {\n      comp = function (a, b) {\n        return String(a).localeCompare(b);\n      };\n    } // Short-circuit when there's nothing to sort.\n\n\n    var len = arr.length;\n\n    if (len <= 1) {\n      return arr;\n    } // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.\n    // Chunks are the size of the left or right hand in merge sort.\n    // Stop when the left-hand covers all of the array.\n\n\n    var buffer = new Array(len);\n\n    for (var chk = 1; chk < len; chk *= 2) {\n      pass(arr, comp, chk, buffer);\n      var tmp = arr;\n      arr = buffer;\n      buffer = tmp;\n    }\n\n    return arr;\n  } // Run a single pass with the given chunk size.\n\n\n  var pass = function (arr, comp, chk, result) {\n    var len = arr.length;\n    var i = 0; // Step size / double chunk size.\n\n    var dbl = chk * 2; // Bounds of the left and right chunks.\n\n    var l, r, e; // Iterators over the left and right chunk.\n\n    var li, ri; // Iterate over pairs of chunks.\n\n    for (l = 0; l < len; l += dbl) {\n      r = l + chk;\n      e = r + chk;\n      if (r > len) r = len;\n      if (e > len) e = len; // Iterate both chunks in parallel.\n\n      li = l;\n      ri = r;\n\n      while (true) {\n        // Compare the chunks.\n        if (li < r && ri < e) {\n          // This works for a regular `sort()` compatible comparator,\n          // but also for a simple comparator like: `a > b`\n          if (comp(arr[li], arr[ri]) <= 0) {\n            result[i++] = arr[li++];\n          } else {\n            result[i++] = arr[ri++];\n          }\n        } // Nothing to compare, just flush what's left.\n        else if (li < r) {\n            result[i++] = arr[li++];\n          } else if (ri < e) {\n            result[i++] = arr[ri++];\n          } // Both iterators are at the chunk ends.\n          else {\n              break;\n            }\n      }\n    }\n  }; // Export using CommonJS or to the window.\n\n\n  if (typeof module !== 'undefined') {\n    module.exports = stable;\n  } else {\n    window.stable = stable;\n  }\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/utils/array/StableSort.js"],"names":["stable","arr","comp","exec","slice","inplace","result","pass","length","a","b","String","localeCompare","len","buffer","Array","chk","tmp","i","dbl","l","r","e","li","ri","module","exports","window"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//! stable.js 0.1.6, https://github.com/Two-Screen/stable\r\n//! © 2017 Angry Bytes and contributors. MIT licensed.\r\n\r\n/**\r\n * @namespace Phaser.Utils.Array.StableSortFunctions\r\n */\r\n\r\n(function() {\r\n\r\n /**\r\n * A stable array sort, because `Array#sort()` is not guaranteed stable.\r\n * This is an implementation of merge sort, without recursion.\r\n *\r\n * @function Phaser.Utils.Array.StableSort\r\n * @since 3.0.0\r\n *\r\n * @param {array} arr - The input array to be sorted.\r\n * @param {function} comp - The comparison handler.\r\n *\r\n * @return {array} The sorted result.\r\n */\r\nvar stable = function(arr, comp) {\r\n    return exec(arr.slice(), comp);\r\n};\r\n\r\n /**\r\n * Sort the input array and simply copy it back if the result isn't in the original array, which happens on an odd number of passes.\r\n *\r\n * @function Phaser.Utils.Array.StableSortFunctions.inplace\r\n * @memberof Phaser.Utils.Array.StableSortFunctions\r\n * @since 3.0.0\r\n *\r\n * @param {array} arr - The input array.\r\n * @param {function} comp - The comparison handler.\r\n *\r\n * @return {array} The sorted array.\r\n */\r\nstable.inplace = function(arr, comp) {\r\n    var result = exec(arr, comp);\r\n\r\n    // This simply copies back if the result isn't in the original array,\r\n    // which happens on an odd number of passes.\r\n    if (result !== arr) {\r\n        pass(result, null, arr.length, arr);\r\n    }\r\n\r\n    return arr;\r\n};\r\n\r\n// Execute the sort using the input array and a second buffer as work space.\r\n// Returns one of those two, containing the final result.\r\nfunction exec(arr, comp) {\r\n    if (typeof(comp) !== 'function') {\r\n        comp = function(a, b) {\r\n            return String(a).localeCompare(b);\r\n        };\r\n    }\r\n\r\n    // Short-circuit when there's nothing to sort.\r\n    var len = arr.length;\r\n    if (len <= 1) {\r\n        return arr;\r\n    }\r\n\r\n    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.\r\n    // Chunks are the size of the left or right hand in merge sort.\r\n    // Stop when the left-hand covers all of the array.\r\n    var buffer = new Array(len);\r\n    for (var chk = 1; chk < len; chk *= 2) {\r\n        pass(arr, comp, chk, buffer);\r\n\r\n        var tmp = arr;\r\n        arr = buffer;\r\n        buffer = tmp;\r\n    }\r\n\r\n    return arr;\r\n}\r\n\r\n// Run a single pass with the given chunk size.\r\nvar pass = function(arr, comp, chk, result) {\r\n    var len = arr.length;\r\n    var i = 0;\r\n    // Step size / double chunk size.\r\n    var dbl = chk * 2;\r\n    // Bounds of the left and right chunks.\r\n    var l, r, e;\r\n    // Iterators over the left and right chunk.\r\n    var li, ri;\r\n\r\n    // Iterate over pairs of chunks.\r\n    for (l = 0; l < len; l += dbl) {\r\n        r = l + chk;\r\n        e = r + chk;\r\n        if (r > len) r = len;\r\n        if (e > len) e = len;\r\n\r\n        // Iterate both chunks in parallel.\r\n        li = l;\r\n        ri = r;\r\n        while (true) {\r\n            // Compare the chunks.\r\n            if (li < r && ri < e) {\r\n                // This works for a regular `sort()` compatible comparator,\r\n                // but also for a simple comparator like: `a > b`\r\n                if (comp(arr[li], arr[ri]) <= 0) {\r\n                    result[i++] = arr[li++];\r\n                }\r\n                else {\r\n                    result[i++] = arr[ri++];\r\n                }\r\n            }\r\n            // Nothing to compare, just flush what's left.\r\n            else if (li < r) {\r\n                result[i++] = arr[li++];\r\n            }\r\n            else if (ri < e) {\r\n                result[i++] = arr[ri++];\r\n            }\r\n            // Both iterators are at the chunk ends.\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n// Export using CommonJS or to the window.\r\nif (typeof(module) !== 'undefined') {\r\n    module.exports = stable;\r\n}\r\nelse {\r\n    window.stable = stable;\r\n}\r\n\r\n})();"]},"metadata":{},"sourceType":"script"}