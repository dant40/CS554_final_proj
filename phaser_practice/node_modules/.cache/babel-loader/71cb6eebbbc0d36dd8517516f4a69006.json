{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../utils/Class');\n\nvar Clamp = require('../math/Clamp');\n\nvar Extend = require('../utils/object/Extend');\n/**\r\n * @classdesc\r\n * A Frame is a section of a Texture.\r\n *\r\n * @class Frame\r\n * @memberof Phaser.Textures\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture this Frame is a part of.\r\n * @param {(integer|string)} name - The name of this Frame. The name is unique within the Texture.\r\n * @param {integer} sourceIndex - The index of the TextureSource that this Frame is a part of.\r\n * @param {number} x - The x coordinate of the top-left of this Frame.\r\n * @param {number} y - The y coordinate of the top-left of this Frame.\r\n * @param {number} width - The width of this Frame.\r\n * @param {number} height - The height of this Frame.\r\n */\n\n\nvar Frame = new Class({\n  initialize: function Frame(texture, name, sourceIndex, x, y, width, height) {\n    /**\r\n     * The Texture this Frame is a part of.\r\n     *\r\n     * @name Phaser.Textures.Frame#texture\r\n     * @type {Phaser.Textures.Texture}\r\n     * @since 3.0.0\r\n     */\n    this.texture = texture;\n    /**\r\n     * The name of this Frame.\r\n     * The name is unique within the Texture.\r\n     *\r\n     * @name Phaser.Textures.Frame#name\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\n\n    this.name = name;\n    /**\r\n     * The TextureSource this Frame is part of.\r\n     *\r\n     * @name Phaser.Textures.Frame#source\r\n     * @type {Phaser.Textures.TextureSource}\r\n     * @since 3.0.0\r\n     */\n\n    this.source = texture.source[sourceIndex];\n    /**\r\n     * The index of the TextureSource in the Texture sources array.\r\n     *\r\n     * @name Phaser.Textures.Frame#sourceIndex\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.sourceIndex = sourceIndex;\n    /**\r\n     * A reference to the Texture Source WebGL Texture that this Frame is using.\r\n     *\r\n     * @name Phaser.Textures.Frame#glTexture\r\n     * @type {?WebGLTexture}\r\n     * @default null\r\n     * @since 3.11.0\r\n     */\n\n    this.glTexture = this.source.glTexture;\n    /**\r\n     * X position within the source image to cut from.\r\n     *\r\n     * @name Phaser.Textures.Frame#cutX\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.cutX;\n    /**\r\n     * Y position within the source image to cut from.\r\n     *\r\n     * @name Phaser.Textures.Frame#cutY\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.cutY;\n    /**\r\n     * The width of the area in the source image to cut.\r\n     *\r\n     * @name Phaser.Textures.Frame#cutWidth\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.cutWidth;\n    /**\r\n     * The height of the area in the source image to cut.\r\n     *\r\n     * @name Phaser.Textures.Frame#cutHeight\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.cutHeight;\n    /**\r\n     * The X rendering offset of this Frame, taking trim into account.\r\n     *\r\n     * @name Phaser.Textures.Frame#x\r\n     * @type {integer}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.x = 0;\n    /**\r\n     * The Y rendering offset of this Frame, taking trim into account.\r\n     *\r\n     * @name Phaser.Textures.Frame#y\r\n     * @type {integer}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.y = 0;\n    /**\r\n     * The rendering width of this Frame, taking trim into account.\r\n     *\r\n     * @name Phaser.Textures.Frame#width\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.width;\n    /**\r\n     * The rendering height of this Frame, taking trim into account.\r\n     *\r\n     * @name Phaser.Textures.Frame#height\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.height;\n    /**\r\n     * Half the width, floored.\r\n     * Precalculated for the renderer.\r\n     *\r\n     * @name Phaser.Textures.Frame#halfWidth\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.halfWidth;\n    /**\r\n     * Half the height, floored.\r\n     * Precalculated for the renderer.\r\n     *\r\n     * @name Phaser.Textures.Frame#halfHeight\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.halfHeight;\n    /**\r\n     * The x center of this frame, floored.\r\n     *\r\n     * @name Phaser.Textures.Frame#centerX\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.centerX;\n    /**\r\n     * The y center of this frame, floored.\r\n     *\r\n     * @name Phaser.Textures.Frame#centerY\r\n     * @type {integer}\r\n     * @since 3.0.0\r\n     */\n\n    this.centerY;\n    /**\r\n     * The horizontal pivot point of this Frame.\r\n     *\r\n     * @name Phaser.Textures.Frame#pivotX\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.pivotX = 0;\n    /**\r\n     * The vertical pivot point of this Frame.\r\n     *\r\n     * @name Phaser.Textures.Frame#pivotY\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.pivotY = 0;\n    /**\r\n     * Does this Frame have a custom pivot point?\r\n     *\r\n     * @name Phaser.Textures.Frame#customPivot\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.customPivot = false;\n    /**\r\n     * **CURRENTLY UNSUPPORTED**\r\n     *\r\n     * Is this frame is rotated or not in the Texture?\r\n     * Rotation allows you to use rotated frames in texture atlas packing.\r\n     * It has nothing to do with Sprite rotation.\r\n     *\r\n     * @name Phaser.Textures.Frame#rotated\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.rotated = false;\n    /**\r\n     * Over-rides the Renderer setting.\r\n     * -1 = use Renderer Setting\r\n     * 0 = No rounding\r\n     * 1 = Round\r\n     *\r\n     * @name Phaser.Textures.Frame#autoRound\r\n     * @type {integer}\r\n     * @default -1\r\n     * @since 3.0.0\r\n     */\n\n    this.autoRound = -1;\n    /**\r\n     * Any Frame specific custom data can be stored here.\r\n     *\r\n     * @name Phaser.Textures.Frame#customData\r\n     * @type {object}\r\n     * @since 3.0.0\r\n     */\n\n    this.customData = {};\n    /**\r\n     * WebGL UV u0 value.\r\n     *\r\n     * @name Phaser.Textures.Frame#u0\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.11.0\r\n     */\n\n    this.u0 = 0;\n    /**\r\n     * WebGL UV v0 value.\r\n     *\r\n     * @name Phaser.Textures.Frame#v0\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.11.0\r\n     */\n\n    this.v0 = 0;\n    /**\r\n     * WebGL UV u1 value.\r\n     *\r\n     * @name Phaser.Textures.Frame#u1\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.11.0\r\n     */\n\n    this.u1 = 0;\n    /**\r\n     * WebGL UV v1 value.\r\n     *\r\n     * @name Phaser.Textures.Frame#v1\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.11.0\r\n     */\n\n    this.v1 = 0;\n    /**\r\n     * The un-modified source frame, trim and UV data.\r\n     *\r\n     * @name Phaser.Textures.Frame#data\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this.data = {\n      cut: {\n        x: 0,\n        y: 0,\n        w: 0,\n        h: 0,\n        r: 0,\n        b: 0\n      },\n      trim: false,\n      sourceSize: {\n        w: 0,\n        h: 0\n      },\n      spriteSourceSize: {\n        x: 0,\n        y: 0,\n        w: 0,\n        h: 0,\n        r: 0,\n        b: 0\n      },\n      radius: 0,\n      drawImage: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      }\n    };\n    this.setSize(width, height, x, y);\n  },\n\n  /**\r\n   * Sets the width, height, x and y of this Frame.\r\n   * \r\n   * This is called automatically by the constructor\r\n   * and should rarely be changed on-the-fly.\r\n   *\r\n   * @method Phaser.Textures.Frame#setSize\r\n   * @since 3.7.0\r\n   *\r\n   * @param {integer} width - The width of the frame before being trimmed.\r\n   * @param {integer} height - The height of the frame before being trimmed.\r\n   * @param {integer} [x=0] - The x coordinate of the top-left of this Frame.\r\n   * @param {integer} [y=0] - The y coordinate of the top-left of this Frame.\r\n   *\r\n   * @return {Phaser.Textures.Frame} This Frame object.\r\n   */\n  setSize: function (width, height, x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    this.cutX = x;\n    this.cutY = y;\n    this.cutWidth = width;\n    this.cutHeight = height;\n    this.width = width;\n    this.height = height;\n    this.halfWidth = Math.floor(width * 0.5);\n    this.halfHeight = Math.floor(height * 0.5);\n    this.centerX = Math.floor(width / 2);\n    this.centerY = Math.floor(height / 2);\n    var data = this.data;\n    var cut = data.cut;\n    cut.x = x;\n    cut.y = y;\n    cut.w = width;\n    cut.h = height;\n    cut.r = x + width;\n    cut.b = y + height;\n    data.sourceSize.w = width;\n    data.sourceSize.h = height;\n    data.spriteSourceSize.w = width;\n    data.spriteSourceSize.h = height;\n    data.radius = 0.5 * Math.sqrt(width * width + height * height);\n    var drawImage = data.drawImage;\n    drawImage.x = x;\n    drawImage.y = y;\n    drawImage.width = width;\n    drawImage.height = height;\n    return this.updateUVs();\n  },\n\n  /**\r\n   * If the frame was trimmed when added to the Texture Atlas, this records the trim and source data.\r\n   *\r\n   * @method Phaser.Textures.Frame#setTrim\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} actualWidth - The width of the frame before being trimmed.\r\n   * @param {number} actualHeight - The height of the frame before being trimmed.\r\n   * @param {number} destX - The destination X position of the trimmed frame for display.\r\n   * @param {number} destY - The destination Y position of the trimmed frame for display.\r\n   * @param {number} destWidth - The destination width of the trimmed frame for display.\r\n   * @param {number} destHeight - The destination height of the trimmed frame for display.\r\n   *\r\n   * @return {Phaser.Textures.Frame} This Frame object.\r\n   */\n  setTrim: function (actualWidth, actualHeight, destX, destY, destWidth, destHeight) {\n    var data = this.data;\n    var ss = data.spriteSourceSize; //  Store actual values\n\n    data.trim = true;\n    data.sourceSize.w = actualWidth;\n    data.sourceSize.h = actualHeight;\n    ss.x = destX;\n    ss.y = destY;\n    ss.w = destWidth;\n    ss.h = destHeight;\n    ss.r = destX + destWidth;\n    ss.b = destY + destHeight; //  Adjust properties\n\n    this.x = destX;\n    this.y = destY;\n    this.width = destWidth;\n    this.height = destHeight;\n    this.halfWidth = destWidth * 0.5;\n    this.halfHeight = destHeight * 0.5;\n    this.centerX = Math.floor(destWidth / 2);\n    this.centerY = Math.floor(destHeight / 2);\n    return this.updateUVs();\n  },\n\n  /**\r\n   * Takes a crop data object and, based on the rectangular region given, calculates the\r\n   * required UV coordinates in order to crop this Frame for WebGL and Canvas rendering.\r\n   * \r\n   * This is called directly by the Game Object Texture Components `setCrop` method.\r\n   * Please use that method to crop a Game Object.\r\n   *\r\n   * @method Phaser.Textures.Frame#setCropUVs\r\n   * @since 3.11.0\r\n   * \r\n   * @param {object} crop - The crop data object. This is the `GameObject._crop` property.\r\n   * @param {number} x - The x coordinate to start the crop from. Cannot be negative or exceed the Frame width.\r\n   * @param {number} y - The y coordinate to start the crop from. Cannot be negative or exceed the Frame height.\r\n   * @param {number} width - The width of the crop rectangle. Cannot exceed the Frame width.\r\n   * @param {number} height - The height of the crop rectangle. Cannot exceed the Frame height.\r\n   * @param {boolean} flipX - Does the parent Game Object have flipX set?\r\n   * @param {boolean} flipY - Does the parent Game Object have flipY set?\r\n   *\r\n   * @return {object} The updated crop data object.\r\n   */\n  setCropUVs: function (crop, x, y, width, height, flipX, flipY) {\n    //  Clamp the input values\n    var cx = this.cutX;\n    var cy = this.cutY;\n    var cw = this.cutWidth;\n    var ch = this.cutHeight;\n    var rw = this.realWidth;\n    var rh = this.realHeight;\n    x = Clamp(x, 0, rw);\n    y = Clamp(y, 0, rh);\n    width = Clamp(width, 0, rw - x);\n    height = Clamp(height, 0, rh - y);\n    var ox = cx + x;\n    var oy = cy + y;\n    var ow = width;\n    var oh = height;\n    var data = this.data;\n\n    if (data.trim) {\n      var ss = data.spriteSourceSize; //  Need to check for intersection between the cut area and the crop area\n      //  If there is none, we set UV to be empty, otherwise set it to be the intersection area\n\n      width = Clamp(width, 0, cw - x);\n      height = Clamp(height, 0, ch - y);\n      var cropRight = x + width;\n      var cropBottom = y + height;\n      var intersects = !(ss.r < x || ss.b < y || ss.x > cropRight || ss.y > cropBottom);\n\n      if (intersects) {\n        var ix = Math.max(ss.x, x);\n        var iy = Math.max(ss.y, y);\n        var iw = Math.min(ss.r, cropRight) - ix;\n        var ih = Math.min(ss.b, cropBottom) - iy;\n        ow = iw;\n        oh = ih;\n\n        if (flipX) {\n          ox = cx + (cw - (ix - ss.x) - iw);\n        } else {\n          ox = cx + (ix - ss.x);\n        }\n\n        if (flipY) {\n          oy = cy + (ch - (iy - ss.y) - ih);\n        } else {\n          oy = cy + (iy - ss.y);\n        }\n\n        x = ix;\n        y = iy;\n        width = iw;\n        height = ih;\n      } else {\n        ox = 0;\n        oy = 0;\n        ow = 0;\n        oh = 0;\n      }\n    } else {\n      if (flipX) {\n        ox = cx + (cw - x - width);\n      }\n\n      if (flipY) {\n        oy = cy + (ch - y - height);\n      }\n    }\n\n    var tw = this.source.width;\n    var th = this.source.height; //  Map the given coordinates into UV space, clamping to the 0-1 range.\n\n    crop.u0 = Math.max(0, ox / tw);\n    crop.v0 = Math.max(0, oy / th);\n    crop.u1 = Math.min(1, (ox + ow) / tw);\n    crop.v1 = Math.min(1, (oy + oh) / th);\n    crop.x = x;\n    crop.y = y;\n    crop.cx = ox;\n    crop.cy = oy;\n    crop.cw = ow;\n    crop.ch = oh;\n    crop.width = width;\n    crop.height = height;\n    crop.flipX = flipX;\n    crop.flipY = flipY;\n    return crop;\n  },\n\n  /**\r\n   * Takes a crop data object and recalculates the UVs based on the dimensions inside the crop object.\r\n   * Called automatically by `setFrame`.\r\n   *\r\n   * @method Phaser.Textures.Frame#updateCropUVs\r\n   * @since 3.11.0\r\n   * \r\n   * @param {object} crop - The crop data object. This is the `GameObject._crop` property.\r\n   * @param {boolean} flipX - Does the parent Game Object have flipX set?\r\n   * @param {boolean} flipY - Does the parent Game Object have flipY set?\r\n   *\r\n   * @return {object} The updated crop data object.\r\n   */\n  updateCropUVs: function (crop, flipX, flipY) {\n    return this.setCropUVs(crop, crop.x, crop.y, crop.width, crop.height, flipX, flipY);\n  },\n\n  /**\r\n   * Updates the internal WebGL UV cache and the drawImage cache.\r\n   *\r\n   * @method Phaser.Textures.Frame#updateUVs\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Textures.Frame} This Frame object.\r\n   */\n  updateUVs: function () {\n    var cx = this.cutX;\n    var cy = this.cutY;\n    var cw = this.cutWidth;\n    var ch = this.cutHeight; //  Canvas data\n\n    var cd = this.data.drawImage;\n    cd.width = cw;\n    cd.height = ch; //  WebGL data\n\n    var tw = this.source.width;\n    var th = this.source.height;\n    this.u0 = cx / tw;\n    this.v0 = cy / th;\n    this.u1 = (cx + cw) / tw;\n    this.v1 = (cy + ch) / th;\n    return this;\n  },\n\n  /**\r\n   * Updates the internal WebGL UV cache.\r\n   *\r\n   * @method Phaser.Textures.Frame#updateUVsInverted\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Textures.Frame} This Frame object.\r\n   */\n  updateUVsInverted: function () {\n    var tw = this.source.width;\n    var th = this.source.height;\n    this.u0 = (this.cutX + this.cutHeight) / tw;\n    this.v0 = this.cutY / th;\n    this.u1 = this.cutX / tw;\n    this.v1 = (this.cutY + this.cutWidth) / th;\n    return this;\n  },\n\n  /**\r\n   * Clones this Frame into a new Frame object.\r\n   *\r\n   * @method Phaser.Textures.Frame#clone\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Textures.Frame} A clone of this Frame.\r\n   */\n  clone: function () {\n    var clone = new Frame(this.texture, this.name, this.sourceIndex);\n    clone.cutX = this.cutX;\n    clone.cutY = this.cutY;\n    clone.cutWidth = this.cutWidth;\n    clone.cutHeight = this.cutHeight;\n    clone.x = this.x;\n    clone.y = this.y;\n    clone.width = this.width;\n    clone.height = this.height;\n    clone.halfWidth = this.halfWidth;\n    clone.halfHeight = this.halfHeight;\n    clone.centerX = this.centerX;\n    clone.centerY = this.centerY;\n    clone.rotated = this.rotated;\n    clone.data = Extend(true, clone.data, this.data);\n    clone.updateUVs();\n    return clone;\n  },\n\n  /**\r\n   * Destroys this Frame by nulling its reference to the parent Texture and and data objects.\r\n   *\r\n   * @method Phaser.Textures.Frame#destroy\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.source = null;\n    this.texture = null;\n    this.glTexture = null;\n    this.customData = null;\n    this.data = null;\n  },\n\n  /**\r\n   * The width of the Frame in its un-trimmed, un-padded state, as prepared in the art package,\r\n   * before being packed.\r\n   *\r\n   * @name Phaser.Textures.Frame#realWidth\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  realWidth: {\n    get: function () {\n      return this.data.sourceSize.w;\n    }\n  },\n\n  /**\r\n   * The height of the Frame in its un-trimmed, un-padded state, as prepared in the art package,\r\n   * before being packed.\r\n   *\r\n   * @name Phaser.Textures.Frame#realHeight\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  realHeight: {\n    get: function () {\n      return this.data.sourceSize.h;\n    }\n  },\n\n  /**\r\n   * The radius of the Frame (derived from sqrt(w * w + h * h) / 2)\r\n   *\r\n   * @name Phaser.Textures.Frame#radius\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  radius: {\n    get: function () {\n      return this.data.radius;\n    }\n  },\n\n  /**\r\n   * Is the Frame trimmed or not?\r\n   *\r\n   * @name Phaser.Textures.Frame#trimmed\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  trimmed: {\n    get: function () {\n      return this.data.trim;\n    }\n  },\n\n  /**\r\n   * The Canvas drawImage data object.\r\n   *\r\n   * @name Phaser.Textures.Frame#canvasData\r\n   * @type {object}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  canvasData: {\n    get: function () {\n      return this.data.drawImage;\n    }\n  }\n});\nmodule.exports = Frame;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/textures/Frame.js"],"names":["Class","require","Clamp","Extend","Frame","initialize","texture","name","sourceIndex","x","y","width","height","source","glTexture","cutX","cutY","cutWidth","cutHeight","halfWidth","halfHeight","centerX","centerY","pivotX","pivotY","customPivot","rotated","autoRound","customData","u0","v0","u1","v1","data","cut","w","h","r","b","trim","sourceSize","spriteSourceSize","radius","drawImage","setSize","undefined","Math","floor","sqrt","updateUVs","setTrim","actualWidth","actualHeight","destX","destY","destWidth","destHeight","ss","setCropUVs","crop","flipX","flipY","cx","cy","cw","ch","rw","realWidth","rh","realHeight","ox","oy","ow","oh","cropRight","cropBottom","intersects","ix","max","iy","iw","min","ih","tw","th","updateCropUVs","cd","updateUVsInverted","clone","destroy","get","trimmed","canvasData","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar Clamp = require('../math/Clamp');\r\nvar Extend = require('../utils/object/Extend');\r\n\r\n/**\r\n * @classdesc\r\n * A Frame is a section of a Texture.\r\n *\r\n * @class Frame\r\n * @memberof Phaser.Textures\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture this Frame is a part of.\r\n * @param {(integer|string)} name - The name of this Frame. The name is unique within the Texture.\r\n * @param {integer} sourceIndex - The index of the TextureSource that this Frame is a part of.\r\n * @param {number} x - The x coordinate of the top-left of this Frame.\r\n * @param {number} y - The y coordinate of the top-left of this Frame.\r\n * @param {number} width - The width of this Frame.\r\n * @param {number} height - The height of this Frame.\r\n */\r\nvar Frame = new Class({\r\n\r\n    initialize:\r\n\r\n    function Frame (texture, name, sourceIndex, x, y, width, height)\r\n    {\r\n        /**\r\n         * The Texture this Frame is a part of.\r\n         *\r\n         * @name Phaser.Textures.Frame#texture\r\n         * @type {Phaser.Textures.Texture}\r\n         * @since 3.0.0\r\n         */\r\n        this.texture = texture;\r\n\r\n        /**\r\n         * The name of this Frame.\r\n         * The name is unique within the Texture.\r\n         *\r\n         * @name Phaser.Textures.Frame#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = name;\r\n\r\n        /**\r\n         * The TextureSource this Frame is part of.\r\n         *\r\n         * @name Phaser.Textures.Frame#source\r\n         * @type {Phaser.Textures.TextureSource}\r\n         * @since 3.0.0\r\n         */\r\n        this.source = texture.source[sourceIndex];\r\n\r\n        /**\r\n         * The index of the TextureSource in the Texture sources array.\r\n         *\r\n         * @name Phaser.Textures.Frame#sourceIndex\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.sourceIndex = sourceIndex;\r\n\r\n        /**\r\n         * A reference to the Texture Source WebGL Texture that this Frame is using.\r\n         *\r\n         * @name Phaser.Textures.Frame#glTexture\r\n         * @type {?WebGLTexture}\r\n         * @default null\r\n         * @since 3.11.0\r\n         */\r\n        this.glTexture = this.source.glTexture;\r\n\r\n        /**\r\n         * X position within the source image to cut from.\r\n         *\r\n         * @name Phaser.Textures.Frame#cutX\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.cutX;\r\n\r\n        /**\r\n         * Y position within the source image to cut from.\r\n         *\r\n         * @name Phaser.Textures.Frame#cutY\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.cutY;\r\n\r\n        /**\r\n         * The width of the area in the source image to cut.\r\n         *\r\n         * @name Phaser.Textures.Frame#cutWidth\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.cutWidth;\r\n\r\n        /**\r\n         * The height of the area in the source image to cut.\r\n         *\r\n         * @name Phaser.Textures.Frame#cutHeight\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.cutHeight;\r\n\r\n        /**\r\n         * The X rendering offset of this Frame, taking trim into account.\r\n         *\r\n         * @name Phaser.Textures.Frame#x\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = 0;\r\n\r\n        /**\r\n         * The Y rendering offset of this Frame, taking trim into account.\r\n         *\r\n         * @name Phaser.Textures.Frame#y\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = 0;\r\n\r\n        /**\r\n         * The rendering width of this Frame, taking trim into account.\r\n         *\r\n         * @name Phaser.Textures.Frame#width\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.width;\r\n\r\n        /**\r\n         * The rendering height of this Frame, taking trim into account.\r\n         *\r\n         * @name Phaser.Textures.Frame#height\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.height;\r\n\r\n        /**\r\n         * Half the width, floored.\r\n         * Precalculated for the renderer.\r\n         *\r\n         * @name Phaser.Textures.Frame#halfWidth\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.halfWidth;\r\n\r\n        /**\r\n         * Half the height, floored.\r\n         * Precalculated for the renderer.\r\n         *\r\n         * @name Phaser.Textures.Frame#halfHeight\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.halfHeight;\r\n\r\n        /**\r\n         * The x center of this frame, floored.\r\n         *\r\n         * @name Phaser.Textures.Frame#centerX\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.centerX;\r\n\r\n        /**\r\n         * The y center of this frame, floored.\r\n         *\r\n         * @name Phaser.Textures.Frame#centerY\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.centerY;\r\n\r\n        /**\r\n         * The horizontal pivot point of this Frame.\r\n         *\r\n         * @name Phaser.Textures.Frame#pivotX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.pivotX = 0;\r\n\r\n        /**\r\n         * The vertical pivot point of this Frame.\r\n         *\r\n         * @name Phaser.Textures.Frame#pivotY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.pivotY = 0;\r\n\r\n        /**\r\n         * Does this Frame have a custom pivot point?\r\n         *\r\n         * @name Phaser.Textures.Frame#customPivot\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.customPivot = false;\r\n\r\n        /**\r\n         * **CURRENTLY UNSUPPORTED**\r\n         *\r\n         * Is this frame is rotated or not in the Texture?\r\n         * Rotation allows you to use rotated frames in texture atlas packing.\r\n         * It has nothing to do with Sprite rotation.\r\n         *\r\n         * @name Phaser.Textures.Frame#rotated\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.rotated = false;\r\n\r\n        /**\r\n         * Over-rides the Renderer setting.\r\n         * -1 = use Renderer Setting\r\n         * 0 = No rounding\r\n         * 1 = Round\r\n         *\r\n         * @name Phaser.Textures.Frame#autoRound\r\n         * @type {integer}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.autoRound = -1;\r\n\r\n        /**\r\n         * Any Frame specific custom data can be stored here.\r\n         *\r\n         * @name Phaser.Textures.Frame#customData\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.customData = {};\r\n\r\n        /**\r\n         * WebGL UV u0 value.\r\n         *\r\n         * @name Phaser.Textures.Frame#u0\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.11.0\r\n         */\r\n        this.u0 = 0;\r\n\r\n        /**\r\n         * WebGL UV v0 value.\r\n         *\r\n         * @name Phaser.Textures.Frame#v0\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.11.0\r\n         */\r\n        this.v0 = 0;\r\n\r\n        /**\r\n         * WebGL UV u1 value.\r\n         *\r\n         * @name Phaser.Textures.Frame#u1\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.11.0\r\n         */\r\n        this.u1 = 0;\r\n\r\n        /**\r\n         * WebGL UV v1 value.\r\n         *\r\n         * @name Phaser.Textures.Frame#v1\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.11.0\r\n         */\r\n        this.v1 = 0;\r\n\r\n        /**\r\n         * The un-modified source frame, trim and UV data.\r\n         *\r\n         * @name Phaser.Textures.Frame#data\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.data = {\r\n            cut: {\r\n                x: 0,\r\n                y: 0,\r\n                w: 0,\r\n                h: 0,\r\n                r: 0,\r\n                b: 0\r\n            },\r\n            trim: false,\r\n            sourceSize: {\r\n                w: 0,\r\n                h: 0\r\n            },\r\n            spriteSourceSize: {\r\n                x: 0,\r\n                y: 0,\r\n                w: 0,\r\n                h: 0,\r\n                r: 0,\r\n                b: 0\r\n            },\r\n            radius: 0,\r\n            drawImage: {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            }\r\n        };\r\n\r\n        this.setSize(width, height, x, y);\r\n    },\r\n\r\n    /**\r\n     * Sets the width, height, x and y of this Frame.\r\n     * \r\n     * This is called automatically by the constructor\r\n     * and should rarely be changed on-the-fly.\r\n     *\r\n     * @method Phaser.Textures.Frame#setSize\r\n     * @since 3.7.0\r\n     *\r\n     * @param {integer} width - The width of the frame before being trimmed.\r\n     * @param {integer} height - The height of the frame before being trimmed.\r\n     * @param {integer} [x=0] - The x coordinate of the top-left of this Frame.\r\n     * @param {integer} [y=0] - The y coordinate of the top-left of this Frame.\r\n     *\r\n     * @return {Phaser.Textures.Frame} This Frame object.\r\n     */\r\n    setSize: function (width, height, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        this.cutX = x;\r\n        this.cutY = y;\r\n        this.cutWidth = width;\r\n        this.cutHeight = height;\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.halfWidth = Math.floor(width * 0.5);\r\n        this.halfHeight = Math.floor(height * 0.5);\r\n\r\n        this.centerX = Math.floor(width / 2);\r\n        this.centerY = Math.floor(height / 2);\r\n\r\n        var data = this.data;\r\n        var cut = data.cut;\r\n\r\n        cut.x = x;\r\n        cut.y = y;\r\n        cut.w = width;\r\n        cut.h = height;\r\n        cut.r = x + width;\r\n        cut.b = y + height;\r\n\r\n        data.sourceSize.w = width;\r\n        data.sourceSize.h = height;\r\n\r\n        data.spriteSourceSize.w = width;\r\n        data.spriteSourceSize.h = height;\r\n\r\n        data.radius = 0.5 * Math.sqrt(width * width + height * height);\r\n\r\n        var drawImage = data.drawImage;\r\n\r\n        drawImage.x = x;\r\n        drawImage.y = y;\r\n        drawImage.width = width;\r\n        drawImage.height = height;\r\n\r\n        return this.updateUVs();\r\n    },\r\n\r\n    /**\r\n     * If the frame was trimmed when added to the Texture Atlas, this records the trim and source data.\r\n     *\r\n     * @method Phaser.Textures.Frame#setTrim\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} actualWidth - The width of the frame before being trimmed.\r\n     * @param {number} actualHeight - The height of the frame before being trimmed.\r\n     * @param {number} destX - The destination X position of the trimmed frame for display.\r\n     * @param {number} destY - The destination Y position of the trimmed frame for display.\r\n     * @param {number} destWidth - The destination width of the trimmed frame for display.\r\n     * @param {number} destHeight - The destination height of the trimmed frame for display.\r\n     *\r\n     * @return {Phaser.Textures.Frame} This Frame object.\r\n     */\r\n    setTrim: function (actualWidth, actualHeight, destX, destY, destWidth, destHeight)\r\n    {\r\n        var data = this.data;\r\n        var ss = data.spriteSourceSize;\r\n\r\n        //  Store actual values\r\n\r\n        data.trim = true;\r\n\r\n        data.sourceSize.w = actualWidth;\r\n        data.sourceSize.h = actualHeight;\r\n\r\n        ss.x = destX;\r\n        ss.y = destY;\r\n        ss.w = destWidth;\r\n        ss.h = destHeight;\r\n        ss.r = destX + destWidth;\r\n        ss.b = destY + destHeight;\r\n\r\n        //  Adjust properties\r\n        this.x = destX;\r\n        this.y = destY;\r\n\r\n        this.width = destWidth;\r\n        this.height = destHeight;\r\n\r\n        this.halfWidth = destWidth * 0.5;\r\n        this.halfHeight = destHeight * 0.5;\r\n\r\n        this.centerX = Math.floor(destWidth / 2);\r\n        this.centerY = Math.floor(destHeight / 2);\r\n\r\n        return this.updateUVs();\r\n    },\r\n\r\n    /**\r\n     * Takes a crop data object and, based on the rectangular region given, calculates the\r\n     * required UV coordinates in order to crop this Frame for WebGL and Canvas rendering.\r\n     * \r\n     * This is called directly by the Game Object Texture Components `setCrop` method.\r\n     * Please use that method to crop a Game Object.\r\n     *\r\n     * @method Phaser.Textures.Frame#setCropUVs\r\n     * @since 3.11.0\r\n     * \r\n     * @param {object} crop - The crop data object. This is the `GameObject._crop` property.\r\n     * @param {number} x - The x coordinate to start the crop from. Cannot be negative or exceed the Frame width.\r\n     * @param {number} y - The y coordinate to start the crop from. Cannot be negative or exceed the Frame height.\r\n     * @param {number} width - The width of the crop rectangle. Cannot exceed the Frame width.\r\n     * @param {number} height - The height of the crop rectangle. Cannot exceed the Frame height.\r\n     * @param {boolean} flipX - Does the parent Game Object have flipX set?\r\n     * @param {boolean} flipY - Does the parent Game Object have flipY set?\r\n     *\r\n     * @return {object} The updated crop data object.\r\n     */\r\n    setCropUVs: function (crop, x, y, width, height, flipX, flipY)\r\n    {\r\n        //  Clamp the input values\r\n\r\n        var cx = this.cutX;\r\n        var cy = this.cutY;\r\n        var cw = this.cutWidth;\r\n        var ch = this.cutHeight;\r\n        var rw = this.realWidth;\r\n        var rh = this.realHeight;\r\n\r\n        x = Clamp(x, 0, rw);\r\n        y = Clamp(y, 0, rh);\r\n\r\n        width = Clamp(width, 0, rw - x);\r\n        height = Clamp(height, 0, rh - y);\r\n\r\n        var ox = cx + x;\r\n        var oy = cy + y;\r\n        var ow = width;\r\n        var oh = height;\r\n\r\n        var data = this.data;\r\n\r\n        if (data.trim)\r\n        {\r\n            var ss = data.spriteSourceSize;\r\n\r\n            //  Need to check for intersection between the cut area and the crop area\r\n            //  If there is none, we set UV to be empty, otherwise set it to be the intersection area\r\n\r\n            width = Clamp(width, 0, cw - x);\r\n            height = Clamp(height, 0, ch - y);\r\n    \r\n            var cropRight = x + width;\r\n            var cropBottom = y + height;\r\n\r\n            var intersects = !(ss.r < x || ss.b < y || ss.x > cropRight || ss.y > cropBottom);\r\n\r\n            if (intersects)\r\n            {\r\n                var ix = Math.max(ss.x, x);\r\n                var iy = Math.max(ss.y, y);\r\n                var iw = Math.min(ss.r, cropRight) - ix;\r\n                var ih = Math.min(ss.b, cropBottom) - iy;\r\n\r\n                ow = iw;\r\n                oh = ih;\r\n    \r\n                if (flipX)\r\n                {\r\n                    ox = cx + (cw - (ix - ss.x) - iw);\r\n                }\r\n                else\r\n                {\r\n                    ox = cx + (ix - ss.x);\r\n                }\r\n        \r\n                if (flipY)\r\n                {\r\n                    oy = cy + (ch - (iy - ss.y) - ih);\r\n                }\r\n                else\r\n                {\r\n                    oy = cy + (iy - ss.y);\r\n                }\r\n\r\n                x = ix;\r\n                y = iy;\r\n\r\n                width = iw;\r\n                height = ih;\r\n            }\r\n            else\r\n            {\r\n                ox = 0;\r\n                oy = 0;\r\n                ow = 0;\r\n                oh = 0;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if (flipX)\r\n            {\r\n                ox = cx + (cw - x - width);\r\n            }\r\n    \r\n            if (flipY)\r\n            {\r\n                oy = cy + (ch - y - height);\r\n            }\r\n        }\r\n\r\n        var tw = this.source.width;\r\n        var th = this.source.height;\r\n\r\n        //  Map the given coordinates into UV space, clamping to the 0-1 range.\r\n\r\n        crop.u0 = Math.max(0, ox / tw);\r\n        crop.v0 = Math.max(0, oy / th);\r\n        crop.u1 = Math.min(1, (ox + ow) / tw);\r\n        crop.v1 = Math.min(1, (oy + oh) / th);\r\n\r\n        crop.x = x;\r\n        crop.y = y;\r\n\r\n        crop.cx = ox;\r\n        crop.cy = oy;\r\n        crop.cw = ow;\r\n        crop.ch = oh;\r\n\r\n        crop.width = width;\r\n        crop.height = height;\r\n\r\n        crop.flipX = flipX;\r\n        crop.flipY = flipY;\r\n\r\n        return crop;\r\n    },\r\n\r\n    /**\r\n     * Takes a crop data object and recalculates the UVs based on the dimensions inside the crop object.\r\n     * Called automatically by `setFrame`.\r\n     *\r\n     * @method Phaser.Textures.Frame#updateCropUVs\r\n     * @since 3.11.0\r\n     * \r\n     * @param {object} crop - The crop data object. This is the `GameObject._crop` property.\r\n     * @param {boolean} flipX - Does the parent Game Object have flipX set?\r\n     * @param {boolean} flipY - Does the parent Game Object have flipY set?\r\n     *\r\n     * @return {object} The updated crop data object.\r\n     */\r\n    updateCropUVs: function (crop, flipX, flipY)\r\n    {\r\n        return this.setCropUVs(crop, crop.x, crop.y, crop.width, crop.height, flipX, flipY);\r\n    },\r\n\r\n    /**\r\n     * Updates the internal WebGL UV cache and the drawImage cache.\r\n     *\r\n     * @method Phaser.Textures.Frame#updateUVs\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Textures.Frame} This Frame object.\r\n     */\r\n    updateUVs: function ()\r\n    {\r\n        var cx = this.cutX;\r\n        var cy = this.cutY;\r\n        var cw = this.cutWidth;\r\n        var ch = this.cutHeight;\r\n\r\n        //  Canvas data\r\n\r\n        var cd = this.data.drawImage;\r\n\r\n        cd.width = cw;\r\n        cd.height = ch;\r\n\r\n        //  WebGL data\r\n\r\n        var tw = this.source.width;\r\n        var th = this.source.height;\r\n\r\n        this.u0 = cx / tw;\r\n        this.v0 = cy / th;\r\n\r\n        this.u1 = (cx + cw) / tw;\r\n        this.v1 = (cy + ch) / th;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Updates the internal WebGL UV cache.\r\n     *\r\n     * @method Phaser.Textures.Frame#updateUVsInverted\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Textures.Frame} This Frame object.\r\n     */\r\n    updateUVsInverted: function ()\r\n    {\r\n        var tw = this.source.width;\r\n        var th = this.source.height;\r\n\r\n        this.u0 = (this.cutX + this.cutHeight) / tw;\r\n        this.v0 = this.cutY / th;\r\n\r\n        this.u1 = this.cutX / tw;\r\n        this.v1 = (this.cutY + this.cutWidth) / th;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clones this Frame into a new Frame object.\r\n     *\r\n     * @method Phaser.Textures.Frame#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Textures.Frame} A clone of this Frame.\r\n     */\r\n    clone: function ()\r\n    {\r\n        var clone = new Frame(this.texture, this.name, this.sourceIndex);\r\n\r\n        clone.cutX = this.cutX;\r\n        clone.cutY = this.cutY;\r\n        clone.cutWidth = this.cutWidth;\r\n        clone.cutHeight = this.cutHeight;\r\n\r\n        clone.x = this.x;\r\n        clone.y = this.y;\r\n\r\n        clone.width = this.width;\r\n        clone.height = this.height;\r\n\r\n        clone.halfWidth = this.halfWidth;\r\n        clone.halfHeight = this.halfHeight;\r\n\r\n        clone.centerX = this.centerX;\r\n        clone.centerY = this.centerY;\r\n\r\n        clone.rotated = this.rotated;\r\n\r\n        clone.data = Extend(true, clone.data, this.data);\r\n\r\n        clone.updateUVs();\r\n\r\n        return clone;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Frame by nulling its reference to the parent Texture and and data objects.\r\n     *\r\n     * @method Phaser.Textures.Frame#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.source = null;\r\n        this.texture = null;\r\n        this.glTexture = null;\r\n        this.customData = null;\r\n        this.data = null;\r\n    },\r\n\r\n    /**\r\n     * The width of the Frame in its un-trimmed, un-padded state, as prepared in the art package,\r\n     * before being packed.\r\n     *\r\n     * @name Phaser.Textures.Frame#realWidth\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    realWidth: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.data.sourceSize.w;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The height of the Frame in its un-trimmed, un-padded state, as prepared in the art package,\r\n     * before being packed.\r\n     *\r\n     * @name Phaser.Textures.Frame#realHeight\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    realHeight: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.data.sourceSize.h;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The radius of the Frame (derived from sqrt(w * w + h * h) / 2)\r\n     *\r\n     * @name Phaser.Textures.Frame#radius\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    radius: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.data.radius;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Frame trimmed or not?\r\n     *\r\n     * @name Phaser.Textures.Frame#trimmed\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    trimmed: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.data.trim;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Canvas drawImage data object.\r\n     *\r\n     * @name Phaser.Textures.Frame#canvasData\r\n     * @type {object}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    canvasData: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.data.drawImage;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Frame;\r\n"]},"metadata":{},"sourceType":"script"}