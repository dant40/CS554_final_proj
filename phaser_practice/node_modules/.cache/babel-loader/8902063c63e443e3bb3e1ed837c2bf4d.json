{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\n\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Extern#renderWebGL\r\n * @since 3.16.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Extern} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\nvar ExternWebGLRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix) {\n  var pipeline = renderer.currentPipeline;\n  renderer.clearPipeline();\n  var camMatrix = renderer._tempMatrix1;\n  var spriteMatrix = renderer._tempMatrix2;\n  var calcMatrix = renderer._tempMatrix3;\n  spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\n  camMatrix.copyFrom(camera.matrix);\n\n  if (parentMatrix) {\n    //  Multiply the camera by the parent matrix\n    camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY); //  Undo the camera scroll\n\n    spriteMatrix.e = src.x;\n    spriteMatrix.f = src.y; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n    camMatrix.multiply(spriteMatrix, calcMatrix);\n  } else {\n    spriteMatrix.e -= camera.scrollX * src.scrollFactorX;\n    spriteMatrix.f -= camera.scrollY * src.scrollFactorY; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n    camMatrix.multiply(spriteMatrix, calcMatrix);\n  } //  Callback\n\n\n  src.render.call(src, renderer, camera, calcMatrix);\n  renderer.rebindPipeline(pipeline);\n};\n\nmodule.exports = ExternWebGLRenderer;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/extern/ExternWebGLRenderer.js"],"names":["ExternWebGLRenderer","renderer","src","interpolationPercentage","camera","parentMatrix","pipeline","currentPipeline","clearPipeline","camMatrix","_tempMatrix1","spriteMatrix","_tempMatrix2","calcMatrix","_tempMatrix3","applyITRS","x","y","rotation","scaleX","scaleY","copyFrom","matrix","multiplyWithOffset","scrollX","scrollFactorX","scrollY","scrollFactorY","e","f","multiply","render","call","rebindPipeline","module","exports"],"mappings":"AAAA;;;;;;AAMA;;;;;;;;;;;;;;;AAeA,IAAIA,mBAAmB,GAAG,UAAUC,QAAV,EAAoBC,GAApB,EAAyBC,uBAAzB,EAAkDC,MAAlD,EAA0DC,YAA1D,EAC1B;AACI,MAAIC,QAAQ,GAAGL,QAAQ,CAACM,eAAxB;AAEAN,EAAAA,QAAQ,CAACO,aAAT;AAEA,MAAIC,SAAS,GAAGR,QAAQ,CAACS,YAAzB;AACA,MAAIC,YAAY,GAAGV,QAAQ,CAACW,YAA5B;AACA,MAAIC,UAAU,GAAGZ,QAAQ,CAACa,YAA1B;AAEAH,EAAAA,YAAY,CAACI,SAAb,CAAuBb,GAAG,CAACc,CAA3B,EAA8Bd,GAAG,CAACe,CAAlC,EAAqCf,GAAG,CAACgB,QAAzC,EAAmDhB,GAAG,CAACiB,MAAvD,EAA+DjB,GAAG,CAACkB,MAAnE;AAEAX,EAAAA,SAAS,CAACY,QAAV,CAAmBjB,MAAM,CAACkB,MAA1B;;AAEA,MAAIjB,YAAJ,EACA;AACI;AACAI,IAAAA,SAAS,CAACc,kBAAV,CAA6BlB,YAA7B,EAA2C,CAACD,MAAM,CAACoB,OAAR,GAAkBtB,GAAG,CAACuB,aAAjE,EAAgF,CAACrB,MAAM,CAACsB,OAAR,GAAkBxB,GAAG,CAACyB,aAAtG,EAFJ,CAII;;AACAhB,IAAAA,YAAY,CAACiB,CAAb,GAAiB1B,GAAG,CAACc,CAArB;AACAL,IAAAA,YAAY,CAACkB,CAAb,GAAiB3B,GAAG,CAACe,CAArB,CANJ,CAQI;;AACAR,IAAAA,SAAS,CAACqB,QAAV,CAAmBnB,YAAnB,EAAiCE,UAAjC;AACH,GAXD,MAaA;AACIF,IAAAA,YAAY,CAACiB,CAAb,IAAkBxB,MAAM,CAACoB,OAAP,GAAiBtB,GAAG,CAACuB,aAAvC;AACAd,IAAAA,YAAY,CAACkB,CAAb,IAAkBzB,MAAM,CAACsB,OAAP,GAAiBxB,GAAG,CAACyB,aAAvC,CAFJ,CAII;;AACAlB,IAAAA,SAAS,CAACqB,QAAV,CAAmBnB,YAAnB,EAAiCE,UAAjC;AACH,GAhCL,CAkCI;;;AACAX,EAAAA,GAAG,CAAC6B,MAAJ,CAAWC,IAAX,CAAgB9B,GAAhB,EAAqBD,QAArB,EAA+BG,MAA/B,EAAuCS,UAAvC;AAEAZ,EAAAA,QAAQ,CAACgC,cAAT,CAAwB3B,QAAxB;AACH,CAvCD;;AAyCA4B,MAAM,CAACC,OAAP,GAAiBnC,mBAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Extern#renderWebGL\r\n * @since 3.16.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Extern} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ExternWebGLRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix)\r\n{\r\n    var pipeline = renderer.currentPipeline;\r\n\r\n    renderer.clearPipeline();\r\n\r\n    var camMatrix = renderer._tempMatrix1;\r\n    var spriteMatrix = renderer._tempMatrix2;\r\n    var calcMatrix = renderer._tempMatrix3;\r\n\r\n    spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\r\n\r\n    camMatrix.copyFrom(camera.matrix);\r\n\r\n    if (parentMatrix)\r\n    {\r\n        //  Multiply the camera by the parent matrix\r\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n\r\n        //  Undo the camera scroll\r\n        spriteMatrix.e = src.x;\r\n        spriteMatrix.f = src.y;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(spriteMatrix, calcMatrix);\r\n    }\r\n    else\r\n    {\r\n        spriteMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n        spriteMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(spriteMatrix, calcMatrix);\r\n    }\r\n\r\n    //  Callback\r\n    src.render.call(src, renderer, camera, calcMatrix);\r\n\r\n    renderer.rebindPipeline(pipeline);\r\n};\r\n\r\nmodule.exports = ExternWebGLRenderer;\r\n"]},"metadata":{},"sourceType":"script"}