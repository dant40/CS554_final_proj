{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar Clamp = require('../../math/Clamp');\n\nvar Components = require('../components');\n\nvar Events = require('../events');\n\nvar GameEvents = require('../../core/events/');\n\nvar GameObject = require('../GameObject');\n\nvar SoundEvents = require('../../sound/events/');\n\nvar UUID = require('../../utils/string/UUID');\n\nvar VideoRender = require('./VideoRender');\n\nvar MATH_CONST = require('../../math/const');\n/**\r\n * @classdesc\r\n * A Video Game Object.\r\n * \r\n * This Game Object is capable of handling playback of a previously loaded video from the Phaser Video Cache,\r\n * or playing a video based on a given URL. Videos can be either local, or streamed.\r\n * \r\n * ```javascript\r\n * preload () {\r\n *   this.load.video('pixar', 'nemo.mp4');\r\n * }\r\n * \r\n * create () {\r\n *   this.add.video(400, 300, 'pixar');\r\n * }\r\n * ```\r\n * \r\n * To all intents and purposes, a video is a standard Game Object, just like a Sprite. And as such, you can do\r\n * all the usual things to it, such as scaling, rotating, cropping, tinting, making interactive, giving a\r\n * physics body, etc.\r\n * \r\n * Transparent videos are also possible via the WebM file format. Providing the video file has was encoded with\r\n * an alpha channel, and providing the browser supports WebM playback (not all of them do), then it will render\r\n * in-game with full transparency.\r\n * \r\n * ### Autoplaying Videos\r\n * \r\n * Videos can only autoplay if the browser has been unlocked with an interaction, or satisfies the MEI settings.\r\n * The policies that control autoplaying are vast and vary between browser.\r\n * You can, ahd should, read more about it here: https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide\r\n * \r\n * If your video doesn't contain any audio, then set the `noAudio` parameter to `true` when the video is _loaded_,\r\n * and it will often allow the video to play immediately:\r\n * \r\n * ```javascript\r\n * preload () {\r\n *   this.load.video('pixar', 'nemo.mp4', 'loadeddata', false, true);\r\n * }\r\n * ```\r\n * \r\n * The 5th parameter in the load call tells Phaser that the video doesn't contain any audio tracks. Video without\r\n * audio can autoplay without requiring a user interaction. Video with audio cannot do this unless it satisfies\r\n * the browsers MEI settings. See the MDN Autoplay Guide for further details.\r\n * \r\n * Note that due to a bug in IE11 you cannot play a video texture to a Sprite in WebGL. For IE11 force Canvas mode.\r\n * \r\n * More details about video playback and the supported media formats can be found on MDN:\r\n * \r\n * https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement\r\n * https://developer.mozilla.org/en-US/docs/Web/Media/Formats\r\n *\r\n * @class Video\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.20.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.TextureCrop\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} [key] - Optional key of the Video this Game Object will play, as stored in the Video Cache.\r\n */\n\n\nvar Video = new Class({\n  Extends: GameObject,\n  Mixins: [Components.Alpha, Components.BlendMode, Components.Depth, Components.Flip, Components.GetBounds, Components.Mask, Components.Origin, Components.Pipeline, Components.ScrollFactor, Components.Size, Components.TextureCrop, Components.Tint, Components.Transform, Components.Visible, VideoRender],\n  initialize: function Video(scene, x, y, key) {\n    GameObject.call(this, scene, 'Video');\n    /**\r\n     * A reference to the HTML Video Element this Video Game Object is playing.\r\n     * Will be `null` until a video is loaded for playback.\r\n     *\r\n     * @name Phaser.GameObjects.Video#video\r\n     * @type {?HTMLVideoElement}\r\n     * @since 3.20.0\r\n     */\n\n    this.video = null;\n    /**\r\n     * The Phaser Texture this Game Object is using to render the video to.\r\n     * Will be `null` until a video is loaded for playback.\r\n     *\r\n     * @name Phaser.GameObjects.Video#videoTexture\r\n     * @type {?Phaser.Textures.Texture}\r\n     * @since 3.20.0\r\n     */\n\n    this.videoTexture = null;\n    /**\r\n     * A reference to the TextureSource belong to the `videoTexture` Texture object.\r\n     * Will be `null` until a video is loaded for playback.\r\n     *\r\n     * @name Phaser.GameObjects.Video#videoTextureSource\r\n     * @type {?Phaser.Textures.TextureSource}\r\n     * @since 3.20.0\r\n     */\n\n    this.videoTextureSource = null;\n    /**\r\n     * A Phaser CanvasTexture instance that holds the most recent snapshot taken from the video.\r\n     * This will only be set if `snapshot` or `snapshotArea` have been called, and will be `null` until that point.\r\n     *\r\n     * @name Phaser.GameObjects.Video#snapshotTexture\r\n     * @type {?Phaser.Textures.CanvasTexture}\r\n     * @since 3.20.0\r\n     */\n\n    this.snapshotTexture = null;\n    /**\r\n     * If you have saved this video to a texture via the `saveTexture` method, this controls if the video\r\n     * is rendered with `flipY` in WebGL or not. You often need to set this if you wish to use the video texture\r\n     * as the input source for a shader. If you find your video is appearing upside down within a shader or\r\n     * custom pipeline, flip this property.\r\n     *\r\n     * @name Phaser.GameObjects.Video#flipY\r\n     * @type {boolean}\r\n     * @since 3.20.0\r\n     */\n\n    this.flipY = false;\n    /**\r\n     * The key used by the texture as stored in the Texture Manager.\r\n     *\r\n     * @name Phaser.GameObjects.Video#_key\r\n     * @type {string}\r\n     * @private\r\n     * @since 3.20.0\r\n     */\n\n    this._key = UUID();\n    /**\r\n     * An internal flag holding the current state of the video lock, should document interaction be required\r\n     * before playback can begin.\r\n     *\r\n     * @name Phaser.GameObjects.Video#touchLocked\r\n     * @type {boolean}\r\n     * @since 3.20.0\r\n     */\n\n    this.touchLocked = true;\n    /**\r\n     * Should the video auto play when document interaction is required and happens?\r\n     *\r\n     * @name Phaser.GameObjects.Video#playWhenUnlocked\r\n     * @type {boolean}\r\n     * @since 3.20.0\r\n     */\n\n    this.playWhenUnlocked = false;\n    /**\r\n     * When starting playback of a video Phaser will monitor its `readyState` using a `setTimeout` call.\r\n     * The `setTimeout` happens once every `Video.retryInterval` ms. It will carry on monitoring the video\r\n     * state in this manner until the `retryLimit` is reached and then abort.\r\n     *\r\n     * @name Phaser.GameObjects.Video#retryLimit\r\n     * @type {integer}\r\n     * @since 3.20.0\r\n     */\n\n    this.retryLimit = 20;\n    /**\r\n     * The current retry attempt.\r\n     *\r\n     * @name Phaser.GameObjects.Video#retry\r\n     * @type {integer}\r\n     * @since 3.20.0\r\n     */\n\n    this.retry = 0;\n    /**\r\n     * The number of ms between each retry while monitoring the ready state of a downloading video.\r\n     *\r\n     * @name Phaser.GameObjects.Video#retryInterval\r\n     * @type {integer}\r\n     * @since 3.20.0\r\n     */\n\n    this.retryInterval = 500;\n    /**\r\n     * The setTimeout callback ID.\r\n     *\r\n     * @name Phaser.GameObjects.Video#_retryID\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.20.0\r\n     */\n\n    this._retryID = null;\n    /**\r\n     * The video was muted due to a system event, such as the game losing focus.\r\n     *\r\n     * @name Phaser.GameObjects.Video#_systemMuted\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.20.0\r\n     */\n\n    this._systemMuted = false;\n    /**\r\n     * The video was muted due to game code, not a system event.\r\n     *\r\n     * @name Phaser.GameObjects.Video#_codeMuted\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.20.0\r\n     */\n\n    this._codeMuted = false;\n    /**\r\n     * The video was paused due to a system event, such as the game losing focus.\r\n     *\r\n     * @name Phaser.GameObjects.Video#_systemPaused\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.20.0\r\n     */\n\n    this._systemPaused = false;\n    /**\r\n     * The video was paused due to game code, not a system event.\r\n     *\r\n     * @name Phaser.GameObjects.Video#_codePaused\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.20.0\r\n     */\n\n    this._codePaused = false;\n    /**\r\n     * The locally bound event callback handlers.\r\n     *\r\n     * @name Phaser.GameObjects.Video#_callbacks\r\n     * @type {any}\r\n     * @private\r\n     * @since 3.20.0\r\n     */\n\n    this._callbacks = {\n      play: this.playHandler.bind(this),\n      error: this.loadErrorHandler.bind(this),\n      end: this.completeHandler.bind(this),\n      time: this.timeUpdateHandler.bind(this),\n      seeking: this.seekingHandler.bind(this),\n      seeked: this.seekedHandler.bind(this)\n    };\n    /**\r\n     * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n     *\r\n     * @name Phaser.GameObjects.Video#_crop\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.20.0\r\n     */\n\n    this._crop = this.resetCropObject();\n    /**\r\n     * An object containing in and out markers for sequence playback.\r\n     *\r\n     * @name Phaser.GameObjects.Video#markers\r\n     * @type {any}\r\n     * @since 3.20.0\r\n     */\n\n    this.markers = {};\n    /**\r\n     * The in marker.\r\n     *\r\n     * @name Phaser.GameObjects.Video#_markerIn\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.20.0\r\n     */\n\n    this._markerIn = -1;\n    /**\r\n     * The out marker.\r\n     *\r\n     * @name Phaser.GameObjects.Video#_markerOut\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.20.0\r\n     */\n\n    this._markerOut = MATH_CONST.MAX_SAFE_INTEGER;\n    /**\r\n     * The last time the TextureSource was updated.\r\n     *\r\n     * @name Phaser.GameObjects.Video#_lastUpdate\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.20.0\r\n     */\n\n    this._lastUpdate = 0;\n    /**\r\n     * The key of the video being played from the Video cache, if any.\r\n     *\r\n     * @name Phaser.GameObjects.Video#_cacheKey\r\n     * @type {string}\r\n     * @private\r\n     * @since 3.20.0\r\n     */\n\n    this._cacheKey = '';\n    /**\r\n     * Is the video currently seeking?\r\n     *\r\n     * @name Phaser.GameObjects.Video#_isSeeking\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.20.0\r\n     */\n\n    this._isSeeking = false;\n    /**\r\n     * Should the Video element that this Video is using, be removed from the DOM\r\n     * when this Video is destroyed?\r\n     *\r\n     * @name Phaser.GameObjects.Video#removeVideoElementOnDestroy\r\n     * @type {boolean}\r\n     * @since 3.21.0\r\n     */\n\n    this.removeVideoElementOnDestroy = false;\n    this.setPosition(x, y);\n    this.initPipeline();\n\n    if (key) {\n      this.changeSource(key, false);\n    }\n\n    var game = scene.sys.game.events;\n    game.on(GameEvents.PAUSE, this.globalPause, this);\n    game.on(GameEvents.RESUME, this.globalResume, this);\n    var sound = scene.sys.sound;\n\n    if (sound) {\n      sound.on(SoundEvents.GLOBAL_MUTE, this.globalMute, this);\n    }\n  },\n\n  /**\r\n   * Starts this video playing.\r\n   *\r\n   * If the video is already playing, or has been queued to play with `changeSource` then this method just returns.\r\n   * \r\n   * Videos can only autoplay if the browser has been unlocked. This happens if you have interacted with the browser, i.e.\r\n   * by clicking on it or pressing a key, or due to server settings. The policies that control autoplaying are vast and\r\n   * vary between browser. You can read more here: https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide\r\n   * \r\n   * If your video doesn't contain any audio, then set the `noAudio` parameter to `true` when the video is loaded,\r\n   * and it will often allow the video to play immediately:\r\n   * \r\n   * ```javascript\r\n   * preload () {\r\n   *   this.load.video('pixar', 'nemo.mp4', 'loadeddata', false, true);\r\n   * }\r\n   * ```\r\n   * \r\n   * The 5th parameter in the load call tells Phaser that the video doesn't contain any audio tracks. Video without\r\n   * audio can autoplay without requiring a user interaction. Video with audio cannot do this unless it satisfies\r\n   * the browsers MEI settings. See the MDN Autoplay Guide for details.\r\n   * \r\n   * If you need audio in your videos, then you'll have to consider the fact that the video cannot start playing until the\r\n   * user has interacted with the browser, into your game flow.\r\n   *\r\n   * @method Phaser.GameObjects.Video#play\r\n   * @since 3.20.0\r\n   * \r\n   * @param {boolean} [loop=false] - Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats.\r\n   * @param {integer} [markerIn] - Optional in marker time, in seconds, for playback of a sequence of the video.\r\n   * @param {integer} [markerOut] - Optional out marker time, in seconds, for playback of a sequence of the video.\r\n   * \r\n   * @return {this} This Video Game Object for method chaining.\r\n   */\n  play: function (loop, markerIn, markerOut) {\n    if (this.touchLocked && this.playWhenUnlocked || this.isPlaying()) {\n      return this;\n    }\n\n    var video = this.video;\n\n    if (!video) {\n      console.warn('Video not loaded');\n      return this;\n    }\n\n    if (loop === undefined) {\n      loop = video.loop;\n    }\n\n    var sound = this.scene.sys.sound;\n\n    if (sound && sound.mute) {\n      //  Mute will be set based on the global mute state of the Sound Manager (if there is one)\n      this.setMute(true);\n    }\n\n    if (!isNaN(markerIn)) {\n      this._markerIn = markerIn;\n    }\n\n    if (!isNaN(markerOut) && markerOut > markerIn) {\n      this._markerOut = markerOut;\n    }\n\n    video.loop = loop;\n    var callbacks = this._callbacks;\n    var playPromise = video.play();\n\n    if (playPromise !== undefined) {\n      playPromise.then(this.playPromiseSuccessHandler.bind(this)).catch(this.playPromiseErrorHandler.bind(this));\n    } else {\n      //  Old-school browsers with no Promises\n      video.addEventListener('playing', callbacks.play, true); //  If video hasn't downloaded properly yet ...\n\n      if (video.readyState < 2) {\n        this.retry = this.retryLimit;\n        this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);\n      }\n    } //  Set these _after_ calling `play` or they don't fire (useful, thanks browsers)\n\n\n    video.addEventListener('ended', callbacks.end, true);\n    video.addEventListener('timeupdate', callbacks.time, true);\n    video.addEventListener('seeking', callbacks.seeking, true);\n    video.addEventListener('seeked', callbacks.seeked, true);\n    return this;\n  },\n\n  /**\r\n   * This method allows you to change the source of the current video element. It works by first stopping the\r\n   * current video, if playing. Then deleting the video texture, if one has been created. Finally, it makes a\r\n   * new video texture and starts playback of the new source through the existing video element.\r\n   * \r\n   * The reason you may wish to do this is because videos that require interaction to unlock, remain in an unlocked\r\n   * state, even if you change the source of the video. By changing the source to a new video you avoid having to\r\n   * go through the unlock process again.\r\n   *\r\n   * @method Phaser.GameObjects.Video#changeSource\r\n   * @since 3.20.0\r\n   * \r\n   * @param {string} key - The key of the Video this Game Object will swap to playing, as stored in the Video Cache.\r\n   * @param {boolean} [autoplay=true] - Should the video start playing immediately, once the swap is complete?\r\n   * @param {boolean} [loop=false] - Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats.\r\n   * @param {integer} [markerIn] - Optional in marker time, in seconds, for playback of a sequence of the video.\r\n   * @param {integer} [markerOut] - Optional out marker time, in seconds, for playback of a sequence of the video.\r\n   * \r\n   * @return {this} This Video Game Object for method chaining.\r\n   */\n  changeSource: function (key, autoplay, loop, markerIn, markerOut) {\n    if (autoplay === undefined) {\n      autoplay = true;\n    }\n\n    var currentVideo = this.video;\n\n    if (currentVideo) {\n      this.stop();\n    }\n\n    var newVideo = this.scene.sys.cache.video.get(key);\n\n    if (newVideo) {\n      this.video = newVideo;\n      this._cacheKey = key;\n      this._codePaused = newVideo.paused;\n      this._codeMuted = newVideo.muted;\n\n      if (this.videoTexture) {\n        this.scene.sys.textures.remove(this._key);\n        this.videoTexture = this.scene.sys.textures.create(this._key, newVideo, newVideo.videoWidth, newVideo.videoHeight);\n        this.videoTextureSource = this.videoTexture.source[0];\n        this.videoTexture.add('__BASE', 0, 0, 0, newVideo.videoWidth, newVideo.videoHeight);\n        this.setTexture(this.videoTexture);\n        this.setSizeToFrame();\n        this.updateDisplayOrigin();\n        this.emit(Events.VIDEO_CREATED, this, newVideo.videoWidth, newVideo.videoHeight);\n      } else {\n        this.updateTexture();\n      }\n\n      newVideo.currentTime = 0;\n      this._lastUpdate = 0;\n\n      if (autoplay) {\n        this.play(loop, markerIn, markerOut);\n      }\n    } else {\n      this.video = null;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Adds a sequence marker to this video.\r\n   * \r\n   * Markers allow you to split a video up into sequences, delineated by a start and end time, given in seconds.\r\n   * \r\n   * You can then play back specific markers via the `playMarker` method.\r\n   * \r\n   * Note that marker timing is _not_ frame-perfect. You should construct your videos in such a way that you allow for\r\n   * plenty of extra padding before and after each sequence to allow for discrepancies in browser seek and currentTime accuracy.\r\n   * \r\n   * See https://github.com/w3c/media-and-entertainment/issues/4 for more details about this issue.\r\n   *\r\n   * @method Phaser.GameObjects.Video#addMarker\r\n   * @since 3.20.0\r\n   * \r\n   * @param {string} key - A unique name to give this marker.\r\n   * @param {integer} markerIn - The time, in seconds, representing the start of this marker.\r\n   * @param {integer} markerOut - The time, in seconds, representing the end of this marker.\r\n   * \r\n   * @return {this} This Video Game Object for method chaining.\r\n   */\n  addMarker: function (key, markerIn, markerOut) {\n    if (!isNaN(markerIn) && markerIn >= 0 && !isNaN(markerOut)) {\n      this.markers[key] = [markerIn, markerOut];\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Plays a pre-defined sequence in this video.\r\n   * \r\n   * Markers allow you to split a video up into sequences, delineated by a start and end time, given in seconds and\r\n   * specified via the `addMarker` method.\r\n   * \r\n   * Note that marker timing is _not_ frame-perfect. You should construct your videos in such a way that you allow for\r\n   * plenty of extra padding before and after each sequence to allow for discrepancies in browser seek and currentTime accuracy.\r\n   * \r\n   * See https://github.com/w3c/media-and-entertainment/issues/4 for more details about this issue.\r\n   *\r\n   * @method Phaser.GameObjects.Video#playMarker\r\n   * @since 3.20.0\r\n   * \r\n   * @param {string} key - The name of the marker sequence to play.\r\n   * @param {boolean} [loop=false] - Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats.\r\n   * \r\n   * @return {this} This Video Game Object for method chaining.\r\n   */\n  playMarker: function (key, loop) {\n    var marker = this.markers[key];\n\n    if (marker) {\n      this.play(loop, marker[0], marker[1]);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes a previously set marker from this video.\r\n   * \r\n   * If the marker is currently playing it will _not_ stop playback.\r\n   *\r\n   * @method Phaser.GameObjects.Video#removeMarker\r\n   * @since 3.20.0\r\n   * \r\n   * @param {string} key - The name of the marker to remove.\r\n   * \r\n   * @return {this} This Video Game Object for method chaining.\r\n   */\n  removeMarker: function (key) {\n    delete this.markers[key];\n    return this;\n  },\n\n  /**\r\n   * Takes a snapshot of the current frame of the video and renders it to a CanvasTexture object,\r\n   * which is then returned. You can optionally resize the grab by passing a width and height.\r\n   * \r\n   * This method returns a reference to the `Video.snapshotTexture` object. Calling this method\r\n   * multiple times will overwrite the previous snapshot with the most recent one.\r\n   *\r\n   * @method Phaser.GameObjects.Video#snapshot\r\n   * @since 3.20.0\r\n   * \r\n   * @param {integer} [width] - The width of the resulting CanvasTexture.\r\n   * @param {integer} [height] - The height of the resulting CanvasTexture.\r\n   * \r\n   * @return {Phaser.Textures.CanvasTexture} \r\n   */\n  snapshot: function (width, height) {\n    if (width === undefined) {\n      width = this.width;\n    }\n\n    if (height === undefined) {\n      height = this.height;\n    }\n\n    return this.snapshotArea(0, 0, this.width, this.height, width, height);\n  },\n\n  /**\r\n   * Takes a snapshot of the specified area of the current frame of the video and renders it to a CanvasTexture object,\r\n   * which is then returned. You can optionally resize the grab by passing a different `destWidth` and `destHeight`.\r\n   * \r\n   * This method returns a reference to the `Video.snapshotTexture` object. Calling this method\r\n   * multiple times will overwrite the previous snapshot with the most recent one.\r\n   *\r\n   * @method Phaser.GameObjects.Video#snapshotArea\r\n   * @since 3.20.0\r\n   * \r\n   * @param {integer} [x=0] - The horizontal location of the top-left of the area to grab from.\r\n   * @param {integer} [y=0] - The vertical location of the top-left of the area to grab from.\r\n   * @param {integer} [srcWidth] - The width of area to grab from the video. If not given it will grab the full video dimensions.\r\n   * @param {integer} [srcHeight] - The height of area to grab from the video. If not given it will grab the full video dimensions.\r\n   * @param {integer} [destWidth] - The destination width of the grab, allowing you to resize it.\r\n   * @param {integer} [destHeight] - The destination height of the grab, allowing you to resize it.\r\n   * \r\n   * @return {Phaser.Textures.CanvasTexture} \r\n   */\n  snapshotArea: function (x, y, srcWidth, srcHeight, destWidth, destHeight) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (srcWidth === undefined) {\n      srcWidth = this.width;\n    }\n\n    if (srcHeight === undefined) {\n      srcHeight = this.height;\n    }\n\n    if (destWidth === undefined) {\n      destWidth = srcWidth;\n    }\n\n    if (destHeight === undefined) {\n      destHeight = srcHeight;\n    }\n\n    var video = this.video;\n    var snap = this.snapshotTexture;\n\n    if (!snap) {\n      snap = this.scene.sys.textures.createCanvas(UUID(), destWidth, destHeight);\n      this.snapshotTexture = snap;\n\n      if (video) {\n        snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);\n      }\n    } else {\n      snap.setSize(destWidth, destHeight);\n\n      if (video) {\n        snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);\n      }\n    }\n\n    return snap.update();\n  },\n\n  /**\r\n   * Stores a copy of this Videos `snapshotTexture` in the Texture Manager using the given key.\r\n   * \r\n   * This texture is created when the `snapshot` or `snapshotArea` methods are called.\r\n   * \r\n   * After doing this, any texture based Game Object, such as a Sprite, can use the contents of the\r\n   * snapshot by using the texture key:\r\n   * \r\n   * ```javascript\r\n   * var vid = this.add.video(0, 0, 'intro');\r\n   * \r\n   * vid.snapshot();\r\n   * \r\n   * vid.saveSnapshotTexture('doodle');\r\n   * \r\n   * this.add.image(400, 300, 'doodle');\r\n   * ```\r\n   * \r\n   * Updating the contents of the `snapshotTexture`, for example by calling `snapshot` again,\r\n   * will automatically update _any_ Game Object that is using it as a texture.\r\n   * Calling `saveSnapshotTexture` again will not save another copy of the same texture,\r\n   * it will just rename the existing one.\r\n   * \r\n   * By default it will create a single base texture. You can add frames to the texture\r\n   * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n   * to use a specific frame.\r\n   *\r\n   * @method Phaser.GameObjects.Video#saveSnapshotTexture\r\n   * @since 3.20.0\r\n   *\r\n   * @param {string} key - The unique key to store the texture as within the global Texture Manager.\r\n   *\r\n   * @return {Phaser.Textures.CanvasTexture} The Texture that was saved.\r\n   */\n  saveSnapshotTexture: function (key) {\n    if (this.snapshotTexture) {\n      this.scene.sys.textures.renameTexture(this.snapshotTexture.key, key);\n    } else {\n      this.snapshotTexture = this.scene.sys.textures.createCanvas(key, this.width, this.height);\n    }\n\n    return this.snapshotTexture;\n  },\n\n  /**\r\n   * Loads a Video from the given URL, ready for playback with the `Video.play` method.\r\n   * \r\n   * You can control at what point the browser determines the video as being ready for playback via\r\n   * the `loadEvent` parameter. See https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement\r\n   * for more details.\r\n   *\r\n   * @method Phaser.GameObjects.Video#loadURL\r\n   * @since 3.20.0\r\n   * \r\n   * @param {string} url - The URL of the video to load or be streamed.\r\n   * @param {string} [loadEvent='loadeddata'] - The load event to listen for. Either `loadeddata`, `canplay` or `canplaythrough`.\r\n   * @param {boolean} [noAudio=false] - Does the video have an audio track? If not you can enable auto-playing on it.\r\n   * \r\n   * @return {this} This Video Game Object for method chaining.\r\n   */\n  loadURL: function (url, loadEvent, noAudio) {\n    if (loadEvent === undefined) {\n      loadEvent = 'loadeddata';\n    }\n\n    if (noAudio === undefined) {\n      noAudio = false;\n    }\n\n    if (this.video) {\n      this.stop();\n    }\n\n    if (this.videoTexture) {\n      this.scene.sys.textures.remove(this._key);\n    }\n\n    var video = document.createElement('video');\n    video.controls = false;\n\n    if (noAudio) {\n      video.muted = true;\n      video.defaultMuted = true;\n      video.setAttribute('autoplay', 'autoplay');\n    }\n\n    video.setAttribute('playsinline', 'playsinline');\n    video.setAttribute('preload', 'auto');\n    video.addEventListener('error', this._callbacks.error, true);\n    video.src = url;\n    video.load();\n    this.video = video;\n    return this;\n  },\n\n  /**\r\n   * This internal method is called automatically if the playback Promise resolves successfully.\r\n   *\r\n   * @method Phaser.GameObjects.Video#playPromiseSuccessHandler\r\n   * @fires Phaser.GameObjects.Events#VIDEO_PLAY\r\n   * @private\r\n   * @since 3.20.0\r\n   */\n  playPromiseSuccessHandler: function () {\n    this.touchLocked = false;\n    this.emit(Events.VIDEO_PLAY, this);\n\n    if (this._markerIn > -1) {\n      this.video.currentTime = this._markerIn;\n    }\n  },\n\n  /**\r\n   * This internal method is called automatically if the playback Promise fails to resolve.\r\n   *\r\n   * @method Phaser.GameObjects.Video#playPromiseErrorHandler\r\n   * @fires Phaser.GameObjects.Events#VIDEO_ERROR\r\n   * @private\r\n   * @since 3.20.0\r\n   * \r\n   * @param {any} error - The Promise resolution error.\r\n   */\n  playPromiseErrorHandler: function (error) {\n    this.scene.sys.input.once('pointerdown', this.unlockHandler, this);\n    this.touchLocked = true;\n    this.playWhenUnlocked = true;\n    this.emit(Events.VIDEO_ERROR, this, error);\n  },\n\n  /**\r\n   * Called when the video emits a `playing` event during load.\r\n   * \r\n   * This is only listened for if the browser doesn't support Promises.\r\n   *\r\n   * @method Phaser.GameObjects.Video#playHandler\r\n   * @fires Phaser.GameObjects.Events#VIDEO_PLAY\r\n   * @since 3.20.0\r\n   */\n  playHandler: function () {\n    this.touchLocked = false;\n    this.emit(Events.VIDEO_PLAY, this);\n    this.video.removeEventListener('playing', this._callbacks.play, true);\n  },\n\n  /**\r\n   * This internal method is called automatically if the video fails to load.\r\n   *\r\n   * @method Phaser.GameObjects.Video#loadErrorHandler\r\n   * @fires Phaser.GameObjects.Events#VIDEO_ERROR\r\n   * @private\r\n   * @since 3.20.0\r\n   * \r\n   * @param {Event} event - The error Event.\r\n   */\n  loadErrorHandler: function (event) {\n    this.stop();\n    this.emit(Events.VIDEO_ERROR, this, event);\n  },\n\n  /**\r\n   * This internal method is called if the video couldn't be played because it was interaction locked\r\n   * by the browser, but an input event has since been received.\r\n   *\r\n   * @method Phaser.GameObjects.Video#unlockHandler\r\n   * @fires Phaser.GameObjects.Events#VIDEO_UNLOCKED\r\n   * @fires Phaser.GameObjects.Events#VIDEO_PLAY\r\n   * @private\r\n   * @since 3.20.0\r\n   * \r\n   * @param {any} error - The Promise resolution error.\r\n   */\n  unlockHandler: function () {\n    this.touchLocked = false;\n    this.playWhenUnlocked = false;\n    this.emit(Events.VIDEO_UNLOCKED, this);\n\n    if (this._markerIn > -1) {\n      this.video.currentTime = this._markerIn;\n    }\n\n    this.video.play();\n    this.emit(Events.VIDEO_PLAY, this);\n  },\n\n  /**\r\n   * Called when the video completes playback, i.e. reaches an `ended` state.\r\n   * \r\n   * This will never happen if the video is coming from a live stream, where the duration is `Infinity`.\r\n   *\r\n   * @method Phaser.GameObjects.Video#completeHandler\r\n   * @fires Phaser.GameObjects.Events#VIDEO_COMPLETE\r\n   * @since 3.20.0\r\n   */\n  completeHandler: function () {\n    this.emit(Events.VIDEO_COMPLETE, this);\n  },\n\n  /**\r\n   * Called when the video emits a `timeUpdate` event during playback.\r\n   * \r\n   * This event is too slow and irregular to be used for actual video timing or texture updating,\r\n   * but we can use it to determine if a video has looped.\r\n   *\r\n   * @method Phaser.GameObjects.Video#timeUpdateHandler\r\n   * @fires Phaser.GameObjects.Events#VIDEO_LOOP\r\n   * @since 3.20.0\r\n   */\n  timeUpdateHandler: function () {\n    if (this.video && this.video.currentTime < this._lastUpdate) {\n      this.emit(Events.VIDEO_LOOP, this);\n      this._lastUpdate = 0;\n    }\n  },\n\n  /**\r\n   * The internal update step.\r\n   *\r\n   * @method Phaser.GameObjects.Video#preUpdate\r\n   * @private\r\n   * @since 3.20.0\r\n   */\n  preUpdate: function () {\n    var video = this.video;\n\n    if (video) {\n      var currentTime = video.currentTime; //  Don't render a new frame unless the video has actually changed time\n\n      if (currentTime !== this._lastUpdate) {\n        this._lastUpdate = currentTime;\n        this.updateTexture();\n\n        if (currentTime >= this._markerOut) {\n          if (video.loop) {\n            video.currentTime = this._markerIn;\n            this.updateTexture();\n            this._lastUpdate = currentTime;\n            this.emit(Events.VIDEO_LOOP, this);\n          } else {\n            this.emit(Events.VIDEO_COMPLETE, this);\n            this.stop();\n          }\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Internal callback that monitors the download progress of a video after changing its source.\r\n   *\r\n   * @method Phaser.GameObjects.Video#checkVideoProgress\r\n   * @fires Phaser.GameObjects.Events#VIDEO_TIMEOUT\r\n   * @private\r\n   * @since 3.20.0\r\n   */\n  checkVideoProgress: function () {\n    if (this.video.readyState >= 2) {\n      //  We've got enough data to update the texture for playback\n      this.updateTexture();\n    } else {\n      this.retry--;\n\n      if (this.retry > 0) {\n        this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);\n      } else {\n        this.emit(Events.VIDEO_TIMEOUT, this);\n      }\n    }\n  },\n\n  /**\r\n   * Internal method that is called when enough video data has been received in order to create a texture\r\n   * from it. The texture is assigned to the `Video.videoTexture` property and given a base frame that\r\n   * encompases the whole video size.\r\n   *\r\n   * @method Phaser.GameObjects.Video#updateTexture\r\n   * @since 3.20.0\r\n   */\n  updateTexture: function () {\n    var video = this.video;\n    var width = video.videoWidth;\n    var height = video.videoHeight;\n\n    if (!this.videoTexture) {\n      this.videoTexture = this.scene.sys.textures.create(this._key, video, width, height);\n      this.videoTextureSource = this.videoTexture.source[0];\n      this.videoTexture.add('__BASE', 0, 0, 0, width, height);\n      this.setTexture(this.videoTexture);\n      this.setSizeToFrame();\n      this.updateDisplayOrigin();\n      this.emit(Events.VIDEO_CREATED, this, width, height);\n    } else {\n      var textureSource = this.videoTextureSource;\n\n      if (textureSource.source !== video) {\n        textureSource.source = video;\n        textureSource.width = width;\n        textureSource.height = height;\n      }\n\n      textureSource.update();\n    }\n  },\n\n  /**\r\n   * Returns the key of the currently played video, as stored in the Video Cache.\r\n   * If the video did not come from the cache this will return an empty string.\r\n   *\r\n   * @method Phaser.GameObjects.Video#getVideoKey\r\n   * @since 3.20.0\r\n   * \r\n   * @return {string} The key of the video being played from the Video Cache, if any.\r\n   */\n  getVideoKey: function () {\n    return this._cacheKey;\n  },\n\n  /**\r\n   * Seeks to a given point in the video. The value is given as a float between 0 and 1,\r\n   * where 0 represents the start of the video and 1 represents the end.\r\n   * \r\n   * Seeking only works if the video has a duration, so will not work for live streams.\r\n   * \r\n   * When seeking begins, this video will emit a `seeking` event. When the video completes\r\n   * seeking (i.e. reaches its designated timestamp) it will emit a `seeked` event.\r\n   * \r\n   * If you wish to seek based on time instead, use the `Video.setCurrentTime` method.\r\n   *\r\n   * @method Phaser.GameObjects.Video#seekTo\r\n   * @since 3.20.0\r\n   * \r\n   * @param {number} value - The point in the video to seek to. A value between 0 and 1.\r\n   * \r\n   * @return {this} This Video Game Object for method chaining.\r\n   */\n  seekTo: function (value) {\n    var video = this.video;\n\n    if (video) {\n      var duration = video.duration;\n\n      if (duration !== Infinity && !isNaN(duration)) {\n        var seekTime = duration * value;\n        this.setCurrentTime(seekTime);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * A double-precision floating-point value indicating the current playback time in seconds.\r\n   * If the media has not started to play and has not been seeked, this value is the media's initial playback time.\r\n   *\r\n   * @method Phaser.GameObjects.Video#getCurrentTime\r\n   * @since 3.20.0\r\n   * \r\n   * @return {number} A double-precision floating-point value indicating the current playback time in seconds.\r\n   */\n  getCurrentTime: function () {\n    return this.video ? this.video.currentTime : 0;\n  },\n\n  /**\r\n   * Seeks to a given playback time in the video. The value is given in _seconds_ or as a string.\r\n   * \r\n   * Seeking only works if the video has a duration, so will not work for live streams.\r\n   * \r\n   * When seeking begins, this video will emit a `seeking` event. When the video completes\r\n   * seeking (i.e. reaches its designated timestamp) it will emit a `seeked` event.\r\n   * \r\n   * You can provide a string prefixed with either a `+` or a `-`, such as `+2.5` or `-2.5`.\r\n   * In this case it will seek to +/- the value given, relative to the _current time_.\r\n   * \r\n   * If you wish to seek based on a duration percentage instead, use the `Video.seekTo` method.\r\n   *\r\n   * @method Phaser.GameObjects.Video#setCurrentTime\r\n   * @since 3.20.0\r\n   * \r\n   * @param {(string|number)} value - The playback time to seek to in seconds. Can be expressed as a string, such as `+2` to seek 2 seconds ahead from the current time.\r\n   * \r\n   * @return {this} This Video Game Object for method chaining.\r\n   */\n  setCurrentTime: function (value) {\n    var video = this.video;\n\n    if (video) {\n      if (typeof value === 'string') {\n        var op = value[0];\n        var num = parseFloat(value.substr(1));\n\n        if (op === '+') {\n          value = video.currentTime + num;\n        } else if (op === '-') {\n          value = video.currentTime - num;\n        }\n      }\n\n      video.currentTime = value;\n      this._lastUpdate = value;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Returns a boolean indicating if this Video is currently seeking, or not.\r\n   *\r\n   * @method Phaser.GameObjects.Video#isSeeking\r\n   * @since 3.20.0\r\n   * \r\n   * @return {boolean} A boolean indicating if this Video is currently seeking, or not.\r\n   */\n  isSeeking: function () {\n    return this._isSeeking;\n  },\n\n  /**\r\n   * Internal seeking handler.\r\n   *\r\n   * @method Phaser.GameObjects.Video#seekingHandler\r\n   * @fires Phaser.GameObjects.Events#VIDEO_SEEKING\r\n   * @private\r\n   * @since 3.20.0\r\n   */\n  seekingHandler: function () {\n    this._isSeeking = true;\n    this.emit(Events.VIDEO_SEEKING, this);\n  },\n\n  /**\r\n   * Internal seeked handler.\r\n   *\r\n   * @method Phaser.GameObjects.Video#seekedHandler\r\n   * @fires Phaser.GameObjects.Events#VIDEO_SEEKED\r\n   * @private\r\n   * @since 3.20.0\r\n   */\n  seekedHandler: function () {\n    this._isSeeking = false;\n    this.emit(Events.VIDEO_SEEKED, this);\n    var video = this.video;\n\n    if (video) {\n      this.updateTexture();\n    }\n  },\n\n  /**\r\n   * Returns the current progress of the video. Progress is defined as a value between 0 (the start)\r\n   * and 1 (the end).\r\n   * \r\n   * Progress can only be returned if the video has a duration, otherwise it will always return zero.\r\n   *\r\n   * @method Phaser.GameObjects.Video#getProgress\r\n   * @since 3.20.0\r\n   * \r\n   * @return {number} The current progress of playback. If the video has no duration, will always return zero.\r\n   */\n  getProgress: function () {\n    var video = this.video;\n\n    if (video) {\n      var now = video.currentTime;\n      var duration = video.duration;\n\n      if (duration !== Infinity && !isNaN(duration)) {\n        return now / duration;\n      }\n    }\n\n    return 0;\n  },\n\n  /**\r\n   * A double-precision floating-point value which indicates the duration (total length) of the media in seconds,\r\n   * on the media's timeline. If no media is present on the element, or the media is not valid, the returned value is NaN.\r\n   * \r\n   * If the media has no known end (such as for live streams of unknown duration, web radio, media incoming from WebRTC,\r\n   * and so forth), this value is +Infinity.\r\n   * \r\n   * @method Phaser.GameObjects.Video#getDuration\r\n   * @since 3.20.0\r\n   * \r\n   * @return {number} A double-precision floating-point value indicating the duration of the media in seconds.\r\n   */\n  getDuration: function () {\n    return this.video ? this.video.duration : 0;\n  },\n\n  /**\r\n   * Sets the muted state of the currently playing video, if one is loaded.\r\n   *\r\n   * @method Phaser.GameObjects.Video#setMute\r\n   * @since 3.20.0\r\n   * \r\n   * @param {boolean} [value=true] - The mute value. `true` if the video should be muted, otherwise `false`.\r\n   * \r\n   * @return {this} This Video Game Object for method chaining.\r\n   */\n  setMute: function (value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this._codeMuted = value;\n    var video = this.video;\n\n    if (video) {\n      video.muted = this._systemMuted ? true : value;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Returns a boolean indicating if this Video is currently muted.\r\n   *\r\n   * @method Phaser.GameObjects.Video#isMuted\r\n   * @since 3.20.0\r\n   * \r\n   * @return {boolean} A boolean indicating if this Video is currently muted, or not.\r\n   */\n  isMuted: function () {\n    return this._codeMuted;\n  },\n\n  /**\r\n   * Internal global mute handler. Will mute the video, if playing, if the global sound system mutes.\r\n   *\r\n   * @method Phaser.GameObjects.Video#globalMute\r\n   * @private\r\n   * @since 3.20.0\r\n   * \r\n   * @param {(Phaser.Sound.WebAudioSoundManager|Phaser.Sound.HTML5AudioSoundManager)} soundManager - A reference to the Sound Manager that emitted the event.\r\n   * @param {boolean} mute - The mute value. `true` if the Sound Manager is now muted, otherwise `false`.\r\n   */\n  globalMute: function (soundManager, value) {\n    this._systemMuted = value;\n    var video = this.video;\n\n    if (video) {\n      video.muted = this._codeMuted ? true : value;\n    }\n  },\n\n  /**\r\n   * Internal global pause handler. Will pause the video if the Game itself pauses.\r\n   *\r\n   * @method Phaser.GameObjects.Video#globalPause\r\n   * @private\r\n   * @since 3.20.0\r\n   */\n  globalPause: function () {\n    this._systemPaused = true;\n\n    if (this.video) {\n      this.video.pause();\n    }\n  },\n\n  /**\r\n   * Internal global resume handler. Will resume a paused video if the Game itself resumes.\r\n   *\r\n   * @method Phaser.GameObjects.Video#globalResume\r\n   * @private\r\n   * @since 3.20.0\r\n   */\n  globalResume: function () {\n    this._systemPaused = false;\n\n    if (this.video && !this._codePaused) {\n      this.video.play();\n    }\n  },\n\n  /**\r\n   * Sets the paused state of the currently loaded video.\r\n   * \r\n   * If the video is playing, calling this method with `true` will pause playback.\r\n   * If the video is paused, calling this method with `false` will resume playback.\r\n   * \r\n   * If no video is loaded, this method does nothing.\r\n   *\r\n   * @method Phaser.GameObjects.Video#setPaused\r\n   * @since 3.20.0\r\n   * \r\n   * @param {boolean} [value=true] - The paused value. `true` if the video should be paused, `false` to resume it.\r\n   * \r\n   * @return {this} This Video Game Object for method chaining.\r\n   */\n  setPaused: function (value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    var video = this.video;\n    this._codePaused = value;\n\n    if (video) {\n      if (value) {\n        if (!video.paused) {\n          video.pause();\n        }\n      } else if (!value) {\n        if (video.paused && !this._systemPaused) {\n          video.play();\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Returns a double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).\r\n   * \r\n   * @method Phaser.GameObjects.Video#getVolume\r\n   * @since 3.20.0\r\n   * \r\n   * @return {number} A double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).\r\n   */\n  getVolume: function () {\n    return this.video ? this.video.volume : 1;\n  },\n\n  /**\r\n   * Sets the volume of the currently playing video.\r\n   * \r\n   * The value given is a double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).\r\n   * \r\n   * @method Phaser.GameObjects.Video#setVolume\r\n   * @since 3.20.0\r\n   * \r\n   * @param {number} [value=1] - A double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).\r\n   * \r\n   * @return {this} This Video Game Object for method chaining.\r\n   */\n  setVolume: function (value) {\n    if (value === undefined) {\n      value = 1;\n    }\n\n    if (this.video) {\n      this.video.volume = Clamp(value, 0, 1);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Returns a double that indicates the rate at which the media is being played back.\r\n   * \r\n   * @method Phaser.GameObjects.Video#getPlaybackRate\r\n   * @since 3.20.0\r\n   * \r\n   * @return {number} A double that indicates the rate at which the media is being played back.\r\n   */\n  getPlaybackRate: function () {\n    return this.video ? this.video.playbackRate : 1;\n  },\n\n  /**\r\n   * Sets the playback rate of the current video.\r\n   * \r\n   * The value given is a double that indicates the rate at which the media is being played back.\r\n   * \r\n   * @method Phaser.GameObjects.Video#setPlaybackRate\r\n   * @since 3.20.0\r\n   * \r\n   * @param {number} [rate] - A double that indicates the rate at which the media is being played back.\r\n   * \r\n   * @return {this} This Video Game Object for method chaining.\r\n   */\n  setPlaybackRate: function (rate) {\n    if (this.video) {\n      this.video.playbackRate = rate;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Returns a boolean which indicates whether the media element should start over when it reaches the end.\r\n   * \r\n   * @method Phaser.GameObjects.Video#getLoop\r\n   * @since 3.20.0\r\n   * \r\n   * @return {boolean} A boolean which indicates whether the media element will start over when it reaches the end.\r\n   */\n  getLoop: function () {\n    return this.video ? this.video.loop : false;\n  },\n\n  /**\r\n   * Sets the loop state of the current video.\r\n   * \r\n   * The value given is a boolean which indicates whether the media element will start over when it reaches the end.\r\n   * \r\n   * Not all videos can loop, for example live streams.\r\n   * \r\n   * Please note that not all browsers support _seamless_ video looping for all encoding formats.\r\n   * \r\n   * @method Phaser.GameObjects.Video#setLoop\r\n   * @since 3.20.0\r\n   * \r\n   * @param {boolean} [value=true] - A boolean which indicates whether the media element will start over when it reaches the end.\r\n   * \r\n   * @return {this} This Video Game Object for method chaining.\r\n   */\n  setLoop: function (value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    if (this.video) {\n      this.video.loop = value;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Returns a boolean which indicates whether the video is currently playing.\r\n   * \r\n   * @method Phaser.GameObjects.Video#isPlaying\r\n   * @since 3.20.0\r\n   * \r\n   * @return {boolean} A boolean which indicates whether the video is playing, or not.\r\n   */\n  isPlaying: function () {\n    return this.video ? !(this.video.paused || this.video.ended) : false;\n  },\n\n  /**\r\n   * Returns a boolean which indicates whether the video is currently paused.\r\n   * \r\n   * @method Phaser.GameObjects.Video#isPaused\r\n   * @since 3.20.0\r\n   * \r\n   * @return {boolean} A boolean which indicates whether the video is paused, or not.\r\n   */\n  isPaused: function () {\n    return this.video && this.video.paused || this._codePaused || this._systemPaused;\n  },\n\n  /**\r\n   * Stores this Video in the Texture Manager using the given key as a dynamic texture,\r\n   * which any texture-based Game Object, such as a Sprite, can use as its texture:\r\n   * \r\n   * ```javascript\r\n   * var vid = this.add.video(0, 0, 'intro');\r\n   * \r\n   * vid.play();\r\n   * \r\n   * vid.saveTexture('doodle');\r\n   * \r\n   * this.add.image(400, 300, 'doodle');\r\n   * ```\r\n   * \r\n   * The saved texture is automatically updated as the video plays. If you pause this video,\r\n   * or change its source, then the saved texture updates instantly.\r\n   * \r\n   * Calling `saveTexture` again will not save another copy of the same texture, it will just rename the existing one.\r\n   * \r\n   * By default it will create a single base texture. You can add frames to the texture\r\n   * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n   * to use a specific frame.\r\n   * \r\n   * If you intend to save the texture so you can use it as the input for a Shader, you may need to set the\r\n   * `flipY` parameter to `true` if you find the video renders upside down in your shader.\r\n   *\r\n   * @method Phaser.GameObjects.Video#saveTexture\r\n   * @since 3.20.0\r\n   *\r\n   * @param {string} key - The unique key to store the texture as within the global Texture Manager.\r\n   * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y` during upload?\r\n   *\r\n   * @return {Phaser.Textures.Texture} The Texture that was saved.\r\n   */\n  saveTexture: function (key, flipY) {\n    if (flipY === undefined) {\n      flipY = false;\n    }\n\n    if (this.videoTexture) {\n      this.scene.sys.textures.renameTexture(this._key, key);\n    }\n\n    this._key = key;\n    this.flipY = flipY;\n\n    if (this.videoTextureSource) {\n      this.videoTextureSource.setFlipY(flipY);\n    }\n\n    return this.videoTexture;\n  },\n\n  /**\r\n   * Stops the video playing and clears all internal event listeners.\r\n   *\r\n   * If you only wish to pause playback of the video, and resume it a later time, use the `Video.pause` method instead.\r\n   * \r\n   * If the video hasn't finished downloading, calling this method will not abort the download. To do that you need to\r\n   * call `destroy` instead.\r\n   *\r\n   * @method Phaser.GameObjects.Video#stop\r\n   * @fires Phaser.GameObjects.Events#VIDEO_STOP\r\n   * @since 3.20.0\r\n   * \r\n   * @return {this} This Video Game Object for method chaining.\r\n   */\n  stop: function () {\n    var video = this.video;\n\n    if (video) {\n      var callbacks = this._callbacks;\n\n      for (var callback in callbacks) {\n        video.removeEventListener(callback, callbacks[callback], true);\n      }\n\n      video.pause();\n    }\n\n    if (this._retryID) {\n      window.clearTimeout(this._retryID);\n    }\n\n    this.emit(Events.VIDEO_STOP, this);\n    return this;\n  },\n\n  /**\r\n   * Removes the Video element from the DOM by calling parentNode.removeChild on itself.\r\n   * \r\n   * Also removes the autoplay and src attributes and nulls the Video reference.\r\n   * \r\n   * You should not call this method if you were playing a video from the Video Cache that\r\n   * you wish to play again in your game, or if another Video object is also using the same\r\n   * video.\r\n   * \r\n   * If you loaded an external video via `Video.loadURL` then you should call this function\r\n   * to clear up once you are done with the instance.\r\n   *\r\n   * @method Phaser.GameObjects.Video#removeVideoElement\r\n   * @since 3.20.0\r\n   */\n  removeVideoElement: function () {\n    var video = this.video;\n\n    if (!video) {\n      return;\n    }\n\n    if (video.parentNode) {\n      video.parentNode.removeChild(video);\n    }\n\n    while (video.hasChildNodes()) {\n      video.removeChild(video.firstChild);\n    }\n\n    video.removeAttribute('autoplay');\n    video.removeAttribute('src');\n    this.video = null;\n  },\n\n  /**\r\n   * Handles the pre-destroy step for the Video object.\r\n   * \r\n   * This calls `Video.stop` and optionally `Video.removeVideoElement`.\r\n   * \r\n   * If any Sprites are using this Video as their texture it is up to you to manage those.\r\n   *\r\n   * @method Phaser.GameObjects.Video#preDestroy\r\n   * @private\r\n   * @since 3.21.0\r\n   */\n  preDestroy: function () {\n    this.stop();\n\n    if (this.removeVideoElementOnDestroy) {\n      this.removeVideoElement();\n    }\n\n    var game = this.scene.sys.game.events;\n    game.off(GameEvents.PAUSE, this.globalPause, this);\n    game.off(GameEvents.RESUME, this.globalResume, this);\n    var sound = this.scene.sys.sound;\n\n    if (sound) {\n      sound.off(SoundEvents.GLOBAL_MUTE, this.globalMute, this);\n    }\n\n    if (this._retryID) {\n      window.clearTimeout(this._retryID);\n    }\n  }\n});\nmodule.exports = Video;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/video/Video.js"],"names":["Class","require","Clamp","Components","Events","GameEvents","GameObject","SoundEvents","UUID","VideoRender","MATH_CONST","Video","Extends","Mixins","Alpha","BlendMode","Depth","Flip","GetBounds","Mask","Origin","Pipeline","ScrollFactor","Size","TextureCrop","Tint","Transform","Visible","initialize","scene","x","y","key","call","video","videoTexture","videoTextureSource","snapshotTexture","flipY","_key","touchLocked","playWhenUnlocked","retryLimit","retry","retryInterval","_retryID","_systemMuted","_codeMuted","_systemPaused","_codePaused","_callbacks","play","playHandler","bind","error","loadErrorHandler","end","completeHandler","time","timeUpdateHandler","seeking","seekingHandler","seeked","seekedHandler","_crop","resetCropObject","markers","_markerIn","_markerOut","MAX_SAFE_INTEGER","_lastUpdate","_cacheKey","_isSeeking","removeVideoElementOnDestroy","setPosition","initPipeline","changeSource","game","sys","events","on","PAUSE","globalPause","RESUME","globalResume","sound","GLOBAL_MUTE","globalMute","loop","markerIn","markerOut","isPlaying","console","warn","undefined","mute","setMute","isNaN","callbacks","playPromise","then","playPromiseSuccessHandler","catch","playPromiseErrorHandler","addEventListener","readyState","window","setTimeout","checkVideoProgress","autoplay","currentVideo","stop","newVideo","cache","get","paused","muted","textures","remove","create","videoWidth","videoHeight","source","add","setTexture","setSizeToFrame","updateDisplayOrigin","emit","VIDEO_CREATED","updateTexture","currentTime","addMarker","playMarker","marker","removeMarker","snapshot","width","height","snapshotArea","srcWidth","srcHeight","destWidth","destHeight","snap","createCanvas","context","drawImage","setSize","update","saveSnapshotTexture","renameTexture","loadURL","url","loadEvent","noAudio","document","createElement","controls","defaultMuted","setAttribute","src","load","VIDEO_PLAY","input","once","unlockHandler","VIDEO_ERROR","removeEventListener","event","VIDEO_UNLOCKED","VIDEO_COMPLETE","VIDEO_LOOP","preUpdate","VIDEO_TIMEOUT","textureSource","getVideoKey","seekTo","value","duration","Infinity","seekTime","setCurrentTime","getCurrentTime","op","num","parseFloat","substr","isSeeking","VIDEO_SEEKING","VIDEO_SEEKED","getProgress","now","getDuration","isMuted","soundManager","pause","setPaused","getVolume","volume","setVolume","getPlaybackRate","playbackRate","setPlaybackRate","rate","getLoop","setLoop","ended","isPaused","saveTexture","setFlipY","callback","clearTimeout","VIDEO_STOP","removeVideoElement","parentNode","removeChild","hasChildNodes","firstChild","removeAttribute","preDestroy","off","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Clamp = require('../../math/Clamp');\r\nvar Components = require('../components');\r\nvar Events = require('../events');\r\nvar GameEvents = require('../../core/events/');\r\nvar GameObject = require('../GameObject');\r\nvar SoundEvents = require('../../sound/events/');\r\nvar UUID = require('../../utils/string/UUID');\r\nvar VideoRender = require('./VideoRender');\r\nvar MATH_CONST = require('../../math/const');\r\n\r\n/**\r\n * @classdesc\r\n * A Video Game Object.\r\n * \r\n * This Game Object is capable of handling playback of a previously loaded video from the Phaser Video Cache,\r\n * or playing a video based on a given URL. Videos can be either local, or streamed.\r\n * \r\n * ```javascript\r\n * preload () {\r\n *   this.load.video('pixar', 'nemo.mp4');\r\n * }\r\n * \r\n * create () {\r\n *   this.add.video(400, 300, 'pixar');\r\n * }\r\n * ```\r\n * \r\n * To all intents and purposes, a video is a standard Game Object, just like a Sprite. And as such, you can do\r\n * all the usual things to it, such as scaling, rotating, cropping, tinting, making interactive, giving a\r\n * physics body, etc.\r\n * \r\n * Transparent videos are also possible via the WebM file format. Providing the video file has was encoded with\r\n * an alpha channel, and providing the browser supports WebM playback (not all of them do), then it will render\r\n * in-game with full transparency.\r\n * \r\n * ### Autoplaying Videos\r\n * \r\n * Videos can only autoplay if the browser has been unlocked with an interaction, or satisfies the MEI settings.\r\n * The policies that control autoplaying are vast and vary between browser.\r\n * You can, ahd should, read more about it here: https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide\r\n * \r\n * If your video doesn't contain any audio, then set the `noAudio` parameter to `true` when the video is _loaded_,\r\n * and it will often allow the video to play immediately:\r\n * \r\n * ```javascript\r\n * preload () {\r\n *   this.load.video('pixar', 'nemo.mp4', 'loadeddata', false, true);\r\n * }\r\n * ```\r\n * \r\n * The 5th parameter in the load call tells Phaser that the video doesn't contain any audio tracks. Video without\r\n * audio can autoplay without requiring a user interaction. Video with audio cannot do this unless it satisfies\r\n * the browsers MEI settings. See the MDN Autoplay Guide for further details.\r\n * \r\n * Note that due to a bug in IE11 you cannot play a video texture to a Sprite in WebGL. For IE11 force Canvas mode.\r\n * \r\n * More details about video playback and the supported media formats can be found on MDN:\r\n * \r\n * https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement\r\n * https://developer.mozilla.org/en-US/docs/Web/Media/Formats\r\n *\r\n * @class Video\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.20.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.TextureCrop\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} [key] - Optional key of the Video this Game Object will play, as stored in the Video Cache.\r\n */\r\nvar Video = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Size,\r\n        Components.TextureCrop,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        VideoRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Video (scene, x, y, key)\r\n    {\r\n        GameObject.call(this, scene, 'Video');\r\n\r\n        /**\r\n         * A reference to the HTML Video Element this Video Game Object is playing.\r\n         * Will be `null` until a video is loaded for playback.\r\n         *\r\n         * @name Phaser.GameObjects.Video#video\r\n         * @type {?HTMLVideoElement}\r\n         * @since 3.20.0\r\n         */\r\n        this.video = null;\r\n\r\n        /**\r\n         * The Phaser Texture this Game Object is using to render the video to.\r\n         * Will be `null` until a video is loaded for playback.\r\n         *\r\n         * @name Phaser.GameObjects.Video#videoTexture\r\n         * @type {?Phaser.Textures.Texture}\r\n         * @since 3.20.0\r\n         */\r\n        this.videoTexture = null;\r\n\r\n        /**\r\n         * A reference to the TextureSource belong to the `videoTexture` Texture object.\r\n         * Will be `null` until a video is loaded for playback.\r\n         *\r\n         * @name Phaser.GameObjects.Video#videoTextureSource\r\n         * @type {?Phaser.Textures.TextureSource}\r\n         * @since 3.20.0\r\n         */\r\n        this.videoTextureSource = null;\r\n\r\n        /**\r\n         * A Phaser CanvasTexture instance that holds the most recent snapshot taken from the video.\r\n         * This will only be set if `snapshot` or `snapshotArea` have been called, and will be `null` until that point.\r\n         *\r\n         * @name Phaser.GameObjects.Video#snapshotTexture\r\n         * @type {?Phaser.Textures.CanvasTexture}\r\n         * @since 3.20.0\r\n         */\r\n        this.snapshotTexture = null;\r\n\r\n        /**\r\n         * If you have saved this video to a texture via the `saveTexture` method, this controls if the video\r\n         * is rendered with `flipY` in WebGL or not. You often need to set this if you wish to use the video texture\r\n         * as the input source for a shader. If you find your video is appearing upside down within a shader or\r\n         * custom pipeline, flip this property.\r\n         *\r\n         * @name Phaser.GameObjects.Video#flipY\r\n         * @type {boolean}\r\n         * @since 3.20.0\r\n         */\r\n        this.flipY = false;\r\n\r\n        /**\r\n         * The key used by the texture as stored in the Texture Manager.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_key\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._key = UUID();\r\n\r\n        /**\r\n         * An internal flag holding the current state of the video lock, should document interaction be required\r\n         * before playback can begin.\r\n         *\r\n         * @name Phaser.GameObjects.Video#touchLocked\r\n         * @type {boolean}\r\n         * @since 3.20.0\r\n         */\r\n        this.touchLocked = true;\r\n\r\n        /**\r\n         * Should the video auto play when document interaction is required and happens?\r\n         *\r\n         * @name Phaser.GameObjects.Video#playWhenUnlocked\r\n         * @type {boolean}\r\n         * @since 3.20.0\r\n         */\r\n        this.playWhenUnlocked = false;\r\n\r\n        /**\r\n         * When starting playback of a video Phaser will monitor its `readyState` using a `setTimeout` call.\r\n         * The `setTimeout` happens once every `Video.retryInterval` ms. It will carry on monitoring the video\r\n         * state in this manner until the `retryLimit` is reached and then abort.\r\n         *\r\n         * @name Phaser.GameObjects.Video#retryLimit\r\n         * @type {integer}\r\n         * @since 3.20.0\r\n         */\r\n        this.retryLimit = 20;\r\n\r\n        /**\r\n         * The current retry attempt.\r\n         *\r\n         * @name Phaser.GameObjects.Video#retry\r\n         * @type {integer}\r\n         * @since 3.20.0\r\n         */\r\n        this.retry = 0;\r\n\r\n        /**\r\n         * The number of ms between each retry while monitoring the ready state of a downloading video.\r\n         *\r\n         * @name Phaser.GameObjects.Video#retryInterval\r\n         * @type {integer}\r\n         * @since 3.20.0\r\n         */\r\n        this.retryInterval = 500;\r\n\r\n        /**\r\n         * The setTimeout callback ID.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_retryID\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._retryID = null;\r\n\r\n        /**\r\n         * The video was muted due to a system event, such as the game losing focus.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_systemMuted\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._systemMuted = false;\r\n\r\n        /**\r\n         * The video was muted due to game code, not a system event.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_codeMuted\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._codeMuted = false;\r\n\r\n        /**\r\n         * The video was paused due to a system event, such as the game losing focus.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_systemPaused\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._systemPaused = false;\r\n\r\n        /**\r\n         * The video was paused due to game code, not a system event.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_codePaused\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._codePaused = false;\r\n\r\n        /**\r\n         * The locally bound event callback handlers.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_callbacks\r\n         * @type {any}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._callbacks = {\r\n            play: this.playHandler.bind(this),\r\n            error: this.loadErrorHandler.bind(this),\r\n            end: this.completeHandler.bind(this),\r\n            time: this.timeUpdateHandler.bind(this),\r\n            seeking: this.seekingHandler.bind(this),\r\n            seeked: this.seekedHandler.bind(this)\r\n        };\r\n\r\n        /**\r\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_crop\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._crop = this.resetCropObject();\r\n\r\n        /**\r\n         * An object containing in and out markers for sequence playback.\r\n         *\r\n         * @name Phaser.GameObjects.Video#markers\r\n         * @type {any}\r\n         * @since 3.20.0\r\n         */\r\n        this.markers = {};\r\n\r\n        /**\r\n         * The in marker.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_markerIn\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._markerIn = -1;\r\n\r\n        /**\r\n         * The out marker.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_markerOut\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._markerOut = MATH_CONST.MAX_SAFE_INTEGER;\r\n\r\n        /**\r\n         * The last time the TextureSource was updated.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_lastUpdate\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._lastUpdate = 0;\r\n\r\n        /**\r\n         * The key of the video being played from the Video cache, if any.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_cacheKey\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._cacheKey = '';\r\n\r\n        /**\r\n         * Is the video currently seeking?\r\n         *\r\n         * @name Phaser.GameObjects.Video#_isSeeking\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._isSeeking = false;\r\n\r\n        /**\r\n         * Should the Video element that this Video is using, be removed from the DOM\r\n         * when this Video is destroyed?\r\n         *\r\n         * @name Phaser.GameObjects.Video#removeVideoElementOnDestroy\r\n         * @type {boolean}\r\n         * @since 3.21.0\r\n         */\r\n        this.removeVideoElementOnDestroy = false;\r\n\r\n        this.setPosition(x, y);\r\n        this.initPipeline();\r\n\r\n        if (key)\r\n        {\r\n            this.changeSource(key, false);\r\n        }\r\n\r\n        var game = scene.sys.game.events;\r\n\r\n        game.on(GameEvents.PAUSE, this.globalPause, this);\r\n        game.on(GameEvents.RESUME, this.globalResume, this);\r\n\r\n        var sound = scene.sys.sound;\r\n\r\n        if (sound)\r\n        {\r\n            sound.on(SoundEvents.GLOBAL_MUTE, this.globalMute, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Starts this video playing.\r\n     *\r\n     * If the video is already playing, or has been queued to play with `changeSource` then this method just returns.\r\n     * \r\n     * Videos can only autoplay if the browser has been unlocked. This happens if you have interacted with the browser, i.e.\r\n     * by clicking on it or pressing a key, or due to server settings. The policies that control autoplaying are vast and\r\n     * vary between browser. You can read more here: https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide\r\n     * \r\n     * If your video doesn't contain any audio, then set the `noAudio` parameter to `true` when the video is loaded,\r\n     * and it will often allow the video to play immediately:\r\n     * \r\n     * ```javascript\r\n     * preload () {\r\n     *   this.load.video('pixar', 'nemo.mp4', 'loadeddata', false, true);\r\n     * }\r\n     * ```\r\n     * \r\n     * The 5th parameter in the load call tells Phaser that the video doesn't contain any audio tracks. Video without\r\n     * audio can autoplay without requiring a user interaction. Video with audio cannot do this unless it satisfies\r\n     * the browsers MEI settings. See the MDN Autoplay Guide for details.\r\n     * \r\n     * If you need audio in your videos, then you'll have to consider the fact that the video cannot start playing until the\r\n     * user has interacted with the browser, into your game flow.\r\n     *\r\n     * @method Phaser.GameObjects.Video#play\r\n     * @since 3.20.0\r\n     * \r\n     * @param {boolean} [loop=false] - Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats.\r\n     * @param {integer} [markerIn] - Optional in marker time, in seconds, for playback of a sequence of the video.\r\n     * @param {integer} [markerOut] - Optional out marker time, in seconds, for playback of a sequence of the video.\r\n     * \r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    play: function (loop, markerIn, markerOut)\r\n    {\r\n        if ((this.touchLocked && this.playWhenUnlocked) || this.isPlaying())\r\n        {\r\n            return this;\r\n        }\r\n\r\n        var video = this.video;\r\n\r\n        if (!video)\r\n        {\r\n            console.warn('Video not loaded');\r\n\r\n            return this;\r\n        }\r\n\r\n        if (loop === undefined) { loop = video.loop; }\r\n\r\n        var sound = this.scene.sys.sound;\r\n        \r\n        if (sound && sound.mute)\r\n        {\r\n            //  Mute will be set based on the global mute state of the Sound Manager (if there is one)\r\n            this.setMute(true);\r\n        }\r\n\r\n        if (!isNaN(markerIn))\r\n        {\r\n            this._markerIn = markerIn;\r\n        }\r\n\r\n        if (!isNaN(markerOut) && markerOut > markerIn)\r\n        {\r\n            this._markerOut = markerOut;\r\n        }\r\n\r\n        video.loop = loop;\r\n\r\n        var callbacks = this._callbacks;\r\n\r\n        var playPromise = video.play();\r\n\r\n        if (playPromise !== undefined)\r\n        {\r\n            playPromise.then(this.playPromiseSuccessHandler.bind(this)).catch(this.playPromiseErrorHandler.bind(this));\r\n        }\r\n        else\r\n        {\r\n            //  Old-school browsers with no Promises\r\n            video.addEventListener('playing', callbacks.play, true);\r\n\r\n            //  If video hasn't downloaded properly yet ...\r\n            if (video.readyState < 2)\r\n            {\r\n                this.retry = this.retryLimit;\r\n\r\n                this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);\r\n            }\r\n        }\r\n\r\n        //  Set these _after_ calling `play` or they don't fire (useful, thanks browsers)\r\n        video.addEventListener('ended', callbacks.end, true);\r\n        video.addEventListener('timeupdate', callbacks.time, true);\r\n        video.addEventListener('seeking', callbacks.seeking, true);\r\n        video.addEventListener('seeked', callbacks.seeked, true);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This method allows you to change the source of the current video element. It works by first stopping the\r\n     * current video, if playing. Then deleting the video texture, if one has been created. Finally, it makes a\r\n     * new video texture and starts playback of the new source through the existing video element.\r\n     * \r\n     * The reason you may wish to do this is because videos that require interaction to unlock, remain in an unlocked\r\n     * state, even if you change the source of the video. By changing the source to a new video you avoid having to\r\n     * go through the unlock process again.\r\n     *\r\n     * @method Phaser.GameObjects.Video#changeSource\r\n     * @since 3.20.0\r\n     * \r\n     * @param {string} key - The key of the Video this Game Object will swap to playing, as stored in the Video Cache.\r\n     * @param {boolean} [autoplay=true] - Should the video start playing immediately, once the swap is complete?\r\n     * @param {boolean} [loop=false] - Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats.\r\n     * @param {integer} [markerIn] - Optional in marker time, in seconds, for playback of a sequence of the video.\r\n     * @param {integer} [markerOut] - Optional out marker time, in seconds, for playback of a sequence of the video.\r\n     * \r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    changeSource: function (key, autoplay, loop, markerIn, markerOut)\r\n    {\r\n        if (autoplay === undefined) { autoplay = true; }\r\n\r\n        var currentVideo = this.video;\r\n\r\n        if (currentVideo)\r\n        {\r\n            this.stop();\r\n        }\r\n\r\n        var newVideo = this.scene.sys.cache.video.get(key);\r\n\r\n        if (newVideo)\r\n        {\r\n            this.video = newVideo;\r\n\r\n            this._cacheKey = key;\r\n\r\n            this._codePaused = newVideo.paused;\r\n            this._codeMuted = newVideo.muted;\r\n\r\n            if (this.videoTexture)\r\n            {\r\n                this.scene.sys.textures.remove(this._key);\r\n\r\n                this.videoTexture = this.scene.sys.textures.create(this._key, newVideo, newVideo.videoWidth, newVideo.videoHeight);\r\n                this.videoTextureSource = this.videoTexture.source[0];\r\n                this.videoTexture.add('__BASE', 0, 0, 0, newVideo.videoWidth, newVideo.videoHeight);\r\n        \r\n                this.setTexture(this.videoTexture);\r\n                this.setSizeToFrame();\r\n                this.updateDisplayOrigin();\r\n\r\n                this.emit(Events.VIDEO_CREATED, this, newVideo.videoWidth, newVideo.videoHeight);\r\n            }\r\n            else\r\n            {\r\n                this.updateTexture();\r\n            }\r\n\r\n            newVideo.currentTime = 0;\r\n\r\n            this._lastUpdate = 0;\r\n\r\n            if (autoplay)\r\n            {\r\n                this.play(loop, markerIn, markerOut);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.video = null;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a sequence marker to this video.\r\n     * \r\n     * Markers allow you to split a video up into sequences, delineated by a start and end time, given in seconds.\r\n     * \r\n     * You can then play back specific markers via the `playMarker` method.\r\n     * \r\n     * Note that marker timing is _not_ frame-perfect. You should construct your videos in such a way that you allow for\r\n     * plenty of extra padding before and after each sequence to allow for discrepancies in browser seek and currentTime accuracy.\r\n     * \r\n     * See https://github.com/w3c/media-and-entertainment/issues/4 for more details about this issue.\r\n     *\r\n     * @method Phaser.GameObjects.Video#addMarker\r\n     * @since 3.20.0\r\n     * \r\n     * @param {string} key - A unique name to give this marker.\r\n     * @param {integer} markerIn - The time, in seconds, representing the start of this marker.\r\n     * @param {integer} markerOut - The time, in seconds, representing the end of this marker.\r\n     * \r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    addMarker: function (key, markerIn, markerOut)\r\n    {\r\n        if (!isNaN(markerIn) && markerIn >= 0 && !isNaN(markerOut))\r\n        {\r\n            this.markers[key] = [ markerIn, markerOut ];\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Plays a pre-defined sequence in this video.\r\n     * \r\n     * Markers allow you to split a video up into sequences, delineated by a start and end time, given in seconds and\r\n     * specified via the `addMarker` method.\r\n     * \r\n     * Note that marker timing is _not_ frame-perfect. You should construct your videos in such a way that you allow for\r\n     * plenty of extra padding before and after each sequence to allow for discrepancies in browser seek and currentTime accuracy.\r\n     * \r\n     * See https://github.com/w3c/media-and-entertainment/issues/4 for more details about this issue.\r\n     *\r\n     * @method Phaser.GameObjects.Video#playMarker\r\n     * @since 3.20.0\r\n     * \r\n     * @param {string} key - The name of the marker sequence to play.\r\n     * @param {boolean} [loop=false] - Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats.\r\n     * \r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    playMarker: function (key, loop)\r\n    {\r\n        var marker = this.markers[key];\r\n\r\n        if (marker)\r\n        {\r\n            this.play(loop, marker[0], marker[1]);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a previously set marker from this video.\r\n     * \r\n     * If the marker is currently playing it will _not_ stop playback.\r\n     *\r\n     * @method Phaser.GameObjects.Video#removeMarker\r\n     * @since 3.20.0\r\n     * \r\n     * @param {string} key - The name of the marker to remove.\r\n     * \r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    removeMarker: function (key)\r\n    {\r\n        delete this.markers[key];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the current frame of the video and renders it to a CanvasTexture object,\r\n     * which is then returned. You can optionally resize the grab by passing a width and height.\r\n     * \r\n     * This method returns a reference to the `Video.snapshotTexture` object. Calling this method\r\n     * multiple times will overwrite the previous snapshot with the most recent one.\r\n     *\r\n     * @method Phaser.GameObjects.Video#snapshot\r\n     * @since 3.20.0\r\n     * \r\n     * @param {integer} [width] - The width of the resulting CanvasTexture.\r\n     * @param {integer} [height] - The height of the resulting CanvasTexture.\r\n     * \r\n     * @return {Phaser.Textures.CanvasTexture} \r\n     */\r\n    snapshot: function (width, height)\r\n    {\r\n        if (width === undefined) { width = this.width; }\r\n        if (height === undefined) { height = this.height; }\r\n\r\n        return this.snapshotArea(0, 0, this.width, this.height, width, height);\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the specified area of the current frame of the video and renders it to a CanvasTexture object,\r\n     * which is then returned. You can optionally resize the grab by passing a different `destWidth` and `destHeight`.\r\n     * \r\n     * This method returns a reference to the `Video.snapshotTexture` object. Calling this method\r\n     * multiple times will overwrite the previous snapshot with the most recent one.\r\n     *\r\n     * @method Phaser.GameObjects.Video#snapshotArea\r\n     * @since 3.20.0\r\n     * \r\n     * @param {integer} [x=0] - The horizontal location of the top-left of the area to grab from.\r\n     * @param {integer} [y=0] - The vertical location of the top-left of the area to grab from.\r\n     * @param {integer} [srcWidth] - The width of area to grab from the video. If not given it will grab the full video dimensions.\r\n     * @param {integer} [srcHeight] - The height of area to grab from the video. If not given it will grab the full video dimensions.\r\n     * @param {integer} [destWidth] - The destination width of the grab, allowing you to resize it.\r\n     * @param {integer} [destHeight] - The destination height of the grab, allowing you to resize it.\r\n     * \r\n     * @return {Phaser.Textures.CanvasTexture} \r\n     */\r\n    snapshotArea: function (x, y, srcWidth, srcHeight, destWidth, destHeight)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (srcWidth === undefined) { srcWidth = this.width; }\r\n        if (srcHeight === undefined) { srcHeight = this.height; }\r\n        if (destWidth === undefined) { destWidth = srcWidth; }\r\n        if (destHeight === undefined) { destHeight = srcHeight; }\r\n\r\n        var video = this.video;\r\n        var snap = this.snapshotTexture;\r\n\r\n        if (!snap)\r\n        {\r\n            snap = this.scene.sys.textures.createCanvas(UUID(), destWidth, destHeight);\r\n\r\n            this.snapshotTexture = snap;\r\n\r\n            if (video)\r\n            {\r\n                snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            snap.setSize(destWidth, destHeight);\r\n\r\n            if (video)\r\n            {\r\n                snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);\r\n            }\r\n        }\r\n\r\n        return snap.update();\r\n    },\r\n\r\n    /**\r\n     * Stores a copy of this Videos `snapshotTexture` in the Texture Manager using the given key.\r\n     * \r\n     * This texture is created when the `snapshot` or `snapshotArea` methods are called.\r\n     * \r\n     * After doing this, any texture based Game Object, such as a Sprite, can use the contents of the\r\n     * snapshot by using the texture key:\r\n     * \r\n     * ```javascript\r\n     * var vid = this.add.video(0, 0, 'intro');\r\n     * \r\n     * vid.snapshot();\r\n     * \r\n     * vid.saveSnapshotTexture('doodle');\r\n     * \r\n     * this.add.image(400, 300, 'doodle');\r\n     * ```\r\n     * \r\n     * Updating the contents of the `snapshotTexture`, for example by calling `snapshot` again,\r\n     * will automatically update _any_ Game Object that is using it as a texture.\r\n     * Calling `saveSnapshotTexture` again will not save another copy of the same texture,\r\n     * it will just rename the existing one.\r\n     * \r\n     * By default it will create a single base texture. You can add frames to the texture\r\n     * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n     * to use a specific frame.\r\n     *\r\n     * @method Phaser.GameObjects.Video#saveSnapshotTexture\r\n     * @since 3.20.0\r\n     *\r\n     * @param {string} key - The unique key to store the texture as within the global Texture Manager.\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} The Texture that was saved.\r\n     */\r\n    saveSnapshotTexture: function (key)\r\n    {\r\n        if (this.snapshotTexture)\r\n        {\r\n            this.scene.sys.textures.renameTexture(this.snapshotTexture.key, key);\r\n        }\r\n        else\r\n        {\r\n            this.snapshotTexture = this.scene.sys.textures.createCanvas(key, this.width, this.height);\r\n        }\r\n\r\n        return this.snapshotTexture;\r\n    },\r\n\r\n    /**\r\n     * Loads a Video from the given URL, ready for playback with the `Video.play` method.\r\n     * \r\n     * You can control at what point the browser determines the video as being ready for playback via\r\n     * the `loadEvent` parameter. See https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement\r\n     * for more details.\r\n     *\r\n     * @method Phaser.GameObjects.Video#loadURL\r\n     * @since 3.20.0\r\n     * \r\n     * @param {string} url - The URL of the video to load or be streamed.\r\n     * @param {string} [loadEvent='loadeddata'] - The load event to listen for. Either `loadeddata`, `canplay` or `canplaythrough`.\r\n     * @param {boolean} [noAudio=false] - Does the video have an audio track? If not you can enable auto-playing on it.\r\n     * \r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    loadURL: function (url, loadEvent, noAudio)\r\n    {\r\n        if (loadEvent === undefined) { loadEvent = 'loadeddata'; }\r\n        if (noAudio === undefined) { noAudio = false; }\r\n\r\n        if (this.video)\r\n        {\r\n            this.stop();\r\n        }\r\n\r\n        if (this.videoTexture)\r\n        {\r\n            this.scene.sys.textures.remove(this._key);\r\n        }\r\n\r\n        var video = document.createElement('video');\r\n    \r\n        video.controls = false;\r\n\r\n        if (noAudio)\r\n        {\r\n            video.muted = true;\r\n            video.defaultMuted = true;\r\n\r\n            video.setAttribute('autoplay', 'autoplay');\r\n        }\r\n\r\n        video.setAttribute('playsinline', 'playsinline');\r\n        video.setAttribute('preload', 'auto');\r\n\r\n        video.addEventListener('error', this._callbacks.error, true);\r\n\r\n        video.src = url;\r\n\r\n        video.load();\r\n\r\n        this.video = video;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This internal method is called automatically if the playback Promise resolves successfully.\r\n     *\r\n     * @method Phaser.GameObjects.Video#playPromiseSuccessHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_PLAY\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    playPromiseSuccessHandler: function ()\r\n    {\r\n        this.touchLocked = false;\r\n\r\n        this.emit(Events.VIDEO_PLAY, this);\r\n\r\n        if (this._markerIn > -1)\r\n        {\r\n            this.video.currentTime = this._markerIn;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * This internal method is called automatically if the playback Promise fails to resolve.\r\n     *\r\n     * @method Phaser.GameObjects.Video#playPromiseErrorHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_ERROR\r\n     * @private\r\n     * @since 3.20.0\r\n     * \r\n     * @param {any} error - The Promise resolution error.\r\n     */\r\n    playPromiseErrorHandler: function (error)\r\n    {\r\n        this.scene.sys.input.once('pointerdown', this.unlockHandler, this);\r\n\r\n        this.touchLocked = true;\r\n        this.playWhenUnlocked = true;\r\n\r\n        this.emit(Events.VIDEO_ERROR, this, error);\r\n    },\r\n\r\n    /**\r\n     * Called when the video emits a `playing` event during load.\r\n     * \r\n     * This is only listened for if the browser doesn't support Promises.\r\n     *\r\n     * @method Phaser.GameObjects.Video#playHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_PLAY\r\n     * @since 3.20.0\r\n     */\r\n    playHandler: function ()\r\n    {\r\n        this.touchLocked = false;\r\n\r\n        this.emit(Events.VIDEO_PLAY, this);\r\n       \r\n        this.video.removeEventListener('playing', this._callbacks.play, true);\r\n    },\r\n\r\n    /**\r\n     * This internal method is called automatically if the video fails to load.\r\n     *\r\n     * @method Phaser.GameObjects.Video#loadErrorHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_ERROR\r\n     * @private\r\n     * @since 3.20.0\r\n     * \r\n     * @param {Event} event - The error Event.\r\n     */\r\n    loadErrorHandler: function (event)\r\n    {\r\n        this.stop();\r\n\r\n        this.emit(Events.VIDEO_ERROR, this, event);\r\n    },\r\n\r\n    /**\r\n     * This internal method is called if the video couldn't be played because it was interaction locked\r\n     * by the browser, but an input event has since been received.\r\n     *\r\n     * @method Phaser.GameObjects.Video#unlockHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_UNLOCKED\r\n     * @fires Phaser.GameObjects.Events#VIDEO_PLAY\r\n     * @private\r\n     * @since 3.20.0\r\n     * \r\n     * @param {any} error - The Promise resolution error.\r\n     */\r\n    unlockHandler: function ()\r\n    {\r\n        this.touchLocked = false;\r\n        this.playWhenUnlocked = false;\r\n\r\n        this.emit(Events.VIDEO_UNLOCKED, this);\r\n\r\n        if (this._markerIn > -1)\r\n        {\r\n            this.video.currentTime = this._markerIn;\r\n        }\r\n\r\n        this.video.play();\r\n\r\n        this.emit(Events.VIDEO_PLAY, this);\r\n    },\r\n\r\n    /**\r\n     * Called when the video completes playback, i.e. reaches an `ended` state.\r\n     * \r\n     * This will never happen if the video is coming from a live stream, where the duration is `Infinity`.\r\n     *\r\n     * @method Phaser.GameObjects.Video#completeHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_COMPLETE\r\n     * @since 3.20.0\r\n     */\r\n    completeHandler: function ()\r\n    {\r\n        this.emit(Events.VIDEO_COMPLETE, this);\r\n    },\r\n\r\n    /**\r\n     * Called when the video emits a `timeUpdate` event during playback.\r\n     * \r\n     * This event is too slow and irregular to be used for actual video timing or texture updating,\r\n     * but we can use it to determine if a video has looped.\r\n     *\r\n     * @method Phaser.GameObjects.Video#timeUpdateHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_LOOP\r\n     * @since 3.20.0\r\n     */\r\n    timeUpdateHandler: function ()\r\n    {\r\n        if (this.video && this.video.currentTime < this._lastUpdate)\r\n        {\r\n            this.emit(Events.VIDEO_LOOP, this);\r\n\r\n            this._lastUpdate = 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The internal update step.\r\n     *\r\n     * @method Phaser.GameObjects.Video#preUpdate\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    preUpdate: function ()\r\n    {\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            var currentTime = video.currentTime;\r\n\r\n            //  Don't render a new frame unless the video has actually changed time\r\n            if (currentTime !== this._lastUpdate)\r\n            {\r\n                this._lastUpdate = currentTime;\r\n\r\n                this.updateTexture();\r\n\r\n                if (currentTime >= this._markerOut)\r\n                {\r\n                    if (video.loop)\r\n                    {\r\n                        video.currentTime = this._markerIn;\r\n\r\n                        this.updateTexture();\r\n\r\n                        this._lastUpdate = currentTime;\r\n\r\n                        this.emit(Events.VIDEO_LOOP, this);\r\n                    }\r\n                    else\r\n                    {\r\n                        this.emit(Events.VIDEO_COMPLETE, this);\r\n\r\n                        this.stop();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal callback that monitors the download progress of a video after changing its source.\r\n     *\r\n     * @method Phaser.GameObjects.Video#checkVideoProgress\r\n     * @fires Phaser.GameObjects.Events#VIDEO_TIMEOUT\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    checkVideoProgress: function ()\r\n    {\r\n        if (this.video.readyState >= 2)\r\n        {\r\n            //  We've got enough data to update the texture for playback\r\n            this.updateTexture();\r\n        }\r\n        else\r\n        {\r\n            this.retry--;\r\n\r\n            if (this.retry > 0)\r\n            {\r\n                this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);\r\n            }\r\n            else\r\n            {\r\n                this.emit(Events.VIDEO_TIMEOUT, this);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that is called when enough video data has been received in order to create a texture\r\n     * from it. The texture is assigned to the `Video.videoTexture` property and given a base frame that\r\n     * encompases the whole video size.\r\n     *\r\n     * @method Phaser.GameObjects.Video#updateTexture\r\n     * @since 3.20.0\r\n     */\r\n    updateTexture: function ()\r\n    {\r\n        var video = this.video;\r\n\r\n        var width = video.videoWidth;\r\n        var height = video.videoHeight;\r\n\r\n        if (!this.videoTexture)\r\n        {\r\n            this.videoTexture = this.scene.sys.textures.create(this._key, video, width, height);\r\n            this.videoTextureSource = this.videoTexture.source[0];\r\n            this.videoTexture.add('__BASE', 0, 0, 0, width, height);\r\n    \r\n            this.setTexture(this.videoTexture);\r\n            this.setSizeToFrame();\r\n            this.updateDisplayOrigin();\r\n    \r\n            this.emit(Events.VIDEO_CREATED, this, width, height);\r\n        }\r\n        else\r\n        {\r\n            var textureSource = this.videoTextureSource;\r\n\r\n            if (textureSource.source !== video)\r\n            {\r\n                textureSource.source = video;\r\n                textureSource.width = width;\r\n                textureSource.height = height;\r\n            }\r\n            \r\n            textureSource.update();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns the key of the currently played video, as stored in the Video Cache.\r\n     * If the video did not come from the cache this will return an empty string.\r\n     *\r\n     * @method Phaser.GameObjects.Video#getVideoKey\r\n     * @since 3.20.0\r\n     * \r\n     * @return {string} The key of the video being played from the Video Cache, if any.\r\n     */\r\n    getVideoKey: function ()\r\n    {\r\n        return this._cacheKey;\r\n    },\r\n\r\n    /**\r\n     * Seeks to a given point in the video. The value is given as a float between 0 and 1,\r\n     * where 0 represents the start of the video and 1 represents the end.\r\n     * \r\n     * Seeking only works if the video has a duration, so will not work for live streams.\r\n     * \r\n     * When seeking begins, this video will emit a `seeking` event. When the video completes\r\n     * seeking (i.e. reaches its designated timestamp) it will emit a `seeked` event.\r\n     * \r\n     * If you wish to seek based on time instead, use the `Video.setCurrentTime` method.\r\n     *\r\n     * @method Phaser.GameObjects.Video#seekTo\r\n     * @since 3.20.0\r\n     * \r\n     * @param {number} value - The point in the video to seek to. A value between 0 and 1.\r\n     * \r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    seekTo: function (value)\r\n    {\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            var duration = video.duration;\r\n\r\n            if (duration !== Infinity && !isNaN(duration))\r\n            {\r\n                var seekTime = duration * value;\r\n\r\n                this.setCurrentTime(seekTime);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * A double-precision floating-point value indicating the current playback time in seconds.\r\n     * If the media has not started to play and has not been seeked, this value is the media's initial playback time.\r\n     *\r\n     * @method Phaser.GameObjects.Video#getCurrentTime\r\n     * @since 3.20.0\r\n     * \r\n     * @return {number} A double-precision floating-point value indicating the current playback time in seconds.\r\n     */\r\n    getCurrentTime: function ()\r\n    {\r\n        return (this.video) ? this.video.currentTime : 0;\r\n    },\r\n\r\n    /**\r\n     * Seeks to a given playback time in the video. The value is given in _seconds_ or as a string.\r\n     * \r\n     * Seeking only works if the video has a duration, so will not work for live streams.\r\n     * \r\n     * When seeking begins, this video will emit a `seeking` event. When the video completes\r\n     * seeking (i.e. reaches its designated timestamp) it will emit a `seeked` event.\r\n     * \r\n     * You can provide a string prefixed with either a `+` or a `-`, such as `+2.5` or `-2.5`.\r\n     * In this case it will seek to +/- the value given, relative to the _current time_.\r\n     * \r\n     * If you wish to seek based on a duration percentage instead, use the `Video.seekTo` method.\r\n     *\r\n     * @method Phaser.GameObjects.Video#setCurrentTime\r\n     * @since 3.20.0\r\n     * \r\n     * @param {(string|number)} value - The playback time to seek to in seconds. Can be expressed as a string, such as `+2` to seek 2 seconds ahead from the current time.\r\n     * \r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setCurrentTime: function (value)\r\n    {\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            if (typeof value === 'string')\r\n            {\r\n                var op = value[0];\r\n                var num = parseFloat(value.substr(1));\r\n\r\n                if (op === '+')\r\n                {\r\n                    value = video.currentTime + num;\r\n                }\r\n                else if (op === '-')\r\n                {\r\n                    value = video.currentTime - num;\r\n                }\r\n            }\r\n\r\n            video.currentTime = value;\r\n\r\n            this._lastUpdate = value;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean indicating if this Video is currently seeking, or not.\r\n     *\r\n     * @method Phaser.GameObjects.Video#isSeeking\r\n     * @since 3.20.0\r\n     * \r\n     * @return {boolean} A boolean indicating if this Video is currently seeking, or not.\r\n     */\r\n    isSeeking: function ()\r\n    {\r\n        return this._isSeeking;\r\n    },\r\n\r\n    /**\r\n     * Internal seeking handler.\r\n     *\r\n     * @method Phaser.GameObjects.Video#seekingHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_SEEKING\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    seekingHandler: function ()\r\n    {\r\n        this._isSeeking = true;\r\n\r\n        this.emit(Events.VIDEO_SEEKING, this);\r\n    },\r\n\r\n    /**\r\n     * Internal seeked handler.\r\n     *\r\n     * @method Phaser.GameObjects.Video#seekedHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_SEEKED\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    seekedHandler: function ()\r\n    {\r\n        this._isSeeking = false;\r\n\r\n        this.emit(Events.VIDEO_SEEKED, this);\r\n\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            this.updateTexture();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns the current progress of the video. Progress is defined as a value between 0 (the start)\r\n     * and 1 (the end).\r\n     * \r\n     * Progress can only be returned if the video has a duration, otherwise it will always return zero.\r\n     *\r\n     * @method Phaser.GameObjects.Video#getProgress\r\n     * @since 3.20.0\r\n     * \r\n     * @return {number} The current progress of playback. If the video has no duration, will always return zero.\r\n     */\r\n    getProgress: function ()\r\n    {\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            var now = video.currentTime;\r\n            var duration = video.duration;\r\n\r\n            if (duration !== Infinity && !isNaN(duration))\r\n            {\r\n                return now / duration;\r\n            }\r\n        }\r\n        \r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * A double-precision floating-point value which indicates the duration (total length) of the media in seconds,\r\n     * on the media's timeline. If no media is present on the element, or the media is not valid, the returned value is NaN.\r\n     * \r\n     * If the media has no known end (such as for live streams of unknown duration, web radio, media incoming from WebRTC,\r\n     * and so forth), this value is +Infinity.\r\n     * \r\n     * @method Phaser.GameObjects.Video#getDuration\r\n     * @since 3.20.0\r\n     * \r\n     * @return {number} A double-precision floating-point value indicating the duration of the media in seconds.\r\n     */\r\n    getDuration: function ()\r\n    {\r\n        return (this.video) ? this.video.duration : 0;\r\n    },\r\n\r\n    /**\r\n     * Sets the muted state of the currently playing video, if one is loaded.\r\n     *\r\n     * @method Phaser.GameObjects.Video#setMute\r\n     * @since 3.20.0\r\n     * \r\n     * @param {boolean} [value=true] - The mute value. `true` if the video should be muted, otherwise `false`.\r\n     * \r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setMute: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this._codeMuted = value;\r\n\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            video.muted = (this._systemMuted) ? true : value;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean indicating if this Video is currently muted.\r\n     *\r\n     * @method Phaser.GameObjects.Video#isMuted\r\n     * @since 3.20.0\r\n     * \r\n     * @return {boolean} A boolean indicating if this Video is currently muted, or not.\r\n     */\r\n    isMuted: function ()\r\n    {\r\n        return this._codeMuted;\r\n    },\r\n\r\n    /**\r\n     * Internal global mute handler. Will mute the video, if playing, if the global sound system mutes.\r\n     *\r\n     * @method Phaser.GameObjects.Video#globalMute\r\n     * @private\r\n     * @since 3.20.0\r\n     * \r\n     * @param {(Phaser.Sound.WebAudioSoundManager|Phaser.Sound.HTML5AudioSoundManager)} soundManager - A reference to the Sound Manager that emitted the event.\r\n     * @param {boolean} mute - The mute value. `true` if the Sound Manager is now muted, otherwise `false`.\r\n     */\r\n    globalMute: function (soundManager, value)\r\n    {\r\n        this._systemMuted = value;\r\n\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            video.muted = (this._codeMuted) ? true : value;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal global pause handler. Will pause the video if the Game itself pauses.\r\n     *\r\n     * @method Phaser.GameObjects.Video#globalPause\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    globalPause: function ()\r\n    {\r\n        this._systemPaused = true;\r\n\r\n        if (this.video)\r\n        {\r\n            this.video.pause();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal global resume handler. Will resume a paused video if the Game itself resumes.\r\n     *\r\n     * @method Phaser.GameObjects.Video#globalResume\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    globalResume: function ()\r\n    {\r\n        this._systemPaused = false;\r\n\r\n        if (this.video && !this._codePaused)\r\n        {\r\n            this.video.play();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the paused state of the currently loaded video.\r\n     * \r\n     * If the video is playing, calling this method with `true` will pause playback.\r\n     * If the video is paused, calling this method with `false` will resume playback.\r\n     * \r\n     * If no video is loaded, this method does nothing.\r\n     *\r\n     * @method Phaser.GameObjects.Video#setPaused\r\n     * @since 3.20.0\r\n     * \r\n     * @param {boolean} [value=true] - The paused value. `true` if the video should be paused, `false` to resume it.\r\n     * \r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setPaused: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        var video = this.video;\r\n\r\n        this._codePaused = value;\r\n\r\n        if (video)\r\n        {\r\n            if (value)\r\n            {\r\n                if (!video.paused)\r\n                {\r\n                    video.pause();\r\n                }\r\n            }\r\n            else if (!value)\r\n            {\r\n                if (video.paused && !this._systemPaused)\r\n                {\r\n                    video.play();\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).\r\n     * \r\n     * @method Phaser.GameObjects.Video#getVolume\r\n     * @since 3.20.0\r\n     * \r\n     * @return {number} A double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).\r\n     */\r\n    getVolume: function ()\r\n    {\r\n        return (this.video) ? this.video.volume : 1;\r\n    },\r\n    \r\n    /**\r\n     * Sets the volume of the currently playing video.\r\n     * \r\n     * The value given is a double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).\r\n     * \r\n     * @method Phaser.GameObjects.Video#setVolume\r\n     * @since 3.20.0\r\n     * \r\n     * @param {number} [value=1] - A double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).\r\n     * \r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setVolume: function (value)\r\n    {\r\n        if (value === undefined) { value = 1; }\r\n\r\n        if (this.video)\r\n        {\r\n            this.video.volume = Clamp(value, 0, 1);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a double that indicates the rate at which the media is being played back.\r\n     * \r\n     * @method Phaser.GameObjects.Video#getPlaybackRate\r\n     * @since 3.20.0\r\n     * \r\n     * @return {number} A double that indicates the rate at which the media is being played back.\r\n     */\r\n    getPlaybackRate: function ()\r\n    {\r\n        return (this.video) ? this.video.playbackRate : 1;\r\n    },\r\n\r\n    /**\r\n     * Sets the playback rate of the current video.\r\n     * \r\n     * The value given is a double that indicates the rate at which the media is being played back.\r\n     * \r\n     * @method Phaser.GameObjects.Video#setPlaybackRate\r\n     * @since 3.20.0\r\n     * \r\n     * @param {number} [rate] - A double that indicates the rate at which the media is being played back.\r\n     * \r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setPlaybackRate: function (rate)\r\n    {\r\n        if (this.video)\r\n        {\r\n            this.video.playbackRate = rate;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean which indicates whether the media element should start over when it reaches the end.\r\n     * \r\n     * @method Phaser.GameObjects.Video#getLoop\r\n     * @since 3.20.0\r\n     * \r\n     * @return {boolean} A boolean which indicates whether the media element will start over when it reaches the end.\r\n     */\r\n    getLoop: function ()\r\n    {\r\n        return (this.video) ? this.video.loop : false;\r\n    },\r\n\r\n    /**\r\n     * Sets the loop state of the current video.\r\n     * \r\n     * The value given is a boolean which indicates whether the media element will start over when it reaches the end.\r\n     * \r\n     * Not all videos can loop, for example live streams.\r\n     * \r\n     * Please note that not all browsers support _seamless_ video looping for all encoding formats.\r\n     * \r\n     * @method Phaser.GameObjects.Video#setLoop\r\n     * @since 3.20.0\r\n     * \r\n     * @param {boolean} [value=true] - A boolean which indicates whether the media element will start over when it reaches the end.\r\n     * \r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setLoop: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        if (this.video)\r\n        {\r\n            this.video.loop = value;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean which indicates whether the video is currently playing.\r\n     * \r\n     * @method Phaser.GameObjects.Video#isPlaying\r\n     * @since 3.20.0\r\n     * \r\n     * @return {boolean} A boolean which indicates whether the video is playing, or not.\r\n     */\r\n    isPlaying: function ()\r\n    {\r\n        return (this.video) ? !(this.video.paused || this.video.ended) : false;\r\n    },\r\n    \r\n    /**\r\n     * Returns a boolean which indicates whether the video is currently paused.\r\n     * \r\n     * @method Phaser.GameObjects.Video#isPaused\r\n     * @since 3.20.0\r\n     * \r\n     * @return {boolean} A boolean which indicates whether the video is paused, or not.\r\n     */\r\n    isPaused: function ()\r\n    {\r\n        return ((this.video && this.video.paused) || this._codePaused || this._systemPaused);\r\n    },\r\n\r\n    /**\r\n     * Stores this Video in the Texture Manager using the given key as a dynamic texture,\r\n     * which any texture-based Game Object, such as a Sprite, can use as its texture:\r\n     * \r\n     * ```javascript\r\n     * var vid = this.add.video(0, 0, 'intro');\r\n     * \r\n     * vid.play();\r\n     * \r\n     * vid.saveTexture('doodle');\r\n     * \r\n     * this.add.image(400, 300, 'doodle');\r\n     * ```\r\n     * \r\n     * The saved texture is automatically updated as the video plays. If you pause this video,\r\n     * or change its source, then the saved texture updates instantly.\r\n     * \r\n     * Calling `saveTexture` again will not save another copy of the same texture, it will just rename the existing one.\r\n     * \r\n     * By default it will create a single base texture. You can add frames to the texture\r\n     * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n     * to use a specific frame.\r\n     * \r\n     * If you intend to save the texture so you can use it as the input for a Shader, you may need to set the\r\n     * `flipY` parameter to `true` if you find the video renders upside down in your shader.\r\n     *\r\n     * @method Phaser.GameObjects.Video#saveTexture\r\n     * @since 3.20.0\r\n     *\r\n     * @param {string} key - The unique key to store the texture as within the global Texture Manager.\r\n     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y` during upload?\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was saved.\r\n     */\r\n    saveTexture: function (key, flipY)\r\n    {\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        if (this.videoTexture)\r\n        {\r\n            this.scene.sys.textures.renameTexture(this._key, key);\r\n        }\r\n\r\n        this._key = key;\r\n\r\n        this.flipY = flipY;\r\n\r\n        if (this.videoTextureSource)\r\n        {\r\n            this.videoTextureSource.setFlipY(flipY);\r\n        }\r\n\r\n        return this.videoTexture;\r\n    },\r\n\r\n    /**\r\n     * Stops the video playing and clears all internal event listeners.\r\n     *\r\n     * If you only wish to pause playback of the video, and resume it a later time, use the `Video.pause` method instead.\r\n     * \r\n     * If the video hasn't finished downloading, calling this method will not abort the download. To do that you need to\r\n     * call `destroy` instead.\r\n     *\r\n     * @method Phaser.GameObjects.Video#stop\r\n     * @fires Phaser.GameObjects.Events#VIDEO_STOP\r\n     * @since 3.20.0\r\n     * \r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    stop: function ()\r\n    {\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            var callbacks = this._callbacks;\r\n\r\n            for (var callback in callbacks)\r\n            {\r\n                video.removeEventListener(callback, callbacks[callback], true);\r\n            }\r\n\r\n            video.pause();\r\n        }\r\n\r\n        if (this._retryID)\r\n        {\r\n            window.clearTimeout(this._retryID);\r\n        }\r\n\r\n        this.emit(Events.VIDEO_STOP, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the Video element from the DOM by calling parentNode.removeChild on itself.\r\n     * \r\n     * Also removes the autoplay and src attributes and nulls the Video reference.\r\n     * \r\n     * You should not call this method if you were playing a video from the Video Cache that\r\n     * you wish to play again in your game, or if another Video object is also using the same\r\n     * video.\r\n     * \r\n     * If you loaded an external video via `Video.loadURL` then you should call this function\r\n     * to clear up once you are done with the instance.\r\n     *\r\n     * @method Phaser.GameObjects.Video#removeVideoElement\r\n     * @since 3.20.0\r\n     */\r\n    removeVideoElement: function ()\r\n    {\r\n        var video = this.video;\r\n\r\n        if (!video)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (video.parentNode)\r\n        {\r\n            video.parentNode.removeChild(video);\r\n        }\r\n\r\n        while (video.hasChildNodes())\r\n        {\r\n            video.removeChild(video.firstChild);\r\n        }\r\n\r\n        video.removeAttribute('autoplay');\r\n        video.removeAttribute('src');\r\n\r\n        this.video = null;\r\n    },\r\n\r\n    /**\r\n     * Handles the pre-destroy step for the Video object.\r\n     * \r\n     * This calls `Video.stop` and optionally `Video.removeVideoElement`.\r\n     * \r\n     * If any Sprites are using this Video as their texture it is up to you to manage those.\r\n     *\r\n     * @method Phaser.GameObjects.Video#preDestroy\r\n     * @private\r\n     * @since 3.21.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.stop();\r\n\r\n        if (this.removeVideoElementOnDestroy)\r\n        {\r\n            this.removeVideoElement();\r\n        }\r\n\r\n        var game = this.scene.sys.game.events;\r\n\r\n        game.off(GameEvents.PAUSE, this.globalPause, this);\r\n        game.off(GameEvents.RESUME, this.globalResume, this);\r\n\r\n        var sound = this.scene.sys.sound;\r\n\r\n        if (sound)\r\n        {\r\n            sound.off(SoundEvents.GLOBAL_MUTE, this.globalMute, this);\r\n        }\r\n\r\n        if (this._retryID)\r\n        {\r\n            window.clearTimeout(this._retryID);\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Video;\r\n"]},"metadata":{},"sourceType":"script"}