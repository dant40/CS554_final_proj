{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Circle = require('../geom/circle/Circle');\n\nvar CircleContains = require('../geom/circle/Contains');\n\nvar Class = require('../utils/Class');\n\nvar CONST = require('./const');\n\nvar CreateInteractiveObject = require('./CreateInteractiveObject');\n\nvar CreatePixelPerfectHandler = require('./CreatePixelPerfectHandler');\n\nvar DistanceBetween = require('../math/distance/DistanceBetween');\n\nvar Ellipse = require('../geom/ellipse/Ellipse');\n\nvar EllipseContains = require('../geom/ellipse/Contains');\n\nvar Events = require('./events');\n\nvar EventEmitter = require('eventemitter3');\n\nvar GetFastValue = require('../utils/object/GetFastValue');\n\nvar GEOM_CONST = require('../geom/const');\n\nvar InputPluginCache = require('./InputPluginCache');\n\nvar IsPlainObject = require('../utils/object/IsPlainObject');\n\nvar PluginCache = require('../plugins/PluginCache');\n\nvar Rectangle = require('../geom/rectangle/Rectangle');\n\nvar RectangleContains = require('../geom/rectangle/Contains');\n\nvar SceneEvents = require('../scene/events');\n\nvar Triangle = require('../geom/triangle/Triangle');\n\nvar TriangleContains = require('../geom/triangle/Contains');\n/**\r\n * @classdesc\r\n * The Input Plugin belongs to a Scene and handles all input related events and operations for it.\r\n *\r\n * You can access it from within a Scene using `this.input`.\r\n *\r\n * It emits events directly. For example, you can do:\r\n *\r\n * ```javascript\r\n * this.input.on('pointerdown', callback, context);\r\n * ```\r\n *\r\n * To listen for a pointer down event anywhere on the game canvas.\r\n *\r\n * Game Objects can be enabled for input by calling their `setInteractive` method. After which they\r\n * will directly emit input events:\r\n *\r\n * ```javascript\r\n * var sprite = this.add.sprite(x, y, texture);\r\n * sprite.setInteractive();\r\n * sprite.on('pointerdown', callback, context);\r\n * ```\r\n *\r\n * There are lots of game configuration options available relating to input.\r\n * See the [Input Config object]{@linkcode Phaser.Types.Core.InputConfig} for more details, including how to deal with Phaser\r\n * listening for input events outside of the canvas, how to set a default number of pointers, input\r\n * capture settings and more.\r\n *\r\n * Please also see the Input examples and tutorials for further information.\r\n *\r\n * @class InputPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that this Input Plugin is responsible for.\r\n */\n\n\nvar InputPlugin = new Class({\n  Extends: EventEmitter,\n  initialize: function InputPlugin(scene) {\n    EventEmitter.call(this);\n    /**\r\n     * A reference to the Scene that this Input Plugin is responsible for.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n\n    this.scene = scene;\n    /**\r\n     * A reference to the Scene Systems class.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#systems\r\n     * @type {Phaser.Scenes.Systems}\r\n     * @since 3.0.0\r\n     */\n\n    this.systems = scene.sys;\n    /**\r\n     * A reference to the Scene Systems Settings.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#settings\r\n     * @type {Phaser.Types.Scenes.SettingsObject}\r\n     * @since 3.5.0\r\n     */\n\n    this.settings = scene.sys.settings;\n    /**\r\n     * A reference to the Game Input Manager.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#manager\r\n     * @type {Phaser.Input.InputManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.manager = scene.sys.game.input;\n    /**\r\n     * Internal event queue used for plugins only.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pluginEvents\r\n     * @type {Phaser.Events.EventEmitter}\r\n     * @private\r\n     * @since 3.10.0\r\n     */\n\n    this.pluginEvents = new EventEmitter();\n    /**\r\n     * If `true` this Input Plugin will process DOM input events.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#enabled\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.5.0\r\n     */\n\n    this.enabled = true;\n    /**\r\n     * A reference to the Scene Display List. This property is set during the `boot` method.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#displayList\r\n     * @type {Phaser.GameObjects.DisplayList}\r\n     * @since 3.0.0\r\n     */\n\n    this.displayList;\n    /**\r\n     * A reference to the Scene Cameras Manager. This property is set during the `boot` method.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#cameras\r\n     * @type {Phaser.Cameras.Scene2D.CameraManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.cameras; //  Inject the available input plugins into this class\n\n    InputPluginCache.install(this);\n    /**\r\n     * A reference to the Mouse Manager.\r\n     *\r\n     * This property is only set if Mouse support has been enabled in your Game Configuration file.\r\n     *\r\n     * If you just wish to get access to the mouse pointer, use the `mousePointer` property instead.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#mouse\r\n     * @type {?Phaser.Input.Mouse.MouseManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.mouse = this.manager.mouse;\n    /**\r\n     * When set to `true` (the default) the Input Plugin will emulate DOM behavior by only emitting events from\r\n     * the top-most Game Objects in the Display List.\r\n     *\r\n     * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#topOnly\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.topOnly = true;\n    /**\r\n     * How often should the Pointers be checked?\r\n     *\r\n     * The value is a time, given in ms, and is the time that must have elapsed between game steps before\r\n     * the Pointers will be polled again. When a pointer is polled it runs a hit test to see which Game\r\n     * Objects are currently below it, or being interacted with it.\r\n     *\r\n     * Pointers will *always* be checked if they have been moved by the user, or press or released.\r\n     *\r\n     * This property only controls how often they will be polled if they have not been updated.\r\n     * You should set this if you want to have Game Objects constantly check against the pointers, even\r\n     * if the pointer didn't itself move.\r\n     *\r\n     * Set to 0 to poll constantly. Set to -1 to only poll on user movement.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pollRate\r\n     * @type {integer}\r\n     * @default -1\r\n     * @since 3.0.0\r\n     */\n\n    this.pollRate = -1;\n    /**\r\n     * Internal poll timer value.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_pollTimer\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this._pollTimer = 0;\n    var _eventData = {\n      cancelled: false\n    };\n    /**\r\n     * Internal event propagation callback container.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_eventContainer\r\n     * @type {Phaser.Types.Input.EventData}\r\n     * @private\r\n     * @since 3.13.0\r\n     */\n\n    this._eventContainer = {\n      stopPropagation: function () {\n        _eventData.cancelled = true;\n      }\n    };\n    /**\r\n     * Internal event propagation data object.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_eventData\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.13.0\r\n     */\n\n    this._eventData = _eventData;\n    /**\r\n     * The distance, in pixels, a pointer has to move while being held down, before it thinks it is being dragged.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#dragDistanceThreshold\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.dragDistanceThreshold = 0;\n    /**\r\n     * The amount of time, in ms, a pointer has to be held down before it thinks it is dragging.\r\n     *\r\n     * The default polling rate is to poll only on move so once the time threshold is reached the\r\n     * drag event will not start until you move the mouse. If you want it to start immediately\r\n     * when the time threshold is reached, you must increase the polling rate by calling\r\n     * [setPollAlways]{@linkcode Phaser.Input.InputPlugin#setPollAlways} or\r\n     * [setPollRate]{@linkcode Phaser.Input.InputPlugin#setPollRate}.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#dragTimeThreshold\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\n\n    this.dragTimeThreshold = 0;\n    /**\r\n     * Used to temporarily store the results of the Hit Test\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_temp\r\n     * @type {array}\r\n     * @private\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this._temp = [];\n    /**\r\n     * Used to temporarily store the results of the Hit Test dropZones\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_tempZones\r\n     * @type {array}\r\n     * @private\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this._tempZones = [];\n    /**\r\n     * A list of all Game Objects that have been set to be interactive in the Scene this Input Plugin is managing.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_list\r\n     * @type {Phaser.GameObjects.GameObject[]}\r\n     * @private\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this._list = [];\n    /**\r\n     * Objects waiting to be inserted to the list on the next call to 'begin'.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_pendingInsertion\r\n     * @type {Phaser.GameObjects.GameObject[]}\r\n     * @private\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this._pendingInsertion = [];\n    /**\r\n     * Objects waiting to be removed from the list on the next call to 'begin'.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_pendingRemoval\r\n     * @type {Phaser.GameObjects.GameObject[]}\r\n     * @private\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this._pendingRemoval = [];\n    /**\r\n     * A list of all Game Objects that have been enabled for dragging.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_draggable\r\n     * @type {Phaser.GameObjects.GameObject[]}\r\n     * @private\r\n     * @default []\r\n     * @since 3.0.0\r\n     */\n\n    this._draggable = [];\n    /**\r\n     * A list of all Interactive Objects currently considered as being 'draggable' by any pointer, indexed by pointer ID.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_drag\r\n     * @type {{0:Array,1:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array,10:Array}}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._drag = {\n      0: [],\n      1: [],\n      2: [],\n      3: [],\n      4: [],\n      5: [],\n      6: [],\n      7: [],\n      8: [],\n      9: [],\n      10: []\n    };\n    /**\r\n     * A array containing the dragStates, for this Scene, index by the Pointer ID.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_dragState\r\n     * @type {integer[]}\r\n     * @private\r\n     * @since 3.16.0\r\n     */\n\n    this._dragState = [];\n    /**\r\n     * A list of all Interactive Objects currently considered as being 'over' by any pointer, indexed by pointer ID.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_over\r\n     * @type {{0:Array,1:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array,10:Array}}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._over = {\n      0: [],\n      1: [],\n      2: [],\n      3: [],\n      4: [],\n      5: [],\n      6: [],\n      7: [],\n      8: [],\n      9: [],\n      10: []\n    };\n    /**\r\n     * A list of valid DOM event types.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_validTypes\r\n     * @type {string[]}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._validTypes = ['onDown', 'onUp', 'onOver', 'onOut', 'onMove', 'onDragStart', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragLeave', 'onDragOver', 'onDrop'];\n    /**\r\n     * Internal property that tracks frame event state.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#_updatedThisFrame\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.18.0\r\n     */\n\n    this._updatedThisFrame = false;\n    scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\n    scene.sys.events.on(SceneEvents.START, this.start, this);\n  },\n\n  /**\r\n   * This method is called automatically, only once, when the Scene is first created.\r\n   * Do not invoke it directly.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#boot\r\n   * @fires Phaser.Input.Events#BOOT\r\n   * @private\r\n   * @since 3.5.1\r\n   */\n  boot: function () {\n    this.cameras = this.systems.cameras;\n    this.displayList = this.systems.displayList;\n    this.systems.events.once(SceneEvents.DESTROY, this.destroy, this); //  Registered input plugins listen for this\n\n    this.pluginEvents.emit(Events.BOOT);\n  },\n\n  /**\r\n   * This method is called automatically by the Scene when it is starting up.\r\n   * It is responsible for creating local systems, properties and listening for Scene events.\r\n   * Do not invoke it directly.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#start\r\n   * @fires Phaser.Input.Events#START\r\n   * @private\r\n   * @since 3.5.0\r\n   */\n  start: function () {\n    var eventEmitter = this.systems.events;\n    eventEmitter.on(SceneEvents.TRANSITION_START, this.transitionIn, this);\n    eventEmitter.on(SceneEvents.TRANSITION_OUT, this.transitionOut, this);\n    eventEmitter.on(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);\n    eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);\n    eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\n    this.manager.events.on(Events.GAME_OUT, this.onGameOut, this);\n    this.manager.events.on(Events.GAME_OVER, this.onGameOver, this);\n    this.enabled = true; //  Populate the pointer drag states\n\n    this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; //  Registered input plugins listen for this\n\n    this.pluginEvents.emit(Events.START);\n  },\n\n  /**\r\n   * Game Over handler.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#onGameOver\r\n   * @fires Phaser.Input.Events#GAME_OVER\r\n   * @private\r\n   * @since 3.16.2\r\n   */\n  onGameOver: function (event) {\n    if (this.isActive()) {\n      this.emit(Events.GAME_OVER, event.timeStamp, event);\n    }\n  },\n\n  /**\r\n   * Game Out handler.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#onGameOut\r\n   * @fires Phaser.Input.Events#GAME_OUT\r\n   * @private\r\n   * @since 3.16.2\r\n   */\n  onGameOut: function (event) {\n    if (this.isActive()) {\n      this.emit(Events.GAME_OUT, event.timeStamp, event);\n    }\n  },\n\n  /**\r\n   * The pre-update handler is responsible for checking the pending removal and insertion lists and\r\n   * deleting old Game Objects.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#preUpdate\r\n   * @private\r\n   * @fires Phaser.Input.Events#PRE_UPDATE\r\n   * @since 3.0.0\r\n   */\n  preUpdate: function () {\n    //  Registered input plugins listen for this\n    this.pluginEvents.emit(Events.PRE_UPDATE);\n    var removeList = this._pendingRemoval;\n    var insertList = this._pendingInsertion;\n    var toRemove = removeList.length;\n    var toInsert = insertList.length;\n\n    if (toRemove === 0 && toInsert === 0) {\n      //  Quick bail\n      return;\n    }\n\n    var current = this._list; //  Delete old gameObjects\n\n    for (var i = 0; i < toRemove; i++) {\n      var gameObject = removeList[i];\n      var index = current.indexOf(gameObject);\n\n      if (index > -1) {\n        current.splice(index, 1);\n        this.clear(gameObject, true);\n      }\n    } //  Clear the removal list\n\n\n    removeList.length = 0;\n    this._pendingRemoval.length = 0; //  Move pendingInsertion to list (also clears pendingInsertion at the same time)\n\n    this._list = current.concat(insertList.splice(0));\n  },\n\n  /**\r\n   * Checks to see if both this plugin and the Scene to which it belongs is active.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#isActive\r\n   * @since 3.10.0\r\n   *\r\n   * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n   */\n  isActive: function () {\n    return this.enabled && this.scene.sys.isActive();\n  },\n\n  /**\r\n   * This is called automatically by the Input Manager.\r\n   * It emits events for plugins to listen to and also handles polling updates, if enabled.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#updatePoll\r\n   * @since 3.18.0\r\n   *\r\n   * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n   * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n   *\r\n   * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n   */\n  updatePoll: function (time, delta) {\n    if (!this.isActive()) {\n      return false;\n    } //  The plugins should update every frame, regardless if there has been\n    //  any DOM input events or not (such as the Gamepad and Keyboard)\n\n\n    this.pluginEvents.emit(Events.UPDATE, time, delta); //  We can leave now if we've already updated once this frame via the immediate DOM event handlers\n\n    if (this._updatedThisFrame) {\n      this._updatedThisFrame = false;\n      return false;\n    }\n\n    var i;\n    var manager = this.manager;\n    var pointers = manager.pointers;\n    var pointersTotal = manager.pointersTotal;\n\n    for (i = 0; i < pointersTotal; i++) {\n      pointers[i].updateMotion();\n    } //  No point going any further if there aren't any interactive objects\n\n\n    if (this._list.length === 0) {\n      return false;\n    }\n\n    var rate = this.pollRate;\n\n    if (rate === -1) {\n      return false;\n    } else if (rate > 0) {\n      this._pollTimer -= delta;\n\n      if (this._pollTimer < 0) {\n        //  Discard timer diff, we're ready to poll again\n        this._pollTimer = this.pollRate;\n      } else {\n        //  Not enough time has elapsed since the last poll, so abort now\n        return false;\n      }\n    } //  We got this far? Then we should poll for movement\n\n\n    var captured = false;\n\n    for (i = 0; i < pointersTotal; i++) {\n      var total = 0;\n      var pointer = pointers[i]; //  Always reset this array\n\n      this._tempZones = []; //  _temp contains a hit tested and camera culled list of IO objects\n\n      this._temp = this.hitTestPointer(pointer);\n      this.sortGameObjects(this._temp);\n      this.sortGameObjects(this._tempZones);\n\n      if (this.topOnly) {\n        //  Only the top-most one counts now, so safely ignore the rest\n        if (this._temp.length) {\n          this._temp.splice(1);\n        }\n\n        if (this._tempZones.length) {\n          this._tempZones.splice(1);\n        }\n      }\n\n      total += this.processOverOutEvents(pointer);\n\n      if (this.getDragState(pointer) === 2) {\n        this.processDragThresholdEvent(pointer, time);\n      }\n\n      if (total > 0) {\n        //  We interacted with an event in this Scene, so block any Scenes below us from doing the same this frame\n        captured = true;\n      }\n    }\n\n    return captured;\n  },\n\n  /**\r\n   * This method is called when a DOM Event is received by the Input Manager. It handles dispatching the events\r\n   * to relevant input enabled Game Objects in this scene.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#update\r\n   * @private\r\n   * @fires Phaser.Input.Events#UPDATE\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} type - The type of event to process.\r\n   * @param {Phaser.Input.Pointer[]} pointers - An array of Pointers on which the event occurred.\r\n   *\r\n   * @return {boolean} `true` if this Scene has captured the input events from all other Scenes, otherwise `false`.\r\n   */\n  update: function (type, pointers) {\n    if (!this.isActive()) {\n      return false;\n    }\n\n    var pointersTotal = pointers.length;\n    var captured = false;\n\n    for (var i = 0; i < pointersTotal; i++) {\n      var total = 0;\n      var pointer = pointers[i]; //  Always reset this array\n\n      this._tempZones = []; //  _temp contains a hit tested and camera culled list of IO objects\n\n      this._temp = this.hitTestPointer(pointer);\n      this.sortGameObjects(this._temp);\n      this.sortGameObjects(this._tempZones);\n\n      if (this.topOnly) {\n        //  Only the top-most one counts now, so safely ignore the rest\n        if (this._temp.length) {\n          this._temp.splice(1);\n        }\n\n        if (this._tempZones.length) {\n          this._tempZones.splice(1);\n        }\n      }\n\n      switch (type) {\n        case CONST.MOUSE_DOWN:\n          total += this.processDragDownEvent(pointer);\n          total += this.processDownEvents(pointer);\n          total += this.processOverOutEvents(pointer);\n          break;\n\n        case CONST.MOUSE_UP:\n          total += this.processDragUpEvent(pointer);\n          total += this.processUpEvents(pointer);\n          total += this.processOverOutEvents(pointer);\n          break;\n\n        case CONST.TOUCH_START:\n          total += this.processDragDownEvent(pointer);\n          total += this.processDownEvents(pointer);\n          total += this.processOverEvents(pointer);\n          break;\n\n        case CONST.TOUCH_END:\n        case CONST.TOUCH_CANCEL:\n          total += this.processDragUpEvent(pointer);\n          total += this.processUpEvents(pointer);\n          total += this.processOutEvents(pointer);\n          break;\n\n        case CONST.MOUSE_MOVE:\n        case CONST.TOUCH_MOVE:\n          total += this.processDragMoveEvent(pointer);\n          total += this.processMoveEvents(pointer);\n          total += this.processOverOutEvents(pointer);\n          break;\n\n        case CONST.MOUSE_WHEEL:\n          total += this.processWheelEvent(pointer);\n          break;\n      }\n\n      if (total > 0) {\n        //  We interacted with an event in this Scene, so block any Scenes below us from doing the same this frame\n        captured = true;\n      }\n    }\n\n    this._updatedThisFrame = true;\n    return captured;\n  },\n\n  /**\r\n   * Clears a Game Object so it no longer has an Interactive Object associated with it.\r\n   * The Game Object is then queued for removal from the Input Plugin on the next update.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#clear\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will have its Interactive Object removed.\r\n   * @param {boolean} [skipQueue=false] - Skip adding this Game Object into the removal queue?\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject} The Game Object that had its Interactive Object removed.\r\n   */\n  clear: function (gameObject, skipQueue) {\n    if (skipQueue === undefined) {\n      skipQueue = false;\n    }\n\n    var input = gameObject.input; // If GameObject.input already cleared from higher class\n\n    if (!input) {\n      return;\n    }\n\n    if (!skipQueue) {\n      this.queueForRemoval(gameObject);\n    }\n\n    input.gameObject = undefined;\n    input.target = undefined;\n    input.hitArea = undefined;\n    input.hitAreaCallback = undefined;\n    input.callbackContext = undefined;\n    this.manager.resetCursor(input);\n    gameObject.input = null; //  Clear from _draggable, _drag and _over\n\n    var index = this._draggable.indexOf(gameObject);\n\n    if (index > -1) {\n      this._draggable.splice(index, 1);\n    }\n\n    index = this._drag[0].indexOf(gameObject);\n\n    if (index > -1) {\n      this._drag[0].splice(index, 1);\n    }\n\n    index = this._over[0].indexOf(gameObject);\n\n    if (index > -1) {\n      this._over[0].splice(index, 1);\n    }\n\n    return gameObject;\n  },\n\n  /**\r\n   * Disables Input on a single Game Object.\r\n   *\r\n   * An input disabled Game Object still retains its Interactive Object component and can be re-enabled\r\n   * at any time, by passing it to `InputPlugin.enable`.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#disable\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to have its input system disabled.\r\n   */\n  disable: function (gameObject) {\n    gameObject.input.enabled = false;\n  },\n\n  /**\r\n   * Enable a Game Object for interaction.\r\n   *\r\n   * If the Game Object already has an Interactive Object component, it is enabled and returned.\r\n   *\r\n   * Otherwise, a new Interactive Object component is created and assigned to the Game Object's `input` property.\r\n   *\r\n   * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area\r\n   * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced\r\n   * input detection.\r\n   *\r\n   * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If\r\n   * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific\r\n   * shape for it to use.\r\n   *\r\n   * You can also provide an Input Configuration Object as the only argument to this method.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#enable\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to be enabled for input.\r\n   * @param {(Phaser.Types.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n   * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The 'contains' function to invoke to check if the pointer is within the hit area.\r\n   * @param {boolean} [dropZone=false] - Is this Game Object a drop zone or not?\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This Input Plugin.\r\n   */\n  enable: function (gameObject, shape, callback, dropZone) {\n    if (dropZone === undefined) {\n      dropZone = false;\n    }\n\n    if (gameObject.input) {\n      //  If it is already has an InteractiveObject then just enable it and return\n      gameObject.input.enabled = true;\n    } else {\n      //  Create an InteractiveObject and enable it\n      this.setHitArea(gameObject, shape, callback);\n    }\n\n    if (gameObject.input && dropZone && !gameObject.input.dropZone) {\n      gameObject.input.dropZone = dropZone;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Takes the given Pointer and performs a hit test against it, to see which interactive Game Objects\r\n   * it is currently above.\r\n   *\r\n   * The hit test is performed against which-ever Camera the Pointer is over. If it is over multiple\r\n   * cameras, it starts checking the camera at the top of the camera list, and if nothing is found, iterates down the list.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#hitTestPointer\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer to check against the Game Objects.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject[]} An array of all the interactive Game Objects the Pointer was above.\r\n   */\n  hitTestPointer: function (pointer) {\n    var cameras = this.cameras.getCamerasBelowPointer(pointer);\n\n    for (var c = 0; c < cameras.length; c++) {\n      var camera = cameras[c]; //  Get a list of all objects that can be seen by the camera below the pointer in the scene and store in 'over' array.\n      //  All objects in this array are input enabled, as checked by the hitTest method, so we don't need to check later on as well.\n\n      var over = this.manager.hitTest(pointer, this._list, camera); //  Filter out the drop zones\n\n      for (var i = 0; i < over.length; i++) {\n        var obj = over[i];\n\n        if (obj.input.dropZone) {\n          this._tempZones.push(obj);\n        }\n      }\n\n      if (over.length > 0) {\n        pointer.camera = camera;\n        return over;\n      }\n    } //  If we got this far then there were no Game Objects below the pointer, but it was still over\n    //  a camera, so set that the top-most one into the pointer\n\n\n    pointer.camera = cameras[0];\n    return [];\n  },\n\n  /**\r\n   * An internal method that handles the Pointer down event.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processDownEvents\r\n   * @private\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_DOWN\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DOWN\r\n   * @fires Phaser.Input.Events#POINTER_DOWN\r\n   * @fires Phaser.Input.Events#POINTER_DOWN_OUTSIDE\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer being tested.\r\n   *\r\n   * @return {integer} The total number of objects interacted with.\r\n   */\n  processDownEvents: function (pointer) {\n    var total = 0;\n    var currentlyOver = this._temp;\n    var _eventData = this._eventData;\n    var _eventContainer = this._eventContainer;\n    _eventData.cancelled = false;\n    var aborted = false; //  Go through all objects the pointer was over and fire their events / callbacks\n\n    for (var i = 0; i < currentlyOver.length; i++) {\n      var gameObject = currentlyOver[i];\n\n      if (!gameObject.input) {\n        continue;\n      }\n\n      total++;\n      gameObject.emit(Events.GAMEOBJECT_POINTER_DOWN, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\n\n      if (_eventData.cancelled || !gameObject.input) {\n        aborted = true;\n        break;\n      }\n\n      this.emit(Events.GAMEOBJECT_DOWN, pointer, gameObject, _eventContainer);\n\n      if (_eventData.cancelled || !gameObject.input) {\n        aborted = true;\n        break;\n      }\n    } //  If they released outside the canvas, but pressed down inside it, we'll still dispatch the event.\n\n\n    if (!aborted && this.manager) {\n      if (pointer.downElement === this.manager.game.canvas) {\n        this.emit(Events.POINTER_DOWN, pointer, currentlyOver);\n      } else {\n        this.emit(Events.POINTER_DOWN_OUTSIDE, pointer);\n      }\n    }\n\n    return total;\n  },\n\n  /**\r\n   * Returns the drag state of the given Pointer for this Input Plugin.\r\n   *\r\n   * The state will be one of the following:\r\n   *\r\n   * 0 = Not dragging anything\r\n   * 1 = Primary button down and objects below, so collect a draglist\r\n   * 2 = Pointer being checked if meets drag criteria\r\n   * 3 = Pointer meets criteria, notify the draglist\r\n   * 4 = Pointer actively dragging the draglist and has moved\r\n   * 5 = Pointer actively dragging but has been released, notify draglist\r\n   *\r\n   * @method Phaser.Input.InputPlugin#getDragState\r\n   * @since 3.16.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer to get the drag state for.\r\n   *\r\n   * @return {integer} The drag state of the given Pointer.\r\n   */\n  getDragState: function (pointer) {\n    return this._dragState[pointer.id];\n  },\n\n  /**\r\n   * Sets the drag state of the given Pointer for this Input Plugin.\r\n   *\r\n   * The state must be one of the following values:\r\n   *\r\n   * 0 = Not dragging anything\r\n   * 1 = Primary button down and objects below, so collect a draglist\r\n   * 2 = Pointer being checked if meets drag criteria\r\n   * 3 = Pointer meets criteria, notify the draglist\r\n   * 4 = Pointer actively dragging the draglist and has moved\r\n   * 5 = Pointer actively dragging but has been released, notify draglist\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setDragState\r\n   * @since 3.16.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer to set the drag state for.\r\n   * @param {integer} state - The drag state value. An integer between 0 and 5.\r\n   */\n  setDragState: function (pointer, state) {\n    this._dragState[pointer.id] = state;\n  },\n\n  /**\r\n   * Checks to see if a Pointer is ready to drag the objects below it, based on either a distance\r\n   * or time threshold.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processDragThresholdEvent\r\n   * @private\r\n   * @since 3.18.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer to check the drag thresholds on.\r\n   * @param {number} time - The current time.\r\n   */\n  processDragThresholdEvent: function (pointer, time) {\n    var passed = false;\n    var timeThreshold = this.dragTimeThreshold;\n    var distanceThreshold = this.dragDistanceThreshold;\n\n    if (distanceThreshold > 0 && DistanceBetween(pointer.x, pointer.y, pointer.downX, pointer.downY) >= distanceThreshold) {\n      //  It has moved far enough to be considered a drag\n      passed = true;\n    } else if (timeThreshold > 0 && time >= pointer.downTime + timeThreshold) {\n      //  It has been held down long enough to be considered a drag\n      passed = true;\n    }\n\n    if (passed) {\n      this.setDragState(pointer, 3);\n      return this.processDragStartList(pointer);\n    }\n  },\n\n  /**\r\n   * Processes the drag list for the given pointer and dispatches the start events for each object on it.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processDragStartList\r\n   * @private\r\n   * @fires Phaser.Input.Events#DRAG_START\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_START\r\n   * @since 3.18.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n   *\r\n   * @return {integer} The number of items that DRAG_START was called on.\r\n   */\n  processDragStartList: function (pointer) {\n    //  3 = Pointer meets criteria and is freshly down, notify the draglist\n    if (this.getDragState(pointer) !== 3) {\n      return 0;\n    }\n\n    var list = this._drag[pointer.id];\n\n    for (var i = 0; i < list.length; i++) {\n      var gameObject = list[i];\n      var input = gameObject.input;\n      input.dragState = 2;\n      input.dragStartX = gameObject.x;\n      input.dragStartY = gameObject.y;\n      input.dragStartXGlobal = pointer.x;\n      input.dragStartYGlobal = pointer.y;\n      input.dragX = input.dragStartXGlobal - input.dragStartX;\n      input.dragY = input.dragStartYGlobal - input.dragStartY;\n      gameObject.emit(Events.GAMEOBJECT_DRAG_START, pointer, input.dragX, input.dragY);\n      this.emit(Events.DRAG_START, pointer, gameObject);\n    }\n\n    this.setDragState(pointer, 4);\n    return list.length;\n  },\n\n  /**\r\n   * Processes a 'drag down' event for the given pointer. Checks the pointer state, builds-up the drag list\r\n   * and prepares them all for interaction.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processDragDownEvent\r\n   * @private\r\n   * @since 3.18.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n   *\r\n   * @return {integer} The number of items that were collected on the drag list.\r\n   */\n  processDragDownEvent: function (pointer) {\n    var currentlyOver = this._temp;\n\n    if (this._draggable.length === 0 || currentlyOver.length === 0 || !pointer.primaryDown || this.getDragState(pointer) !== 0) {\n      //  There are no draggable items, no over items or the pointer isn't down, so let's not even bother going further\n      return 0;\n    } //  1 = Primary button down and objects below, so collect a draglist\n\n\n    this.setDragState(pointer, 1); //  Get draggable objects, sort them, pick the top (or all) and store them somewhere\n\n    var draglist = [];\n\n    for (var i = 0; i < currentlyOver.length; i++) {\n      var gameObject = currentlyOver[i];\n\n      if (gameObject.input.draggable && gameObject.input.dragState === 0) {\n        draglist.push(gameObject);\n      }\n    }\n\n    if (draglist.length === 0) {\n      this.setDragState(pointer, 0);\n      return 0;\n    } else if (draglist.length > 1) {\n      this.sortGameObjects(draglist);\n\n      if (this.topOnly) {\n        draglist.splice(1);\n      }\n    } //  draglist now contains all potential candidates for dragging\n\n\n    this._drag[pointer.id] = draglist;\n\n    if (this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0) {\n      //  No drag criteria, so snap immediately to mode 3\n      this.setDragState(pointer, 3);\n      return this.processDragStartList(pointer);\n    } else {\n      //  Check the distance / time on the next event\n      this.setDragState(pointer, 2);\n      return 0;\n    }\n  },\n\n  /**\r\n   * Processes a 'drag move' event for the given pointer.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processDragMoveEvent\r\n   * @private\r\n   * @fires Phaser.Input.Events#DRAG_ENTER\r\n   * @fires Phaser.Input.Events#DRAG\r\n   * @fires Phaser.Input.Events#DRAG_LEAVE\r\n   * @fires Phaser.Input.Events#DRAG_OVER\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_ENTER\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DRAG\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_LEAVE\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_OVER\r\n   * @since 3.18.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n   *\r\n   * @return {integer} The number of items that were updated by this drag event.\r\n   */\n  processDragMoveEvent: function (pointer) {\n    //  2 = Pointer being checked if meets drag criteria\n    if (this.getDragState(pointer) === 2) {\n      this.processDragThresholdEvent(pointer, this.manager.game.loop.now);\n    }\n\n    if (this.getDragState(pointer) !== 4) {\n      return 0;\n    } //  4 = Pointer actively dragging the draglist and has moved\n\n\n    var dropZones = this._tempZones;\n    var list = this._drag[pointer.id];\n\n    for (var i = 0; i < list.length; i++) {\n      var gameObject = list[i];\n      var input = gameObject.input;\n      var target = input.target; //  If this GO has a target then let's check it\n\n      if (target) {\n        var index = dropZones.indexOf(target); //  Got a target, are we still over it?\n\n        if (index === 0) {\n          //  We're still over it, and it's still the top of the display list, phew ...\n          gameObject.emit(Events.GAMEOBJECT_DRAG_OVER, pointer, target);\n          this.emit(Events.DRAG_OVER, pointer, gameObject, target);\n        } else if (index > 0) {\n          //  Still over it but it's no longer top of the display list (targets must always be at the top)\n          gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);\n          this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);\n          input.target = dropZones[0];\n          target = input.target;\n          gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);\n          this.emit(Events.DRAG_ENTER, pointer, gameObject, target);\n        } else {\n          //  Nope, we've moved on (or the target has!), leave the old target\n          gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);\n          this.emit(Events.DRAG_LEAVE, pointer, gameObject, target); //  Anything new to replace it?\n          //  Yup!\n\n          if (dropZones[0]) {\n            input.target = dropZones[0];\n            target = input.target;\n            gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);\n            this.emit(Events.DRAG_ENTER, pointer, gameObject, target);\n          } else {\n            //  Nope\n            input.target = null;\n          }\n        }\n      } else if (!target && dropZones[0]) {\n        input.target = dropZones[0];\n        target = input.target;\n        gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);\n        this.emit(Events.DRAG_ENTER, pointer, gameObject, target);\n      }\n\n      var dragX;\n      var dragY;\n\n      if (!gameObject.parentContainer) {\n        dragX = pointer.x - input.dragX;\n        dragY = pointer.y - input.dragY;\n      } else {\n        var dx = pointer.x - input.dragStartXGlobal;\n        var dy = pointer.y - input.dragStartYGlobal;\n        var rotation = gameObject.getParentRotation();\n        var dxRotated = dx * Math.cos(rotation) + dy * Math.sin(rotation);\n        var dyRotated = dy * Math.cos(rotation) - dx * Math.sin(rotation);\n        dxRotated *= 1 / gameObject.parentContainer.scaleX;\n        dyRotated *= 1 / gameObject.parentContainer.scaleY;\n        dragX = dxRotated + input.dragStartX;\n        dragY = dyRotated + input.dragStartY;\n      }\n\n      gameObject.emit(Events.GAMEOBJECT_DRAG, pointer, dragX, dragY);\n      this.emit(Events.DRAG, pointer, gameObject, dragX, dragY);\n    }\n\n    return list.length;\n  },\n\n  /**\r\n   * Processes a 'drag down' event for the given pointer. Checks the pointer state, builds-up the drag list\r\n   * and prepares them all for interaction.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processDragUpEvent\r\n   * @fires Phaser.Input.Events#DRAG_END\r\n   * @fires Phaser.Input.Events#DROP\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_END\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_DROP\r\n   * @private\r\n   * @since 3.18.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n   *\r\n   * @return {integer} The number of items that were updated by this drag event.\r\n   */\n  processDragUpEvent: function (pointer) {\n    //  5 = Pointer was actively dragging but has been released, notify draglist\n    var list = this._drag[pointer.id];\n\n    for (var i = 0; i < list.length; i++) {\n      var gameObject = list[i];\n      var input = gameObject.input;\n\n      if (input && input.dragState === 2) {\n        input.dragState = 0;\n        input.dragX = input.localX - gameObject.displayOriginX;\n        input.dragY = input.localY - gameObject.displayOriginY;\n        var dropped = false;\n        var target = input.target;\n\n        if (target) {\n          gameObject.emit(Events.GAMEOBJECT_DROP, pointer, target);\n          this.emit(Events.DROP, pointer, gameObject, target);\n          input.target = null;\n          dropped = true;\n        } //  And finally the dragend event\n\n\n        if (gameObject.input) {\n          gameObject.emit(Events.GAMEOBJECT_DRAG_END, pointer, input.dragX, input.dragY, dropped);\n          this.emit(Events.DRAG_END, pointer, gameObject, dropped);\n        }\n      }\n    }\n\n    this.setDragState(pointer, 0);\n    list.splice(0);\n    return 0;\n  },\n\n  /**\r\n   * An internal method that handles the Pointer movement event.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processMoveEvents\r\n   * @private\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_MOVE\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_MOVE\r\n   * @fires Phaser.Input.Events#POINTER_MOVE\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n   *\r\n   * @return {integer} The total number of objects interacted with.\r\n   */\n  processMoveEvents: function (pointer) {\n    var total = 0;\n    var currentlyOver = this._temp;\n    var _eventData = this._eventData;\n    var _eventContainer = this._eventContainer;\n    _eventData.cancelled = false;\n    var aborted = false; //  Go through all objects the pointer was over and fire their events / callbacks\n\n    for (var i = 0; i < currentlyOver.length; i++) {\n      var gameObject = currentlyOver[i];\n\n      if (!gameObject.input) {\n        continue;\n      }\n\n      total++;\n      gameObject.emit(Events.GAMEOBJECT_POINTER_MOVE, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\n\n      if (_eventData.cancelled || !gameObject.input) {\n        aborted = true;\n        break;\n      }\n\n      this.emit(Events.GAMEOBJECT_MOVE, pointer, gameObject, _eventContainer);\n\n      if (_eventData.cancelled || !gameObject.input) {\n        aborted = true;\n        break;\n      }\n\n      if (this.topOnly) {\n        break;\n      }\n    }\n\n    if (!aborted) {\n      this.emit(Events.POINTER_MOVE, pointer, currentlyOver);\n    }\n\n    return total;\n  },\n\n  /**\r\n   * An internal method that handles a mouse wheel event.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processWheelEvent\r\n   * @private\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_WHEEL\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_WHEEL\r\n   * @fires Phaser.Input.Events#POINTER_WHEEL\r\n   * @since 3.18.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n   *\r\n   * @return {integer} The total number of objects interacted with.\r\n   */\n  processWheelEvent: function (pointer) {\n    var total = 0;\n    var currentlyOver = this._temp;\n    var _eventData = this._eventData;\n    var _eventContainer = this._eventContainer;\n    _eventData.cancelled = false;\n    var aborted = false;\n    var dx = pointer.deltaX;\n    var dy = pointer.deltaY;\n    var dz = pointer.deltaZ; //  Go through all objects the pointer was over and fire their events / callbacks\n\n    for (var i = 0; i < currentlyOver.length; i++) {\n      var gameObject = currentlyOver[i];\n\n      if (!gameObject.input) {\n        continue;\n      }\n\n      total++;\n      gameObject.emit(Events.GAMEOBJECT_POINTER_WHEEL, pointer, dx, dy, dz, _eventContainer);\n\n      if (_eventData.cancelled || !gameObject.input) {\n        aborted = true;\n        break;\n      }\n\n      this.emit(Events.GAMEOBJECT_WHEEL, pointer, gameObject, dx, dy, dz, _eventContainer);\n\n      if (_eventData.cancelled || !gameObject.input) {\n        aborted = true;\n        break;\n      }\n    }\n\n    if (!aborted) {\n      this.emit(Events.POINTER_WHEEL, pointer, currentlyOver, dx, dy, dz);\n    }\n\n    return total;\n  },\n\n  /**\r\n   * An internal method that handles the Pointer over events.\r\n   * This is called when a touch input hits the canvas, having previously been off of it.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processOverEvents\r\n   * @private\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OVER\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_OVER\r\n   * @fires Phaser.Input.Events#POINTER_OVER\r\n   * @since 3.18.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n   *\r\n   * @return {integer} The total number of objects interacted with.\r\n   */\n  processOverEvents: function (pointer) {\n    var currentlyOver = this._temp;\n    var totalInteracted = 0;\n    var total = currentlyOver.length;\n    var justOver = [];\n\n    if (total > 0) {\n      var manager = this.manager;\n      var _eventData = this._eventData;\n      var _eventContainer = this._eventContainer;\n      _eventData.cancelled = false;\n      var aborted = false;\n\n      for (var i = 0; i < total; i++) {\n        var gameObject = currentlyOver[i];\n\n        if (!gameObject.input) {\n          continue;\n        }\n\n        justOver.push(gameObject);\n        manager.setCursor(gameObject.input);\n        gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\n        totalInteracted++;\n\n        if (_eventData.cancelled || !gameObject.input) {\n          aborted = true;\n          break;\n        }\n\n        this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);\n\n        if (_eventData.cancelled || !gameObject.input) {\n          aborted = true;\n          break;\n        }\n      }\n\n      if (!aborted) {\n        this.emit(Events.POINTER_OVER, pointer, justOver);\n      }\n    } //  Then sort it into display list order\n\n\n    this._over[pointer.id] = justOver;\n    return totalInteracted;\n  },\n\n  /**\r\n   * An internal method that handles the Pointer out events.\r\n   * This is called when a touch input leaves the canvas, as it can never be 'over' in this case.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processOutEvents\r\n   * @private\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OUT\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_OUT\r\n   * @fires Phaser.Input.Events#POINTER_OUT\r\n   * @since 3.18.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n   *\r\n   * @return {integer} The total number of objects interacted with.\r\n   */\n  processOutEvents: function (pointer) {\n    var previouslyOver = this._over[pointer.id];\n    var totalInteracted = 0;\n    var total = previouslyOver.length;\n\n    if (total > 0) {\n      var manager = this.manager;\n      var _eventData = this._eventData;\n      var _eventContainer = this._eventContainer;\n      _eventData.cancelled = false;\n      var aborted = false;\n      this.sortGameObjects(previouslyOver);\n\n      for (var i = 0; i < total; i++) {\n        var gameObject = previouslyOver[i]; //  Call onOut for everything in the previouslyOver array\n\n        for (i = 0; i < total; i++) {\n          gameObject = previouslyOver[i];\n\n          if (!gameObject.input) {\n            continue;\n          }\n\n          manager.resetCursor(gameObject.input);\n          gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);\n          totalInteracted++;\n\n          if (_eventData.cancelled || !gameObject.input) {\n            aborted = true;\n            break;\n          }\n\n          this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);\n\n          if (_eventData.cancelled || !gameObject.input) {\n            aborted = true;\n            break;\n          }\n        }\n\n        if (!aborted) {\n          this.emit(Events.POINTER_OUT, pointer, previouslyOver);\n        }\n      }\n\n      this._over[pointer.id] = [];\n    }\n\n    return totalInteracted;\n  },\n\n  /**\r\n   * An internal method that handles the Pointer over and out events.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processOverOutEvents\r\n   * @private\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OVER\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_OVER\r\n   * @fires Phaser.Input.Events#POINTER_OVER\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OUT\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_OUT\r\n   * @fires Phaser.Input.Events#POINTER_OUT\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n   *\r\n   * @return {integer} The total number of objects interacted with.\r\n   */\n  processOverOutEvents: function (pointer) {\n    var currentlyOver = this._temp;\n    var i;\n    var gameObject;\n    var justOut = [];\n    var justOver = [];\n    var stillOver = [];\n    var previouslyOver = this._over[pointer.id];\n    var currentlyDragging = this._drag[pointer.id];\n    var manager = this.manager; //  Go through all objects the pointer was previously over, and see if it still is.\n    //  Splits the previouslyOver array into two parts: justOut and stillOver\n\n    for (i = 0; i < previouslyOver.length; i++) {\n      gameObject = previouslyOver[i];\n\n      if (currentlyOver.indexOf(gameObject) === -1 && currentlyDragging.indexOf(gameObject) === -1) {\n        //  Not in the currentlyOver array, so must be outside of this object now\n        justOut.push(gameObject);\n      } else {\n        //  In the currentlyOver array\n        stillOver.push(gameObject);\n      }\n    } //  Go through all objects the pointer is currently over (the hit test results)\n    //  and if not in the previouslyOver array we know it's a new entry, so add to justOver\n\n\n    for (i = 0; i < currentlyOver.length; i++) {\n      gameObject = currentlyOver[i]; //  Is this newly over?\n\n      if (previouslyOver.indexOf(gameObject) === -1) {\n        justOver.push(gameObject);\n      }\n    } //  By this point the arrays are filled, so now we can process what happened...\n    //  Process the Just Out objects\n\n\n    var total = justOut.length;\n    var totalInteracted = 0;\n    var _eventData = this._eventData;\n    var _eventContainer = this._eventContainer;\n    _eventData.cancelled = false;\n    var aborted = false;\n\n    if (total > 0) {\n      this.sortGameObjects(justOut); //  Call onOut for everything in the justOut array\n\n      for (i = 0; i < total; i++) {\n        gameObject = justOut[i];\n\n        if (!gameObject.input) {\n          continue;\n        } //  Reset cursor before we emit the event, in case they want to change it during the event\n\n\n        manager.resetCursor(gameObject.input);\n        gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);\n        totalInteracted++;\n\n        if (_eventData.cancelled || !gameObject.input) {\n          aborted = true;\n          break;\n        }\n\n        this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);\n\n        if (_eventData.cancelled || !gameObject.input) {\n          aborted = true;\n          break;\n        }\n      }\n\n      if (!aborted) {\n        this.emit(Events.POINTER_OUT, pointer, justOut);\n      }\n    } //  Process the Just Over objects\n\n\n    total = justOver.length;\n    _eventData.cancelled = false;\n    aborted = false;\n\n    if (total > 0) {\n      this.sortGameObjects(justOver); //  Call onOver for everything in the justOver array\n\n      for (i = 0; i < total; i++) {\n        gameObject = justOver[i];\n\n        if (!gameObject.input) {\n          continue;\n        } //  Set cursor before we emit the event, in case they want to change it during the event\n\n\n        manager.setCursor(gameObject.input);\n        gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\n        totalInteracted++;\n\n        if (_eventData.cancelled || !gameObject.input) {\n          aborted = true;\n          break;\n        }\n\n        this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);\n\n        if (_eventData.cancelled || !gameObject.input) {\n          aborted = true;\n          break;\n        }\n      }\n\n      if (!aborted) {\n        this.emit(Events.POINTER_OVER, pointer, justOver);\n      }\n    } //  Add the contents of justOver to the previously over array\n\n\n    previouslyOver = stillOver.concat(justOver); //  Then sort it into display list order\n\n    this._over[pointer.id] = this.sortGameObjects(previouslyOver);\n    return totalInteracted;\n  },\n\n  /**\r\n   * An internal method that handles the Pointer up events.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#processUpEvents\r\n   * @private\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_UP\r\n   * @fires Phaser.Input.Events#GAMEOBJECT_UP\r\n   * @fires Phaser.Input.Events#POINTER_UP\r\n   * @fires Phaser.Input.Events#POINTER_UP_OUTSIDE\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n   *\r\n   * @return {integer} The total number of objects interacted with.\r\n   */\n  processUpEvents: function (pointer) {\n    var currentlyOver = this._temp;\n    var _eventData = this._eventData;\n    var _eventContainer = this._eventContainer;\n    _eventData.cancelled = false;\n    var aborted = false; //  Go through all objects the pointer was over and fire their events / callbacks\n\n    for (var i = 0; i < currentlyOver.length; i++) {\n      var gameObject = currentlyOver[i];\n\n      if (!gameObject.input) {\n        continue;\n      }\n\n      gameObject.emit(Events.GAMEOBJECT_POINTER_UP, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\n\n      if (_eventData.cancelled || !gameObject.input) {\n        aborted = true;\n        break;\n      }\n\n      this.emit(Events.GAMEOBJECT_UP, pointer, gameObject, _eventContainer);\n\n      if (_eventData.cancelled || !gameObject.input) {\n        aborted = true;\n        break;\n      }\n    } //  If they released outside the canvas, but pressed down inside it, we'll still dispatch the event.\n\n\n    if (!aborted && this.manager) {\n      if (pointer.upElement === this.manager.game.canvas) {\n        this.emit(Events.POINTER_UP, pointer, currentlyOver);\n      } else {\n        this.emit(Events.POINTER_UP_OUTSIDE, pointer);\n      }\n    }\n\n    return currentlyOver.length;\n  },\n\n  /**\r\n   * Queues a Game Object for insertion into this Input Plugin on the next update.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#queueForInsertion\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} child - The Game Object to add.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  queueForInsertion: function (child) {\n    if (this._pendingInsertion.indexOf(child) === -1 && this._list.indexOf(child) === -1) {\n      this._pendingInsertion.push(child);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Queues a Game Object for removal from this Input Plugin on the next update.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#queueForRemoval\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} child - The Game Object to remove.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  queueForRemoval: function (child) {\n    this._pendingRemoval.push(child);\n\n    return this;\n  },\n\n  /**\r\n   * Sets the draggable state of the given array of Game Objects.\r\n   *\r\n   * They can either be set to be draggable, or can have their draggable state removed by passing `false`.\r\n   *\r\n   * A Game Object will not fire drag events unless it has been specifically enabled for drag.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setDraggable\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to change the draggable state on.\r\n   * @param {boolean} [value=true] - Set to `true` if the Game Objects should be made draggable, `false` if they should be unset.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setDraggable: function (gameObjects, value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    if (!Array.isArray(gameObjects)) {\n      gameObjects = [gameObjects];\n    }\n\n    for (var i = 0; i < gameObjects.length; i++) {\n      var gameObject = gameObjects[i];\n      gameObject.input.draggable = value;\n\n      var index = this._draggable.indexOf(gameObject);\n\n      if (value && index === -1) {\n        this._draggable.push(gameObject);\n      } else if (!value && index > -1) {\n        this._draggable.splice(index, 1);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Creates a function that can be passed to `setInteractive`, `enable` or `setHitArea` that will handle\r\n   * pixel-perfect input detection on an Image or Sprite based Game Object, or any custom class that extends them.\r\n   *\r\n   * The following will create a sprite that is clickable on any pixel that has an alpha value >= 1.\r\n   *\r\n   * ```javascript\r\n   * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect());\r\n   * ```\r\n   *\r\n   * The following will create a sprite that is clickable on any pixel that has an alpha value >= 150.\r\n   *\r\n   * ```javascript\r\n   * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect(150));\r\n   * ```\r\n   *\r\n   * Once you have made an Interactive Object pixel perfect it impacts all input related events for it: down, up,\r\n   * dragstart, drag, etc.\r\n   *\r\n   * As a pointer interacts with the Game Object it will constantly poll the texture, extracting a single pixel from\r\n   * the given coordinates and checking its color values. This is an expensive process, so should only be enabled on\r\n   * Game Objects that really need it.\r\n   *\r\n   * You cannot make non-texture based Game Objects pixel perfect. So this will not work on Graphics, BitmapText,\r\n   * Render Textures, Text, Tilemaps, Containers or Particles.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#makePixelPerfect\r\n   * @since 3.10.0\r\n   *\r\n   * @param {integer} [alphaTolerance=1] - The alpha level that the pixel should be above to be included as a successful interaction.\r\n   *\r\n   * @return {function} A Pixel Perfect Handler for use as a hitArea shape callback.\r\n   */\n  makePixelPerfect: function (alphaTolerance) {\n    if (alphaTolerance === undefined) {\n      alphaTolerance = 1;\n    }\n\n    var textureManager = this.systems.textures;\n    return CreatePixelPerfectHandler(textureManager, alphaTolerance);\n  },\n\n  /**\r\n   * Sets the hit area for the given array of Game Objects.\r\n   *\r\n   * A hit area is typically one of the geometric shapes Phaser provides, such as a `Phaser.Geom.Rectangle`\r\n   * or `Phaser.Geom.Circle`. However, it can be any object as long as it works with the provided callback.\r\n   *\r\n   * If no hit area is provided a Rectangle is created based on the size of the Game Object, if possible\r\n   * to calculate.\r\n   *\r\n   * The hit area callback is the function that takes an `x` and `y` coordinate and returns a boolean if\r\n   * those values fall within the area of the shape or not. All of the Phaser geometry objects provide this,\r\n   * such as `Phaser.Geom.Rectangle.Contains`.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setHitArea\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set the hit area on.\r\n   * @param {(Phaser.Types.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n   * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The 'contains' function to invoke to check if the pointer is within the hit area.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setHitArea: function (gameObjects, shape, callback) {\n    if (shape === undefined) {\n      return this.setHitAreaFromTexture(gameObjects);\n    }\n\n    if (!Array.isArray(gameObjects)) {\n      gameObjects = [gameObjects];\n    }\n\n    var draggable = false;\n    var dropZone = false;\n    var cursor = false;\n    var useHandCursor = false;\n    var pixelPerfect = false;\n    var customHitArea = true; //  Config object?\n\n    if (IsPlainObject(shape)) {\n      var config = shape;\n      shape = GetFastValue(config, 'hitArea', null);\n      callback = GetFastValue(config, 'hitAreaCallback', null);\n      draggable = GetFastValue(config, 'draggable', false);\n      dropZone = GetFastValue(config, 'dropZone', false);\n      cursor = GetFastValue(config, 'cursor', false);\n      useHandCursor = GetFastValue(config, 'useHandCursor', false);\n      pixelPerfect = GetFastValue(config, 'pixelPerfect', false);\n      var alphaTolerance = GetFastValue(config, 'alphaTolerance', 1);\n\n      if (pixelPerfect) {\n        shape = {};\n        callback = this.makePixelPerfect(alphaTolerance);\n      } //  Still no hitArea or callback?\n\n\n      if (!shape || !callback) {\n        this.setHitAreaFromTexture(gameObjects);\n        customHitArea = false;\n      }\n    } else if (typeof shape === 'function' && !callback) {\n      callback = shape;\n      shape = {};\n    }\n\n    for (var i = 0; i < gameObjects.length; i++) {\n      var gameObject = gameObjects[i];\n\n      if (pixelPerfect && gameObject.type === 'Container') {\n        console.warn('Cannot pixelPerfect test a Container. Use a custom callback.');\n        continue;\n      }\n\n      var io = !gameObject.input ? CreateInteractiveObject(gameObject, shape, callback) : gameObject.input;\n      io.customHitArea = customHitArea;\n      io.dropZone = dropZone;\n      io.cursor = useHandCursor ? 'pointer' : cursor;\n      gameObject.input = io;\n\n      if (draggable) {\n        this.setDraggable(gameObject);\n      }\n\n      this.queueForInsertion(gameObject);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Circle` shape, using\r\n   * the given coordinates and radius to control its position and size.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setHitAreaCircle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a circle hit area.\r\n   * @param {number} x - The center of the circle.\r\n   * @param {number} y - The center of the circle.\r\n   * @param {number} radius - The radius of the circle.\r\n   * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Circle.Contains.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setHitAreaCircle: function (gameObjects, x, y, radius, callback) {\n    if (callback === undefined) {\n      callback = CircleContains;\n    }\n\n    var shape = new Circle(x, y, radius);\n    return this.setHitArea(gameObjects, shape, callback);\n  },\n\n  /**\r\n   * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Ellipse` shape, using\r\n   * the given coordinates and dimensions to control its position and size.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setHitAreaEllipse\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.\r\n   * @param {number} x - The center of the ellipse.\r\n   * @param {number} y - The center of the ellipse.\r\n   * @param {number} width - The width of the ellipse.\r\n   * @param {number} height - The height of the ellipse.\r\n   * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Ellipse.Contains.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setHitAreaEllipse: function (gameObjects, x, y, width, height, callback) {\n    if (callback === undefined) {\n      callback = EllipseContains;\n    }\n\n    var shape = new Ellipse(x, y, width, height);\n    return this.setHitArea(gameObjects, shape, callback);\n  },\n\n  /**\r\n   * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using\r\n   * the Game Objects texture frame to define the position and size of the hit area.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setHitAreaFromTexture\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.\r\n   * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setHitAreaFromTexture: function (gameObjects, callback) {\n    if (callback === undefined) {\n      callback = RectangleContains;\n    }\n\n    if (!Array.isArray(gameObjects)) {\n      gameObjects = [gameObjects];\n    }\n\n    for (var i = 0; i < gameObjects.length; i++) {\n      var gameObject = gameObjects[i];\n      var frame = gameObject.frame;\n      var width = 0;\n      var height = 0;\n\n      if (gameObject.width) {\n        width = gameObject.width;\n        height = gameObject.height;\n      } else if (frame) {\n        width = frame.realWidth;\n        height = frame.realHeight;\n      }\n\n      if (gameObject.type === 'Container' && (width === 0 || height === 0)) {\n        console.warn('Container.setInteractive must specify a Shape or call setSize() first');\n        continue;\n      }\n\n      if (width !== 0 && height !== 0) {\n        gameObject.input = CreateInteractiveObject(gameObject, new Rectangle(0, 0, width, height), callback);\n        this.queueForInsertion(gameObject);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using\r\n   * the given coordinates and dimensions to control its position and size.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setHitAreaRectangle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a rectangular hit area.\r\n   * @param {number} x - The top-left of the rectangle.\r\n   * @param {number} y - The top-left of the rectangle.\r\n   * @param {number} width - The width of the rectangle.\r\n   * @param {number} height - The height of the rectangle.\r\n   * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setHitAreaRectangle: function (gameObjects, x, y, width, height, callback) {\n    if (callback === undefined) {\n      callback = RectangleContains;\n    }\n\n    var shape = new Rectangle(x, y, width, height);\n    return this.setHitArea(gameObjects, shape, callback);\n  },\n\n  /**\r\n   * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Triangle` shape, using\r\n   * the given coordinates to control the position of its points.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setHitAreaTriangle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a  triangular hit area.\r\n   * @param {number} x1 - The x coordinate of the first point of the triangle.\r\n   * @param {number} y1 - The y coordinate of the first point of the triangle.\r\n   * @param {number} x2 - The x coordinate of the second point of the triangle.\r\n   * @param {number} y2 - The y coordinate of the second point of the triangle.\r\n   * @param {number} x3 - The x coordinate of the third point of the triangle.\r\n   * @param {number} y3 - The y coordinate of the third point of the triangle.\r\n   * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Triangle.Contains.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setHitAreaTriangle: function (gameObjects, x1, y1, x2, y2, x3, y3, callback) {\n    if (callback === undefined) {\n      callback = TriangleContains;\n    }\n\n    var shape = new Triangle(x1, y1, x2, y2, x3, y3);\n    return this.setHitArea(gameObjects, shape, callback);\n  },\n\n  /**\r\n   * Creates an Input Debug Shape for the given Game Object.\r\n   *\r\n   * The Game Object must have _already_ been enabled for input prior to calling this method.\r\n   *\r\n   * This is intended to assist you during development and debugging.\r\n   *\r\n   * Debug Shapes can only be created for Game Objects that are using standard Phaser Geometry for input,\r\n   * including: Circle, Ellipse, Line, Polygon, Rectangle and Triangle.\r\n   *\r\n   * Game Objects that are using their automatic hit areas are using Rectangles by default, so will also work.\r\n   *\r\n   * The Debug Shape is created and added to the display list and is then kept in sync with the Game Object\r\n   * it is connected with. Should you need to modify it yourself, such as to hide it, you can access it via\r\n   * the Game Object property: `GameObject.input.hitAreaDebug`.\r\n   *\r\n   * Calling this method on a Game Object that already has a Debug Shape will first destroy the old shape,\r\n   * before creating a new one. If you wish to remove the Debug Shape entirely, you should call the\r\n   * method `InputPlugin.removeDebug`.\r\n   *\r\n   * Note that the debug shape will only show the outline of the input area. If the input test is using a\r\n   * pixel perfect check, for example, then this is not displayed. If you are using a custom shape, that\r\n   * doesn't extend one of the base Phaser Geometry objects, as your hit area, then this method will not\r\n   * work.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#enableDebug\r\n   * @since 3.19.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to create the input debug shape for.\r\n   * @param {number} [color=0x00ff00] - The outline color of the debug shape.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This Input Plugin.\r\n   */\n  enableDebug: function (gameObject, color) {\n    if (color === undefined) {\n      color = 0x00ff00;\n    }\n\n    var input = gameObject.input;\n\n    if (!input || !input.hitArea) {\n      return this;\n    }\n\n    var shape = input.hitArea;\n    var shapeType = shape.type;\n    var debug = input.hitAreaDebug;\n    var factory = this.systems.add;\n    var updateList = this.systems.updateList;\n\n    if (debug) {\n      updateList.remove(debug);\n      debug.destroy();\n      debug = null;\n    }\n\n    var offsetx = 0;\n    var offsety = 0;\n\n    switch (shapeType) {\n      case GEOM_CONST.CIRCLE:\n        debug = factory.arc(0, 0, shape.radius);\n        offsetx = shape.x - shape.radius;\n        offsety = shape.y - shape.radius;\n        break;\n\n      case GEOM_CONST.ELLIPSE:\n        debug = factory.ellipse(0, 0, shape.width, shape.height);\n        offsetx = shape.x - shape.width / 2;\n        offsety = shape.y - shape.height / 2;\n        break;\n\n      case GEOM_CONST.LINE:\n        debug = factory.line(0, 0, shape.x1, shape.y1, shape.x2, shape.y2);\n        break;\n\n      case GEOM_CONST.POLYGON:\n        debug = factory.polygon(0, 0, shape.points);\n        break;\n\n      case GEOM_CONST.RECTANGLE:\n        debug = factory.rectangle(0, 0, shape.width, shape.height);\n        offsetx = shape.x;\n        offsety = shape.y;\n        break;\n\n      case GEOM_CONST.TRIANGLE:\n        debug = factory.triangle(0, 0, shape.x1, shape.y1, shape.x2, shape.y2, shape.x3, shape.y3);\n        break;\n    }\n\n    if (debug) {\n      debug.isFilled = false;\n\n      debug.preUpdate = function () {\n        debug.setStrokeStyle(1 / gameObject.scale, color);\n        debug.setDisplayOrigin(gameObject.displayOriginX, gameObject.displayOriginY);\n        debug.setRotation(gameObject.rotation);\n        debug.setScale(gameObject.scaleX, gameObject.scaleY);\n        debug.setPosition(gameObject.x + offsetx, gameObject.y + offsety);\n        debug.setScrollFactor(gameObject.scrollFactorX, gameObject.scrollFactorY);\n      };\n\n      updateList.add(debug);\n      input.hitAreaDebug = debug;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes an Input Debug Shape from the given Game Object.\r\n   *\r\n   * The shape is destroyed immediately and the `hitAreaDebug` property is set to `null`.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#removeDebug\r\n   * @since 3.19.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to remove the input debug shape from.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This Input Plugin.\r\n   */\n  removeDebug: function (gameObject) {\n    var input = gameObject.input;\n\n    if (input && input.hitAreaDebug) {\n      var debug = input.hitAreaDebug;\n      this.systems.updateList.remove(debug);\n      debug.destroy();\n      input.hitAreaDebug = null;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the Pointers to always poll.\r\n   *\r\n   * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,\r\n   * or being interacted with it, regardless if the Pointer has actually moved or not.\r\n   *\r\n   * You should enable this if you want objects in your game to fire over / out events, and the objects\r\n   * are constantly moving, but the pointer may not have. Polling every frame has additional computation\r\n   * costs, especially if there are a large number of interactive objects in your game.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setPollAlways\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setPollAlways: function () {\n    return this.setPollRate(0);\n  },\n\n  /**\r\n   * Sets the Pointers to only poll when they are moved or updated.\r\n   *\r\n   * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,\r\n   * or being interacted with it.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setPollOnMove\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setPollOnMove: function () {\n    return this.setPollRate(-1);\n  },\n\n  /**\r\n   * Sets the poll rate value. This is the amount of time that should have elapsed before a pointer\r\n   * will be polled again. See the `setPollAlways` and `setPollOnMove` methods.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setPollRate\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} value - The amount of time, in ms, that should elapsed before re-polling the pointers.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setPollRate: function (value) {\n    this.pollRate = value;\n    this._pollTimer = 0;\n    return this;\n  },\n\n  /**\r\n   * When set to `true` the global Input Manager will emulate DOM behavior by only emitting events from\r\n   * the top-most Scene in the Scene List. By default, if a Scene receives an input event it will then stop the event\r\n   * from flowing down to any Scenes below it in the Scene list. To disable this behavior call this method with `false`.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setGlobalTopOnly\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - Set to `true` to stop processing input events on the Scene that receives it, or `false` to let the event continue down the Scene list.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setGlobalTopOnly: function (value) {\n    this.manager.globalTopOnly = value;\n    return this;\n  },\n\n  /**\r\n   * When set to `true` this Input Plugin will emulate DOM behavior by only emitting events from\r\n   * the top-most Game Objects in the Display List.\r\n   *\r\n   * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setTopOnly\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - `true` to only include the top-most Game Object, or `false` to include all Game Objects in a hit test.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  setTopOnly: function (value) {\n    this.topOnly = value;\n    return this;\n  },\n\n  /**\r\n   * Given an array of Game Objects, sort the array and return it, so that the objects are in depth index order\r\n   * with the lowest at the bottom.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#sortGameObjects\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject[]} gameObjects - An array of Game Objects to be sorted.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject[]} The sorted array of Game Objects.\r\n   */\n  sortGameObjects: function (gameObjects) {\n    if (gameObjects.length < 2) {\n      return gameObjects;\n    }\n\n    this.scene.sys.depthSort();\n    return gameObjects.sort(this.sortHandlerGO.bind(this));\n  },\n\n  /**\r\n   * Return the child lowest down the display list (with the smallest index)\r\n   * Will iterate through all parent containers, if present.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#sortHandlerGO\r\n   * @private\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} childA - The first Game Object to compare.\r\n   * @param {Phaser.GameObjects.GameObject} childB - The second Game Object to compare.\r\n   *\r\n   * @return {integer} Returns either a negative or positive integer, or zero if they match.\r\n   */\n  sortHandlerGO: function (childA, childB) {\n    if (!childA.parentContainer && !childB.parentContainer) {\n      //  Quick bail out when neither child has a container\n      return this.displayList.getIndex(childB) - this.displayList.getIndex(childA);\n    } else if (childA.parentContainer === childB.parentContainer) {\n      //  Quick bail out when both children have the same container\n      return childB.parentContainer.getIndex(childB) - childA.parentContainer.getIndex(childA);\n    } else if (childA.parentContainer === childB) {\n      //  Quick bail out when childA is a child of childB\n      return -1;\n    } else if (childB.parentContainer === childA) {\n      //  Quick bail out when childA is a child of childB\n      return 1;\n    } else {\n      //  Container index check\n      var listA = childA.getIndexList();\n      var listB = childB.getIndexList();\n      var len = Math.min(listA.length, listB.length);\n\n      for (var i = 0; i < len; i++) {\n        var indexA = listA[i];\n        var indexB = listB[i];\n\n        if (indexA === indexB) {\n          //  Go to the next level down\n          continue;\n        } else {\n          //  Non-matching parents, so return\n          return indexB - indexA;\n        }\n      }\n    } //  Technically this shouldn't happen, but ...\n\n\n    return 0;\n  },\n\n  /**\r\n   * This method should be called from within an input event handler, such as `pointerdown`.\r\n   *\r\n   * When called, it stops the Input Manager from allowing _this specific event_ to be processed by any other Scene\r\n   * not yet handled in the scene list.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#stopPropagation\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n   */\n  stopPropagation: function () {\n    this.manager._tempSkip = true;\n    return this;\n  },\n\n  /**\r\n   * Adds new Pointer objects to the Input Manager.\r\n   *\r\n   * By default Phaser creates 2 pointer objects: `mousePointer` and `pointer1`.\r\n   *\r\n   * You can create more either by calling this method, or by setting the `input.activePointers` property\r\n   * in the Game Config, up to a maximum of 10 pointers.\r\n   *\r\n   * The first 10 pointers are available via the `InputPlugin.pointerX` properties, once they have been added\r\n   * via this method.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#addPointer\r\n   * @since 3.10.0\r\n   *\r\n   * @param {integer} [quantity=1] The number of new Pointers to create. A maximum of 10 is allowed in total.\r\n   *\r\n   * @return {Phaser.Input.Pointer[]} An array containing all of the new Pointer objects that were created.\r\n   */\n  addPointer: function (quantity) {\n    return this.manager.addPointer(quantity);\n  },\n\n  /**\r\n   * Tells the Input system to set a custom cursor.\r\n   *\r\n   * This cursor will be the default cursor used when interacting with the game canvas.\r\n   *\r\n   * If an Interactive Object also sets a custom cursor, this is the cursor that is reset after its use.\r\n   *\r\n   * Any valid CSS cursor value is allowed, including paths to image files, i.e.:\r\n   *\r\n   * ```javascript\r\n   * this.input.setDefaultCursor('url(assets/cursors/sword.cur), pointer');\r\n   * ```\r\n   *\r\n   * Please read about the differences between browsers when it comes to the file formats and sizes they support:\r\n   *\r\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\r\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_User_Interface/Using_URL_values_for_the_cursor_property\r\n   *\r\n   * It's up to you to pick a suitable cursor format that works across the range of browsers you need to support.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#setDefaultCursor\r\n   * @since 3.10.0\r\n   *\r\n   * @param {string} cursor - The CSS to be used when setting the default cursor.\r\n   *\r\n   * @return {Phaser.Input.InputPlugin} This Input instance.\r\n   */\n  setDefaultCursor: function (cursor) {\n    this.manager.setDefaultCursor(cursor);\n    return this;\n  },\n\n  /**\r\n   * The Scene that owns this plugin is transitioning in.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#transitionIn\r\n   * @private\r\n   * @since 3.5.0\r\n   */\n  transitionIn: function () {\n    this.enabled = this.settings.transitionAllowInput;\n  },\n\n  /**\r\n   * The Scene that owns this plugin has finished transitioning in.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#transitionComplete\r\n   * @private\r\n   * @since 3.5.0\r\n   */\n  transitionComplete: function () {\n    if (!this.settings.transitionAllowInput) {\n      this.enabled = true;\n    }\n  },\n\n  /**\r\n   * The Scene that owns this plugin is transitioning out.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#transitionOut\r\n   * @private\r\n   * @since 3.5.0\r\n   */\n  transitionOut: function () {\n    this.enabled = this.settings.transitionAllowInput;\n  },\n\n  /**\r\n   * The Scene that owns this plugin is shutting down.\r\n   * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#shutdown\r\n   * @fires Phaser.Input.Events#SHUTDOWN\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  shutdown: function () {\n    //  Registered input plugins listen for this\n    this.pluginEvents.emit(Events.SHUTDOWN);\n    this._temp.length = 0;\n    this._list.length = 0;\n    this._draggable.length = 0;\n    this._pendingRemoval.length = 0;\n    this._pendingInsertion.length = 0;\n    this._dragState.length = 0;\n\n    for (var i = 0; i < 10; i++) {\n      this._drag[i] = [];\n      this._over[i] = [];\n    }\n\n    this.removeAllListeners();\n    var eventEmitter = this.systems.events;\n    eventEmitter.off(SceneEvents.TRANSITION_START, this.transitionIn, this);\n    eventEmitter.off(SceneEvents.TRANSITION_OUT, this.transitionOut, this);\n    eventEmitter.off(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);\n    eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);\n    this.manager.events.off(Events.GAME_OUT, this.onGameOut, this);\n    this.manager.events.off(Events.GAME_OVER, this.onGameOver, this);\n    eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\n  },\n\n  /**\r\n   * The Scene that owns this plugin is being destroyed.\r\n   * We need to shutdown and then kill off all external references.\r\n   *\r\n   * @method Phaser.Input.InputPlugin#destroy\r\n   * @fires Phaser.Input.Events#DESTROY\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.shutdown(); //  Registered input plugins listen for this\n\n    this.pluginEvents.emit(Events.DESTROY);\n    this.pluginEvents.removeAllListeners();\n    this.scene.sys.events.off(SceneEvents.START, this.start, this);\n    this.scene = null;\n    this.cameras = null;\n    this.manager = null;\n    this.events = null;\n    this.mouse = null;\n  },\n\n  /**\r\n   * The x coordinates of the ActivePointer based on the first camera in the camera list.\r\n   * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#x\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  x: {\n    get: function () {\n      return this.manager.activePointer.x;\n    }\n  },\n\n  /**\r\n   * The y coordinates of the ActivePointer based on the first camera in the camera list.\r\n   * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#y\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  y: {\n    get: function () {\n      return this.manager.activePointer.y;\n    }\n  },\n\n  /**\r\n   * Are any mouse or touch pointers currently over the game canvas?\r\n   *\r\n   * @name Phaser.Input.InputPlugin#isOver\r\n   * @type {boolean}\r\n   * @readonly\r\n   * @since 3.16.0\r\n   */\n  isOver: {\n    get: function () {\n      return this.manager.isOver;\n    }\n  },\n\n  /**\r\n   * The mouse has its own unique Pointer object, which you can reference directly if making a _desktop specific game_.\r\n   * If you are supporting both desktop and touch devices then do not use this property, instead use `activePointer`\r\n   * which will always map to the most recently interacted pointer.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#mousePointer\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  mousePointer: {\n    get: function () {\n      return this.manager.mousePointer;\n    }\n  },\n\n  /**\r\n   * The current active input Pointer.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#activePointer\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.0.0\r\n   */\n  activePointer: {\n    get: function () {\n      return this.manager.activePointer;\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer1\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer1: {\n    get: function () {\n      return this.manager.pointers[1];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer2\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer2: {\n    get: function () {\n      return this.manager.pointers[2];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer3\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer3: {\n    get: function () {\n      return this.manager.pointers[3];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer4\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer4: {\n    get: function () {\n      return this.manager.pointers[4];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer5\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer5: {\n    get: function () {\n      return this.manager.pointers[5];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer6\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer6: {\n    get: function () {\n      return this.manager.pointers[6];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer7\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer7: {\n    get: function () {\n      return this.manager.pointers[7];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer8\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer8: {\n    get: function () {\n      return this.manager.pointers[8];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer9\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer9: {\n    get: function () {\n      return this.manager.pointers[9];\n    }\n  },\n\n  /**\r\n   * A touch-based Pointer object.\r\n   * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n   *\r\n   * @name Phaser.Input.InputPlugin#pointer10\r\n   * @type {Phaser.Input.Pointer}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  pointer10: {\n    get: function () {\n      return this.manager.pointers[10];\n    }\n  }\n});\nPluginCache.register('InputPlugin', InputPlugin, 'input');\nmodule.exports = InputPlugin;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/input/InputPlugin.js"],"names":["Circle","require","CircleContains","Class","CONST","CreateInteractiveObject","CreatePixelPerfectHandler","DistanceBetween","Ellipse","EllipseContains","Events","EventEmitter","GetFastValue","GEOM_CONST","InputPluginCache","IsPlainObject","PluginCache","Rectangle","RectangleContains","SceneEvents","Triangle","TriangleContains","InputPlugin","Extends","initialize","scene","call","systems","sys","settings","manager","game","input","pluginEvents","enabled","displayList","cameras","install","mouse","topOnly","pollRate","_pollTimer","_eventData","cancelled","_eventContainer","stopPropagation","dragDistanceThreshold","dragTimeThreshold","_temp","_tempZones","_list","_pendingInsertion","_pendingRemoval","_draggable","_drag","_dragState","_over","_validTypes","_updatedThisFrame","events","once","BOOT","boot","on","START","start","DESTROY","destroy","emit","eventEmitter","TRANSITION_START","transitionIn","TRANSITION_OUT","transitionOut","TRANSITION_COMPLETE","transitionComplete","PRE_UPDATE","preUpdate","SHUTDOWN","shutdown","GAME_OUT","onGameOut","GAME_OVER","onGameOver","event","isActive","timeStamp","removeList","insertList","toRemove","length","toInsert","current","i","gameObject","index","indexOf","splice","clear","concat","updatePoll","time","delta","UPDATE","pointers","pointersTotal","updateMotion","rate","captured","total","pointer","hitTestPointer","sortGameObjects","processOverOutEvents","getDragState","processDragThresholdEvent","update","type","MOUSE_DOWN","processDragDownEvent","processDownEvents","MOUSE_UP","processDragUpEvent","processUpEvents","TOUCH_START","processOverEvents","TOUCH_END","TOUCH_CANCEL","processOutEvents","MOUSE_MOVE","TOUCH_MOVE","processDragMoveEvent","processMoveEvents","MOUSE_WHEEL","processWheelEvent","skipQueue","undefined","queueForRemoval","target","hitArea","hitAreaCallback","callbackContext","resetCursor","disable","enable","shape","callback","dropZone","setHitArea","getCamerasBelowPointer","c","camera","over","hitTest","obj","push","currentlyOver","aborted","GAMEOBJECT_POINTER_DOWN","localX","localY","GAMEOBJECT_DOWN","downElement","canvas","POINTER_DOWN","POINTER_DOWN_OUTSIDE","id","setDragState","state","passed","timeThreshold","distanceThreshold","x","y","downX","downY","downTime","processDragStartList","list","dragState","dragStartX","dragStartY","dragStartXGlobal","dragStartYGlobal","dragX","dragY","GAMEOBJECT_DRAG_START","DRAG_START","primaryDown","draglist","draggable","loop","now","dropZones","GAMEOBJECT_DRAG_OVER","DRAG_OVER","GAMEOBJECT_DRAG_LEAVE","DRAG_LEAVE","GAMEOBJECT_DRAG_ENTER","DRAG_ENTER","parentContainer","dx","dy","rotation","getParentRotation","dxRotated","Math","cos","sin","dyRotated","scaleX","scaleY","GAMEOBJECT_DRAG","DRAG","displayOriginX","displayOriginY","dropped","GAMEOBJECT_DROP","DROP","GAMEOBJECT_DRAG_END","DRAG_END","GAMEOBJECT_POINTER_MOVE","GAMEOBJECT_MOVE","POINTER_MOVE","deltaX","deltaY","dz","deltaZ","GAMEOBJECT_POINTER_WHEEL","GAMEOBJECT_WHEEL","POINTER_WHEEL","totalInteracted","justOver","setCursor","GAMEOBJECT_POINTER_OVER","GAMEOBJECT_OVER","POINTER_OVER","previouslyOver","GAMEOBJECT_POINTER_OUT","GAMEOBJECT_OUT","POINTER_OUT","justOut","stillOver","currentlyDragging","GAMEOBJECT_POINTER_UP","GAMEOBJECT_UP","upElement","POINTER_UP","POINTER_UP_OUTSIDE","queueForInsertion","child","setDraggable","gameObjects","value","Array","isArray","makePixelPerfect","alphaTolerance","textureManager","textures","setHitAreaFromTexture","cursor","useHandCursor","pixelPerfect","customHitArea","config","console","warn","io","setHitAreaCircle","radius","setHitAreaEllipse","width","height","frame","realWidth","realHeight","setHitAreaRectangle","setHitAreaTriangle","x1","y1","x2","y2","x3","y3","enableDebug","color","shapeType","debug","hitAreaDebug","factory","add","updateList","remove","offsetx","offsety","CIRCLE","arc","ELLIPSE","ellipse","LINE","line","POLYGON","polygon","points","RECTANGLE","rectangle","TRIANGLE","triangle","isFilled","setStrokeStyle","scale","setDisplayOrigin","setRotation","setScale","setPosition","setScrollFactor","scrollFactorX","scrollFactorY","removeDebug","setPollAlways","setPollRate","setPollOnMove","setGlobalTopOnly","globalTopOnly","setTopOnly","depthSort","sort","sortHandlerGO","bind","childA","childB","getIndex","listA","getIndexList","listB","len","min","indexA","indexB","_tempSkip","addPointer","quantity","setDefaultCursor","transitionAllowInput","removeAllListeners","off","get","activePointer","isOver","mousePointer","pointer1","pointer2","pointer3","pointer4","pointer5","pointer6","pointer7","pointer8","pointer9","pointer10","register","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Circle = require('../geom/circle/Circle');\r\nvar CircleContains = require('../geom/circle/Contains');\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar CreateInteractiveObject = require('./CreateInteractiveObject');\r\nvar CreatePixelPerfectHandler = require('./CreatePixelPerfectHandler');\r\nvar DistanceBetween = require('../math/distance/DistanceBetween');\r\nvar Ellipse = require('../geom/ellipse/Ellipse');\r\nvar EllipseContains = require('../geom/ellipse/Contains');\r\nvar Events = require('./events');\r\nvar EventEmitter = require('eventemitter3');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar GEOM_CONST = require('../geom/const');\r\nvar InputPluginCache = require('./InputPluginCache');\r\nvar IsPlainObject = require('../utils/object/IsPlainObject');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar Rectangle = require('../geom/rectangle/Rectangle');\r\nvar RectangleContains = require('../geom/rectangle/Contains');\r\nvar SceneEvents = require('../scene/events');\r\nvar Triangle = require('../geom/triangle/Triangle');\r\nvar TriangleContains = require('../geom/triangle/Contains');\r\n\r\n/**\r\n * @classdesc\r\n * The Input Plugin belongs to a Scene and handles all input related events and operations for it.\r\n *\r\n * You can access it from within a Scene using `this.input`.\r\n *\r\n * It emits events directly. For example, you can do:\r\n *\r\n * ```javascript\r\n * this.input.on('pointerdown', callback, context);\r\n * ```\r\n *\r\n * To listen for a pointer down event anywhere on the game canvas.\r\n *\r\n * Game Objects can be enabled for input by calling their `setInteractive` method. After which they\r\n * will directly emit input events:\r\n *\r\n * ```javascript\r\n * var sprite = this.add.sprite(x, y, texture);\r\n * sprite.setInteractive();\r\n * sprite.on('pointerdown', callback, context);\r\n * ```\r\n *\r\n * There are lots of game configuration options available relating to input.\r\n * See the [Input Config object]{@linkcode Phaser.Types.Core.InputConfig} for more details, including how to deal with Phaser\r\n * listening for input events outside of the canvas, how to set a default number of pointers, input\r\n * capture settings and more.\r\n *\r\n * Please also see the Input examples and tutorials for further information.\r\n *\r\n * @class InputPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that this Input Plugin is responsible for.\r\n */\r\nvar InputPlugin = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function InputPlugin (scene)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Scene that this Input Plugin is responsible for.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems class.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * A reference to the Scene Systems Settings.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#settings\r\n         * @type {Phaser.Types.Scenes.SettingsObject}\r\n         * @since 3.5.0\r\n         */\r\n        this.settings = scene.sys.settings;\r\n\r\n        /**\r\n         * A reference to the Game Input Manager.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#manager\r\n         * @type {Phaser.Input.InputManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = scene.sys.game.input;\r\n\r\n        /**\r\n         * Internal event queue used for plugins only.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#pluginEvents\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this.pluginEvents = new EventEmitter();\r\n\r\n        /**\r\n         * If `true` this Input Plugin will process DOM input events.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.5.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * A reference to the Scene Display List. This property is set during the `boot` method.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @since 3.0.0\r\n         */\r\n        this.displayList;\r\n\r\n        /**\r\n         * A reference to the Scene Cameras Manager. This property is set during the `boot` method.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#cameras\r\n         * @type {Phaser.Cameras.Scene2D.CameraManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.cameras;\r\n\r\n        //  Inject the available input plugins into this class\r\n        InputPluginCache.install(this);\r\n\r\n        /**\r\n         * A reference to the Mouse Manager.\r\n         *\r\n         * This property is only set if Mouse support has been enabled in your Game Configuration file.\r\n         *\r\n         * If you just wish to get access to the mouse pointer, use the `mousePointer` property instead.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#mouse\r\n         * @type {?Phaser.Input.Mouse.MouseManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.mouse = this.manager.mouse;\r\n\r\n        /**\r\n         * When set to `true` (the default) the Input Plugin will emulate DOM behavior by only emitting events from\r\n         * the top-most Game Objects in the Display List.\r\n         *\r\n         * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#topOnly\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.topOnly = true;\r\n\r\n        /**\r\n         * How often should the Pointers be checked?\r\n         *\r\n         * The value is a time, given in ms, and is the time that must have elapsed between game steps before\r\n         * the Pointers will be polled again. When a pointer is polled it runs a hit test to see which Game\r\n         * Objects are currently below it, or being interacted with it.\r\n         *\r\n         * Pointers will *always* be checked if they have been moved by the user, or press or released.\r\n         *\r\n         * This property only controls how often they will be polled if they have not been updated.\r\n         * You should set this if you want to have Game Objects constantly check against the pointers, even\r\n         * if the pointer didn't itself move.\r\n         *\r\n         * Set to 0 to poll constantly. Set to -1 to only poll on user movement.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#pollRate\r\n         * @type {integer}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.pollRate = -1;\r\n\r\n        /**\r\n         * Internal poll timer value.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pollTimer\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._pollTimer = 0;\r\n\r\n        var _eventData = { cancelled: false };\r\n\r\n        /**\r\n         * Internal event propagation callback container.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_eventContainer\r\n         * @type {Phaser.Types.Input.EventData}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._eventContainer = {\r\n            stopPropagation: function ()\r\n            {\r\n                _eventData.cancelled = true;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Internal event propagation data object.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_eventData\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._eventData = _eventData;\r\n\r\n        /**\r\n         * The distance, in pixels, a pointer has to move while being held down, before it thinks it is being dragged.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#dragDistanceThreshold\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.dragDistanceThreshold = 0;\r\n\r\n        /**\r\n         * The amount of time, in ms, a pointer has to be held down before it thinks it is dragging.\r\n         *\r\n         * The default polling rate is to poll only on move so once the time threshold is reached the\r\n         * drag event will not start until you move the mouse. If you want it to start immediately\r\n         * when the time threshold is reached, you must increase the polling rate by calling\r\n         * [setPollAlways]{@linkcode Phaser.Input.InputPlugin#setPollAlways} or\r\n         * [setPollRate]{@linkcode Phaser.Input.InputPlugin#setPollRate}.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#dragTimeThreshold\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.dragTimeThreshold = 0;\r\n\r\n        /**\r\n         * Used to temporarily store the results of the Hit Test\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_temp\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._temp = [];\r\n\r\n        /**\r\n         * Used to temporarily store the results of the Hit Test dropZones\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_tempZones\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._tempZones = [];\r\n\r\n        /**\r\n         * A list of all Game Objects that have been set to be interactive in the Scene this Input Plugin is managing.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_list\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._list = [];\r\n\r\n        /**\r\n         * Objects waiting to be inserted to the list on the next call to 'begin'.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pendingInsertion\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._pendingInsertion = [];\r\n\r\n        /**\r\n         * Objects waiting to be removed from the list on the next call to 'begin'.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pendingRemoval\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._pendingRemoval = [];\r\n\r\n        /**\r\n         * A list of all Game Objects that have been enabled for dragging.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_draggable\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._draggable = [];\r\n\r\n        /**\r\n         * A list of all Interactive Objects currently considered as being 'draggable' by any pointer, indexed by pointer ID.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_drag\r\n         * @type {{0:Array,1:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array,10:Array}}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._drag = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] };\r\n\r\n        /**\r\n         * A array containing the dragStates, for this Scene, index by the Pointer ID.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_dragState\r\n         * @type {integer[]}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._dragState = [];\r\n\r\n        /**\r\n         * A list of all Interactive Objects currently considered as being 'over' by any pointer, indexed by pointer ID.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_over\r\n         * @type {{0:Array,1:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array,10:Array}}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._over = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] };\r\n\r\n        /**\r\n         * A list of valid DOM event types.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_validTypes\r\n         * @type {string[]}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._validTypes = [ 'onDown', 'onUp', 'onOver', 'onOut', 'onMove', 'onDragStart', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragLeave', 'onDragOver', 'onDrop' ];\r\n\r\n        /**\r\n         * Internal property that tracks frame event state.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_updatedThisFrame\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.18.0\r\n         */\r\n        this._updatedThisFrame = false;\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        scene.sys.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#boot\r\n     * @fires Phaser.Input.Events#BOOT\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.cameras = this.systems.cameras;\r\n\r\n        this.displayList = this.systems.displayList;\r\n\r\n        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.BOOT);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#start\r\n     * @fires Phaser.Input.Events#START\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.on(SceneEvents.TRANSITION_START, this.transitionIn, this);\r\n        eventEmitter.on(SceneEvents.TRANSITION_OUT, this.transitionOut, this);\r\n        eventEmitter.on(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);\r\n        eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);\r\n        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n\r\n        this.manager.events.on(Events.GAME_OUT, this.onGameOut, this);\r\n        this.manager.events.on(Events.GAME_OVER, this.onGameOver, this);\r\n\r\n        this.enabled = true;\r\n\r\n        //  Populate the pointer drag states\r\n        this._dragState = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\r\n\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.START);\r\n    },\r\n\r\n    /**\r\n     * Game Over handler.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#onGameOver\r\n     * @fires Phaser.Input.Events#GAME_OVER\r\n     * @private\r\n     * @since 3.16.2\r\n     */\r\n    onGameOver: function (event)\r\n    {\r\n        if (this.isActive())\r\n        {\r\n            this.emit(Events.GAME_OVER, event.timeStamp, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Game Out handler.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#onGameOut\r\n     * @fires Phaser.Input.Events#GAME_OUT\r\n     * @private\r\n     * @since 3.16.2\r\n     */\r\n    onGameOut: function (event)\r\n    {\r\n        if (this.isActive())\r\n        {\r\n            this.emit(Events.GAME_OUT, event.timeStamp, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The pre-update handler is responsible for checking the pending removal and insertion lists and\r\n     * deleting old Game Objects.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#preUpdate\r\n     * @private\r\n     * @fires Phaser.Input.Events#PRE_UPDATE\r\n     * @since 3.0.0\r\n     */\r\n    preUpdate: function ()\r\n    {\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.PRE_UPDATE);\r\n\r\n        var removeList = this._pendingRemoval;\r\n        var insertList = this._pendingInsertion;\r\n\r\n        var toRemove = removeList.length;\r\n        var toInsert = insertList.length;\r\n\r\n        if (toRemove === 0 && toInsert === 0)\r\n        {\r\n            //  Quick bail\r\n            return;\r\n        }\r\n\r\n        var current = this._list;\r\n\r\n        //  Delete old gameObjects\r\n        for (var i = 0; i < toRemove; i++)\r\n        {\r\n            var gameObject = removeList[i];\r\n\r\n            var index = current.indexOf(gameObject);\r\n\r\n            if (index > -1)\r\n            {\r\n                current.splice(index, 1);\r\n\r\n                this.clear(gameObject, true);\r\n            }\r\n        }\r\n\r\n        //  Clear the removal list\r\n        removeList.length = 0;\r\n        this._pendingRemoval.length = 0;\r\n\r\n        //  Move pendingInsertion to list (also clears pendingInsertion at the same time)\r\n        this._list = current.concat(insertList.splice(0));\r\n    },\r\n\r\n    /**\r\n     * Checks to see if both this plugin and the Scene to which it belongs is active.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#isActive\r\n     * @since 3.10.0\r\n     *\r\n     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n     */\r\n    isActive: function ()\r\n    {\r\n        return (this.enabled && this.scene.sys.isActive());\r\n    },\r\n\r\n    /**\r\n     * This is called automatically by the Input Manager.\r\n     * It emits events for plugins to listen to and also handles polling updates, if enabled.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#updatePoll\r\n     * @since 3.18.0\r\n     *\r\n     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     *\r\n     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n     */\r\n    updatePoll: function (time, delta)\r\n    {\r\n        if (!this.isActive())\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //  The plugins should update every frame, regardless if there has been\r\n        //  any DOM input events or not (such as the Gamepad and Keyboard)\r\n        this.pluginEvents.emit(Events.UPDATE, time, delta);\r\n\r\n        //  We can leave now if we've already updated once this frame via the immediate DOM event handlers\r\n        if (this._updatedThisFrame)\r\n        {\r\n            this._updatedThisFrame = false;\r\n\r\n            return false;\r\n        }\r\n\r\n        var i;\r\n        var manager = this.manager;\r\n\r\n        var pointers = manager.pointers;\r\n        var pointersTotal = manager.pointersTotal;\r\n\r\n        for (i = 0; i < pointersTotal; i++)\r\n        {\r\n            pointers[i].updateMotion();\r\n        }\r\n\r\n        //  No point going any further if there aren't any interactive objects\r\n        if (this._list.length === 0)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var rate = this.pollRate;\r\n\r\n        if (rate === -1)\r\n        {\r\n            return false;\r\n        }\r\n        else if (rate > 0)\r\n        {\r\n            this._pollTimer -= delta;\r\n\r\n            if (this._pollTimer < 0)\r\n            {\r\n                //  Discard timer diff, we're ready to poll again\r\n                this._pollTimer = this.pollRate;\r\n            }\r\n            else\r\n            {\r\n                //  Not enough time has elapsed since the last poll, so abort now\r\n                return false;\r\n            }\r\n        }\r\n\r\n        //  We got this far? Then we should poll for movement\r\n        var captured = false;\r\n\r\n        for (i = 0; i < pointersTotal; i++)\r\n        {\r\n            var total = 0;\r\n\r\n            var pointer = pointers[i];\r\n\r\n            //  Always reset this array\r\n            this._tempZones = [];\r\n\r\n            //  _temp contains a hit tested and camera culled list of IO objects\r\n            this._temp = this.hitTestPointer(pointer);\r\n\r\n            this.sortGameObjects(this._temp);\r\n            this.sortGameObjects(this._tempZones);\r\n\r\n            if (this.topOnly)\r\n            {\r\n                //  Only the top-most one counts now, so safely ignore the rest\r\n                if (this._temp.length)\r\n                {\r\n                    this._temp.splice(1);\r\n                }\r\n\r\n                if (this._tempZones.length)\r\n                {\r\n                    this._tempZones.splice(1);\r\n                }\r\n            }\r\n\r\n            total += this.processOverOutEvents(pointer);\r\n\r\n            if (this.getDragState(pointer) === 2)\r\n            {\r\n                this.processDragThresholdEvent(pointer, time);\r\n            }\r\n\r\n            if (total > 0)\r\n            {\r\n                //  We interacted with an event in this Scene, so block any Scenes below us from doing the same this frame\r\n                captured = true;\r\n            }\r\n        }\r\n\r\n        return captured;\r\n    },\r\n\r\n    /**\r\n     * This method is called when a DOM Event is received by the Input Manager. It handles dispatching the events\r\n     * to relevant input enabled Game Objects in this scene.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#update\r\n     * @private\r\n     * @fires Phaser.Input.Events#UPDATE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} type - The type of event to process.\r\n     * @param {Phaser.Input.Pointer[]} pointers - An array of Pointers on which the event occurred.\r\n     *\r\n     * @return {boolean} `true` if this Scene has captured the input events from all other Scenes, otherwise `false`.\r\n     */\r\n    update: function (type, pointers)\r\n    {\r\n        if (!this.isActive())\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var pointersTotal = pointers.length;\r\n        var captured = false;\r\n\r\n        for (var i = 0; i < pointersTotal; i++)\r\n        {\r\n            var total = 0;\r\n            var pointer = pointers[i];\r\n\r\n            //  Always reset this array\r\n            this._tempZones = [];\r\n\r\n            //  _temp contains a hit tested and camera culled list of IO objects\r\n            this._temp = this.hitTestPointer(pointer);\r\n\r\n            this.sortGameObjects(this._temp);\r\n            this.sortGameObjects(this._tempZones);\r\n\r\n            if (this.topOnly)\r\n            {\r\n                //  Only the top-most one counts now, so safely ignore the rest\r\n                if (this._temp.length)\r\n                {\r\n                    this._temp.splice(1);\r\n                }\r\n\r\n                if (this._tempZones.length)\r\n                {\r\n                    this._tempZones.splice(1);\r\n                }\r\n            }\r\n\r\n            switch (type)\r\n            {\r\n                case CONST.MOUSE_DOWN:\r\n                    total += this.processDragDownEvent(pointer);\r\n                    total += this.processDownEvents(pointer);\r\n                    total += this.processOverOutEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.MOUSE_UP:\r\n                    total += this.processDragUpEvent(pointer);\r\n                    total += this.processUpEvents(pointer);\r\n                    total += this.processOverOutEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.TOUCH_START:\r\n                    total += this.processDragDownEvent(pointer);\r\n                    total += this.processDownEvents(pointer);\r\n                    total += this.processOverEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.TOUCH_END:\r\n                case CONST.TOUCH_CANCEL:\r\n                    total += this.processDragUpEvent(pointer);\r\n                    total += this.processUpEvents(pointer);\r\n                    total += this.processOutEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.MOUSE_MOVE:\r\n                case CONST.TOUCH_MOVE:\r\n                    total += this.processDragMoveEvent(pointer);\r\n                    total += this.processMoveEvents(pointer);\r\n                    total += this.processOverOutEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.MOUSE_WHEEL:\r\n                    total += this.processWheelEvent(pointer);\r\n                    break;\r\n            }\r\n\r\n            if (total > 0)\r\n            {\r\n                //  We interacted with an event in this Scene, so block any Scenes below us from doing the same this frame\r\n                captured = true;\r\n            }\r\n        }\r\n\r\n        this._updatedThisFrame = true;\r\n\r\n        return captured;\r\n    },\r\n\r\n    /**\r\n     * Clears a Game Object so it no longer has an Interactive Object associated with it.\r\n     * The Game Object is then queued for removal from the Input Plugin on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will have its Interactive Object removed.\r\n     * @param {boolean} [skipQueue=false] - Skip adding this Game Object into the removal queue?\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that had its Interactive Object removed.\r\n     */\r\n    clear: function (gameObject, skipQueue)\r\n    {\r\n        if (skipQueue === undefined) { skipQueue = false; }\r\n\r\n        var input = gameObject.input;\r\n\r\n        // If GameObject.input already cleared from higher class\r\n        if (!input)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (!skipQueue)\r\n        {\r\n            this.queueForRemoval(gameObject);\r\n        }\r\n\r\n        input.gameObject = undefined;\r\n        input.target = undefined;\r\n        input.hitArea = undefined;\r\n        input.hitAreaCallback = undefined;\r\n        input.callbackContext = undefined;\r\n\r\n        this.manager.resetCursor(input);\r\n\r\n        gameObject.input = null;\r\n\r\n        //  Clear from _draggable, _drag and _over\r\n        var index = this._draggable.indexOf(gameObject);\r\n\r\n        if (index > -1)\r\n        {\r\n            this._draggable.splice(index, 1);\r\n        }\r\n\r\n        index = this._drag[0].indexOf(gameObject);\r\n\r\n        if (index > -1)\r\n        {\r\n            this._drag[0].splice(index, 1);\r\n        }\r\n\r\n        index = this._over[0].indexOf(gameObject);\r\n\r\n        if (index > -1)\r\n        {\r\n            this._over[0].splice(index, 1);\r\n        }\r\n\r\n        return gameObject;\r\n    },\r\n\r\n    /**\r\n     * Disables Input on a single Game Object.\r\n     *\r\n     * An input disabled Game Object still retains its Interactive Object component and can be re-enabled\r\n     * at any time, by passing it to `InputPlugin.enable`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#disable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to have its input system disabled.\r\n     */\r\n    disable: function (gameObject)\r\n    {\r\n        gameObject.input.enabled = false;\r\n    },\r\n\r\n    /**\r\n     * Enable a Game Object for interaction.\r\n     *\r\n     * If the Game Object already has an Interactive Object component, it is enabled and returned.\r\n     *\r\n     * Otherwise, a new Interactive Object component is created and assigned to the Game Object's `input` property.\r\n     *\r\n     * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area\r\n     * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced\r\n     * input detection.\r\n     *\r\n     * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If\r\n     * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific\r\n     * shape for it to use.\r\n     *\r\n     * You can also provide an Input Configuration Object as the only argument to this method.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#enable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to be enabled for input.\r\n     * @param {(Phaser.Types.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The 'contains' function to invoke to check if the pointer is within the hit area.\r\n     * @param {boolean} [dropZone=false] - Is this Game Object a drop zone or not?\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This Input Plugin.\r\n     */\r\n    enable: function (gameObject, shape, callback, dropZone)\r\n    {\r\n        if (dropZone === undefined) { dropZone = false; }\r\n\r\n        if (gameObject.input)\r\n        {\r\n            //  If it is already has an InteractiveObject then just enable it and return\r\n            gameObject.input.enabled = true;\r\n        }\r\n        else\r\n        {\r\n            //  Create an InteractiveObject and enable it\r\n            this.setHitArea(gameObject, shape, callback);\r\n        }\r\n\r\n        if (gameObject.input && dropZone && !gameObject.input.dropZone)\r\n        {\r\n            gameObject.input.dropZone = dropZone;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes the given Pointer and performs a hit test against it, to see which interactive Game Objects\r\n     * it is currently above.\r\n     *\r\n     * The hit test is performed against which-ever Camera the Pointer is over. If it is over multiple\r\n     * cameras, it starts checking the camera at the top of the camera list, and if nothing is found, iterates down the list.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#hitTestPointer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to check against the Game Objects.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} An array of all the interactive Game Objects the Pointer was above.\r\n     */\r\n    hitTestPointer: function (pointer)\r\n    {\r\n        var cameras = this.cameras.getCamerasBelowPointer(pointer);\r\n\r\n        for (var c = 0; c < cameras.length; c++)\r\n        {\r\n            var camera = cameras[c];\r\n\r\n            //  Get a list of all objects that can be seen by the camera below the pointer in the scene and store in 'over' array.\r\n            //  All objects in this array are input enabled, as checked by the hitTest method, so we don't need to check later on as well.\r\n            var over = this.manager.hitTest(pointer, this._list, camera);\r\n\r\n            //  Filter out the drop zones\r\n            for (var i = 0; i < over.length; i++)\r\n            {\r\n                var obj = over[i];\r\n\r\n                if (obj.input.dropZone)\r\n                {\r\n                    this._tempZones.push(obj);\r\n                }\r\n            }\r\n\r\n            if (over.length > 0)\r\n            {\r\n                pointer.camera = camera;\r\n\r\n                return over;\r\n            }\r\n        }\r\n\r\n        //  If we got this far then there were no Game Objects below the pointer, but it was still over\r\n        //  a camera, so set that the top-most one into the pointer\r\n\r\n        pointer.camera = cameras[0];\r\n\r\n        return [];\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer down event.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDownEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_DOWN\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DOWN\r\n     * @fires Phaser.Input.Events#POINTER_DOWN\r\n     * @fires Phaser.Input.Events#POINTER_DOWN_OUTSIDE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer being tested.\r\n     *\r\n     * @return {integer} The total number of objects interacted with.\r\n     */\r\n    processDownEvents: function (pointer)\r\n    {\r\n        var total = 0;\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            total++;\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_POINTER_DOWN, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit(Events.GAMEOBJECT_DOWN, pointer, gameObject, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        //  If they released outside the canvas, but pressed down inside it, we'll still dispatch the event.\r\n        if (!aborted && this.manager)\r\n        {\r\n            if (pointer.downElement === this.manager.game.canvas)\r\n            {\r\n                this.emit(Events.POINTER_DOWN, pointer, currentlyOver);\r\n            }\r\n            else\r\n            {\r\n                this.emit(Events.POINTER_DOWN_OUTSIDE, pointer);\r\n            }\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * Returns the drag state of the given Pointer for this Input Plugin.\r\n     *\r\n     * The state will be one of the following:\r\n     *\r\n     * 0 = Not dragging anything\r\n     * 1 = Primary button down and objects below, so collect a draglist\r\n     * 2 = Pointer being checked if meets drag criteria\r\n     * 3 = Pointer meets criteria, notify the draglist\r\n     * 4 = Pointer actively dragging the draglist and has moved\r\n     * 5 = Pointer actively dragging but has been released, notify draglist\r\n     *\r\n     * @method Phaser.Input.InputPlugin#getDragState\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to get the drag state for.\r\n     *\r\n     * @return {integer} The drag state of the given Pointer.\r\n     */\r\n    getDragState: function (pointer)\r\n    {\r\n        return this._dragState[pointer.id];\r\n    },\r\n\r\n    /**\r\n     * Sets the drag state of the given Pointer for this Input Plugin.\r\n     *\r\n     * The state must be one of the following values:\r\n     *\r\n     * 0 = Not dragging anything\r\n     * 1 = Primary button down and objects below, so collect a draglist\r\n     * 2 = Pointer being checked if meets drag criteria\r\n     * 3 = Pointer meets criteria, notify the draglist\r\n     * 4 = Pointer actively dragging the draglist and has moved\r\n     * 5 = Pointer actively dragging but has been released, notify draglist\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setDragState\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to set the drag state for.\r\n     * @param {integer} state - The drag state value. An integer between 0 and 5.\r\n     */\r\n    setDragState: function (pointer, state)\r\n    {\r\n        this._dragState[pointer.id] = state;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if a Pointer is ready to drag the objects below it, based on either a distance\r\n     * or time threshold.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragThresholdEvent\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to check the drag thresholds on.\r\n     * @param {number} time - The current time.\r\n     */\r\n    processDragThresholdEvent: function (pointer, time)\r\n    {\r\n        var passed = false;\r\n        var timeThreshold = this.dragTimeThreshold;\r\n        var distanceThreshold = this.dragDistanceThreshold;\r\n\r\n        if (distanceThreshold > 0 && DistanceBetween(pointer.x, pointer.y, pointer.downX, pointer.downY) >= distanceThreshold)\r\n        {\r\n            //  It has moved far enough to be considered a drag\r\n            passed = true;\r\n        }\r\n        else if (timeThreshold > 0 && (time >= pointer.downTime + timeThreshold))\r\n        {\r\n            //  It has been held down long enough to be considered a drag\r\n            passed = true;\r\n        }\r\n\r\n        if (passed)\r\n        {\r\n            this.setDragState(pointer, 3);\r\n\r\n            return this.processDragStartList(pointer);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Processes the drag list for the given pointer and dispatches the start events for each object on it.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragStartList\r\n     * @private\r\n     * @fires Phaser.Input.Events#DRAG_START\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_START\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n     *\r\n     * @return {integer} The number of items that DRAG_START was called on.\r\n     */\r\n    processDragStartList: function (pointer)\r\n    {\r\n        //  3 = Pointer meets criteria and is freshly down, notify the draglist\r\n        if (this.getDragState(pointer) !== 3)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        var list = this._drag[pointer.id];\r\n\r\n        for (var i = 0; i < list.length; i++)\r\n        {\r\n            var gameObject = list[i];\r\n\r\n            var input = gameObject.input;\r\n\r\n            input.dragState = 2;\r\n\r\n            input.dragStartX = gameObject.x;\r\n            input.dragStartY = gameObject.y;\r\n\r\n            input.dragStartXGlobal = pointer.x;\r\n            input.dragStartYGlobal = pointer.y;\r\n\r\n            input.dragX = input.dragStartXGlobal - input.dragStartX;\r\n            input.dragY = input.dragStartYGlobal - input.dragStartY;\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_DRAG_START, pointer, input.dragX, input.dragY);\r\n\r\n            this.emit(Events.DRAG_START, pointer, gameObject);\r\n        }\r\n\r\n        this.setDragState(pointer, 4);\r\n\r\n        return list.length;\r\n    },\r\n\r\n    /**\r\n     * Processes a 'drag down' event for the given pointer. Checks the pointer state, builds-up the drag list\r\n     * and prepares them all for interaction.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragDownEvent\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n     *\r\n     * @return {integer} The number of items that were collected on the drag list.\r\n     */\r\n    processDragDownEvent: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        if (this._draggable.length === 0 || currentlyOver.length === 0 || !pointer.primaryDown || this.getDragState(pointer) !== 0)\r\n        {\r\n            //  There are no draggable items, no over items or the pointer isn't down, so let's not even bother going further\r\n            return 0;\r\n        }\r\n\r\n        //  1 = Primary button down and objects below, so collect a draglist\r\n        this.setDragState(pointer, 1);\r\n\r\n        //  Get draggable objects, sort them, pick the top (or all) and store them somewhere\r\n        var draglist = [];\r\n\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (gameObject.input.draggable && (gameObject.input.dragState === 0))\r\n            {\r\n                draglist.push(gameObject);\r\n            }\r\n        }\r\n\r\n        if (draglist.length === 0)\r\n        {\r\n            this.setDragState(pointer, 0);\r\n\r\n            return 0;\r\n        }\r\n        else if (draglist.length > 1)\r\n        {\r\n            this.sortGameObjects(draglist);\r\n\r\n            if (this.topOnly)\r\n            {\r\n                draglist.splice(1);\r\n            }\r\n        }\r\n\r\n        //  draglist now contains all potential candidates for dragging\r\n        this._drag[pointer.id] = draglist;\r\n\r\n        if (this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0)\r\n        {\r\n            //  No drag criteria, so snap immediately to mode 3\r\n            this.setDragState(pointer, 3);\r\n\r\n            return this.processDragStartList(pointer);\r\n        }\r\n        else\r\n        {\r\n            //  Check the distance / time on the next event\r\n            this.setDragState(pointer, 2);\r\n\r\n            return 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Processes a 'drag move' event for the given pointer.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragMoveEvent\r\n     * @private\r\n     * @fires Phaser.Input.Events#DRAG_ENTER\r\n     * @fires Phaser.Input.Events#DRAG\r\n     * @fires Phaser.Input.Events#DRAG_LEAVE\r\n     * @fires Phaser.Input.Events#DRAG_OVER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_ENTER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_LEAVE\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_OVER\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n     *\r\n     * @return {integer} The number of items that were updated by this drag event.\r\n     */\r\n    processDragMoveEvent: function (pointer)\r\n    {\r\n        //  2 = Pointer being checked if meets drag criteria\r\n        if (this.getDragState(pointer) === 2)\r\n        {\r\n            this.processDragThresholdEvent(pointer, this.manager.game.loop.now);\r\n        }\r\n\r\n        if (this.getDragState(pointer) !== 4)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        //  4 = Pointer actively dragging the draglist and has moved\r\n        var dropZones = this._tempZones;\r\n\r\n        var list = this._drag[pointer.id];\r\n\r\n        for (var i = 0; i < list.length; i++)\r\n        {\r\n            var gameObject = list[i];\r\n\r\n            var input = gameObject.input;\r\n\r\n            var target = input.target;\r\n\r\n            //  If this GO has a target then let's check it\r\n            if (target)\r\n            {\r\n                var index = dropZones.indexOf(target);\r\n\r\n                //  Got a target, are we still over it?\r\n                if (index === 0)\r\n                {\r\n                    //  We're still over it, and it's still the top of the display list, phew ...\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_OVER, pointer, target);\r\n\r\n                    this.emit(Events.DRAG_OVER, pointer, gameObject, target);\r\n                }\r\n                else if (index > 0)\r\n                {\r\n                    //  Still over it but it's no longer top of the display list (targets must always be at the top)\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);\r\n\r\n                    this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);\r\n\r\n                    input.target = dropZones[0];\r\n\r\n                    target = input.target;\r\n\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);\r\n\r\n                    this.emit(Events.DRAG_ENTER, pointer, gameObject, target);\r\n                }\r\n                else\r\n                {\r\n                    //  Nope, we've moved on (or the target has!), leave the old target\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);\r\n\r\n                    this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);\r\n\r\n                    //  Anything new to replace it?\r\n                    //  Yup!\r\n                    if (dropZones[0])\r\n                    {\r\n                        input.target = dropZones[0];\r\n\r\n                        target = input.target;\r\n\r\n                        gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);\r\n\r\n                        this.emit(Events.DRAG_ENTER, pointer, gameObject, target);\r\n                    }\r\n                    else\r\n                    {\r\n                        //  Nope\r\n                        input.target = null;\r\n                    }\r\n                }\r\n            }\r\n            else if (!target && dropZones[0])\r\n            {\r\n                input.target = dropZones[0];\r\n\r\n                target = input.target;\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);\r\n\r\n                this.emit(Events.DRAG_ENTER, pointer, gameObject, target);\r\n            }\r\n\r\n            var dragX;\r\n            var dragY;\r\n\r\n            if (!gameObject.parentContainer)\r\n            {\r\n                dragX = pointer.x - input.dragX;\r\n                dragY = pointer.y - input.dragY;\r\n            }\r\n            else\r\n            {\r\n                var dx = pointer.x - input.dragStartXGlobal;\r\n                var dy = pointer.y - input.dragStartYGlobal;\r\n\r\n                var rotation = gameObject.getParentRotation();\r\n\r\n                var dxRotated = dx * Math.cos(rotation) + dy * Math.sin(rotation);\r\n                var dyRotated = dy * Math.cos(rotation) - dx * Math.sin(rotation);\r\n\r\n                dxRotated *= (1 / gameObject.parentContainer.scaleX);\r\n                dyRotated *= (1 / gameObject.parentContainer.scaleY);\r\n\r\n                dragX = dxRotated + input.dragStartX;\r\n                dragY = dyRotated + input.dragStartY;\r\n            }\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_DRAG, pointer, dragX, dragY);\r\n\r\n            this.emit(Events.DRAG, pointer, gameObject, dragX, dragY);\r\n        }\r\n\r\n        return list.length;\r\n    },\r\n\r\n    /**\r\n     * Processes a 'drag down' event for the given pointer. Checks the pointer state, builds-up the drag list\r\n     * and prepares them all for interaction.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragUpEvent\r\n     * @fires Phaser.Input.Events#DRAG_END\r\n     * @fires Phaser.Input.Events#DROP\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_END\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DROP\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n     *\r\n     * @return {integer} The number of items that were updated by this drag event.\r\n     */\r\n    processDragUpEvent: function (pointer)\r\n    {\r\n        //  5 = Pointer was actively dragging but has been released, notify draglist\r\n        var list = this._drag[pointer.id];\r\n\r\n        for (var i = 0; i < list.length; i++)\r\n        {\r\n            var gameObject = list[i];\r\n\r\n            var input = gameObject.input;\r\n\r\n            if (input && input.dragState === 2)\r\n            {\r\n                input.dragState = 0;\r\n\r\n                input.dragX = input.localX - gameObject.displayOriginX;\r\n                input.dragY = input.localY - gameObject.displayOriginY;\r\n\r\n                var dropped = false;\r\n\r\n                var target = input.target;\r\n\r\n                if (target)\r\n                {\r\n                    gameObject.emit(Events.GAMEOBJECT_DROP, pointer, target);\r\n\r\n                    this.emit(Events.DROP, pointer, gameObject, target);\r\n\r\n                    input.target = null;\r\n\r\n                    dropped = true;\r\n                }\r\n\r\n                //  And finally the dragend event\r\n\r\n                if (gameObject.input)\r\n                {\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_END, pointer, input.dragX, input.dragY, dropped);\r\n\r\n                    this.emit(Events.DRAG_END, pointer, gameObject, dropped);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setDragState(pointer, 0);\r\n\r\n        list.splice(0);\r\n\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer movement event.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processMoveEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_MOVE\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_MOVE\r\n     * @fires Phaser.Input.Events#POINTER_MOVE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {integer} The total number of objects interacted with.\r\n     */\r\n    processMoveEvents: function (pointer)\r\n    {\r\n        var total = 0;\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            total++;\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_POINTER_MOVE, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit(Events.GAMEOBJECT_MOVE, pointer, gameObject, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            if (this.topOnly)\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!aborted)\r\n        {\r\n            this.emit(Events.POINTER_MOVE, pointer, currentlyOver);\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles a mouse wheel event.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processWheelEvent\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_WHEEL\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_WHEEL\r\n     * @fires Phaser.Input.Events#POINTER_WHEEL\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {integer} The total number of objects interacted with.\r\n     */\r\n    processWheelEvent: function (pointer)\r\n    {\r\n        var total = 0;\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        var dx = pointer.deltaX;\r\n        var dy = pointer.deltaY;\r\n        var dz = pointer.deltaZ;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            total++;\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_POINTER_WHEEL, pointer, dx, dy, dz, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit(Events.GAMEOBJECT_WHEEL, pointer, gameObject, dx, dy, dz, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!aborted)\r\n        {\r\n            this.emit(Events.POINTER_WHEEL, pointer, currentlyOver, dx, dy, dz);\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer over events.\r\n     * This is called when a touch input hits the canvas, having previously been off of it.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processOverEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OVER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_OVER\r\n     * @fires Phaser.Input.Events#POINTER_OVER\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {integer} The total number of objects interacted with.\r\n     */\r\n    processOverEvents: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        var totalInteracted = 0;\r\n\r\n        var total = currentlyOver.length;\r\n\r\n        var justOver = [];\r\n\r\n        if (total > 0)\r\n        {\r\n            var manager = this.manager;\r\n\r\n            var _eventData = this._eventData;\r\n            var _eventContainer = this._eventContainer;\r\n\r\n            _eventData.cancelled = false;\r\n\r\n            var aborted = false;\r\n\r\n            for (var i = 0; i < total; i++)\r\n            {\r\n                var gameObject = currentlyOver[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                justOver.push(gameObject);\r\n\r\n                manager.setCursor(gameObject.input);\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!aborted)\r\n            {\r\n                this.emit(Events.POINTER_OVER, pointer, justOver);\r\n            }\r\n        }\r\n\r\n        //  Then sort it into display list order\r\n        this._over[pointer.id] = justOver;\r\n\r\n        return totalInteracted;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer out events.\r\n     * This is called when a touch input leaves the canvas, as it can never be 'over' in this case.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processOutEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OUT\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_OUT\r\n     * @fires Phaser.Input.Events#POINTER_OUT\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {integer} The total number of objects interacted with.\r\n     */\r\n    processOutEvents: function (pointer)\r\n    {\r\n        var previouslyOver = this._over[pointer.id];\r\n\r\n        var totalInteracted = 0;\r\n\r\n        var total = previouslyOver.length;\r\n\r\n        if (total > 0)\r\n        {\r\n            var manager = this.manager;\r\n\r\n            var _eventData = this._eventData;\r\n            var _eventContainer = this._eventContainer;\r\n\r\n            _eventData.cancelled = false;\r\n\r\n            var aborted = false;\r\n\r\n            this.sortGameObjects(previouslyOver);\r\n\r\n            for (var i = 0; i < total; i++)\r\n            {\r\n                var gameObject = previouslyOver[i];\r\n\r\n                //  Call onOut for everything in the previouslyOver array\r\n                for (i = 0; i < total; i++)\r\n                {\r\n                    gameObject = previouslyOver[i];\r\n\r\n                    if (!gameObject.input)\r\n                    {\r\n                        continue;\r\n                    }\r\n\r\n                    manager.resetCursor(gameObject.input);\r\n\r\n                    gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);\r\n\r\n                    totalInteracted++;\r\n\r\n                    if (_eventData.cancelled || !gameObject.input)\r\n                    {\r\n                        aborted = true;\r\n                        break;\r\n                    }\r\n\r\n                    this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);\r\n\r\n                    if (_eventData.cancelled || !gameObject.input)\r\n                    {\r\n                        aborted = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!aborted)\r\n                {\r\n                    this.emit(Events.POINTER_OUT, pointer, previouslyOver);\r\n                }\r\n            }\r\n\r\n            this._over[pointer.id] = [];\r\n        }\r\n\r\n        return totalInteracted;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer over and out events.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processOverOutEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OVER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_OVER\r\n     * @fires Phaser.Input.Events#POINTER_OVER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OUT\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_OUT\r\n     * @fires Phaser.Input.Events#POINTER_OUT\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {integer} The total number of objects interacted with.\r\n     */\r\n    processOverOutEvents: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        var i;\r\n        var gameObject;\r\n        var justOut = [];\r\n        var justOver = [];\r\n        var stillOver = [];\r\n        var previouslyOver = this._over[pointer.id];\r\n        var currentlyDragging = this._drag[pointer.id];\r\n\r\n        var manager = this.manager;\r\n\r\n        //  Go through all objects the pointer was previously over, and see if it still is.\r\n        //  Splits the previouslyOver array into two parts: justOut and stillOver\r\n\r\n        for (i = 0; i < previouslyOver.length; i++)\r\n        {\r\n            gameObject = previouslyOver[i];\r\n\r\n            if (currentlyOver.indexOf(gameObject) === -1 && currentlyDragging.indexOf(gameObject) === -1)\r\n            {\r\n                //  Not in the currentlyOver array, so must be outside of this object now\r\n                justOut.push(gameObject);\r\n            }\r\n            else\r\n            {\r\n                //  In the currentlyOver array\r\n                stillOver.push(gameObject);\r\n            }\r\n        }\r\n\r\n        //  Go through all objects the pointer is currently over (the hit test results)\r\n        //  and if not in the previouslyOver array we know it's a new entry, so add to justOver\r\n        for (i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            gameObject = currentlyOver[i];\r\n\r\n            //  Is this newly over?\r\n\r\n            if (previouslyOver.indexOf(gameObject) === -1)\r\n            {\r\n                justOver.push(gameObject);\r\n            }\r\n        }\r\n\r\n        //  By this point the arrays are filled, so now we can process what happened...\r\n\r\n        //  Process the Just Out objects\r\n        var total = justOut.length;\r\n\r\n        var totalInteracted = 0;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        if (total > 0)\r\n        {\r\n            this.sortGameObjects(justOut);\r\n\r\n            //  Call onOut for everything in the justOut array\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                gameObject = justOut[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  Reset cursor before we emit the event, in case they want to change it during the event\r\n                manager.resetCursor(gameObject.input);\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!aborted)\r\n            {\r\n                this.emit(Events.POINTER_OUT, pointer, justOut);\r\n            }\r\n        }\r\n\r\n        //  Process the Just Over objects\r\n        total = justOver.length;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        aborted = false;\r\n\r\n        if (total > 0)\r\n        {\r\n            this.sortGameObjects(justOver);\r\n\r\n            //  Call onOver for everything in the justOver array\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                gameObject = justOver[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  Set cursor before we emit the event, in case they want to change it during the event\r\n                manager.setCursor(gameObject.input);\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!aborted)\r\n            {\r\n                this.emit(Events.POINTER_OVER, pointer, justOver);\r\n            }\r\n        }\r\n\r\n        //  Add the contents of justOver to the previously over array\r\n        previouslyOver = stillOver.concat(justOver);\r\n\r\n        //  Then sort it into display list order\r\n        this._over[pointer.id] = this.sortGameObjects(previouslyOver);\r\n\r\n        return totalInteracted;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer up events.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processUpEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_UP\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_UP\r\n     * @fires Phaser.Input.Events#POINTER_UP\r\n     * @fires Phaser.Input.Events#POINTER_UP_OUTSIDE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {integer} The total number of objects interacted with.\r\n     */\r\n    processUpEvents: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_POINTER_UP, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit(Events.GAMEOBJECT_UP, pointer, gameObject, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        //  If they released outside the canvas, but pressed down inside it, we'll still dispatch the event.\r\n        if (!aborted && this.manager)\r\n        {\r\n            if (pointer.upElement === this.manager.game.canvas)\r\n            {\r\n                this.emit(Events.POINTER_UP, pointer, currentlyOver);\r\n            }\r\n            else\r\n            {\r\n                this.emit(Events.POINTER_UP_OUTSIDE, pointer);\r\n            }\r\n        }\r\n\r\n        return currentlyOver.length;\r\n    },\r\n\r\n    /**\r\n     * Queues a Game Object for insertion into this Input Plugin on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#queueForInsertion\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to add.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    queueForInsertion: function (child)\r\n    {\r\n        if (this._pendingInsertion.indexOf(child) === -1 && this._list.indexOf(child) === -1)\r\n        {\r\n            this._pendingInsertion.push(child);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Queues a Game Object for removal from this Input Plugin on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#queueForRemoval\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to remove.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    queueForRemoval: function (child)\r\n    {\r\n        this._pendingRemoval.push(child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the draggable state of the given array of Game Objects.\r\n     *\r\n     * They can either be set to be draggable, or can have their draggable state removed by passing `false`.\r\n     *\r\n     * A Game Object will not fire drag events unless it has been specifically enabled for drag.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setDraggable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to change the draggable state on.\r\n     * @param {boolean} [value=true] - Set to `true` if the Game Objects should be made draggable, `false` if they should be unset.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setDraggable: function (gameObjects, value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        if (!Array.isArray(gameObjects))\r\n        {\r\n            gameObjects = [ gameObjects ];\r\n        }\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            gameObject.input.draggable = value;\r\n\r\n            var index = this._draggable.indexOf(gameObject);\r\n\r\n            if (value && index === -1)\r\n            {\r\n                this._draggable.push(gameObject);\r\n            }\r\n            else if (!value && index > -1)\r\n            {\r\n                this._draggable.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a function that can be passed to `setInteractive`, `enable` or `setHitArea` that will handle\r\n     * pixel-perfect input detection on an Image or Sprite based Game Object, or any custom class that extends them.\r\n     *\r\n     * The following will create a sprite that is clickable on any pixel that has an alpha value >= 1.\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect());\r\n     * ```\r\n     *\r\n     * The following will create a sprite that is clickable on any pixel that has an alpha value >= 150.\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect(150));\r\n     * ```\r\n     *\r\n     * Once you have made an Interactive Object pixel perfect it impacts all input related events for it: down, up,\r\n     * dragstart, drag, etc.\r\n     *\r\n     * As a pointer interacts with the Game Object it will constantly poll the texture, extracting a single pixel from\r\n     * the given coordinates and checking its color values. This is an expensive process, so should only be enabled on\r\n     * Game Objects that really need it.\r\n     *\r\n     * You cannot make non-texture based Game Objects pixel perfect. So this will not work on Graphics, BitmapText,\r\n     * Render Textures, Text, Tilemaps, Containers or Particles.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#makePixelPerfect\r\n     * @since 3.10.0\r\n     *\r\n     * @param {integer} [alphaTolerance=1] - The alpha level that the pixel should be above to be included as a successful interaction.\r\n     *\r\n     * @return {function} A Pixel Perfect Handler for use as a hitArea shape callback.\r\n     */\r\n    makePixelPerfect: function (alphaTolerance)\r\n    {\r\n        if (alphaTolerance === undefined) { alphaTolerance = 1; }\r\n\r\n        var textureManager = this.systems.textures;\r\n\r\n        return CreatePixelPerfectHandler(textureManager, alphaTolerance);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for the given array of Game Objects.\r\n     *\r\n     * A hit area is typically one of the geometric shapes Phaser provides, such as a `Phaser.Geom.Rectangle`\r\n     * or `Phaser.Geom.Circle`. However, it can be any object as long as it works with the provided callback.\r\n     *\r\n     * If no hit area is provided a Rectangle is created based on the size of the Game Object, if possible\r\n     * to calculate.\r\n     *\r\n     * The hit area callback is the function that takes an `x` and `y` coordinate and returns a boolean if\r\n     * those values fall within the area of the shape or not. All of the Phaser geometry objects provide this,\r\n     * such as `Phaser.Geom.Rectangle.Contains`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitArea\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set the hit area on.\r\n     * @param {(Phaser.Types.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The 'contains' function to invoke to check if the pointer is within the hit area.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setHitArea: function (gameObjects, shape, callback)\r\n    {\r\n        if (shape === undefined)\r\n        {\r\n            return this.setHitAreaFromTexture(gameObjects);\r\n        }\r\n\r\n        if (!Array.isArray(gameObjects))\r\n        {\r\n            gameObjects = [ gameObjects ];\r\n        }\r\n\r\n        var draggable = false;\r\n        var dropZone = false;\r\n        var cursor = false;\r\n        var useHandCursor = false;\r\n        var pixelPerfect = false;\r\n        var customHitArea = true;\r\n\r\n        //  Config object?\r\n        if (IsPlainObject(shape))\r\n        {\r\n            var config = shape;\r\n\r\n            shape = GetFastValue(config, 'hitArea', null);\r\n            callback = GetFastValue(config, 'hitAreaCallback', null);\r\n            draggable = GetFastValue(config, 'draggable', false);\r\n            dropZone = GetFastValue(config, 'dropZone', false);\r\n            cursor = GetFastValue(config, 'cursor', false);\r\n            useHandCursor = GetFastValue(config, 'useHandCursor', false);\r\n\r\n            pixelPerfect = GetFastValue(config, 'pixelPerfect', false);\r\n            var alphaTolerance = GetFastValue(config, 'alphaTolerance', 1);\r\n\r\n            if (pixelPerfect)\r\n            {\r\n                shape = {};\r\n                callback = this.makePixelPerfect(alphaTolerance);\r\n            }\r\n\r\n            //  Still no hitArea or callback?\r\n            if (!shape || !callback)\r\n            {\r\n                this.setHitAreaFromTexture(gameObjects);\r\n                customHitArea = false;\r\n            }\r\n        }\r\n        else if (typeof shape === 'function' && !callback)\r\n        {\r\n            callback = shape;\r\n            shape = {};\r\n        }\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            if (pixelPerfect && gameObject.type === 'Container')\r\n            {\r\n                console.warn('Cannot pixelPerfect test a Container. Use a custom callback.');\r\n                continue;\r\n            }\r\n\r\n            var io = (!gameObject.input) ? CreateInteractiveObject(gameObject, shape, callback) : gameObject.input;\r\n\r\n            io.customHitArea = customHitArea;\r\n            io.dropZone = dropZone;\r\n            io.cursor = (useHandCursor) ? 'pointer' : cursor;\r\n\r\n            gameObject.input = io;\r\n\r\n            if (draggable)\r\n            {\r\n                this.setDraggable(gameObject);\r\n            }\r\n\r\n            this.queueForInsertion(gameObject);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Circle` shape, using\r\n     * the given coordinates and radius to control its position and size.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a circle hit area.\r\n     * @param {number} x - The center of the circle.\r\n     * @param {number} y - The center of the circle.\r\n     * @param {number} radius - The radius of the circle.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Circle.Contains.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setHitAreaCircle: function (gameObjects, x, y, radius, callback)\r\n    {\r\n        if (callback === undefined) { callback = CircleContains; }\r\n\r\n        var shape = new Circle(x, y, radius);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Ellipse` shape, using\r\n     * the given coordinates and dimensions to control its position and size.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaEllipse\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.\r\n     * @param {number} x - The center of the ellipse.\r\n     * @param {number} y - The center of the ellipse.\r\n     * @param {number} width - The width of the ellipse.\r\n     * @param {number} height - The height of the ellipse.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Ellipse.Contains.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setHitAreaEllipse: function (gameObjects, x, y, width, height, callback)\r\n    {\r\n        if (callback === undefined) { callback = EllipseContains; }\r\n\r\n        var shape = new Ellipse(x, y, width, height);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using\r\n     * the Game Objects texture frame to define the position and size of the hit area.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaFromTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setHitAreaFromTexture: function (gameObjects, callback)\r\n    {\r\n        if (callback === undefined) { callback = RectangleContains; }\r\n\r\n        if (!Array.isArray(gameObjects))\r\n        {\r\n            gameObjects = [ gameObjects ];\r\n        }\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            var frame = gameObject.frame;\r\n\r\n            var width = 0;\r\n            var height = 0;\r\n\r\n            if (gameObject.width)\r\n            {\r\n                width = gameObject.width;\r\n                height = gameObject.height;\r\n            }\r\n            else if (frame)\r\n            {\r\n                width = frame.realWidth;\r\n                height = frame.realHeight;\r\n            }\r\n\r\n            if (gameObject.type === 'Container' && (width === 0 || height === 0))\r\n            {\r\n                console.warn('Container.setInteractive must specify a Shape or call setSize() first');\r\n                continue;\r\n            }\r\n\r\n            if (width !== 0 && height !== 0)\r\n            {\r\n                gameObject.input = CreateInteractiveObject(gameObject, new Rectangle(0, 0, width, height), callback);\r\n\r\n                this.queueForInsertion(gameObject);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using\r\n     * the given coordinates and dimensions to control its position and size.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaRectangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a rectangular hit area.\r\n     * @param {number} x - The top-left of the rectangle.\r\n     * @param {number} y - The top-left of the rectangle.\r\n     * @param {number} width - The width of the rectangle.\r\n     * @param {number} height - The height of the rectangle.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setHitAreaRectangle: function (gameObjects, x, y, width, height, callback)\r\n    {\r\n        if (callback === undefined) { callback = RectangleContains; }\r\n\r\n        var shape = new Rectangle(x, y, width, height);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Triangle` shape, using\r\n     * the given coordinates to control the position of its points.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaTriangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a  triangular hit area.\r\n     * @param {number} x1 - The x coordinate of the first point of the triangle.\r\n     * @param {number} y1 - The y coordinate of the first point of the triangle.\r\n     * @param {number} x2 - The x coordinate of the second point of the triangle.\r\n     * @param {number} y2 - The y coordinate of the second point of the triangle.\r\n     * @param {number} x3 - The x coordinate of the third point of the triangle.\r\n     * @param {number} y3 - The y coordinate of the third point of the triangle.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Triangle.Contains.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setHitAreaTriangle: function (gameObjects, x1, y1, x2, y2, x3, y3, callback)\r\n    {\r\n        if (callback === undefined) { callback = TriangleContains; }\r\n\r\n        var shape = new Triangle(x1, y1, x2, y2, x3, y3);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Creates an Input Debug Shape for the given Game Object.\r\n     *\r\n     * The Game Object must have _already_ been enabled for input prior to calling this method.\r\n     *\r\n     * This is intended to assist you during development and debugging.\r\n     *\r\n     * Debug Shapes can only be created for Game Objects that are using standard Phaser Geometry for input,\r\n     * including: Circle, Ellipse, Line, Polygon, Rectangle and Triangle.\r\n     *\r\n     * Game Objects that are using their automatic hit areas are using Rectangles by default, so will also work.\r\n     *\r\n     * The Debug Shape is created and added to the display list and is then kept in sync with the Game Object\r\n     * it is connected with. Should you need to modify it yourself, such as to hide it, you can access it via\r\n     * the Game Object property: `GameObject.input.hitAreaDebug`.\r\n     *\r\n     * Calling this method on a Game Object that already has a Debug Shape will first destroy the old shape,\r\n     * before creating a new one. If you wish to remove the Debug Shape entirely, you should call the\r\n     * method `InputPlugin.removeDebug`.\r\n     *\r\n     * Note that the debug shape will only show the outline of the input area. If the input test is using a\r\n     * pixel perfect check, for example, then this is not displayed. If you are using a custom shape, that\r\n     * doesn't extend one of the base Phaser Geometry objects, as your hit area, then this method will not\r\n     * work.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#enableDebug\r\n     * @since 3.19.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to create the input debug shape for.\r\n     * @param {number} [color=0x00ff00] - The outline color of the debug shape.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This Input Plugin.\r\n     */\r\n    enableDebug: function (gameObject, color)\r\n    {\r\n        if (color === undefined) { color = 0x00ff00; }\r\n\r\n        var input = gameObject.input;\r\n\r\n        if (!input || !input.hitArea)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        var shape = input.hitArea;\r\n        var shapeType = shape.type;\r\n        var debug = input.hitAreaDebug;\r\n        var factory = this.systems.add;\r\n        var updateList = this.systems.updateList;\r\n\r\n        if (debug)\r\n        {\r\n            updateList.remove(debug);\r\n\r\n            debug.destroy();\r\n\r\n            debug = null;\r\n        }\r\n\r\n        var offsetx = 0;\r\n        var offsety = 0;\r\n        switch (shapeType)\r\n        {\r\n            case GEOM_CONST.CIRCLE:\r\n                debug = factory.arc(0, 0, shape.radius);\r\n                offsetx = shape.x - shape.radius;\r\n                offsety = shape.y - shape.radius;\r\n                break;\r\n\r\n            case GEOM_CONST.ELLIPSE:\r\n                debug = factory.ellipse(0, 0, shape.width, shape.height);\r\n                offsetx = shape.x - shape.width / 2;\r\n                offsety = shape.y - shape.height / 2;\r\n                break;\r\n\r\n            case GEOM_CONST.LINE:\r\n                debug = factory.line(0, 0, shape.x1, shape.y1, shape.x2, shape.y2);\r\n                break;\r\n\r\n            case GEOM_CONST.POLYGON:\r\n                debug = factory.polygon(0, 0, shape.points);\r\n                break;\r\n\r\n            case GEOM_CONST.RECTANGLE:\r\n                debug = factory.rectangle(0, 0, shape.width, shape.height);\r\n                offsetx = shape.x;\r\n                offsety = shape.y;\r\n                break;\r\n\r\n            case GEOM_CONST.TRIANGLE:\r\n                debug = factory.triangle(0, 0, shape.x1, shape.y1, shape.x2, shape.y2, shape.x3, shape.y3);\r\n                break;\r\n        }\r\n\r\n        if (debug)\r\n        {\r\n            debug.isFilled = false;\r\n\r\n            debug.preUpdate = function ()\r\n            {\r\n                debug.setStrokeStyle(1 / gameObject.scale, color);\r\n\r\n                debug.setDisplayOrigin(gameObject.displayOriginX, gameObject.displayOriginY);\r\n                debug.setRotation(gameObject.rotation);\r\n                debug.setScale(gameObject.scaleX, gameObject.scaleY);\r\n                debug.setPosition(gameObject.x + offsetx, gameObject.y + offsety);\r\n                debug.setScrollFactor(gameObject.scrollFactorX, gameObject.scrollFactorY);\r\n            };\r\n\r\n            updateList.add(debug);\r\n\r\n            input.hitAreaDebug = debug;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes an Input Debug Shape from the given Game Object.\r\n     *\r\n     * The shape is destroyed immediately and the `hitAreaDebug` property is set to `null`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#removeDebug\r\n     * @since 3.19.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to remove the input debug shape from.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This Input Plugin.\r\n     */\r\n    removeDebug: function (gameObject)\r\n    {\r\n        var input = gameObject.input;\r\n\r\n        if (input && input.hitAreaDebug)\r\n        {\r\n            var debug = input.hitAreaDebug;\r\n\r\n            this.systems.updateList.remove(debug);\r\n\r\n            debug.destroy();\r\n\r\n            input.hitAreaDebug = null;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Pointers to always poll.\r\n     *\r\n     * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,\r\n     * or being interacted with it, regardless if the Pointer has actually moved or not.\r\n     *\r\n     * You should enable this if you want objects in your game to fire over / out events, and the objects\r\n     * are constantly moving, but the pointer may not have. Polling every frame has additional computation\r\n     * costs, especially if there are a large number of interactive objects in your game.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollAlways\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setPollAlways: function ()\r\n    {\r\n        return this.setPollRate(0);\r\n    },\r\n\r\n    /**\r\n     * Sets the Pointers to only poll when they are moved or updated.\r\n     *\r\n     * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,\r\n     * or being interacted with it.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollOnMove\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setPollOnMove: function ()\r\n    {\r\n        return this.setPollRate(-1);\r\n    },\r\n\r\n    /**\r\n     * Sets the poll rate value. This is the amount of time that should have elapsed before a pointer\r\n     * will be polled again. See the `setPollAlways` and `setPollOnMove` methods.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollRate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The amount of time, in ms, that should elapsed before re-polling the pointers.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setPollRate: function (value)\r\n    {\r\n        this.pollRate = value;\r\n        this._pollTimer = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * When set to `true` the global Input Manager will emulate DOM behavior by only emitting events from\r\n     * the top-most Scene in the Scene List. By default, if a Scene receives an input event it will then stop the event\r\n     * from flowing down to any Scenes below it in the Scene list. To disable this behavior call this method with `false`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setGlobalTopOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - Set to `true` to stop processing input events on the Scene that receives it, or `false` to let the event continue down the Scene list.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setGlobalTopOnly: function (value)\r\n    {\r\n        this.manager.globalTopOnly = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * When set to `true` this Input Plugin will emulate DOM behavior by only emitting events from\r\n     * the top-most Game Objects in the Display List.\r\n     *\r\n     * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setTopOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - `true` to only include the top-most Game Object, or `false` to include all Game Objects in a hit test.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    setTopOnly: function (value)\r\n    {\r\n        this.topOnly = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Given an array of Game Objects, sort the array and return it, so that the objects are in depth index order\r\n     * with the lowest at the bottom.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#sortGameObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} gameObjects - An array of Game Objects to be sorted.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} The sorted array of Game Objects.\r\n     */\r\n    sortGameObjects: function (gameObjects)\r\n    {\r\n        if (gameObjects.length < 2)\r\n        {\r\n            return gameObjects;\r\n        }\r\n\r\n        this.scene.sys.depthSort();\r\n\r\n        return gameObjects.sort(this.sortHandlerGO.bind(this));\r\n    },\r\n\r\n    /**\r\n     * Return the child lowest down the display list (with the smallest index)\r\n     * Will iterate through all parent containers, if present.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#sortHandlerGO\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} childA - The first Game Object to compare.\r\n     * @param {Phaser.GameObjects.GameObject} childB - The second Game Object to compare.\r\n     *\r\n     * @return {integer} Returns either a negative or positive integer, or zero if they match.\r\n     */\r\n    sortHandlerGO: function (childA, childB)\r\n    {\r\n        if (!childA.parentContainer && !childB.parentContainer)\r\n        {\r\n            //  Quick bail out when neither child has a container\r\n            return this.displayList.getIndex(childB) - this.displayList.getIndex(childA);\r\n        }\r\n        else if (childA.parentContainer === childB.parentContainer)\r\n        {\r\n            //  Quick bail out when both children have the same container\r\n            return childB.parentContainer.getIndex(childB) - childA.parentContainer.getIndex(childA);\r\n        }\r\n        else if (childA.parentContainer === childB)\r\n        {\r\n            //  Quick bail out when childA is a child of childB\r\n            return -1;\r\n        }\r\n        else if (childB.parentContainer === childA)\r\n        {\r\n            //  Quick bail out when childA is a child of childB\r\n            return 1;\r\n        }\r\n        else\r\n        {\r\n            //  Container index check\r\n            var listA = childA.getIndexList();\r\n            var listB = childB.getIndexList();\r\n            var len = Math.min(listA.length, listB.length);\r\n\r\n            for (var i = 0; i < len; i++)\r\n            {\r\n                var indexA = listA[i];\r\n                var indexB = listB[i];\r\n\r\n                if (indexA === indexB)\r\n                {\r\n                    //  Go to the next level down\r\n                    continue;\r\n                }\r\n                else\r\n                {\r\n                    //  Non-matching parents, so return\r\n                    return indexB - indexA;\r\n                }\r\n            }\r\n        }\r\n\r\n        //  Technically this shouldn't happen, but ...\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * This method should be called from within an input event handler, such as `pointerdown`.\r\n     *\r\n     * When called, it stops the Input Manager from allowing _this specific event_ to be processed by any other Scene\r\n     * not yet handled in the scene list.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#stopPropagation\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This InputPlugin object.\r\n     */\r\n    stopPropagation: function ()\r\n    {\r\n        this.manager._tempSkip = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds new Pointer objects to the Input Manager.\r\n     *\r\n     * By default Phaser creates 2 pointer objects: `mousePointer` and `pointer1`.\r\n     *\r\n     * You can create more either by calling this method, or by setting the `input.activePointers` property\r\n     * in the Game Config, up to a maximum of 10 pointers.\r\n     *\r\n     * The first 10 pointers are available via the `InputPlugin.pointerX` properties, once they have been added\r\n     * via this method.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#addPointer\r\n     * @since 3.10.0\r\n     *\r\n     * @param {integer} [quantity=1] The number of new Pointers to create. A maximum of 10 is allowed in total.\r\n     *\r\n     * @return {Phaser.Input.Pointer[]} An array containing all of the new Pointer objects that were created.\r\n     */\r\n    addPointer: function (quantity)\r\n    {\r\n        return this.manager.addPointer(quantity);\r\n    },\r\n\r\n    /**\r\n     * Tells the Input system to set a custom cursor.\r\n     *\r\n     * This cursor will be the default cursor used when interacting with the game canvas.\r\n     *\r\n     * If an Interactive Object also sets a custom cursor, this is the cursor that is reset after its use.\r\n     *\r\n     * Any valid CSS cursor value is allowed, including paths to image files, i.e.:\r\n     *\r\n     * ```javascript\r\n     * this.input.setDefaultCursor('url(assets/cursors/sword.cur), pointer');\r\n     * ```\r\n     *\r\n     * Please read about the differences between browsers when it comes to the file formats and sizes they support:\r\n     *\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_User_Interface/Using_URL_values_for_the_cursor_property\r\n     *\r\n     * It's up to you to pick a suitable cursor format that works across the range of browsers you need to support.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setDefaultCursor\r\n     * @since 3.10.0\r\n     *\r\n     * @param {string} cursor - The CSS to be used when setting the default cursor.\r\n     *\r\n     * @return {Phaser.Input.InputPlugin} This Input instance.\r\n     */\r\n    setDefaultCursor: function (cursor)\r\n    {\r\n        this.manager.setDefaultCursor(cursor);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is transitioning in.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#transitionIn\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    transitionIn: function ()\r\n    {\r\n        this.enabled = this.settings.transitionAllowInput;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin has finished transitioning in.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#transitionComplete\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    transitionComplete: function ()\r\n    {\r\n        if (!this.settings.transitionAllowInput)\r\n        {\r\n            this.enabled = true;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is transitioning out.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#transitionOut\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    transitionOut: function ()\r\n    {\r\n        this.enabled = this.settings.transitionAllowInput;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#shutdown\r\n     * @fires Phaser.Input.Events#SHUTDOWN\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.SHUTDOWN);\r\n\r\n        this._temp.length = 0;\r\n        this._list.length = 0;\r\n        this._draggable.length = 0;\r\n        this._pendingRemoval.length = 0;\r\n        this._pendingInsertion.length = 0;\r\n        this._dragState.length = 0;\r\n\r\n        for (var i = 0; i < 10; i++)\r\n        {\r\n            this._drag[i] = [];\r\n            this._over[i] = [];\r\n        }\r\n\r\n        this.removeAllListeners();\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off(SceneEvents.TRANSITION_START, this.transitionIn, this);\r\n        eventEmitter.off(SceneEvents.TRANSITION_OUT, this.transitionOut, this);\r\n        eventEmitter.off(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);\r\n        eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);\r\n\r\n        this.manager.events.off(Events.GAME_OUT, this.onGameOut, this);\r\n        this.manager.events.off(Events.GAME_OVER, this.onGameOver, this);\r\n\r\n        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#destroy\r\n     * @fires Phaser.Input.Events#DESTROY\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.DESTROY);\r\n\r\n        this.pluginEvents.removeAllListeners();\r\n\r\n        this.scene.sys.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.cameras = null;\r\n        this.manager = null;\r\n        this.events = null;\r\n        this.mouse = null;\r\n    },\r\n\r\n    /**\r\n     * The x coordinates of the ActivePointer based on the first camera in the camera list.\r\n     * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#x\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.activePointer.x;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The y coordinates of the ActivePointer based on the first camera in the camera list.\r\n     * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#y\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.activePointer.y;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Are any mouse or touch pointers currently over the game canvas?\r\n     *\r\n     * @name Phaser.Input.InputPlugin#isOver\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isOver: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.isOver;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The mouse has its own unique Pointer object, which you can reference directly if making a _desktop specific game_.\r\n     * If you are supporting both desktop and touch devices then do not use this property, instead use `activePointer`\r\n     * which will always map to the most recently interacted pointer.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#mousePointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    mousePointer: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.mousePointer;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The current active input Pointer.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#activePointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    activePointer: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.activePointer;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer1\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer1: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[1];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer2\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer2: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[2];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer3\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer3: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[3];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer4\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer4: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[4];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer5\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer5: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[5];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer6\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer6: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[6];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer7\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer7: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[7];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer8\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer8: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[8];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer9\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer9: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[9];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer10\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer10: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[10];\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('InputPlugin', InputPlugin, 'input');\r\n\r\nmodule.exports = InputPlugin;\r\n"]},"metadata":{},"sourceType":"script"}