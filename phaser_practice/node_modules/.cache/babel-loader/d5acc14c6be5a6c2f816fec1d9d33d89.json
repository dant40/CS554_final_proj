{"ast":null,"code":"/**\r\n* The `Matter.Composites` module contains factory methods for creating composite bodies\r\n* with commonly used configurations (such as stacks and chains).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Composites\r\n*/\nvar Composites = {};\nmodule.exports = Composites;\n\nvar Composite = require('../body/Composite');\n\nvar Constraint = require('../constraint/Constraint');\n\nvar Common = require('../core/Common');\n\nvar Body = require('../body/Body');\n\nvar Bodies = require('./Bodies');\n\n(function () {\n  /**\r\n   * Create a new composite containing bodies created in the callback in a grid arrangement.\r\n   * This function uses the body's bounds to prevent overlaps.\r\n   * @method stack\r\n   * @param {number} xx\r\n   * @param {number} yy\r\n   * @param {number} columns\r\n   * @param {number} rows\r\n   * @param {number} columnGap\r\n   * @param {number} rowGap\r\n   * @param {function} callback\r\n   * @return {composite} A new composite containing objects created in the callback\r\n   */\n  Composites.stack = function (xx, yy, columns, rows, columnGap, rowGap, callback) {\n    var stack = Composite.create({\n      label: 'Stack'\n    }),\n        x = xx,\n        y = yy,\n        lastBody,\n        i = 0;\n\n    for (var row = 0; row < rows; row++) {\n      var maxHeight = 0;\n\n      for (var column = 0; column < columns; column++) {\n        var body = callback(x, y, column, row, lastBody, i);\n\n        if (body) {\n          var bodyHeight = body.bounds.max.y - body.bounds.min.y,\n              bodyWidth = body.bounds.max.x - body.bounds.min.x;\n          if (bodyHeight > maxHeight) maxHeight = bodyHeight;\n          Body.translate(body, {\n            x: bodyWidth * 0.5,\n            y: bodyHeight * 0.5\n          });\n          x = body.bounds.max.x + columnGap;\n          Composite.addBody(stack, body);\n          lastBody = body;\n          i += 1;\n        } else {\n          x += columnGap;\n        }\n      }\n\n      y += maxHeight + rowGap;\n      x = xx;\n    }\n\n    return stack;\n  };\n  /**\r\n   * Chains all bodies in the given composite together using constraints.\r\n   * @method chain\r\n   * @param {composite} composite\r\n   * @param {number} xOffsetA\r\n   * @param {number} yOffsetA\r\n   * @param {number} xOffsetB\r\n   * @param {number} yOffsetB\r\n   * @param {object} options\r\n   * @return {composite} A new composite containing objects chained together with constraints\r\n   */\n\n\n  Composites.chain = function (composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {\n    var bodies = composite.bodies;\n\n    for (var i = 1; i < bodies.length; i++) {\n      var bodyA = bodies[i - 1],\n          bodyB = bodies[i],\n          bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y,\n          bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x,\n          bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y,\n          bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;\n      var defaults = {\n        bodyA: bodyA,\n        pointA: {\n          x: bodyAWidth * xOffsetA,\n          y: bodyAHeight * yOffsetA\n        },\n        bodyB: bodyB,\n        pointB: {\n          x: bodyBWidth * xOffsetB,\n          y: bodyBHeight * yOffsetB\n        }\n      };\n      var constraint = Common.extend(defaults, options);\n      Composite.addConstraint(composite, Constraint.create(constraint));\n    }\n\n    composite.label += ' Chain';\n    return composite;\n  };\n  /**\r\n   * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.\r\n   * @method mesh\r\n   * @param {composite} composite\r\n   * @param {number} columns\r\n   * @param {number} rows\r\n   * @param {boolean} crossBrace\r\n   * @param {object} options\r\n   * @return {composite} The composite containing objects meshed together with constraints\r\n   */\n\n\n  Composites.mesh = function (composite, columns, rows, crossBrace, options) {\n    var bodies = composite.bodies,\n        row,\n        col,\n        bodyA,\n        bodyB,\n        bodyC;\n\n    for (row = 0; row < rows; row++) {\n      for (col = 1; col < columns; col++) {\n        bodyA = bodies[col - 1 + row * columns];\n        bodyB = bodies[col + row * columns];\n        Composite.addConstraint(composite, Constraint.create(Common.extend({\n          bodyA: bodyA,\n          bodyB: bodyB\n        }, options)));\n      }\n\n      if (row > 0) {\n        for (col = 0; col < columns; col++) {\n          bodyA = bodies[col + (row - 1) * columns];\n          bodyB = bodies[col + row * columns];\n          Composite.addConstraint(composite, Constraint.create(Common.extend({\n            bodyA: bodyA,\n            bodyB: bodyB\n          }, options)));\n\n          if (crossBrace && col > 0) {\n            bodyC = bodies[col - 1 + (row - 1) * columns];\n            Composite.addConstraint(composite, Constraint.create(Common.extend({\n              bodyA: bodyC,\n              bodyB: bodyB\n            }, options)));\n          }\n\n          if (crossBrace && col < columns - 1) {\n            bodyC = bodies[col + 1 + (row - 1) * columns];\n            Composite.addConstraint(composite, Constraint.create(Common.extend({\n              bodyA: bodyC,\n              bodyB: bodyB\n            }, options)));\n          }\n        }\n      }\n    }\n\n    composite.label += ' Mesh';\n    return composite;\n  };\n  /**\r\n   * Create a new composite containing bodies created in the callback in a pyramid arrangement.\r\n   * This function uses the body's bounds to prevent overlaps.\r\n   * @method pyramid\r\n   * @param {number} xx\r\n   * @param {number} yy\r\n   * @param {number} columns\r\n   * @param {number} rows\r\n   * @param {number} columnGap\r\n   * @param {number} rowGap\r\n   * @param {function} callback\r\n   * @return {composite} A new composite containing objects created in the callback\r\n   */\n\n\n  Composites.pyramid = function (xx, yy, columns, rows, columnGap, rowGap, callback) {\n    return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function (x, y, column, row, lastBody, i) {\n      var actualRows = Math.min(rows, Math.ceil(columns / 2)),\n          lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;\n      if (row > actualRows) return; // reverse row order\n\n      row = actualRows - row;\n      var start = row,\n          end = columns - 1 - row;\n      if (column < start || column > end) return; // retroactively fix the first body's position, since width was unknown\n\n      if (i === 1) {\n        Body.translate(lastBody, {\n          x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth,\n          y: 0\n        });\n      }\n\n      var xOffset = lastBody ? column * lastBodyWidth : 0;\n      return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);\n    });\n  };\n  /**\r\n   * Creates a composite with a Newton's Cradle setup of bodies and constraints.\r\n   * @method newtonsCradle\r\n   * @param {number} xx\r\n   * @param {number} yy\r\n   * @param {number} number\r\n   * @param {number} size\r\n   * @param {number} length\r\n   * @return {composite} A new composite newtonsCradle body\r\n   */\n\n\n  Composites.newtonsCradle = function (xx, yy, number, size, length) {\n    var newtonsCradle = Composite.create({\n      label: 'Newtons Cradle'\n    });\n\n    for (var i = 0; i < number; i++) {\n      var separation = 1.9,\n          circle = Bodies.circle(xx + i * (size * separation), yy + length, size, {\n        inertia: Infinity,\n        restitution: 1,\n        friction: 0,\n        frictionAir: 0.0001,\n        slop: 1\n      }),\n          constraint = Constraint.create({\n        pointA: {\n          x: xx + i * (size * separation),\n          y: yy\n        },\n        bodyB: circle\n      });\n      Composite.addBody(newtonsCradle, circle);\n      Composite.addConstraint(newtonsCradle, constraint);\n    }\n\n    return newtonsCradle;\n  };\n  /**\r\n   * Creates a composite with simple car setup of bodies and constraints.\r\n   * @method car\r\n   * @param {number} xx\r\n   * @param {number} yy\r\n   * @param {number} width\r\n   * @param {number} height\r\n   * @param {number} wheelSize\r\n   * @return {composite} A new composite car body\r\n   */\n\n\n  Composites.car = function (xx, yy, width, height, wheelSize) {\n    var group = Body.nextGroup(true),\n        wheelBase = 20,\n        wheelAOffset = -width * 0.5 + wheelBase,\n        wheelBOffset = width * 0.5 - wheelBase,\n        wheelYOffset = 0;\n    var car = Composite.create({\n      label: 'Car'\n    }),\n        body = Bodies.rectangle(xx, yy, width, height, {\n      collisionFilter: {\n        group: group\n      },\n      chamfer: {\n        radius: height * 0.5\n      },\n      density: 0.0002\n    });\n    var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, {\n      collisionFilter: {\n        group: group\n      },\n      friction: 0.8\n    });\n    var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, {\n      collisionFilter: {\n        group: group\n      },\n      friction: 0.8\n    });\n    var axelA = Constraint.create({\n      bodyB: body,\n      pointB: {\n        x: wheelAOffset,\n        y: wheelYOffset\n      },\n      bodyA: wheelA,\n      stiffness: 1,\n      length: 0\n    });\n    var axelB = Constraint.create({\n      bodyB: body,\n      pointB: {\n        x: wheelBOffset,\n        y: wheelYOffset\n      },\n      bodyA: wheelB,\n      stiffness: 1,\n      length: 0\n    });\n    Composite.addBody(car, body);\n    Composite.addBody(car, wheelA);\n    Composite.addBody(car, wheelB);\n    Composite.addConstraint(car, axelA);\n    Composite.addConstraint(car, axelB);\n    return car;\n  };\n  /**\r\n   * Creates a simple soft body like object.\r\n   * @method softBody\r\n   * @param {number} xx\r\n   * @param {number} yy\r\n   * @param {number} columns\r\n   * @param {number} rows\r\n   * @param {number} columnGap\r\n   * @param {number} rowGap\r\n   * @param {boolean} crossBrace\r\n   * @param {number} particleRadius\r\n   * @param {} particleOptions\r\n   * @param {} constraintOptions\r\n   * @return {composite} A new composite softBody\r\n   */\n\n\n  Composites.softBody = function (xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {\n    particleOptions = Common.extend({\n      inertia: Infinity\n    }, particleOptions);\n    constraintOptions = Common.extend({\n      stiffness: 0.2,\n      render: {\n        type: 'line',\n        anchors: false\n      }\n    }, constraintOptions);\n    var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function (x, y) {\n      return Bodies.circle(x, y, particleRadius, particleOptions);\n    });\n    Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);\n    softBody.label = 'Soft Body';\n    return softBody;\n  };\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/lib/factory/Composites.js"],"names":["Composites","module","exports","Composite","require","Constraint","Common","Body","Bodies","stack","xx","yy","columns","rows","columnGap","rowGap","callback","create","label","x","y","lastBody","i","row","maxHeight","column","body","bodyHeight","bounds","max","min","bodyWidth","translate","addBody","chain","composite","xOffsetA","yOffsetA","xOffsetB","yOffsetB","options","bodies","length","bodyA","bodyB","bodyAHeight","bodyAWidth","bodyBHeight","bodyBWidth","defaults","pointA","pointB","constraint","extend","addConstraint","mesh","crossBrace","col","bodyC","pyramid","actualRows","Math","ceil","lastBodyWidth","start","end","xOffset","newtonsCradle","number","size","separation","circle","inertia","Infinity","restitution","friction","frictionAir","slop","car","width","height","wheelSize","group","nextGroup","wheelBase","wheelAOffset","wheelBOffset","wheelYOffset","rectangle","collisionFilter","chamfer","radius","density","wheelA","wheelB","axelA","stiffness","axelB","softBody","particleRadius","particleOptions","constraintOptions","render","type","anchors"],"mappings":"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","sourcesContent":["/**\r\n* The `Matter.Composites` module contains factory methods for creating composite bodies\r\n* with commonly used configurations (such as stacks and chains).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Composites\r\n*/\r\n\r\nvar Composites = {};\r\n\r\nmodule.exports = Composites;\r\n\r\nvar Composite = require('../body/Composite');\r\nvar Constraint = require('../constraint/Constraint');\r\nvar Common = require('../core/Common');\r\nvar Body = require('../body/Body');\r\nvar Bodies = require('./Bodies');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Create a new composite containing bodies created in the callback in a grid arrangement.\r\n     * This function uses the body's bounds to prevent overlaps.\r\n     * @method stack\r\n     * @param {number} xx\r\n     * @param {number} yy\r\n     * @param {number} columns\r\n     * @param {number} rows\r\n     * @param {number} columnGap\r\n     * @param {number} rowGap\r\n     * @param {function} callback\r\n     * @return {composite} A new composite containing objects created in the callback\r\n     */\r\n    Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {\r\n        var stack = Composite.create({ label: 'Stack' }),\r\n            x = xx,\r\n            y = yy,\r\n            lastBody,\r\n            i = 0;\r\n\r\n        for (var row = 0; row < rows; row++) {\r\n            var maxHeight = 0;\r\n            \r\n            for (var column = 0; column < columns; column++) {\r\n                var body = callback(x, y, column, row, lastBody, i);\r\n                    \r\n                if (body) {\r\n                    var bodyHeight = body.bounds.max.y - body.bounds.min.y,\r\n                        bodyWidth = body.bounds.max.x - body.bounds.min.x; \r\n\r\n                    if (bodyHeight > maxHeight)\r\n                        maxHeight = bodyHeight;\r\n                    \r\n                    Body.translate(body, { x: bodyWidth * 0.5, y: bodyHeight * 0.5 });\r\n\r\n                    x = body.bounds.max.x + columnGap;\r\n\r\n                    Composite.addBody(stack, body);\r\n                    \r\n                    lastBody = body;\r\n                    i += 1;\r\n                } else {\r\n                    x += columnGap;\r\n                }\r\n            }\r\n            \r\n            y += maxHeight + rowGap;\r\n            x = xx;\r\n        }\r\n\r\n        return stack;\r\n    };\r\n    \r\n    /**\r\n     * Chains all bodies in the given composite together using constraints.\r\n     * @method chain\r\n     * @param {composite} composite\r\n     * @param {number} xOffsetA\r\n     * @param {number} yOffsetA\r\n     * @param {number} xOffsetB\r\n     * @param {number} yOffsetB\r\n     * @param {object} options\r\n     * @return {composite} A new composite containing objects chained together with constraints\r\n     */\r\n    Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {\r\n        var bodies = composite.bodies;\r\n        \r\n        for (var i = 1; i < bodies.length; i++) {\r\n            var bodyA = bodies[i - 1],\r\n                bodyB = bodies[i],\r\n                bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y,\r\n                bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, \r\n                bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y,\r\n                bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;\r\n        \r\n            var defaults = {\r\n                bodyA: bodyA,\r\n                pointA: { x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA },\r\n                bodyB: bodyB,\r\n                pointB: { x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB }\r\n            };\r\n            \r\n            var constraint = Common.extend(defaults, options);\r\n        \r\n            Composite.addConstraint(composite, Constraint.create(constraint));\r\n        }\r\n\r\n        composite.label += ' Chain';\r\n        \r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.\r\n     * @method mesh\r\n     * @param {composite} composite\r\n     * @param {number} columns\r\n     * @param {number} rows\r\n     * @param {boolean} crossBrace\r\n     * @param {object} options\r\n     * @return {composite} The composite containing objects meshed together with constraints\r\n     */\r\n    Composites.mesh = function(composite, columns, rows, crossBrace, options) {\r\n        var bodies = composite.bodies,\r\n            row,\r\n            col,\r\n            bodyA,\r\n            bodyB,\r\n            bodyC;\r\n        \r\n        for (row = 0; row < rows; row++) {\r\n            for (col = 1; col < columns; col++) {\r\n                bodyA = bodies[(col - 1) + (row * columns)];\r\n                bodyB = bodies[col + (row * columns)];\r\n                Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));\r\n            }\r\n\r\n            if (row > 0) {\r\n                for (col = 0; col < columns; col++) {\r\n                    bodyA = bodies[col + ((row - 1) * columns)];\r\n                    bodyB = bodies[col + (row * columns)];\r\n                    Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));\r\n\r\n                    if (crossBrace && col > 0) {\r\n                        bodyC = bodies[(col - 1) + ((row - 1) * columns)];\r\n                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));\r\n                    }\r\n\r\n                    if (crossBrace && col < columns - 1) {\r\n                        bodyC = bodies[(col + 1) + ((row - 1) * columns)];\r\n                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        composite.label += ' Mesh';\r\n        \r\n        return composite;\r\n    };\r\n    \r\n    /**\r\n     * Create a new composite containing bodies created in the callback in a pyramid arrangement.\r\n     * This function uses the body's bounds to prevent overlaps.\r\n     * @method pyramid\r\n     * @param {number} xx\r\n     * @param {number} yy\r\n     * @param {number} columns\r\n     * @param {number} rows\r\n     * @param {number} columnGap\r\n     * @param {number} rowGap\r\n     * @param {function} callback\r\n     * @return {composite} A new composite containing objects created in the callback\r\n     */\r\n    Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {\r\n        return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y, column, row, lastBody, i) {\r\n            var actualRows = Math.min(rows, Math.ceil(columns / 2)),\r\n                lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;\r\n            \r\n            if (row > actualRows)\r\n                return;\r\n            \r\n            // reverse row order\r\n            row = actualRows - row;\r\n            \r\n            var start = row,\r\n                end = columns - 1 - row;\r\n\r\n            if (column < start || column > end)\r\n                return;\r\n            \r\n            // retroactively fix the first body's position, since width was unknown\r\n            if (i === 1) {\r\n                Body.translate(lastBody, { x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0 });\r\n            }\r\n\r\n            var xOffset = lastBody ? column * lastBodyWidth : 0;\r\n            \r\n            return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Creates a composite with a Newton's Cradle setup of bodies and constraints.\r\n     * @method newtonsCradle\r\n     * @param {number} xx\r\n     * @param {number} yy\r\n     * @param {number} number\r\n     * @param {number} size\r\n     * @param {number} length\r\n     * @return {composite} A new composite newtonsCradle body\r\n     */\r\n    Composites.newtonsCradle = function(xx, yy, number, size, length) {\r\n        var newtonsCradle = Composite.create({ label: 'Newtons Cradle' });\r\n\r\n        for (var i = 0; i < number; i++) {\r\n            var separation = 1.9,\r\n                circle = Bodies.circle(xx + i * (size * separation), yy + length, size, \r\n                    { inertia: Infinity, restitution: 1, friction: 0, frictionAir: 0.0001, slop: 1 }),\r\n                constraint = Constraint.create({ pointA: { x: xx + i * (size * separation), y: yy }, bodyB: circle });\r\n\r\n            Composite.addBody(newtonsCradle, circle);\r\n            Composite.addConstraint(newtonsCradle, constraint);\r\n        }\r\n\r\n        return newtonsCradle;\r\n    };\r\n    \r\n    /**\r\n     * Creates a composite with simple car setup of bodies and constraints.\r\n     * @method car\r\n     * @param {number} xx\r\n     * @param {number} yy\r\n     * @param {number} width\r\n     * @param {number} height\r\n     * @param {number} wheelSize\r\n     * @return {composite} A new composite car body\r\n     */\r\n    Composites.car = function(xx, yy, width, height, wheelSize) {\r\n        var group = Body.nextGroup(true),\r\n            wheelBase = 20,\r\n            wheelAOffset = -width * 0.5 + wheelBase,\r\n            wheelBOffset = width * 0.5 - wheelBase,\r\n            wheelYOffset = 0;\r\n    \r\n        var car = Composite.create({ label: 'Car' }),\r\n            body = Bodies.rectangle(xx, yy, width, height, { \r\n                collisionFilter: {\r\n                    group: group\r\n                },\r\n                chamfer: {\r\n                    radius: height * 0.5\r\n                },\r\n                density: 0.0002\r\n            });\r\n    \r\n        var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, { \r\n            collisionFilter: {\r\n                group: group\r\n            },\r\n            friction: 0.8\r\n        });\r\n                    \r\n        var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, { \r\n            collisionFilter: {\r\n                group: group\r\n            },\r\n            friction: 0.8\r\n        });\r\n                    \r\n        var axelA = Constraint.create({\r\n            bodyB: body,\r\n            pointB: { x: wheelAOffset, y: wheelYOffset },\r\n            bodyA: wheelA,\r\n            stiffness: 1,\r\n            length: 0\r\n        });\r\n                        \r\n        var axelB = Constraint.create({\r\n            bodyB: body,\r\n            pointB: { x: wheelBOffset, y: wheelYOffset },\r\n            bodyA: wheelB,\r\n            stiffness: 1,\r\n            length: 0\r\n        });\r\n        \r\n        Composite.addBody(car, body);\r\n        Composite.addBody(car, wheelA);\r\n        Composite.addBody(car, wheelB);\r\n        Composite.addConstraint(car, axelA);\r\n        Composite.addConstraint(car, axelB);\r\n\r\n        return car;\r\n    };\r\n\r\n    /**\r\n     * Creates a simple soft body like object.\r\n     * @method softBody\r\n     * @param {number} xx\r\n     * @param {number} yy\r\n     * @param {number} columns\r\n     * @param {number} rows\r\n     * @param {number} columnGap\r\n     * @param {number} rowGap\r\n     * @param {boolean} crossBrace\r\n     * @param {number} particleRadius\r\n     * @param {} particleOptions\r\n     * @param {} constraintOptions\r\n     * @return {composite} A new composite softBody\r\n     */\r\n    Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {\r\n        particleOptions = Common.extend({ inertia: Infinity }, particleOptions);\r\n        constraintOptions = Common.extend({ stiffness: 0.2, render: { type: 'line', anchors: false } }, constraintOptions);\r\n\r\n        var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y) {\r\n            return Bodies.circle(x, y, particleRadius, particleOptions);\r\n        });\r\n\r\n        Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);\r\n\r\n        softBody.label = 'Soft Body';\r\n\r\n        return softBody;\r\n    };\r\n\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}