{"ast":null,"code":"/**\r\n* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.\r\n*\r\n* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Svg\r\n*/\nvar Svg = {};\nmodule.exports = Svg;\n\nvar Bounds = require('../geometry/Bounds');\n\nvar Common = require('../core/Common');\n\n(function () {\n  /**\r\n   * Converts an SVG path into an array of vector points.\r\n   * If the input path forms a concave shape, you must decompose the result into convex parts before use.\r\n   * See `Bodies.fromVertices` which provides support for this.\r\n   * Note that this function is not guaranteed to support complex paths (such as those with holes).\r\n   * You must load the `pathseg.js` polyfill on newer browsers.\r\n   * @method pathToVertices\r\n   * @param {SVGPathElement} path\r\n   * @param {Number} [sampleLength=15]\r\n   * @return {Vector[]} points\r\n   */\n  Svg.pathToVertices = function (path, sampleLength) {\n    if (typeof window !== 'undefined' && !('SVGPathSeg' in window)) {\n      Common.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.');\n    } // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js\n\n\n    var i,\n        il,\n        total,\n        point,\n        segment,\n        segments,\n        segmentsQueue,\n        lastSegment,\n        lastPoint,\n        segmentIndex,\n        points = [],\n        lx,\n        ly,\n        length = 0,\n        x = 0,\n        y = 0;\n    sampleLength = sampleLength || 15;\n\n    var addPoint = function (px, py, pathSegType) {\n      // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)\n      var isRelative = pathSegType % 2 === 1 && pathSegType > 1; // when the last point doesn't equal the current point add the current point\n\n      if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {\n        if (lastPoint && isRelative) {\n          lx = lastPoint.x;\n          ly = lastPoint.y;\n        } else {\n          lx = 0;\n          ly = 0;\n        }\n\n        var point = {\n          x: lx + px,\n          y: ly + py\n        }; // set last point\n\n        if (isRelative || !lastPoint) {\n          lastPoint = point;\n        }\n\n        points.push(point);\n        x = lx + px;\n        y = ly + py;\n      }\n    };\n\n    var addSegmentPoint = function (segment) {\n      var segType = segment.pathSegTypeAsLetter.toUpperCase(); // skip path ends\n\n      if (segType === 'Z') return; // map segment to x and y\n\n      switch (segType) {\n        case 'M':\n        case 'L':\n        case 'T':\n        case 'C':\n        case 'S':\n        case 'Q':\n          x = segment.x;\n          y = segment.y;\n          break;\n\n        case 'H':\n          x = segment.x;\n          break;\n\n        case 'V':\n          y = segment.y;\n          break;\n      }\n\n      addPoint(x, y, segment.pathSegType);\n    }; // ensure path is absolute\n\n\n    Svg._svgPathToAbsolute(path); // get total length\n\n\n    total = path.getTotalLength(); // queue segments\n\n    segments = [];\n\n    for (i = 0; i < path.pathSegList.numberOfItems; i += 1) segments.push(path.pathSegList.getItem(i));\n\n    segmentsQueue = segments.concat(); // sample through path\n\n    while (length < total) {\n      // get segment at position\n      segmentIndex = path.getPathSegAtLength(length);\n      segment = segments[segmentIndex]; // new segment\n\n      if (segment != lastSegment) {\n        while (segmentsQueue.length && segmentsQueue[0] != segment) addSegmentPoint(segmentsQueue.shift());\n\n        lastSegment = segment;\n      } // add points in between when curving\n      // TODO: adaptive sampling\n\n\n      switch (segment.pathSegTypeAsLetter.toUpperCase()) {\n        case 'C':\n        case 'T':\n        case 'S':\n        case 'Q':\n        case 'A':\n          point = path.getPointAtLength(length);\n          addPoint(point.x, point.y, 0);\n          break;\n      } // increment by sample value\n\n\n      length += sampleLength;\n    } // add remaining segments not passed by sampling\n\n\n    for (i = 0, il = segmentsQueue.length; i < il; ++i) addSegmentPoint(segmentsQueue[i]);\n\n    return points;\n  };\n\n  Svg._svgPathToAbsolute = function (path) {\n    // http://phrogz.net/convert-svg-path-to-all-absolute-commands\n    // Copyright (c) Gavin Kistner\n    // http://phrogz.net/js/_ReuseLicense.txt\n    // Modifications: tidy formatting and naming\n    var x0,\n        y0,\n        x1,\n        y1,\n        x2,\n        y2,\n        segs = path.pathSegList,\n        x = 0,\n        y = 0,\n        len = segs.numberOfItems;\n\n    for (var i = 0; i < len; ++i) {\n      var seg = segs.getItem(i),\n          segType = seg.pathSegTypeAsLetter;\n\n      if (/[MLHVCSQTA]/.test(segType)) {\n        if ('x' in seg) x = seg.x;\n        if ('y' in seg) y = seg.y;\n      } else {\n        if ('x1' in seg) x1 = x + seg.x1;\n        if ('x2' in seg) x2 = x + seg.x2;\n        if ('y1' in seg) y1 = y + seg.y1;\n        if ('y2' in seg) y2 = y + seg.y2;\n        if ('x' in seg) x += seg.x;\n        if ('y' in seg) y += seg.y;\n\n        switch (segType) {\n          case 'm':\n            segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);\n            break;\n\n          case 'l':\n            segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);\n            break;\n\n          case 'h':\n            segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);\n            break;\n\n          case 'v':\n            segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);\n            break;\n\n          case 'c':\n            segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);\n            break;\n\n          case 's':\n            segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);\n            break;\n\n          case 'q':\n            segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);\n            break;\n\n          case 't':\n            segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);\n            break;\n\n          case 'a':\n            segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);\n            break;\n\n          case 'z':\n          case 'Z':\n            x = x0;\n            y = y0;\n            break;\n        }\n      }\n\n      if (segType == 'M' || segType == 'm') {\n        x0 = x;\n        y0 = y;\n      }\n    }\n  };\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/lib/geometry/Svg.js"],"names":["Svg","module","exports","Bounds","require","Common","pathToVertices","path","sampleLength","window","warn","i","il","total","point","segment","segments","segmentsQueue","lastSegment","lastPoint","segmentIndex","points","lx","ly","length","x","y","addPoint","px","py","pathSegType","isRelative","push","addSegmentPoint","segType","pathSegTypeAsLetter","toUpperCase","_svgPathToAbsolute","getTotalLength","pathSegList","numberOfItems","getItem","concat","getPathSegAtLength","shift","getPointAtLength","x0","y0","x1","y1","x2","y2","segs","len","seg","test","replaceItem","createSVGPathSegMovetoAbs","createSVGPathSegLinetoAbs","createSVGPathSegLinetoHorizontalAbs","createSVGPathSegLinetoVerticalAbs","createSVGPathSegCurvetoCubicAbs","createSVGPathSegCurvetoCubicSmoothAbs","createSVGPathSegCurvetoQuadraticAbs","createSVGPathSegCurvetoQuadraticSmoothAbs","createSVGPathSegArcAbs","r1","r2","angle","largeArcFlag","sweepFlag"],"mappings":"AAAA;;;;;;;;;AAUA,IAAIA,GAAG,GAAG,EAAV;AAEAC,MAAM,CAACC,OAAP,GAAiBF,GAAjB;;AAEA,IAAIG,MAAM,GAAGC,OAAO,CAAC,oBAAD,CAApB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,gBAAD,CAApB;;AAEA,CAAC,YAAW;AAER;;;;;;;;;;;AAWAJ,EAAAA,GAAG,CAACM,cAAJ,GAAqB,UAASC,IAAT,EAAeC,YAAf,EAA6B;AAC9C,QAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiC,EAAE,gBAAgBA,MAAlB,CAArC,EAAgE;AAC5DJ,MAAAA,MAAM,CAACK,IAAP,CAAY,qEAAZ;AACH,KAH6C,CAK9C;;;AACA,QAAIC,CAAJ;AAAA,QAAOC,EAAP;AAAA,QAAWC,KAAX;AAAA,QAAkBC,KAAlB;AAAA,QAAyBC,OAAzB;AAAA,QAAkCC,QAAlC;AAAA,QACIC,aADJ;AAAA,QACmBC,WADnB;AAAA,QAEIC,SAFJ;AAAA,QAEeC,YAFf;AAAA,QAE6BC,MAAM,GAAG,EAFtC;AAAA,QAGIC,EAHJ;AAAA,QAGQC,EAHR;AAAA,QAGYC,MAAM,GAAG,CAHrB;AAAA,QAGwBC,CAAC,GAAG,CAH5B;AAAA,QAG+BC,CAAC,GAAG,CAHnC;AAKAlB,IAAAA,YAAY,GAAGA,YAAY,IAAI,EAA/B;;AAEA,QAAImB,QAAQ,GAAG,UAASC,EAAT,EAAaC,EAAb,EAAiBC,WAAjB,EAA8B;AACzC;AACA,UAAIC,UAAU,GAAGD,WAAW,GAAG,CAAd,KAAoB,CAApB,IAAyBA,WAAW,GAAG,CAAxD,CAFyC,CAIzC;;AACA,UAAI,CAACX,SAAD,IAAcS,EAAE,IAAIT,SAAS,CAACM,CAA9B,IAAmCI,EAAE,IAAIV,SAAS,CAACO,CAAvD,EAA0D;AACtD,YAAIP,SAAS,IAAIY,UAAjB,EAA6B;AACzBT,UAAAA,EAAE,GAAGH,SAAS,CAACM,CAAf;AACAF,UAAAA,EAAE,GAAGJ,SAAS,CAACO,CAAf;AACH,SAHD,MAGO;AACHJ,UAAAA,EAAE,GAAG,CAAL;AACAC,UAAAA,EAAE,GAAG,CAAL;AACH;;AAED,YAAIT,KAAK,GAAG;AACRW,UAAAA,CAAC,EAAEH,EAAE,GAAGM,EADA;AAERF,UAAAA,CAAC,EAAEH,EAAE,GAAGM;AAFA,SAAZ,CATsD,CActD;;AACA,YAAIE,UAAU,IAAI,CAACZ,SAAnB,EAA8B;AAC1BA,UAAAA,SAAS,GAAGL,KAAZ;AACH;;AAEDO,QAAAA,MAAM,CAACW,IAAP,CAAYlB,KAAZ;AAEAW,QAAAA,CAAC,GAAGH,EAAE,GAAGM,EAAT;AACAF,QAAAA,CAAC,GAAGH,EAAE,GAAGM,EAAT;AACH;AACJ,KA7BD;;AA+BA,QAAII,eAAe,GAAG,UAASlB,OAAT,EAAkB;AACpC,UAAImB,OAAO,GAAGnB,OAAO,CAACoB,mBAAR,CAA4BC,WAA5B,EAAd,CADoC,CAGpC;;AACA,UAAIF,OAAO,KAAK,GAAhB,EACI,OALgC,CAOpC;;AACA,cAAQA,OAAR;AAEA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACIT,UAAAA,CAAC,GAAGV,OAAO,CAACU,CAAZ;AACAC,UAAAA,CAAC,GAAGX,OAAO,CAACW,CAAZ;AACA;;AACJ,aAAK,GAAL;AACID,UAAAA,CAAC,GAAGV,OAAO,CAACU,CAAZ;AACA;;AACJ,aAAK,GAAL;AACIC,UAAAA,CAAC,GAAGX,OAAO,CAACW,CAAZ;AACA;AAhBJ;;AAmBAC,MAAAA,QAAQ,CAACF,CAAD,EAAIC,CAAJ,EAAOX,OAAO,CAACe,WAAf,CAAR;AACH,KA5BD,CA5C8C,CA0E9C;;;AACA9B,IAAAA,GAAG,CAACqC,kBAAJ,CAAuB9B,IAAvB,EA3E8C,CA6E9C;;;AACAM,IAAAA,KAAK,GAAGN,IAAI,CAAC+B,cAAL,EAAR,CA9E8C,CAgF9C;;AACAtB,IAAAA,QAAQ,GAAG,EAAX;;AACA,SAAKL,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGJ,IAAI,CAACgC,WAAL,CAAiBC,aAAjC,EAAgD7B,CAAC,IAAI,CAArD,EACIK,QAAQ,CAACgB,IAAT,CAAczB,IAAI,CAACgC,WAAL,CAAiBE,OAAjB,CAAyB9B,CAAzB,CAAd;;AAEJM,IAAAA,aAAa,GAAGD,QAAQ,CAAC0B,MAAT,EAAhB,CArF8C,CAuF9C;;AACA,WAAOlB,MAAM,GAAGX,KAAhB,EAAuB;AACnB;AACAO,MAAAA,YAAY,GAAGb,IAAI,CAACoC,kBAAL,CAAwBnB,MAAxB,CAAf;AACAT,MAAAA,OAAO,GAAGC,QAAQ,CAACI,YAAD,CAAlB,CAHmB,CAKnB;;AACA,UAAIL,OAAO,IAAIG,WAAf,EAA4B;AACxB,eAAOD,aAAa,CAACO,MAAd,IAAwBP,aAAa,CAAC,CAAD,CAAb,IAAoBF,OAAnD,EACIkB,eAAe,CAAChB,aAAa,CAAC2B,KAAd,EAAD,CAAf;;AAEJ1B,QAAAA,WAAW,GAAGH,OAAd;AACH,OAXkB,CAanB;AACA;;;AACA,cAAQA,OAAO,CAACoB,mBAAR,CAA4BC,WAA5B,EAAR;AAEA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACItB,UAAAA,KAAK,GAAGP,IAAI,CAACsC,gBAAL,CAAsBrB,MAAtB,CAAR;AACAG,UAAAA,QAAQ,CAACb,KAAK,CAACW,CAAP,EAAUX,KAAK,CAACY,CAAhB,EAAmB,CAAnB,CAAR;AACA;AATJ,OAfmB,CA4BnB;;;AACAF,MAAAA,MAAM,IAAIhB,YAAV;AACH,KAtH6C,CAwH9C;;;AACA,SAAKG,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGK,aAAa,CAACO,MAA/B,EAAuCb,CAAC,GAAGC,EAA3C,EAA+C,EAAED,CAAjD,EACIsB,eAAe,CAAChB,aAAa,CAACN,CAAD,CAAd,CAAf;;AAEJ,WAAOU,MAAP;AACH,GA7HD;;AA+HArB,EAAAA,GAAG,CAACqC,kBAAJ,GAAyB,UAAS9B,IAAT,EAAe;AACpC;AACA;AACA;AACA;AACA,QAAIuC,EAAJ;AAAA,QAAQC,EAAR;AAAA,QAAYC,EAAZ;AAAA,QAAgBC,EAAhB;AAAA,QAAoBC,EAApB;AAAA,QAAwBC,EAAxB;AAAA,QAA4BC,IAAI,GAAG7C,IAAI,CAACgC,WAAxC;AAAA,QACId,CAAC,GAAG,CADR;AAAA,QACWC,CAAC,GAAG,CADf;AAAA,QACkB2B,GAAG,GAAGD,IAAI,CAACZ,aAD7B;;AAGA,SAAK,IAAI7B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0C,GAApB,EAAyB,EAAE1C,CAA3B,EAA8B;AAC1B,UAAI2C,GAAG,GAAGF,IAAI,CAACX,OAAL,CAAa9B,CAAb,CAAV;AAAA,UACIuB,OAAO,GAAGoB,GAAG,CAACnB,mBADlB;;AAGA,UAAI,cAAcoB,IAAd,CAAmBrB,OAAnB,CAAJ,EAAiC;AAC7B,YAAI,OAAOoB,GAAX,EAAgB7B,CAAC,GAAG6B,GAAG,CAAC7B,CAAR;AAChB,YAAI,OAAO6B,GAAX,EAAgB5B,CAAC,GAAG4B,GAAG,CAAC5B,CAAR;AACnB,OAHD,MAGO;AACH,YAAI,QAAQ4B,GAAZ,EAAiBN,EAAE,GAAGvB,CAAC,GAAG6B,GAAG,CAACN,EAAb;AACjB,YAAI,QAAQM,GAAZ,EAAiBJ,EAAE,GAAGzB,CAAC,GAAG6B,GAAG,CAACJ,EAAb;AACjB,YAAI,QAAQI,GAAZ,EAAiBL,EAAE,GAAGvB,CAAC,GAAG4B,GAAG,CAACL,EAAb;AACjB,YAAI,QAAQK,GAAZ,EAAiBH,EAAE,GAAGzB,CAAC,GAAG4B,GAAG,CAACH,EAAb;AACjB,YAAI,OAAOG,GAAX,EAAgB7B,CAAC,IAAI6B,GAAG,CAAC7B,CAAT;AAChB,YAAI,OAAO6B,GAAX,EAAgB5B,CAAC,IAAI4B,GAAG,CAAC5B,CAAT;;AAEhB,gBAAQQ,OAAR;AAEA,eAAK,GAAL;AACIkB,YAAAA,IAAI,CAACI,WAAL,CAAiBjD,IAAI,CAACkD,yBAAL,CAA+BhC,CAA/B,EAAkCC,CAAlC,CAAjB,EAAuDf,CAAvD;AACA;;AACJ,eAAK,GAAL;AACIyC,YAAAA,IAAI,CAACI,WAAL,CAAiBjD,IAAI,CAACmD,yBAAL,CAA+BjC,CAA/B,EAAkCC,CAAlC,CAAjB,EAAuDf,CAAvD;AACA;;AACJ,eAAK,GAAL;AACIyC,YAAAA,IAAI,CAACI,WAAL,CAAiBjD,IAAI,CAACoD,mCAAL,CAAyClC,CAAzC,CAAjB,EAA8Dd,CAA9D;AACA;;AACJ,eAAK,GAAL;AACIyC,YAAAA,IAAI,CAACI,WAAL,CAAiBjD,IAAI,CAACqD,iCAAL,CAAuClC,CAAvC,CAAjB,EAA4Df,CAA5D;AACA;;AACJ,eAAK,GAAL;AACIyC,YAAAA,IAAI,CAACI,WAAL,CAAiBjD,IAAI,CAACsD,+BAAL,CAAqCpC,CAArC,EAAwCC,CAAxC,EAA2CsB,EAA3C,EAA+CC,EAA/C,EAAmDC,EAAnD,EAAuDC,EAAvD,CAAjB,EAA6ExC,CAA7E;AACA;;AACJ,eAAK,GAAL;AACIyC,YAAAA,IAAI,CAACI,WAAL,CAAiBjD,IAAI,CAACuD,qCAAL,CAA2CrC,CAA3C,EAA8CC,CAA9C,EAAiDwB,EAAjD,EAAqDC,EAArD,CAAjB,EAA2ExC,CAA3E;AACA;;AACJ,eAAK,GAAL;AACIyC,YAAAA,IAAI,CAACI,WAAL,CAAiBjD,IAAI,CAACwD,mCAAL,CAAyCtC,CAAzC,EAA4CC,CAA5C,EAA+CsB,EAA/C,EAAmDC,EAAnD,CAAjB,EAAyEtC,CAAzE;AACA;;AACJ,eAAK,GAAL;AACIyC,YAAAA,IAAI,CAACI,WAAL,CAAiBjD,IAAI,CAACyD,yCAAL,CAA+CvC,CAA/C,EAAkDC,CAAlD,CAAjB,EAAuEf,CAAvE;AACA;;AACJ,eAAK,GAAL;AACIyC,YAAAA,IAAI,CAACI,WAAL,CAAiBjD,IAAI,CAAC0D,sBAAL,CAA4BxC,CAA5B,EAA+BC,CAA/B,EAAkC4B,GAAG,CAACY,EAAtC,EAA0CZ,GAAG,CAACa,EAA9C,EAAkDb,GAAG,CAACc,KAAtD,EAA6Dd,GAAG,CAACe,YAAjE,EAA+Ef,GAAG,CAACgB,SAAnF,CAAjB,EAAgH3D,CAAhH;AACA;;AACJ,eAAK,GAAL;AACA,eAAK,GAAL;AACIc,YAAAA,CAAC,GAAGqB,EAAJ;AACApB,YAAAA,CAAC,GAAGqB,EAAJ;AACA;AAjCJ;AAoCH;;AAED,UAAIb,OAAO,IAAI,GAAX,IAAkBA,OAAO,IAAI,GAAjC,EAAsC;AAClCY,QAAAA,EAAE,GAAGrB,CAAL;AACAsB,QAAAA,EAAE,GAAGrB,CAAL;AACH;AACJ;AACJ,GAlED;AAoEH,CAhND","sourcesContent":["/**\r\n* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.\r\n*\r\n* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Svg\r\n*/\r\n\r\nvar Svg = {};\r\n\r\nmodule.exports = Svg;\r\n\r\nvar Bounds = require('../geometry/Bounds');\r\nvar Common = require('../core/Common');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Converts an SVG path into an array of vector points.\r\n     * If the input path forms a concave shape, you must decompose the result into convex parts before use.\r\n     * See `Bodies.fromVertices` which provides support for this.\r\n     * Note that this function is not guaranteed to support complex paths (such as those with holes).\r\n     * You must load the `pathseg.js` polyfill on newer browsers.\r\n     * @method pathToVertices\r\n     * @param {SVGPathElement} path\r\n     * @param {Number} [sampleLength=15]\r\n     * @return {Vector[]} points\r\n     */\r\n    Svg.pathToVertices = function(path, sampleLength) {\r\n        if (typeof window !== 'undefined' && !('SVGPathSeg' in window)) {\r\n            Common.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.');\r\n        }\r\n\r\n        // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js\r\n        var i, il, total, point, segment, segments, \r\n            segmentsQueue, lastSegment, \r\n            lastPoint, segmentIndex, points = [],\r\n            lx, ly, length = 0, x = 0, y = 0;\r\n\r\n        sampleLength = sampleLength || 15;\r\n\r\n        var addPoint = function(px, py, pathSegType) {\r\n            // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)\r\n            var isRelative = pathSegType % 2 === 1 && pathSegType > 1;\r\n\r\n            // when the last point doesn't equal the current point add the current point\r\n            if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {\r\n                if (lastPoint && isRelative) {\r\n                    lx = lastPoint.x;\r\n                    ly = lastPoint.y;\r\n                } else {\r\n                    lx = 0;\r\n                    ly = 0;\r\n                }\r\n\r\n                var point = {\r\n                    x: lx + px,\r\n                    y: ly + py\r\n                };\r\n\r\n                // set last point\r\n                if (isRelative || !lastPoint) {\r\n                    lastPoint = point;\r\n                }\r\n\r\n                points.push(point);\r\n\r\n                x = lx + px;\r\n                y = ly + py;\r\n            }\r\n        };\r\n\r\n        var addSegmentPoint = function(segment) {\r\n            var segType = segment.pathSegTypeAsLetter.toUpperCase();\r\n\r\n            // skip path ends\r\n            if (segType === 'Z') \r\n                return;\r\n\r\n            // map segment to x and y\r\n            switch (segType) {\r\n\r\n            case 'M':\r\n            case 'L':\r\n            case 'T':\r\n            case 'C':\r\n            case 'S':\r\n            case 'Q':\r\n                x = segment.x;\r\n                y = segment.y;\r\n                break;\r\n            case 'H':\r\n                x = segment.x;\r\n                break;\r\n            case 'V':\r\n                y = segment.y;\r\n                break;\r\n            }\r\n\r\n            addPoint(x, y, segment.pathSegType);\r\n        };\r\n\r\n        // ensure path is absolute\r\n        Svg._svgPathToAbsolute(path);\r\n\r\n        // get total length\r\n        total = path.getTotalLength();\r\n\r\n        // queue segments\r\n        segments = [];\r\n        for (i = 0; i < path.pathSegList.numberOfItems; i += 1)\r\n            segments.push(path.pathSegList.getItem(i));\r\n\r\n        segmentsQueue = segments.concat();\r\n\r\n        // sample through path\r\n        while (length < total) {\r\n            // get segment at position\r\n            segmentIndex = path.getPathSegAtLength(length);\r\n            segment = segments[segmentIndex];\r\n\r\n            // new segment\r\n            if (segment != lastSegment) {\r\n                while (segmentsQueue.length && segmentsQueue[0] != segment)\r\n                    addSegmentPoint(segmentsQueue.shift());\r\n\r\n                lastSegment = segment;\r\n            }\r\n\r\n            // add points in between when curving\r\n            // TODO: adaptive sampling\r\n            switch (segment.pathSegTypeAsLetter.toUpperCase()) {\r\n\r\n            case 'C':\r\n            case 'T':\r\n            case 'S':\r\n            case 'Q':\r\n            case 'A':\r\n                point = path.getPointAtLength(length);\r\n                addPoint(point.x, point.y, 0);\r\n                break;\r\n\r\n            }\r\n\r\n            // increment by sample value\r\n            length += sampleLength;\r\n        }\r\n\r\n        // add remaining segments not passed by sampling\r\n        for (i = 0, il = segmentsQueue.length; i < il; ++i)\r\n            addSegmentPoint(segmentsQueue[i]);\r\n\r\n        return points;\r\n    };\r\n\r\n    Svg._svgPathToAbsolute = function(path) {\r\n        // http://phrogz.net/convert-svg-path-to-all-absolute-commands\r\n        // Copyright (c) Gavin Kistner\r\n        // http://phrogz.net/js/_ReuseLicense.txt\r\n        // Modifications: tidy formatting and naming\r\n        var x0, y0, x1, y1, x2, y2, segs = path.pathSegList,\r\n            x = 0, y = 0, len = segs.numberOfItems;\r\n\r\n        for (var i = 0; i < len; ++i) {\r\n            var seg = segs.getItem(i),\r\n                segType = seg.pathSegTypeAsLetter;\r\n\r\n            if (/[MLHVCSQTA]/.test(segType)) {\r\n                if ('x' in seg) x = seg.x;\r\n                if ('y' in seg) y = seg.y;\r\n            } else {\r\n                if ('x1' in seg) x1 = x + seg.x1;\r\n                if ('x2' in seg) x2 = x + seg.x2;\r\n                if ('y1' in seg) y1 = y + seg.y1;\r\n                if ('y2' in seg) y2 = y + seg.y2;\r\n                if ('x' in seg) x += seg.x;\r\n                if ('y' in seg) y += seg.y;\r\n\r\n                switch (segType) {\r\n\r\n                case 'm':\r\n                    segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);\r\n                    break;\r\n                case 'l':\r\n                    segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);\r\n                    break;\r\n                case 'h':\r\n                    segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);\r\n                    break;\r\n                case 'v':\r\n                    segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);\r\n                    break;\r\n                case 'c':\r\n                    segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);\r\n                    break;\r\n                case 's':\r\n                    segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);\r\n                    break;\r\n                case 'q':\r\n                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);\r\n                    break;\r\n                case 't':\r\n                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);\r\n                    break;\r\n                case 'a':\r\n                    segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);\r\n                    break;\r\n                case 'z':\r\n                case 'Z':\r\n                    x = x0;\r\n                    y = y0;\r\n                    break;\r\n\r\n                }\r\n            }\r\n\r\n            if (segType == 'M' || segType == 'm') {\r\n                x0 = x;\r\n                y0 = y;\r\n            }\r\n        }\r\n    };\r\n\r\n})();"]},"metadata":{},"sourceType":"script"}