{"ast":null,"code":"/**\r\n * The `Matter.Body` module contains methods for creating and manipulating body models.\r\n * A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.\r\n * Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.\r\n *\r\n * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n * @class Body\r\n */\nvar Body = {};\nmodule.exports = Body;\n\nvar Vertices = require('../geometry/Vertices');\n\nvar Vector = require('../geometry/Vector');\n\nvar Sleeping = require('../core/Sleeping');\n\nvar Common = require('../core/Common');\n\nvar Bounds = require('../geometry/Bounds');\n\nvar Axes = require('../geometry/Axes');\n\n(function () {\n  Body._inertiaScale = 4;\n  Body._nextCollidingGroupId = 1;\n  Body._nextNonCollidingGroupId = -1;\n  Body._nextCategory = 0x0001;\n  /**\r\n   * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n   * All properties have default values, and many are pre-calculated automatically based on other properties.\r\n   * Vertices must be specified in clockwise order.\r\n   * See the properties section below for detailed information on what you can pass via the `options` object.\r\n   * @method create\r\n   * @param {} options\r\n   * @return {body} body\r\n   */\n\n  Body.create = function (options) {\n    var defaults = {\n      id: Common.nextId(),\n      type: 'body',\n      label: 'Body',\n      parts: [],\n      plugin: {},\n      angle: 0,\n      vertices: null,\n      // Phaser change: no point calling fromPath if they pass in vertices anyway\n      position: {\n        x: 0,\n        y: 0\n      },\n      force: {\n        x: 0,\n        y: 0\n      },\n      torque: 0,\n      positionImpulse: {\n        x: 0,\n        y: 0\n      },\n      previousPositionImpulse: {\n        x: 0,\n        y: 0\n      },\n      constraintImpulse: {\n        x: 0,\n        y: 0,\n        angle: 0\n      },\n      totalContacts: 0,\n      speed: 0,\n      angularSpeed: 0,\n      velocity: {\n        x: 0,\n        y: 0\n      },\n      angularVelocity: 0,\n      isSensor: false,\n      isStatic: false,\n      isSleeping: false,\n      motion: 0,\n      sleepThreshold: 60,\n      density: 0.001,\n      restitution: 0,\n      friction: 0.1,\n      frictionStatic: 0.5,\n      frictionAir: 0.01,\n      collisionFilter: {\n        category: 0x0001,\n        mask: 0xFFFFFFFF,\n        group: 0\n      },\n      slop: 0.05,\n      timeScale: 1,\n      events: null,\n      bounds: null,\n      chamfer: null,\n      circleRadius: 0,\n      positionPrev: null,\n      anglePrev: 0,\n      parent: null,\n      axes: null,\n      area: 0,\n      mass: 0,\n      inverseMass: 0,\n      inertia: 0,\n      inverseInertia: 0,\n      _original: null,\n      render: {\n        visible: true,\n        opacity: 1,\n        sprite: {\n          xOffset: 0,\n          yOffset: 0\n        },\n        fillColor: null,\n        // custom Phaser property\n        fillOpacity: null,\n        // custom Phaser property\n        lineColor: null,\n        // custom Phaser property\n        lineOpacity: null,\n        // custom Phaser property\n        lineThickness: null // custom Phaser property\n\n      },\n      gameObject: null,\n      // custom Phaser property\n      scale: {\n        x: 1,\n        y: 1\n      },\n      // custom Phaser property\n      centerOfMass: {\n        x: 0,\n        y: 0\n      },\n      // custom Phaser property (float, 0 - 1)\n      centerOffset: {\n        x: 0,\n        y: 0\n      },\n      // custom Phaser property (pixel values)\n      gravityScale: {\n        x: 1,\n        y: 1\n      },\n      // custom Phaser property\n      ignoreGravity: false,\n      // custom Phaser property\n      ignorePointer: false,\n      // custom Phaser property\n      onCollideCallback: null,\n      // custom Phaser property\n      onCollideEndCallback: null,\n      // custom Phaser property\n      onCollideActiveCallback: null,\n      // custom Phaser property\n      onCollideWith: {} // custom Phaser property\n\n    };\n\n    if (!options.hasOwnProperty('position') && options.hasOwnProperty('vertices')) {\n      options.position = Vertices.centre(options.vertices);\n    } else if (!options.hasOwnProperty('vertices')) {\n      defaults.vertices = Vertices.fromPath('L 0 0 L 40 0 L 40 40 L 0 40');\n    }\n\n    var body = Common.extend(defaults, options);\n\n    _initProperties(body, options); //  Helper function\n\n\n    body.setOnCollideWith = function (body, callback) {\n      if (callback) {\n        this.onCollideWith[body.id] = callback;\n      } else {\n        delete this.onCollideWith[body.id];\n      }\n\n      return this;\n    };\n\n    return body;\n  };\n  /**\r\n   * Returns the next unique group index for which bodies will collide.\r\n   * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.\r\n   * See `body.collisionFilter` for more information.\r\n   * @method nextGroup\r\n   * @param {bool} [isNonColliding=false]\r\n   * @return {Number} Unique group index\r\n   */\n\n\n  Body.nextGroup = function (isNonColliding) {\n    if (isNonColliding) return Body._nextNonCollidingGroupId--;\n    return Body._nextCollidingGroupId++;\n  };\n  /**\r\n   * Returns the next unique category bitfield (starting after the initial default category `0x0001`).\r\n   * There are 32 available. See `body.collisionFilter` for more information.\r\n   * @method nextCategory\r\n   * @return {Number} Unique category bitfield\r\n   */\n\n\n  Body.nextCategory = function () {\n    Body._nextCategory = Body._nextCategory << 1;\n    return Body._nextCategory;\n  };\n  /**\r\n   * Initialises body properties.\r\n   * @method _initProperties\r\n   * @private\r\n   * @param {body} body\r\n   * @param {} [options]\r\n   */\n\n\n  var _initProperties = function (body, options) {\n    options = options || {}; // init required properties (order is important)\n\n    Body.set(body, {\n      bounds: body.bounds || Bounds.create(body.vertices),\n      positionPrev: body.positionPrev || Vector.clone(body.position),\n      anglePrev: body.anglePrev || body.angle,\n      vertices: body.vertices,\n      parts: body.parts || [body],\n      isStatic: body.isStatic,\n      isSleeping: body.isSleeping,\n      parent: body.parent || body\n    });\n    var bounds = body.bounds;\n    Vertices.rotate(body.vertices, body.angle, body.position);\n    Axes.rotate(body.axes, body.angle);\n    Bounds.update(bounds, body.vertices, body.velocity); // allow options to override the automatically calculated properties\n\n    Body.set(body, {\n      axes: options.axes || body.axes,\n      area: options.area || body.area,\n      mass: options.mass || body.mass,\n      inertia: options.inertia || body.inertia\n    });\n\n    if (body.parts.length === 1) {\n      var centerOfMass = body.centerOfMass;\n      var centerOffset = body.centerOffset;\n      var bodyWidth = bounds.max.x - bounds.min.x;\n      var bodyHeight = bounds.max.y - bounds.min.y;\n      centerOfMass.x = -(bounds.min.x - body.position.x) / bodyWidth;\n      centerOfMass.y = -(bounds.min.y - body.position.y) / bodyHeight;\n      centerOffset.x = bodyWidth * centerOfMass.x;\n      centerOffset.y = bodyHeight * centerOfMass.y;\n    }\n  };\n  /**\r\n   * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.\r\n   * Prefer to use the actual setter functions in performance critical situations.\r\n   * @method set\r\n   * @param {body} body\r\n   * @param {} settings A property name (or map of properties and values) to set on the body.\r\n   * @param {} value The value to set if `settings` is a single property name.\r\n   */\n\n\n  Body.set = function (body, settings, value) {\n    var property;\n\n    if (typeof settings === 'string') {\n      property = settings;\n      settings = {};\n      settings[property] = value;\n    }\n\n    for (property in settings) {\n      if (!Object.prototype.hasOwnProperty.call(settings, property)) continue;\n      value = settings[property];\n\n      switch (property) {\n        case 'isStatic':\n          Body.setStatic(body, value);\n          break;\n\n        case 'isSleeping':\n          Sleeping.set(body, value);\n          break;\n\n        case 'mass':\n          Body.setMass(body, value);\n          break;\n\n        case 'density':\n          Body.setDensity(body, value);\n          break;\n\n        case 'inertia':\n          Body.setInertia(body, value);\n          break;\n\n        case 'vertices':\n          Body.setVertices(body, value);\n          break;\n\n        case 'position':\n          Body.setPosition(body, value);\n          break;\n\n        case 'angle':\n          Body.setAngle(body, value);\n          break;\n\n        case 'velocity':\n          Body.setVelocity(body, value);\n          break;\n\n        case 'angularVelocity':\n          Body.setAngularVelocity(body, value);\n          break;\n\n        case 'parts':\n          Body.setParts(body, value);\n          break;\n\n        case 'centre':\n          Body.setCentre(body, value);\n          break;\n\n        default:\n          body[property] = value;\n      }\n    }\n  };\n  /**\r\n   * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.\r\n   * @method setStatic\r\n   * @param {body} body\r\n   * @param {bool} isStatic\r\n   */\n\n\n  Body.setStatic = function (body, isStatic) {\n    for (var i = 0; i < body.parts.length; i++) {\n      var part = body.parts[i];\n      part.isStatic = isStatic;\n\n      if (isStatic) {\n        part._original = {\n          restitution: part.restitution,\n          friction: part.friction,\n          mass: part.mass,\n          inertia: part.inertia,\n          density: part.density,\n          inverseMass: part.inverseMass,\n          inverseInertia: part.inverseInertia\n        };\n        part.restitution = 0;\n        part.friction = 1;\n        part.mass = part.inertia = part.density = Infinity;\n        part.inverseMass = part.inverseInertia = 0;\n        part.positionPrev.x = part.position.x;\n        part.positionPrev.y = part.position.y;\n        part.anglePrev = part.angle;\n        part.angularVelocity = 0;\n        part.speed = 0;\n        part.angularSpeed = 0;\n        part.motion = 0;\n      } else if (part._original) {\n        part.restitution = part._original.restitution;\n        part.friction = part._original.friction;\n        part.mass = part._original.mass;\n        part.inertia = part._original.inertia;\n        part.density = part._original.density;\n        part.inverseMass = part._original.inverseMass;\n        part.inverseInertia = part._original.inverseInertia;\n        part._original = null;\n      }\n    }\n  };\n  /**\r\n   * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.\r\n   * @method setMass\r\n   * @param {body} body\r\n   * @param {number} mass\r\n   */\n\n\n  Body.setMass = function (body, mass) {\n    var moment = body.inertia / (body.mass / 6);\n    body.inertia = moment * (mass / 6);\n    body.inverseInertia = 1 / body.inertia;\n    body.mass = mass;\n    body.inverseMass = 1 / body.mass;\n    body.density = body.mass / body.area;\n  };\n  /**\r\n   * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.\r\n   * @method setDensity\r\n   * @param {body} body\r\n   * @param {number} density\r\n   */\n\n\n  Body.setDensity = function (body, density) {\n    Body.setMass(body, density * body.area);\n    body.density = density;\n  };\n  /**\r\n   * Sets the moment of inertia (i.e. second moment of area) of the body. \r\n   * Inverse inertia is automatically updated to reflect the change. Mass is not changed.\r\n   * @method setInertia\r\n   * @param {body} body\r\n   * @param {number} inertia\r\n   */\n\n\n  Body.setInertia = function (body, inertia) {\n    body.inertia = inertia;\n    body.inverseInertia = 1 / body.inertia;\n  };\n  /**\r\n   * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).\r\n   * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.\r\n   * They are then automatically translated to world space based on `body.position`.\r\n   *\r\n   * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).\r\n   * Vertices must form a convex hull, concave hulls are not supported.\r\n   *\r\n   * @method setVertices\r\n   * @param {body} body\r\n   * @param {vector[]} vertices\r\n   */\n\n\n  Body.setVertices = function (body, vertices) {\n    // change vertices\n    if (vertices[0].body === body) {\n      body.vertices = vertices;\n    } else {\n      body.vertices = Vertices.create(vertices, body);\n    } // update properties\n\n\n    body.axes = Axes.fromVertices(body.vertices);\n    body.area = Vertices.area(body.vertices);\n    Body.setMass(body, body.density * body.area); // orient vertices around the centre of mass at origin (0, 0)\n\n    var centre = Vertices.centre(body.vertices);\n    Vertices.translate(body.vertices, centre, -1); // update inertia while vertices are at origin (0, 0)\n\n    Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass)); // update geometry\n\n    Vertices.translate(body.vertices, body.position);\n    Bounds.update(body.bounds, body.vertices, body.velocity);\n  };\n  /**\r\n   * Sets the parts of the `body` and updates mass, inertia and centroid.\r\n   * Each part will have its parent set to `body`.\r\n   * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`\r\n   * Note that this method will ensure that the first part in `body.parts` will always be the `body`.\r\n   * @method setParts\r\n   * @param {body} body\r\n   * @param [body] parts\r\n   * @param {bool} [autoHull=true]\r\n   */\n\n\n  Body.setParts = function (body, parts, autoHull) {\n    var i; // add all the parts, ensuring that the first part is always the parent body\n\n    parts = parts.slice(0);\n    body.parts.length = 0;\n    body.parts.push(body);\n    body.parent = body;\n\n    for (i = 0; i < parts.length; i++) {\n      var part = parts[i];\n\n      if (part !== body) {\n        part.parent = body;\n        body.parts.push(part);\n      }\n    }\n\n    if (body.parts.length === 1) return;\n    autoHull = typeof autoHull !== 'undefined' ? autoHull : true; // find the convex hull of all parts to set on the parent body\n\n    if (autoHull) {\n      var vertices = [];\n\n      for (i = 0; i < parts.length; i++) {\n        vertices = vertices.concat(parts[i].vertices);\n      }\n\n      Vertices.clockwiseSort(vertices);\n      var hull = Vertices.hull(vertices),\n          hullCentre = Vertices.centre(hull);\n      Body.setVertices(body, hull);\n      Vertices.translate(body.vertices, hullCentre);\n    } // sum the properties of all compound parts of the parent body\n\n\n    var total = Body._totalProperties(body); //  Phaser addition\n\n\n    var cx = total.centre.x;\n    var cy = total.centre.y;\n    var bounds = body.bounds;\n    var centerOfMass = body.centerOfMass;\n    var centerOffset = body.centerOffset;\n    Bounds.update(bounds, body.vertices, body.velocity);\n    centerOfMass.x = -(bounds.min.x - cx) / (bounds.max.x - bounds.min.x);\n    centerOfMass.y = -(bounds.min.y - cy) / (bounds.max.y - bounds.min.y);\n    centerOffset.x = cx;\n    centerOffset.y = cy;\n    body.area = total.area;\n    body.parent = body;\n    body.position.x = cx;\n    body.position.y = cy;\n    body.positionPrev.x = cx;\n    body.positionPrev.y = cy;\n    Body.setMass(body, total.mass);\n    Body.setInertia(body, total.inertia);\n    Body.setPosition(body, total.centre);\n  };\n  /**\r\n   * Set the centre of mass of the body. \r\n   * The `centre` is a vector in world-space unless `relative` is set, in which case it is a translation.\r\n   * The centre of mass is the point the body rotates about and can be used to simulate non-uniform density.\r\n   * This is equal to moving `body.position` but not the `body.vertices`.\r\n   * Invalid if the `centre` falls outside the body's convex hull.\r\n   * @method setCentre\r\n   * @param {body} body\r\n   * @param {vector} centre\r\n   * @param {bool} relative\r\n   */\n\n\n  Body.setCentre = function (body, centre, relative) {\n    if (!relative) {\n      body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);\n      body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);\n      body.position.x = centre.x;\n      body.position.y = centre.y;\n    } else {\n      body.positionPrev.x += centre.x;\n      body.positionPrev.y += centre.y;\n      body.position.x += centre.x;\n      body.position.y += centre.y;\n    }\n  };\n  /**\r\n   * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.\r\n   * @method setPosition\r\n   * @param {body} body\r\n   * @param {vector} position\r\n   */\n\n\n  Body.setPosition = function (body, position) {\n    var delta = Vector.sub(position, body.position);\n    body.positionPrev.x += delta.x;\n    body.positionPrev.y += delta.y;\n\n    for (var i = 0; i < body.parts.length; i++) {\n      var part = body.parts[i];\n      part.position.x += delta.x;\n      part.position.y += delta.y;\n      Vertices.translate(part.vertices, delta);\n      Bounds.update(part.bounds, part.vertices, body.velocity);\n    }\n  };\n  /**\r\n   * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.\r\n   * @method setAngle\r\n   * @param {body} body\r\n   * @param {number} angle\r\n   */\n\n\n  Body.setAngle = function (body, angle) {\n    var delta = angle - body.angle;\n    body.anglePrev += delta;\n\n    for (var i = 0; i < body.parts.length; i++) {\n      var part = body.parts[i];\n      part.angle += delta;\n      Vertices.rotate(part.vertices, delta, body.position);\n      Axes.rotate(part.axes, delta);\n      Bounds.update(part.bounds, part.vertices, body.velocity);\n\n      if (i > 0) {\n        Vector.rotateAbout(part.position, delta, body.position, part.position);\n      }\n    }\n  };\n  /**\r\n   * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.\r\n   * @method setVelocity\r\n   * @param {body} body\r\n   * @param {vector} velocity\r\n   */\n\n\n  Body.setVelocity = function (body, velocity) {\n    body.positionPrev.x = body.position.x - velocity.x;\n    body.positionPrev.y = body.position.y - velocity.y;\n    body.velocity.x = velocity.x;\n    body.velocity.y = velocity.y;\n    body.speed = Vector.magnitude(body.velocity);\n  };\n  /**\r\n   * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.\r\n   * @method setAngularVelocity\r\n   * @param {body} body\r\n   * @param {number} velocity\r\n   */\n\n\n  Body.setAngularVelocity = function (body, velocity) {\n    body.anglePrev = body.angle - velocity;\n    body.angularVelocity = velocity;\n    body.angularSpeed = Math.abs(body.angularVelocity);\n  };\n  /**\r\n   * Moves a body by a given vector relative to its current position, without imparting any velocity.\r\n   * @method translate\r\n   * @param {body} body\r\n   * @param {vector} translation\r\n   */\n\n\n  Body.translate = function (body, translation) {\n    Body.setPosition(body, Vector.add(body.position, translation));\n  };\n  /**\r\n   * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.\r\n   * @method rotate\r\n   * @param {body} body\r\n   * @param {number} rotation\r\n   * @param {vector} [point]\r\n   */\n\n\n  Body.rotate = function (body, rotation, point) {\n    if (!point) {\n      Body.setAngle(body, body.angle + rotation);\n    } else {\n      var cos = Math.cos(rotation),\n          sin = Math.sin(rotation),\n          dx = body.position.x - point.x,\n          dy = body.position.y - point.y;\n      Body.setPosition(body, {\n        x: point.x + (dx * cos - dy * sin),\n        y: point.y + (dx * sin + dy * cos)\n      });\n      Body.setAngle(body, body.angle + rotation);\n    }\n  };\n  /**\r\n   * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).\r\n   * @method scale\r\n   * @param {body} body\r\n   * @param {number} scaleX\r\n   * @param {number} scaleY\r\n   * @param {vector} [point]\r\n   */\n\n\n  Body.scale = function (body, scaleX, scaleY, point) {\n    var totalArea = 0,\n        totalInertia = 0;\n    point = point || body.position;\n\n    for (var i = 0; i < body.parts.length; i++) {\n      var part = body.parts[i];\n      part.scale.x = scaleX;\n      part.scale.y = scaleY; // scale vertices\n\n      Vertices.scale(part.vertices, scaleX, scaleY, point); // update properties\n\n      part.axes = Axes.fromVertices(part.vertices);\n      part.area = Vertices.area(part.vertices);\n      Body.setMass(part, body.density * part.area); // update inertia (requires vertices to be at origin)\n\n      Vertices.translate(part.vertices, {\n        x: -part.position.x,\n        y: -part.position.y\n      });\n      Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));\n      Vertices.translate(part.vertices, {\n        x: part.position.x,\n        y: part.position.y\n      });\n\n      if (i > 0) {\n        totalArea += part.area;\n        totalInertia += part.inertia;\n      } // scale position\n\n\n      part.position.x = point.x + (part.position.x - point.x) * scaleX;\n      part.position.y = point.y + (part.position.y - point.y) * scaleY; // update bounds\n\n      Bounds.update(part.bounds, part.vertices, body.velocity);\n    } // handle parent body\n\n\n    if (body.parts.length > 1) {\n      body.area = totalArea;\n\n      if (!body.isStatic) {\n        Body.setMass(body, body.density * totalArea);\n        Body.setInertia(body, totalInertia);\n      }\n    } // handle circles\n\n\n    if (body.circleRadius) {\n      if (scaleX === scaleY) {\n        body.circleRadius *= scaleX;\n      } else {\n        // body is no longer a circle\n        body.circleRadius = null;\n      }\n    }\n  };\n  /**\r\n   * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.\r\n   * @method update\r\n   * @param {body} body\r\n   * @param {number} deltaTime\r\n   * @param {number} timeScale\r\n   * @param {number} correction\r\n   */\n\n\n  Body.update = function (body, deltaTime, timeScale, correction) {\n    var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2); // from the previous step\n\n    var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale,\n        velocityPrevX = body.position.x - body.positionPrev.x,\n        velocityPrevY = body.position.y - body.positionPrev.y; // update velocity with Verlet integration\n\n    body.velocity.x = velocityPrevX * frictionAir * correction + body.force.x / body.mass * deltaTimeSquared;\n    body.velocity.y = velocityPrevY * frictionAir * correction + body.force.y / body.mass * deltaTimeSquared;\n    body.positionPrev.x = body.position.x;\n    body.positionPrev.y = body.position.y;\n    body.position.x += body.velocity.x;\n    body.position.y += body.velocity.y; // update angular velocity with Verlet integration\n\n    body.angularVelocity = (body.angle - body.anglePrev) * frictionAir * correction + body.torque / body.inertia * deltaTimeSquared;\n    body.anglePrev = body.angle;\n    body.angle += body.angularVelocity; // track speed and acceleration\n\n    body.speed = Vector.magnitude(body.velocity);\n    body.angularSpeed = Math.abs(body.angularVelocity); // transform the body geometry\n\n    for (var i = 0; i < body.parts.length; i++) {\n      var part = body.parts[i];\n      Vertices.translate(part.vertices, body.velocity);\n\n      if (i > 0) {\n        part.position.x += body.velocity.x;\n        part.position.y += body.velocity.y;\n      }\n\n      if (body.angularVelocity !== 0) {\n        Vertices.rotate(part.vertices, body.angularVelocity, body.position);\n        Axes.rotate(part.axes, body.angularVelocity);\n\n        if (i > 0) {\n          Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);\n        }\n      }\n\n      Bounds.update(part.bounds, part.vertices, body.velocity);\n    }\n  };\n  /**\r\n   * Applies a force to a body from a given world-space position, including resulting torque.\r\n   * @method applyForce\r\n   * @param {body} body\r\n   * @param {vector} position\r\n   * @param {vector} force\r\n   */\n\n\n  Body.applyForce = function (body, position, force) {\n    body.force.x += force.x;\n    body.force.y += force.y;\n    var offset = {\n      x: position.x - body.position.x,\n      y: position.y - body.position.y\n    };\n    body.torque += offset.x * force.y - offset.y * force.x;\n  };\n  /**\r\n   * Returns the sums of the properties of all compound parts of the parent body.\r\n   * @method _totalProperties\r\n   * @private\r\n   * @param {body} body\r\n   * @return {}\r\n   */\n\n\n  Body._totalProperties = function (body) {\n    // from equations at:\n    // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory\n    // http://output.to/sideway/default.asp?qno=121100087\n    var properties = {\n      mass: 0,\n      area: 0,\n      inertia: 0,\n      centre: {\n        x: 0,\n        y: 0\n      }\n    }; // sum the properties of all compound parts of the parent body\n\n    for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {\n      var part = body.parts[i],\n          mass = part.mass !== Infinity ? part.mass : 1;\n      properties.mass += mass;\n      properties.area += part.area;\n      properties.inertia += part.inertia;\n      properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));\n    }\n\n    properties.centre = Vector.div(properties.centre, properties.mass);\n    return properties;\n  };\n  /*\r\n  *\r\n  *  Events Documentation\r\n  *\r\n  */\n\n  /**\r\n  * Fired when a body starts sleeping (where `this` is the body).\r\n  *\r\n  * @event sleepStart\r\n  * @this {body} The body that has started sleeping\r\n  * @param {} event An event object\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /**\r\n  * Fired when a body ends sleeping (where `this` is the body).\r\n  *\r\n  * @event sleepEnd\r\n  * @this {body} The body that has ended sleeping\r\n  * @param {} event An event object\r\n  * @param {} event.source The source object of the event\r\n  * @param {} event.name The name of the event\r\n  */\n\n  /*\r\n  *\r\n  *  Properties Documentation\r\n  *\r\n  */\n\n  /**\r\n   * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.\r\n   *\r\n   * @property id\r\n   * @type number\r\n   */\n\n  /**\r\n   * A `String` denoting the type of object.\r\n   *\r\n   * @property type\r\n   * @type string\r\n   * @default \"body\"\r\n   * @readOnly\r\n   */\n\n  /**\r\n   * An arbitrary `String` name to help the user identify and manage bodies.\r\n   *\r\n   * @property label\r\n   * @type string\r\n   * @default \"Body\"\r\n   */\n\n  /**\r\n   * An array of bodies that make up this body. \r\n   * The first body in the array must always be a self reference to the current body instance.\r\n   * All bodies in the `parts` array together form a single rigid compound body.\r\n   * Parts are allowed to overlap, have gaps or holes or even form concave bodies.\r\n   * Parts themselves should never be added to a `World`, only the parent body should be.\r\n   * Use `Body.setParts` when setting parts to ensure correct updates of all properties.\r\n   *\r\n   * @property parts\r\n   * @type body[]\r\n   */\n\n  /**\r\n   * An object reserved for storing plugin-specific properties.\r\n   *\r\n   * @property plugin\r\n   * @type {}\r\n   */\n\n  /**\r\n   * A self reference if the body is _not_ a part of another body.\r\n   * Otherwise this is a reference to the body that this is a part of.\r\n   * See `body.parts`.\r\n   *\r\n   * @property parent\r\n   * @type body\r\n   */\n\n  /**\r\n   * A `Number` specifying the angle of the body, in radians.\r\n   *\r\n   * @property angle\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * An array of `Vector` objects that specify the convex hull of the rigid body.\r\n   * These should be provided about the origin `(0, 0)`. E.g.\r\n   *\r\n   *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\r\n   *\r\n   * When passed via `Body.create`, the vertices are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).\r\n   * The `Vector` objects are also augmented with additional properties required for efficient collision detection. \r\n   *\r\n   * Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).\r\n   * Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.\r\n   *\r\n   * @property vertices\r\n   * @type vector[]\r\n   */\n\n  /**\r\n   * A `Vector` that specifies the current world-space position of the body.\r\n   *\r\n   * @property position\r\n   * @type vector\r\n   * @default { x: 0, y: 0 }\r\n   */\n\n  /**\r\n   * A `Vector` that holds the current scale values as set by `Body.setScale`.\r\n   *\r\n   * @property scale\r\n   * @type vector\r\n   * @default { x: 1, y: 1 }\r\n   */\n\n  /**\r\n   * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.\r\n   *\r\n   * @property force\r\n   * @type vector\r\n   * @default { x: 0, y: 0 }\r\n   */\n\n  /**\r\n   * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.\r\n   *\r\n   * @property torque\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`).\r\n   *\r\n   * @readOnly\r\n   * @property speed\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A `Number` that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.angularVelocity`).\r\n   *\r\n   * @readOnly\r\n   * @property angularSpeed\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only. \r\n   * If you need to modify a body's velocity directly, you should either apply a force or simply change the body's `position` (as the engine uses position-Verlet integration).\r\n   *\r\n   * @readOnly\r\n   * @property velocity\r\n   * @type vector\r\n   * @default { x: 0, y: 0 }\r\n   */\n\n  /**\r\n   * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only. \r\n   * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body's `angle` (as the engine uses position-Verlet integration).\r\n   *\r\n   * @readOnly\r\n   * @property angularVelocity\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.\r\n   * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.\r\n   *\r\n   * @property isStatic\r\n   * @type boolean\r\n   * @default false\r\n   */\n\n  /**\r\n   * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.\r\n   *\r\n   * @property isSensor\r\n   * @type boolean\r\n   * @default false\r\n   */\n\n  /**\r\n   * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.\r\n   * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.\r\n   *\r\n   * @property isSleeping\r\n   * @type boolean\r\n   * @default false\r\n   */\n\n  /**\r\n   * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`). It is read-only and always positive.\r\n   * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest.\r\n   *\r\n   * @readOnly\r\n   * @property motion\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).\r\n   *\r\n   * @property sleepThreshold\r\n   * @type number\r\n   * @default 60\r\n   */\n\n  /**\r\n   * A `Number` that defines the density of the body, that is its mass per unit area.\r\n   * If you pass the density via `Body.create` the `mass` property is automatically calculated for you based on the size (area) of the object.\r\n   * This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).\r\n   *\r\n   * @property density\r\n   * @type number\r\n   * @default 0.001\r\n   */\n\n  /**\r\n   * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead.\r\n   * If you modify this value, you must also modify the `body.inverseMass` property (`1 / mass`).\r\n   *\r\n   * @property mass\r\n   * @type number\r\n   */\n\n  /**\r\n   * A `Number` that defines the inverse mass of the body (`1 / mass`).\r\n   * If you modify this value, you must also modify the `body.mass` property.\r\n   *\r\n   * @property inverseMass\r\n   * @type number\r\n   */\n\n  /**\r\n   * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body.\r\n   * It is automatically calculated from the given convex hull (`vertices` array) and density in `Body.create`.\r\n   * If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`).\r\n   *\r\n   * @property inertia\r\n   * @type number\r\n   */\n\n  /**\r\n   * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).\r\n   * If you modify this value, you must also modify the `body.inertia` property.\r\n   *\r\n   * @property inverseInertia\r\n   * @type number\r\n   */\n\n  /**\r\n   * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.\r\n   * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. \r\n   * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.\r\n   * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:\r\n   *\r\n   *     Math.max(bodyA.restitution, bodyB.restitution)\r\n   *\r\n   * @property restitution\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.\r\n   * A value of `0` means that the body may slide indefinitely.\r\n   * A value of `1` means the body may come to a stop almost instantly after a force is applied.\r\n   *\r\n   * The effects of the value may be non-linear. \r\n   * High values may be unstable depending on the body.\r\n   * The engine uses a Coulomb friction model including static and kinetic friction.\r\n   * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:\r\n   *\r\n   *     Math.min(bodyA.friction, bodyB.friction)\r\n   *\r\n   * @property friction\r\n   * @type number\r\n   * @default 0.1\r\n   */\n\n  /**\r\n   * A `Number` that defines the static friction of the body (in the Coulomb friction model). \r\n   * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.\r\n   * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.\r\n   * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.\r\n   *\r\n   * @property frictionStatic\r\n   * @type number\r\n   * @default 0.5\r\n   */\n\n  /**\r\n   * A `Number` that defines the air friction of the body (air resistance). \r\n   * A value of `0` means the body will never slow as it moves through space.\r\n   * The higher the value, the faster a body slows when moving through space.\r\n   * The effects of the value are non-linear. \r\n   *\r\n   * @property frictionAir\r\n   * @type number\r\n   * @default 0.01\r\n   */\n\n  /**\r\n   * An `Object` that specifies the collision filtering properties of this body.\r\n   *\r\n   * Collisions between two bodies will obey the following rules:\r\n   * - If the two bodies have the same non-zero value of `collisionFilter.group`,\r\n   *   they will always collide if the value is positive, and they will never collide\r\n   *   if the value is negative.\r\n   * - If the two bodies have different values of `collisionFilter.group` or if one\r\n   *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:\r\n   *\r\n   * Each body belongs to a collision category, given by `collisionFilter.category`. This\r\n   * value is used as a bit field and the category should have only one bit set, meaning that\r\n   * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32\r\n   * different collision categories available.\r\n   *\r\n   * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies\r\n   * the categories it collides with (the value is the bitwise AND value of all these categories).\r\n   *\r\n   * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's\r\n   * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`\r\n   * are both true.\r\n   *\r\n   * @property collisionFilter\r\n   * @type object\r\n   */\n\n  /**\r\n   * An Integer `Number`, that specifies the collision group this body belongs to.\r\n   * See `body.collisionFilter` for more information.\r\n   *\r\n   * @property collisionFilter.group\r\n   * @type object\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A bit field that specifies the collision category this body belongs to.\r\n   * The category value should have only one bit set, for example `0x0001`.\r\n   * This means there are up to 32 unique collision categories available.\r\n   * See `body.collisionFilter` for more information.\r\n   *\r\n   * @property collisionFilter.category\r\n   * @type object\r\n   * @default 1\r\n   */\n\n  /**\r\n   * A bit mask that specifies the collision categories this body may collide with.\r\n   * See `body.collisionFilter` for more information.\r\n   *\r\n   * @property collisionFilter.mask\r\n   * @type object\r\n   * @default -1\r\n   */\n\n  /**\r\n   * A `Number` that specifies a tolerance on how far a body is allowed to 'sink' or rotate into other bodies.\r\n   * Avoid changing this value unless you understand the purpose of `slop` in physics engines.\r\n   * The default should generally suffice, although very large bodies may require larger values for stable stacking.\r\n   *\r\n   * @property slop\r\n   * @type number\r\n   * @default 0.05\r\n   */\n\n  /**\r\n   * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.\r\n   *\r\n   * @property timeScale\r\n   * @type number\r\n   * @default 1\r\n   */\n\n  /**\r\n   * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\r\n   *\r\n   * @property render\r\n   * @type object\r\n   */\n\n  /**\r\n   * A flag that indicates if the body should be rendered.\r\n   *\r\n   * @property render.visible\r\n   * @type boolean\r\n   * @default true\r\n   */\n\n  /**\r\n   * Sets the opacity to use when rendering.\r\n   *\r\n   * @property render.opacity\r\n   * @type number\r\n   * @default 1\r\n  */\n\n  /**\r\n   * An `Object` that defines the sprite properties to use when rendering, if any.\r\n   *\r\n   * @property render.sprite\r\n   * @type object\r\n   */\n\n  /**\r\n   * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).\r\n   *\r\n   * @property render.sprite.xOffset\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).\r\n   *\r\n   * @property render.sprite.yOffset\r\n   * @type number\r\n   * @default 0\r\n   */\n\n  /**\r\n   * A hex color value that defines the fill color to use when rendering the body.\r\n   *\r\n   * @property render.fillColor\r\n   * @type number\r\n   */\n\n  /**\r\n   * A value that defines the fill opacity to use when rendering the body.\r\n   *\r\n   * @property render.fillOpacity\r\n   * @type number\r\n   */\n\n  /**\r\n  * A hex color value that defines the line color to use when rendering the body.\r\n  *\r\n  * @property render.lineColor\r\n  * @type number\r\n  */\n\n  /**\r\n   * A value that defines the line opacity to use when rendering the body.\r\n   *\r\n   * @property render.lineOpacity\r\n   * @type number\r\n   */\n\n  /**\r\n  * A `Number` that defines the line width to use when rendering the body outline.\r\n  *\r\n  * @property render.lineThickness\r\n  * @type number\r\n  */\n\n  /**\r\n   * An array of unique axis vectors (edge normals) used for collision detection.\r\n   * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.\r\n   * They are constantly updated by `Body.update` during the simulation.\r\n   *\r\n   * @property axes\r\n   * @type vector[]\r\n   */\n\n  /**\r\n   * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`.\r\n   *\r\n   * @property area\r\n   * @type string\r\n   * @default \r\n   */\n\n  /**\r\n   * A `Bounds` object that defines the AABB region for the body.\r\n   * It is automatically calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation.\r\n   *\r\n   * @property bounds\r\n   * @type bounds\r\n   */\n\n  /**\r\n   * A reference to the Phaser Game Object this body belongs to, if any.\r\n   *\r\n   * @property gameObject\r\n   * @type Phaser.GameObjects.GameObject\r\n   */\n\n  /**\r\n   * The center of mass of the Body.\r\n   *\r\n   * @property centerOfMass\r\n   * @type vector\r\n   * @default { x: 0, y: 0 }\r\n   */\n\n  /**\r\n   * The center of the body in pixel values.\r\n   * Used by Phaser for texture aligment.\r\n   *\r\n   * @property centerOffset\r\n   * @type vector\r\n   * @default { x: 0, y: 0 }\r\n   */\n\n  /**\r\n   * Will this Body ignore World gravity during the Engine update?\r\n   *\r\n   * @property ignoreGravity\r\n   * @type boolean\r\n   * @default false\r\n   */\n\n  /**\r\n   * Scale the influence of World gravity when applied to this body.\r\n   *\r\n   * @property gravityScale\r\n   * @type vector\r\n   * @default { x: 1, y: 1 }\r\n   */\n\n  /**\r\n  * Will this Body ignore Phaser Pointer input events?\r\n  *\r\n  * @property ignorePointer\r\n  * @type boolean\r\n  * @default false\r\n  */\n\n  /**\r\n   * A callback that is invoked when this Body starts colliding with any other Body.\r\n   * \r\n   * You can register callbacks by providing a function of type `( pair: Matter.Pair) => void`.\r\n   *\r\n   * @property onCollideCallback\r\n   * @type function\r\n   * @default null\r\n   */\n\n  /**\r\n   * A callback that is invoked when this Body stops colliding with any other Body.\r\n   * \r\n   * You can register callbacks by providing a function of type `( pair: Matter.Pair) => void`.\r\n   *\r\n   * @property onCollideEndCallback\r\n   * @type function\r\n   * @default null\r\n   */\n\n  /**\r\n   * A callback that is invoked for the duration that this Body is colliding with any other Body.\r\n   * \r\n   * You can register callbacks by providing a function of type `( pair: Matter.Pair) => void`.\r\n   *\r\n   * @property onCollideActiveCallback\r\n   * @type function\r\n   * @default null\r\n   */\n\n  /**\r\n   * A collision callback dictionary used by the `Body.setOnCollideWith` function.\r\n   *\r\n   * @property onCollideWith\r\n   * @type object\r\n   * @default null\r\n   */\n\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/lib/body/Body.js"],"names":["Body","module","exports","Vertices","require","Vector","Sleeping","Common","Bounds","Axes","_inertiaScale","_nextCollidingGroupId","_nextNonCollidingGroupId","_nextCategory","create","options","defaults","id","nextId","type","label","parts","plugin","angle","vertices","position","x","y","force","torque","positionImpulse","previousPositionImpulse","constraintImpulse","totalContacts","speed","angularSpeed","velocity","angularVelocity","isSensor","isStatic","isSleeping","motion","sleepThreshold","density","restitution","friction","frictionStatic","frictionAir","collisionFilter","category","mask","group","slop","timeScale","events","bounds","chamfer","circleRadius","positionPrev","anglePrev","parent","axes","area","mass","inverseMass","inertia","inverseInertia","_original","render","visible","opacity","sprite","xOffset","yOffset","fillColor","fillOpacity","lineColor","lineOpacity","lineThickness","gameObject","scale","centerOfMass","centerOffset","gravityScale","ignoreGravity","ignorePointer","onCollideCallback","onCollideEndCallback","onCollideActiveCallback","onCollideWith","hasOwnProperty","centre","fromPath","body","extend","_initProperties","setOnCollideWith","callback","nextGroup","isNonColliding","nextCategory","set","clone","rotate","update","length","bodyWidth","max","min","bodyHeight","settings","value","property","Object","prototype","call","setStatic","setMass","setDensity","setInertia","setVertices","setPosition","setAngle","setVelocity","setAngularVelocity","setParts","setCentre","i","part","Infinity","moment","fromVertices","translate","autoHull","slice","push","concat","clockwiseSort","hull","hullCentre","total","_totalProperties","cx","cy","relative","delta","sub","rotateAbout","magnitude","Math","abs","translation","add","rotation","point","cos","sin","dx","dy","scaleX","scaleY","totalArea","totalInertia","deltaTime","correction","deltaTimeSquared","pow","velocityPrevX","velocityPrevY","applyForce","offset","properties","mult","div"],"mappings":"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","sourcesContent":["/**\r\n * The `Matter.Body` module contains methods for creating and manipulating body models.\r\n * A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.\r\n * Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.\r\n *\r\n * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n * @class Body\r\n */\r\n\r\nvar Body = {};\r\n\r\nmodule.exports = Body;\r\n\r\nvar Vertices = require('../geometry/Vertices');\r\nvar Vector = require('../geometry/Vector');\r\nvar Sleeping = require('../core/Sleeping');\r\nvar Common = require('../core/Common');\r\nvar Bounds = require('../geometry/Bounds');\r\nvar Axes = require('../geometry/Axes');\r\n\r\n(function() {\r\n\r\n    Body._inertiaScale = 4;\r\n    Body._nextCollidingGroupId = 1;\r\n    Body._nextNonCollidingGroupId = -1;\r\n    Body._nextCategory = 0x0001;\r\n\r\n    /**\r\n     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\r\n     * Vertices must be specified in clockwise order.\r\n     * See the properties section below for detailed information on what you can pass via the `options` object.\r\n     * @method create\r\n     * @param {} options\r\n     * @return {body} body\r\n     */\r\n    Body.create = function(options) {\r\n        var defaults = {\r\n            id: Common.nextId(),\r\n            type: 'body',\r\n            label: 'Body',\r\n            parts: [],\r\n            plugin: {},\r\n            angle: 0,\r\n            vertices: null, // Phaser change: no point calling fromPath if they pass in vertices anyway\r\n            position: { x: 0, y: 0 },\r\n            force: { x: 0, y: 0 },\r\n            torque: 0,\r\n            positionImpulse: { x: 0, y: 0 },\r\n            previousPositionImpulse: { x: 0, y: 0 },\r\n            constraintImpulse: { x: 0, y: 0, angle: 0 },\r\n            totalContacts: 0,\r\n            speed: 0,\r\n            angularSpeed: 0,\r\n            velocity: { x: 0, y: 0 },\r\n            angularVelocity: 0,\r\n            isSensor: false,\r\n            isStatic: false,\r\n            isSleeping: false,\r\n            motion: 0,\r\n            sleepThreshold: 60,\r\n            density: 0.001,\r\n            restitution: 0,\r\n            friction: 0.1,\r\n            frictionStatic: 0.5,\r\n            frictionAir: 0.01,\r\n            collisionFilter: {\r\n                category: 0x0001,\r\n                mask: 0xFFFFFFFF,\r\n                group: 0\r\n            },\r\n            slop: 0.05,\r\n            timeScale: 1,\r\n            events: null,\r\n            bounds: null,\r\n            chamfer: null,\r\n            circleRadius: 0,\r\n            positionPrev: null,\r\n            anglePrev: 0,\r\n            parent: null,\r\n            axes: null,\r\n            area: 0,\r\n            mass: 0,\r\n            inverseMass: 0,\r\n            inertia: 0,\r\n            inverseInertia: 0,\r\n            _original: null,\r\n            render: {\r\n                visible: true,\r\n                opacity: 1,\r\n                sprite: {\r\n                    xOffset: 0,\r\n                    yOffset: 0\r\n                },\r\n                fillColor: null,            // custom Phaser property\r\n                fillOpacity: null,          // custom Phaser property\r\n                lineColor: null,            // custom Phaser property\r\n                lineOpacity: null,          // custom Phaser property\r\n                lineThickness: null         // custom Phaser property\r\n            },\r\n            gameObject: null,               // custom Phaser property\r\n            scale: { x: 1, y: 1 },          // custom Phaser property\r\n            centerOfMass: { x: 0, y: 0 },   // custom Phaser property (float, 0 - 1)\r\n            centerOffset: { x: 0, y: 0 },   // custom Phaser property (pixel values)\r\n            gravityScale: { x: 1, y: 1 },   // custom Phaser property\r\n            ignoreGravity: false,           // custom Phaser property\r\n            ignorePointer: false,           // custom Phaser property\r\n            onCollideCallback: null,        // custom Phaser property\r\n            onCollideEndCallback: null,     // custom Phaser property\r\n            onCollideActiveCallback: null,  // custom Phaser property\r\n            onCollideWith: {}               // custom Phaser property\r\n        };\r\n\r\n        if (!options.hasOwnProperty('position') && options.hasOwnProperty('vertices'))\r\n        {\r\n            options.position = Vertices.centre(options.vertices);\r\n        }\r\n        else if (!options.hasOwnProperty('vertices'))\r\n        {\r\n            defaults.vertices = Vertices.fromPath('L 0 0 L 40 0 L 40 40 L 0 40');\r\n        }\r\n\r\n        var body = Common.extend(defaults, options);\r\n\r\n        _initProperties(body, options);\r\n\r\n        //  Helper function\r\n        body.setOnCollideWith = function (body, callback)\r\n        {\r\n            if (callback)\r\n            {\r\n                this.onCollideWith[body.id] = callback;\r\n            }\r\n            else\r\n            {\r\n                delete this.onCollideWith[body.id];\r\n            }\r\n\r\n            return this;\r\n        }\r\n\r\n        return body;\r\n    };\r\n\r\n    /**\r\n     * Returns the next unique group index for which bodies will collide.\r\n     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.\r\n     * See `body.collisionFilter` for more information.\r\n     * @method nextGroup\r\n     * @param {bool} [isNonColliding=false]\r\n     * @return {Number} Unique group index\r\n     */\r\n    Body.nextGroup = function(isNonColliding) {\r\n        if (isNonColliding)\r\n            return Body._nextNonCollidingGroupId--;\r\n\r\n        return Body._nextCollidingGroupId++;\r\n    };\r\n\r\n    /**\r\n     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).\r\n     * There are 32 available. See `body.collisionFilter` for more information.\r\n     * @method nextCategory\r\n     * @return {Number} Unique category bitfield\r\n     */\r\n    Body.nextCategory = function() {\r\n        Body._nextCategory = Body._nextCategory << 1;\r\n        return Body._nextCategory;\r\n    };\r\n\r\n    /**\r\n     * Initialises body properties.\r\n     * @method _initProperties\r\n     * @private\r\n     * @param {body} body\r\n     * @param {} [options]\r\n     */\r\n    var _initProperties = function(body, options) {\r\n        options = options || {};\r\n\r\n        // init required properties (order is important)\r\n        Body.set(body, {\r\n            bounds: body.bounds || Bounds.create(body.vertices),\r\n            positionPrev: body.positionPrev || Vector.clone(body.position),\r\n            anglePrev: body.anglePrev || body.angle,\r\n            vertices: body.vertices,\r\n            parts: body.parts || [body],\r\n            isStatic: body.isStatic,\r\n            isSleeping: body.isSleeping,\r\n            parent: body.parent || body\r\n        });\r\n\r\n        var bounds = body.bounds;\r\n\r\n        Vertices.rotate(body.vertices, body.angle, body.position);\r\n        Axes.rotate(body.axes, body.angle);\r\n        Bounds.update(bounds, body.vertices, body.velocity);\r\n\r\n        // allow options to override the automatically calculated properties\r\n        Body.set(body, {\r\n            axes: options.axes || body.axes,\r\n            area: options.area || body.area,\r\n            mass: options.mass || body.mass,\r\n            inertia: options.inertia || body.inertia\r\n        });\r\n\r\n        if (body.parts.length === 1)\r\n        {\r\n            var centerOfMass = body.centerOfMass;\r\n            var centerOffset = body.centerOffset;\r\n    \r\n            var bodyWidth = bounds.max.x - bounds.min.x;\r\n            var bodyHeight = bounds.max.y - bounds.min.y;\r\n    \r\n            centerOfMass.x = -(bounds.min.x - body.position.x) / bodyWidth;\r\n            centerOfMass.y = -(bounds.min.y - body.position.y) / bodyHeight;\r\n    \r\n            centerOffset.x = bodyWidth * centerOfMass.x;\r\n            centerOffset.y = bodyHeight * centerOfMass.y;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.\r\n     * Prefer to use the actual setter functions in performance critical situations.\r\n     * @method set\r\n     * @param {body} body\r\n     * @param {} settings A property name (or map of properties and values) to set on the body.\r\n     * @param {} value The value to set if `settings` is a single property name.\r\n     */\r\n    Body.set = function(body, settings, value) {\r\n        var property;\r\n\r\n        if (typeof settings === 'string') {\r\n            property = settings;\r\n            settings = {};\r\n            settings[property] = value;\r\n        }\r\n\r\n        for (property in settings) {\r\n            if (!Object.prototype.hasOwnProperty.call(settings, property))\r\n                continue;\r\n\r\n            value = settings[property];\r\n            switch (property) {\r\n\r\n            case 'isStatic':\r\n                Body.setStatic(body, value);\r\n                break;\r\n            case 'isSleeping':\r\n                Sleeping.set(body, value);\r\n                break;\r\n            case 'mass':\r\n                Body.setMass(body, value);\r\n                break;\r\n            case 'density':\r\n                Body.setDensity(body, value);\r\n                break;\r\n            case 'inertia':\r\n                Body.setInertia(body, value);\r\n                break;\r\n            case 'vertices':\r\n                Body.setVertices(body, value);\r\n                break;\r\n            case 'position':\r\n                Body.setPosition(body, value);\r\n                break;\r\n            case 'angle':\r\n                Body.setAngle(body, value);\r\n                break;\r\n            case 'velocity':\r\n                Body.setVelocity(body, value);\r\n                break;\r\n            case 'angularVelocity':\r\n                Body.setAngularVelocity(body, value);\r\n                break;\r\n            case 'parts':\r\n                Body.setParts(body, value);\r\n                break;\r\n            case 'centre':\r\n                Body.setCentre(body, value);\r\n                break;\r\n            default:\r\n                body[property] = value;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.\r\n     * @method setStatic\r\n     * @param {body} body\r\n     * @param {bool} isStatic\r\n     */\r\n    Body.setStatic = function(body, isStatic) {\r\n        for (var i = 0; i < body.parts.length; i++) {\r\n            var part = body.parts[i];\r\n            part.isStatic = isStatic;\r\n\r\n            if (isStatic) {\r\n                part._original = {\r\n                    restitution: part.restitution,\r\n                    friction: part.friction,\r\n                    mass: part.mass,\r\n                    inertia: part.inertia,\r\n                    density: part.density,\r\n                    inverseMass: part.inverseMass,\r\n                    inverseInertia: part.inverseInertia\r\n                };\r\n\r\n                part.restitution = 0;\r\n                part.friction = 1;\r\n                part.mass = part.inertia = part.density = Infinity;\r\n                part.inverseMass = part.inverseInertia = 0;\r\n\r\n                part.positionPrev.x = part.position.x;\r\n                part.positionPrev.y = part.position.y;\r\n                part.anglePrev = part.angle;\r\n                part.angularVelocity = 0;\r\n                part.speed = 0;\r\n                part.angularSpeed = 0;\r\n                part.motion = 0;\r\n            } else if (part._original) {\r\n                part.restitution = part._original.restitution;\r\n                part.friction = part._original.friction;\r\n                part.mass = part._original.mass;\r\n                part.inertia = part._original.inertia;\r\n                part.density = part._original.density;\r\n                part.inverseMass = part._original.inverseMass;\r\n                part.inverseInertia = part._original.inverseInertia;\r\n\r\n                part._original = null;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.\r\n     * @method setMass\r\n     * @param {body} body\r\n     * @param {number} mass\r\n     */\r\n    Body.setMass = function(body, mass) {\r\n        var moment = body.inertia / (body.mass / 6);\r\n        body.inertia = moment * (mass / 6);\r\n        body.inverseInertia = 1 / body.inertia;\r\n\r\n        body.mass = mass;\r\n        body.inverseMass = 1 / body.mass;\r\n        body.density = body.mass / body.area;\r\n    };\r\n\r\n    /**\r\n     * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.\r\n     * @method setDensity\r\n     * @param {body} body\r\n     * @param {number} density\r\n     */\r\n    Body.setDensity = function(body, density) {\r\n        Body.setMass(body, density * body.area);\r\n        body.density = density;\r\n    };\r\n\r\n    /**\r\n     * Sets the moment of inertia (i.e. second moment of area) of the body. \r\n     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.\r\n     * @method setInertia\r\n     * @param {body} body\r\n     * @param {number} inertia\r\n     */\r\n    Body.setInertia = function(body, inertia) {\r\n        body.inertia = inertia;\r\n        body.inverseInertia = 1 / body.inertia;\r\n    };\r\n\r\n    /**\r\n     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).\r\n     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.\r\n     * They are then automatically translated to world space based on `body.position`.\r\n     *\r\n     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).\r\n     * Vertices must form a convex hull, concave hulls are not supported.\r\n     *\r\n     * @method setVertices\r\n     * @param {body} body\r\n     * @param {vector[]} vertices\r\n     */\r\n    Body.setVertices = function(body, vertices) {\r\n        // change vertices\r\n        if (vertices[0].body === body) {\r\n            body.vertices = vertices;\r\n        } else {\r\n            body.vertices = Vertices.create(vertices, body);\r\n        }\r\n\r\n        // update properties\r\n        body.axes = Axes.fromVertices(body.vertices);\r\n        body.area = Vertices.area(body.vertices);\r\n        Body.setMass(body, body.density * body.area);\r\n\r\n        // orient vertices around the centre of mass at origin (0, 0)\r\n        var centre = Vertices.centre(body.vertices);\r\n        Vertices.translate(body.vertices, centre, -1);\r\n\r\n        // update inertia while vertices are at origin (0, 0)\r\n        Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));\r\n\r\n        // update geometry\r\n        Vertices.translate(body.vertices, body.position);\r\n\r\n        Bounds.update(body.bounds, body.vertices, body.velocity);\r\n    };\r\n\r\n    /**\r\n     * Sets the parts of the `body` and updates mass, inertia and centroid.\r\n     * Each part will have its parent set to `body`.\r\n     * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`\r\n     * Note that this method will ensure that the first part in `body.parts` will always be the `body`.\r\n     * @method setParts\r\n     * @param {body} body\r\n     * @param [body] parts\r\n     * @param {bool} [autoHull=true]\r\n     */\r\n    Body.setParts = function(body, parts, autoHull) {\r\n        var i;\r\n\r\n        // add all the parts, ensuring that the first part is always the parent body\r\n        parts = parts.slice(0);\r\n        body.parts.length = 0;\r\n        body.parts.push(body);\r\n        body.parent = body;\r\n\r\n        for (i = 0; i < parts.length; i++) {\r\n            var part = parts[i];\r\n            if (part !== body) {\r\n                part.parent = body;\r\n                body.parts.push(part);\r\n            }\r\n        }\r\n\r\n        if (body.parts.length === 1)\r\n            return;\r\n\r\n        autoHull = typeof autoHull !== 'undefined' ? autoHull : true;\r\n\r\n        // find the convex hull of all parts to set on the parent body\r\n        if (autoHull) {\r\n            var vertices = [];\r\n            for (i = 0; i < parts.length; i++) {\r\n                vertices = vertices.concat(parts[i].vertices);\r\n            }\r\n\r\n            Vertices.clockwiseSort(vertices);\r\n\r\n            var hull = Vertices.hull(vertices),\r\n                hullCentre = Vertices.centre(hull);\r\n\r\n            Body.setVertices(body, hull);\r\n            Vertices.translate(body.vertices, hullCentre);\r\n        }\r\n\r\n        // sum the properties of all compound parts of the parent body\r\n        var total = Body._totalProperties(body);\r\n\r\n        //  Phaser addition\r\n        var cx = total.centre.x;\r\n        var cy = total.centre.y;\r\n\r\n        var bounds = body.bounds;\r\n        var centerOfMass = body.centerOfMass;\r\n        var centerOffset = body.centerOffset;\r\n\r\n        Bounds.update(bounds, body.vertices, body.velocity);\r\n\r\n        centerOfMass.x = -(bounds.min.x - cx) / (bounds.max.x - bounds.min.x);\r\n        centerOfMass.y = -(bounds.min.y - cy) / (bounds.max.y - bounds.min.y);\r\n\r\n        centerOffset.x = cx;\r\n        centerOffset.y = cy;\r\n\r\n        body.area = total.area;\r\n        body.parent = body;\r\n        body.position.x = cx;\r\n        body.position.y = cy;\r\n        body.positionPrev.x = cx;\r\n        body.positionPrev.y = cy;\r\n\r\n        Body.setMass(body, total.mass);\r\n        Body.setInertia(body, total.inertia);\r\n        Body.setPosition(body, total.centre);\r\n    };\r\n\r\n    /**\r\n     * Set the centre of mass of the body. \r\n     * The `centre` is a vector in world-space unless `relative` is set, in which case it is a translation.\r\n     * The centre of mass is the point the body rotates about and can be used to simulate non-uniform density.\r\n     * This is equal to moving `body.position` but not the `body.vertices`.\r\n     * Invalid if the `centre` falls outside the body's convex hull.\r\n     * @method setCentre\r\n     * @param {body} body\r\n     * @param {vector} centre\r\n     * @param {bool} relative\r\n     */\r\n    Body.setCentre = function(body, centre, relative) {\r\n        if (!relative) {\r\n            body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);\r\n            body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);\r\n            body.position.x = centre.x;\r\n            body.position.y = centre.y;\r\n        } else {\r\n            body.positionPrev.x += centre.x;\r\n            body.positionPrev.y += centre.y;\r\n            body.position.x += centre.x;\r\n            body.position.y += centre.y;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.\r\n     * @method setPosition\r\n     * @param {body} body\r\n     * @param {vector} position\r\n     */\r\n    Body.setPosition = function(body, position) {\r\n        var delta = Vector.sub(position, body.position);\r\n        body.positionPrev.x += delta.x;\r\n        body.positionPrev.y += delta.y;\r\n\r\n        for (var i = 0; i < body.parts.length; i++) {\r\n            var part = body.parts[i];\r\n            part.position.x += delta.x;\r\n            part.position.y += delta.y;\r\n            Vertices.translate(part.vertices, delta);\r\n            Bounds.update(part.bounds, part.vertices, body.velocity);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.\r\n     * @method setAngle\r\n     * @param {body} body\r\n     * @param {number} angle\r\n     */\r\n    Body.setAngle = function(body, angle) {\r\n        var delta = angle - body.angle;\r\n        body.anglePrev += delta;\r\n\r\n        for (var i = 0; i < body.parts.length; i++) {\r\n            var part = body.parts[i];\r\n            part.angle += delta;\r\n            Vertices.rotate(part.vertices, delta, body.position);\r\n            Axes.rotate(part.axes, delta);\r\n            Bounds.update(part.bounds, part.vertices, body.velocity);\r\n            if (i > 0) {\r\n                Vector.rotateAbout(part.position, delta, body.position, part.position);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.\r\n     * @method setVelocity\r\n     * @param {body} body\r\n     * @param {vector} velocity\r\n     */\r\n    Body.setVelocity = function(body, velocity) {\r\n        body.positionPrev.x = body.position.x - velocity.x;\r\n        body.positionPrev.y = body.position.y - velocity.y;\r\n        body.velocity.x = velocity.x;\r\n        body.velocity.y = velocity.y;\r\n        body.speed = Vector.magnitude(body.velocity);\r\n    };\r\n\r\n    /**\r\n     * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.\r\n     * @method setAngularVelocity\r\n     * @param {body} body\r\n     * @param {number} velocity\r\n     */\r\n    Body.setAngularVelocity = function(body, velocity) {\r\n        body.anglePrev = body.angle - velocity;\r\n        body.angularVelocity = velocity;\r\n        body.angularSpeed = Math.abs(body.angularVelocity);\r\n    };\r\n\r\n    /**\r\n     * Moves a body by a given vector relative to its current position, without imparting any velocity.\r\n     * @method translate\r\n     * @param {body} body\r\n     * @param {vector} translation\r\n     */\r\n    Body.translate = function(body, translation) {\r\n        Body.setPosition(body, Vector.add(body.position, translation));\r\n    };\r\n\r\n    /**\r\n     * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.\r\n     * @method rotate\r\n     * @param {body} body\r\n     * @param {number} rotation\r\n     * @param {vector} [point]\r\n     */\r\n    Body.rotate = function(body, rotation, point) {\r\n        if (!point) {\r\n            Body.setAngle(body, body.angle + rotation);\r\n        } else {\r\n            var cos = Math.cos(rotation),\r\n                sin = Math.sin(rotation),\r\n                dx = body.position.x - point.x,\r\n                dy = body.position.y - point.y;\r\n                \r\n            Body.setPosition(body, {\r\n                x: point.x + (dx * cos - dy * sin),\r\n                y: point.y + (dx * sin + dy * cos)\r\n            });\r\n\r\n            Body.setAngle(body, body.angle + rotation);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).\r\n     * @method scale\r\n     * @param {body} body\r\n     * @param {number} scaleX\r\n     * @param {number} scaleY\r\n     * @param {vector} [point]\r\n     */\r\n    Body.scale = function(body, scaleX, scaleY, point) {\r\n        var totalArea = 0,\r\n            totalInertia = 0;\r\n\r\n        point = point || body.position;\r\n\r\n        for (var i = 0; i < body.parts.length; i++) {\r\n            var part = body.parts[i];\r\n\r\n            part.scale.x = scaleX;\r\n            part.scale.y = scaleY;\r\n\r\n            // scale vertices\r\n            Vertices.scale(part.vertices, scaleX, scaleY, point);\r\n\r\n            // update properties\r\n            part.axes = Axes.fromVertices(part.vertices);\r\n            part.area = Vertices.area(part.vertices);\r\n            Body.setMass(part, body.density * part.area);\r\n\r\n            // update inertia (requires vertices to be at origin)\r\n            Vertices.translate(part.vertices, { x: -part.position.x, y: -part.position.y });\r\n            Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));\r\n            Vertices.translate(part.vertices, { x: part.position.x, y: part.position.y });\r\n\r\n            if (i > 0) {\r\n                totalArea += part.area;\r\n                totalInertia += part.inertia;\r\n            }\r\n\r\n            // scale position\r\n            part.position.x = point.x + (part.position.x - point.x) * scaleX;\r\n            part.position.y = point.y + (part.position.y - point.y) * scaleY;\r\n\r\n            // update bounds\r\n            Bounds.update(part.bounds, part.vertices, body.velocity);\r\n        }\r\n\r\n        // handle parent body\r\n        if (body.parts.length > 1) {\r\n            body.area = totalArea;\r\n\r\n            if (!body.isStatic) {\r\n                Body.setMass(body, body.density * totalArea);\r\n                Body.setInertia(body, totalInertia);\r\n            }\r\n        }\r\n\r\n        // handle circles\r\n        if (body.circleRadius) { \r\n            if (scaleX === scaleY) {\r\n                body.circleRadius *= scaleX;\r\n            } else {\r\n                // body is no longer a circle\r\n                body.circleRadius = null;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.\r\n     * @method update\r\n     * @param {body} body\r\n     * @param {number} deltaTime\r\n     * @param {number} timeScale\r\n     * @param {number} correction\r\n     */\r\n    Body.update = function(body, deltaTime, timeScale, correction) {\r\n        var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2);\r\n\r\n        // from the previous step\r\n        var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale,\r\n            velocityPrevX = body.position.x - body.positionPrev.x,\r\n            velocityPrevY = body.position.y - body.positionPrev.y;\r\n\r\n        // update velocity with Verlet integration\r\n        body.velocity.x = (velocityPrevX * frictionAir * correction) + (body.force.x / body.mass) * deltaTimeSquared;\r\n        body.velocity.y = (velocityPrevY * frictionAir * correction) + (body.force.y / body.mass) * deltaTimeSquared;\r\n\r\n        body.positionPrev.x = body.position.x;\r\n        body.positionPrev.y = body.position.y;\r\n        body.position.x += body.velocity.x;\r\n        body.position.y += body.velocity.y;\r\n\r\n        // update angular velocity with Verlet integration\r\n        body.angularVelocity = ((body.angle - body.anglePrev) * frictionAir * correction) + (body.torque / body.inertia) * deltaTimeSquared;\r\n        body.anglePrev = body.angle;\r\n        body.angle += body.angularVelocity;\r\n\r\n        // track speed and acceleration\r\n        body.speed = Vector.magnitude(body.velocity);\r\n        body.angularSpeed = Math.abs(body.angularVelocity);\r\n\r\n        // transform the body geometry\r\n        for (var i = 0; i < body.parts.length; i++) {\r\n            var part = body.parts[i];\r\n\r\n            Vertices.translate(part.vertices, body.velocity);\r\n            \r\n            if (i > 0) {\r\n                part.position.x += body.velocity.x;\r\n                part.position.y += body.velocity.y;\r\n            }\r\n\r\n            if (body.angularVelocity !== 0) {\r\n                Vertices.rotate(part.vertices, body.angularVelocity, body.position);\r\n                Axes.rotate(part.axes, body.angularVelocity);\r\n                if (i > 0) {\r\n                    Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);\r\n                }\r\n            }\r\n\r\n            Bounds.update(part.bounds, part.vertices, body.velocity);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Applies a force to a body from a given world-space position, including resulting torque.\r\n     * @method applyForce\r\n     * @param {body} body\r\n     * @param {vector} position\r\n     * @param {vector} force\r\n     */\r\n    Body.applyForce = function(body, position, force) {\r\n        body.force.x += force.x;\r\n        body.force.y += force.y;\r\n        var offset = { x: position.x - body.position.x, y: position.y - body.position.y };\r\n        body.torque += offset.x * force.y - offset.y * force.x;\r\n    };\r\n\r\n    /**\r\n     * Returns the sums of the properties of all compound parts of the parent body.\r\n     * @method _totalProperties\r\n     * @private\r\n     * @param {body} body\r\n     * @return {}\r\n     */\r\n    Body._totalProperties = function(body) {\r\n        // from equations at:\r\n        // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory\r\n        // http://output.to/sideway/default.asp?qno=121100087\r\n\r\n        var properties = {\r\n            mass: 0,\r\n            area: 0,\r\n            inertia: 0,\r\n            centre: { x: 0, y: 0 }\r\n        };\r\n\r\n        // sum the properties of all compound parts of the parent body\r\n        for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {\r\n            var part = body.parts[i],\r\n                mass = part.mass !== Infinity ? part.mass : 1;\r\n\r\n            properties.mass += mass;\r\n            properties.area += part.area;\r\n            properties.inertia += part.inertia;\r\n            properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));\r\n        }\r\n\r\n        properties.centre = Vector.div(properties.centre, properties.mass);\r\n\r\n        return properties;\r\n    };\r\n\r\n    /*\r\n    *\r\n    *  Events Documentation\r\n    *\r\n    */\r\n\r\n    /**\r\n    * Fired when a body starts sleeping (where `this` is the body).\r\n    *\r\n    * @event sleepStart\r\n    * @this {body} The body that has started sleeping\r\n    * @param {} event An event object\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /**\r\n    * Fired when a body ends sleeping (where `this` is the body).\r\n    *\r\n    * @event sleepEnd\r\n    * @this {body} The body that has ended sleeping\r\n    * @param {} event An event object\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /*\r\n    *\r\n    *  Properties Documentation\r\n    *\r\n    */\r\n\r\n    /**\r\n     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.\r\n     *\r\n     * @property id\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A `String` denoting the type of object.\r\n     *\r\n     * @property type\r\n     * @type string\r\n     * @default \"body\"\r\n     * @readOnly\r\n     */\r\n\r\n    /**\r\n     * An arbitrary `String` name to help the user identify and manage bodies.\r\n     *\r\n     * @property label\r\n     * @type string\r\n     * @default \"Body\"\r\n     */\r\n\r\n    /**\r\n     * An array of bodies that make up this body. \r\n     * The first body in the array must always be a self reference to the current body instance.\r\n     * All bodies in the `parts` array together form a single rigid compound body.\r\n     * Parts are allowed to overlap, have gaps or holes or even form concave bodies.\r\n     * Parts themselves should never be added to a `World`, only the parent body should be.\r\n     * Use `Body.setParts` when setting parts to ensure correct updates of all properties.\r\n     *\r\n     * @property parts\r\n     * @type body[]\r\n     */\r\n\r\n    /**\r\n     * An object reserved for storing plugin-specific properties.\r\n     *\r\n     * @property plugin\r\n     * @type {}\r\n     */\r\n\r\n    /**\r\n     * A self reference if the body is _not_ a part of another body.\r\n     * Otherwise this is a reference to the body that this is a part of.\r\n     * See `body.parts`.\r\n     *\r\n     * @property parent\r\n     * @type body\r\n     */\r\n\r\n    /**\r\n     * A `Number` specifying the angle of the body, in radians.\r\n     *\r\n     * @property angle\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * An array of `Vector` objects that specify the convex hull of the rigid body.\r\n     * These should be provided about the origin `(0, 0)`. E.g.\r\n     *\r\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\r\n     *\r\n     * When passed via `Body.create`, the vertices are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).\r\n     * The `Vector` objects are also augmented with additional properties required for efficient collision detection. \r\n     *\r\n     * Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).\r\n     * Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.\r\n     *\r\n     * @property vertices\r\n     * @type vector[]\r\n     */\r\n\r\n    /**\r\n     * A `Vector` that specifies the current world-space position of the body.\r\n     *\r\n     * @property position\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     */\r\n\r\n    /**\r\n     * A `Vector` that holds the current scale values as set by `Body.setScale`.\r\n     *\r\n     * @property scale\r\n     * @type vector\r\n     * @default { x: 1, y: 1 }\r\n     */\r\n\r\n    /**\r\n     * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.\r\n     *\r\n     * @property force\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     */\r\n\r\n    /**\r\n     * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.\r\n     *\r\n     * @property torque\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`).\r\n     *\r\n     * @readOnly\r\n     * @property speed\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * A `Number` that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.angularVelocity`).\r\n     *\r\n     * @readOnly\r\n     * @property angularSpeed\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only. \r\n     * If you need to modify a body's velocity directly, you should either apply a force or simply change the body's `position` (as the engine uses position-Verlet integration).\r\n     *\r\n     * @readOnly\r\n     * @property velocity\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     */\r\n\r\n    /**\r\n     * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only. \r\n     * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body's `angle` (as the engine uses position-Verlet integration).\r\n     *\r\n     * @readOnly\r\n     * @property angularVelocity\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.\r\n     * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.\r\n     *\r\n     * @property isStatic\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n\r\n    /**\r\n     * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.\r\n     *\r\n     * @property isSensor\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n\r\n    /**\r\n     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.\r\n     * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.\r\n     *\r\n     * @property isSleeping\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n\r\n    /**\r\n     * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`). It is read-only and always positive.\r\n     * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest.\r\n     *\r\n     * @readOnly\r\n     * @property motion\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).\r\n     *\r\n     * @property sleepThreshold\r\n     * @type number\r\n     * @default 60\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the density of the body, that is its mass per unit area.\r\n     * If you pass the density via `Body.create` the `mass` property is automatically calculated for you based on the size (area) of the object.\r\n     * This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).\r\n     *\r\n     * @property density\r\n     * @type number\r\n     * @default 0.001\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead.\r\n     * If you modify this value, you must also modify the `body.inverseMass` property (`1 / mass`).\r\n     *\r\n     * @property mass\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the inverse mass of the body (`1 / mass`).\r\n     * If you modify this value, you must also modify the `body.mass` property.\r\n     *\r\n     * @property inverseMass\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body.\r\n     * It is automatically calculated from the given convex hull (`vertices` array) and density in `Body.create`.\r\n     * If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`).\r\n     *\r\n     * @property inertia\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).\r\n     * If you modify this value, you must also modify the `body.inertia` property.\r\n     *\r\n     * @property inverseInertia\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.\r\n     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. \r\n     * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.\r\n     * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:\r\n     *\r\n     *     Math.max(bodyA.restitution, bodyB.restitution)\r\n     *\r\n     * @property restitution\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.\r\n     * A value of `0` means that the body may slide indefinitely.\r\n     * A value of `1` means the body may come to a stop almost instantly after a force is applied.\r\n     *\r\n     * The effects of the value may be non-linear. \r\n     * High values may be unstable depending on the body.\r\n     * The engine uses a Coulomb friction model including static and kinetic friction.\r\n     * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:\r\n     *\r\n     *     Math.min(bodyA.friction, bodyB.friction)\r\n     *\r\n     * @property friction\r\n     * @type number\r\n     * @default 0.1\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the static friction of the body (in the Coulomb friction model). \r\n     * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.\r\n     * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.\r\n     * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.\r\n     *\r\n     * @property frictionStatic\r\n     * @type number\r\n     * @default 0.5\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the air friction of the body (air resistance). \r\n     * A value of `0` means the body will never slow as it moves through space.\r\n     * The higher the value, the faster a body slows when moving through space.\r\n     * The effects of the value are non-linear. \r\n     *\r\n     * @property frictionAir\r\n     * @type number\r\n     * @default 0.01\r\n     */\r\n\r\n    /**\r\n     * An `Object` that specifies the collision filtering properties of this body.\r\n     *\r\n     * Collisions between two bodies will obey the following rules:\r\n     * - If the two bodies have the same non-zero value of `collisionFilter.group`,\r\n     *   they will always collide if the value is positive, and they will never collide\r\n     *   if the value is negative.\r\n     * - If the two bodies have different values of `collisionFilter.group` or if one\r\n     *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:\r\n     *\r\n     * Each body belongs to a collision category, given by `collisionFilter.category`. This\r\n     * value is used as a bit field and the category should have only one bit set, meaning that\r\n     * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32\r\n     * different collision categories available.\r\n     *\r\n     * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies\r\n     * the categories it collides with (the value is the bitwise AND value of all these categories).\r\n     *\r\n     * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's\r\n     * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`\r\n     * are both true.\r\n     *\r\n     * @property collisionFilter\r\n     * @type object\r\n     */\r\n\r\n    /**\r\n     * An Integer `Number`, that specifies the collision group this body belongs to.\r\n     * See `body.collisionFilter` for more information.\r\n     *\r\n     * @property collisionFilter.group\r\n     * @type object\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * A bit field that specifies the collision category this body belongs to.\r\n     * The category value should have only one bit set, for example `0x0001`.\r\n     * This means there are up to 32 unique collision categories available.\r\n     * See `body.collisionFilter` for more information.\r\n     *\r\n     * @property collisionFilter.category\r\n     * @type object\r\n     * @default 1\r\n     */\r\n\r\n    /**\r\n     * A bit mask that specifies the collision categories this body may collide with.\r\n     * See `body.collisionFilter` for more information.\r\n     *\r\n     * @property collisionFilter.mask\r\n     * @type object\r\n     * @default -1\r\n     */\r\n\r\n    /**\r\n     * A `Number` that specifies a tolerance on how far a body is allowed to 'sink' or rotate into other bodies.\r\n     * Avoid changing this value unless you understand the purpose of `slop` in physics engines.\r\n     * The default should generally suffice, although very large bodies may require larger values for stable stacking.\r\n     *\r\n     * @property slop\r\n     * @type number\r\n     * @default 0.05\r\n     */\r\n\r\n    /**\r\n     * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.\r\n     *\r\n     * @property timeScale\r\n     * @type number\r\n     * @default 1\r\n     */\r\n\r\n    /**\r\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\r\n     *\r\n     * @property render\r\n     * @type object\r\n     */\r\n\r\n    /**\r\n     * A flag that indicates if the body should be rendered.\r\n     *\r\n     * @property render.visible\r\n     * @type boolean\r\n     * @default true\r\n     */\r\n\r\n    /**\r\n     * Sets the opacity to use when rendering.\r\n     *\r\n     * @property render.opacity\r\n     * @type number\r\n     * @default 1\r\n    */\r\n\r\n    /**\r\n     * An `Object` that defines the sprite properties to use when rendering, if any.\r\n     *\r\n     * @property render.sprite\r\n     * @type object\r\n     */\r\n\r\n     /**\r\n      * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).\r\n      *\r\n      * @property render.sprite.xOffset\r\n      * @type number\r\n      * @default 0\r\n      */\r\n\r\n     /**\r\n      * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).\r\n      *\r\n      * @property render.sprite.yOffset\r\n      * @type number\r\n      * @default 0\r\n      */\r\n\r\n    /**\r\n     * A hex color value that defines the fill color to use when rendering the body.\r\n     *\r\n     * @property render.fillColor\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A value that defines the fill opacity to use when rendering the body.\r\n     *\r\n     * @property render.fillOpacity\r\n     * @type number\r\n     */\r\n\r\n     /**\r\n     * A hex color value that defines the line color to use when rendering the body.\r\n     *\r\n     * @property render.lineColor\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A value that defines the line opacity to use when rendering the body.\r\n     *\r\n     * @property render.lineOpacity\r\n     * @type number\r\n     */\r\n\r\n     /**\r\n     * A `Number` that defines the line width to use when rendering the body outline.\r\n     *\r\n     * @property render.lineThickness\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * An array of unique axis vectors (edge normals) used for collision detection.\r\n     * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.\r\n     * They are constantly updated by `Body.update` during the simulation.\r\n     *\r\n     * @property axes\r\n     * @type vector[]\r\n     */\r\n     \r\n    /**\r\n     * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`.\r\n     *\r\n     * @property area\r\n     * @type string\r\n     * @default \r\n     */\r\n\r\n    /**\r\n     * A `Bounds` object that defines the AABB region for the body.\r\n     * It is automatically calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation.\r\n     *\r\n     * @property bounds\r\n     * @type bounds\r\n     */\r\n\r\n    /**\r\n     * A reference to the Phaser Game Object this body belongs to, if any.\r\n     *\r\n     * @property gameObject\r\n     * @type Phaser.GameObjects.GameObject\r\n     */\r\n\r\n    /**\r\n     * The center of mass of the Body.\r\n     *\r\n     * @property centerOfMass\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     */\r\n\r\n    /**\r\n     * The center of the body in pixel values.\r\n     * Used by Phaser for texture aligment.\r\n     *\r\n     * @property centerOffset\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     */\r\n\r\n    /**\r\n     * Will this Body ignore World gravity during the Engine update?\r\n     *\r\n     * @property ignoreGravity\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n\r\n    /**\r\n     * Scale the influence of World gravity when applied to this body.\r\n     *\r\n     * @property gravityScale\r\n     * @type vector\r\n     * @default { x: 1, y: 1 }\r\n     */\r\n\r\n     /**\r\n     * Will this Body ignore Phaser Pointer input events?\r\n     *\r\n     * @property ignorePointer\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n\r\n    /**\r\n     * A callback that is invoked when this Body starts colliding with any other Body.\r\n     * \r\n     * You can register callbacks by providing a function of type `( pair: Matter.Pair) => void`.\r\n     *\r\n     * @property onCollideCallback\r\n     * @type function\r\n     * @default null\r\n     */\r\n\r\n    /**\r\n     * A callback that is invoked when this Body stops colliding with any other Body.\r\n     * \r\n     * You can register callbacks by providing a function of type `( pair: Matter.Pair) => void`.\r\n     *\r\n     * @property onCollideEndCallback\r\n     * @type function\r\n     * @default null\r\n     */\r\n\r\n    /**\r\n     * A callback that is invoked for the duration that this Body is colliding with any other Body.\r\n     * \r\n     * You can register callbacks by providing a function of type `( pair: Matter.Pair) => void`.\r\n     *\r\n     * @property onCollideActiveCallback\r\n     * @type function\r\n     * @default null\r\n     */\r\n\r\n    /**\r\n     * A collision callback dictionary used by the `Body.setOnCollideWith` function.\r\n     *\r\n     * @property onCollideWith\r\n     * @type object\r\n     * @default null\r\n     */\r\n\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}