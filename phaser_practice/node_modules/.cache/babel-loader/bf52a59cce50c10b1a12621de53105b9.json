{"ast":null,"code":"/**\r\n * This method will search the given rectangular area and return an array of all physics bodies that\r\n * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.\r\n * \r\n * A body only has to intersect with the search area to be considered, it doesn't have to be fully\r\n * contained within it.\r\n * \r\n * If Arcade Physics is set to use the RTree (which it is by default) then the search for is extremely fast,\r\n * otherwise the search is O(N) for Dynamic Bodies.\r\n *\r\n * @function Phaser.Physics.Arcade.Components.OverlapRect\r\n * @since 3.17.0\r\n *\r\n * @param {number} x - The top-left x coordinate of the area to search within.\r\n * @param {number} y - The top-left y coordinate of the area to search within.\r\n * @param {number} width - The width of the area to search within.\r\n * @param {number} height - The height of the area to search within.\r\n * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?\r\n * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?\r\n *\r\n * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.\r\n */\nvar OverlapRect = function (world, x, y, width, height, includeDynamic, includeStatic) {\n  if (includeDynamic === undefined) {\n    includeDynamic = true;\n  }\n\n  if (includeStatic === undefined) {\n    includeStatic = false;\n  }\n\n  var dynamicBodies = [];\n  var staticBodies = [];\n  var minMax = world.treeMinMax;\n  minMax.minX = x;\n  minMax.minY = y;\n  minMax.maxX = x + width;\n  minMax.maxY = y + height;\n\n  if (includeStatic) {\n    staticBodies = world.staticTree.search(minMax);\n  }\n\n  if (includeDynamic && world.useTree) {\n    dynamicBodies = world.tree.search(minMax);\n  } else if (includeDynamic) {\n    var bodies = world.bodies;\n    var fakeBody = {\n      position: {\n        x: x,\n        y: y\n      },\n      left: x,\n      top: y,\n      right: x + width,\n      bottom: y + height,\n      isCircle: false\n    };\n    var intersects = world.intersects;\n    bodies.iterate(function (target) {\n      if (intersects(target, fakeBody)) {\n        dynamicBodies.push(target);\n      }\n    });\n  }\n\n  return staticBodies.concat(dynamicBodies);\n};\n\nmodule.exports = OverlapRect;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/arcade/components/OverlapRect.js"],"names":["OverlapRect","world","x","y","width","height","includeDynamic","includeStatic","undefined","dynamicBodies","staticBodies","minMax","treeMinMax","minX","minY","maxX","maxY","staticTree","search","useTree","tree","bodies","fakeBody","position","left","top","right","bottom","isCircle","intersects","iterate","target","push","concat","module","exports"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;AAsBA,IAAIA,WAAW,GAAG,UAAUC,KAAV,EAAiBC,CAAjB,EAAoBC,CAApB,EAAuBC,KAAvB,EAA8BC,MAA9B,EAAsCC,cAAtC,EAAsDC,aAAtD,EAClB;AACI,MAAID,cAAc,KAAKE,SAAvB,EAAkC;AAAEF,IAAAA,cAAc,GAAG,IAAjB;AAAwB;;AAC5D,MAAIC,aAAa,KAAKC,SAAtB,EAAiC;AAAED,IAAAA,aAAa,GAAG,KAAhB;AAAwB;;AAE3D,MAAIE,aAAa,GAAG,EAApB;AACA,MAAIC,YAAY,GAAG,EAAnB;AAEA,MAAIC,MAAM,GAAGV,KAAK,CAACW,UAAnB;AAEAD,EAAAA,MAAM,CAACE,IAAP,GAAcX,CAAd;AACAS,EAAAA,MAAM,CAACG,IAAP,GAAcX,CAAd;AACAQ,EAAAA,MAAM,CAACI,IAAP,GAAcb,CAAC,GAAGE,KAAlB;AACAO,EAAAA,MAAM,CAACK,IAAP,GAAcb,CAAC,GAAGE,MAAlB;;AAEA,MAAIE,aAAJ,EACA;AACIG,IAAAA,YAAY,GAAGT,KAAK,CAACgB,UAAN,CAAiBC,MAAjB,CAAwBP,MAAxB,CAAf;AACH;;AAED,MAAIL,cAAc,IAAIL,KAAK,CAACkB,OAA5B,EACA;AACIV,IAAAA,aAAa,GAAGR,KAAK,CAACmB,IAAN,CAAWF,MAAX,CAAkBP,MAAlB,CAAhB;AACH,GAHD,MAIK,IAAIL,cAAJ,EACL;AACI,QAAIe,MAAM,GAAGpB,KAAK,CAACoB,MAAnB;AAEA,QAAIC,QAAQ,GACZ;AACIC,MAAAA,QAAQ,EAAE;AACNrB,QAAAA,CAAC,EAAEA,CADG;AAENC,QAAAA,CAAC,EAAEA;AAFG,OADd;AAKIqB,MAAAA,IAAI,EAAEtB,CALV;AAMIuB,MAAAA,GAAG,EAAEtB,CANT;AAOIuB,MAAAA,KAAK,EAAExB,CAAC,GAAGE,KAPf;AAQIuB,MAAAA,MAAM,EAAExB,CAAC,GAAGE,MARhB;AASIuB,MAAAA,QAAQ,EAAE;AATd,KADA;AAaA,QAAIC,UAAU,GAAG5B,KAAK,CAAC4B,UAAvB;AAEAR,IAAAA,MAAM,CAACS,OAAP,CAAe,UAAUC,MAAV,EACf;AACI,UAAIF,UAAU,CAACE,MAAD,EAAST,QAAT,CAAd,EACA;AACIb,QAAAA,aAAa,CAACuB,IAAd,CAAmBD,MAAnB;AACH;AAEJ,KAPD;AAQH;;AAED,SAAOrB,YAAY,CAACuB,MAAb,CAAoBxB,aAApB,CAAP;AACH,CAtDD;;AAwDAyB,MAAM,CAACC,OAAP,GAAiBnC,WAAjB","sourcesContent":["/**\r\n * This method will search the given rectangular area and return an array of all physics bodies that\r\n * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.\r\n * \r\n * A body only has to intersect with the search area to be considered, it doesn't have to be fully\r\n * contained within it.\r\n * \r\n * If Arcade Physics is set to use the RTree (which it is by default) then the search for is extremely fast,\r\n * otherwise the search is O(N) for Dynamic Bodies.\r\n *\r\n * @function Phaser.Physics.Arcade.Components.OverlapRect\r\n * @since 3.17.0\r\n *\r\n * @param {number} x - The top-left x coordinate of the area to search within.\r\n * @param {number} y - The top-left y coordinate of the area to search within.\r\n * @param {number} width - The width of the area to search within.\r\n * @param {number} height - The height of the area to search within.\r\n * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?\r\n * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?\r\n *\r\n * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.\r\n */\r\nvar OverlapRect = function (world, x, y, width, height, includeDynamic, includeStatic)\r\n{\r\n    if (includeDynamic === undefined) { includeDynamic = true; }\r\n    if (includeStatic === undefined) { includeStatic = false; }\r\n\r\n    var dynamicBodies = [];\r\n    var staticBodies = [];\r\n\r\n    var minMax = world.treeMinMax;\r\n\r\n    minMax.minX = x;\r\n    minMax.minY = y;\r\n    minMax.maxX = x + width;\r\n    minMax.maxY = y + height;\r\n\r\n    if (includeStatic)\r\n    {\r\n        staticBodies = world.staticTree.search(minMax);\r\n    }\r\n\r\n    if (includeDynamic && world.useTree)\r\n    {\r\n        dynamicBodies = world.tree.search(minMax);\r\n    }\r\n    else if (includeDynamic)\r\n    {\r\n        var bodies = world.bodies;\r\n\r\n        var fakeBody =\r\n        {\r\n            position: {\r\n                x: x,\r\n                y: y\r\n            },\r\n            left: x,\r\n            top: y,\r\n            right: x + width,\r\n            bottom: y + height,\r\n            isCircle: false\r\n        };\r\n\r\n        var intersects = world.intersects;\r\n\r\n        bodies.iterate(function (target)\r\n        {\r\n            if (intersects(target, fakeBody))\r\n            {\r\n                dynamicBodies.push(target);\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n    return staticBodies.concat(dynamicBodies);\r\n};\r\n\r\nmodule.exports = OverlapRect;\r\n"]},"metadata":{},"sourceType":"script"}