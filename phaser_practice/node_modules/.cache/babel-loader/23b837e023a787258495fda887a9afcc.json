{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Tile = require('../Tile');\n\nvar IsInLayerBounds = require('./IsInLayerBounds');\n\nvar CalculateFacesAt = require('./CalculateFacesAt');\n\nvar SetTileCollision = require('./SetTileCollision');\n/**\r\n * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n * location. If you pass in an index, only the index at the specified location will be changed.\r\n * Collision information will be recalculated at the specified location.\r\n *\r\n * @function Phaser.Tilemaps.Components.PutTileAt\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was created or added to this map.\r\n */\n\n\nvar PutTileAt = function (tile, tileX, tileY, recalculateFaces, layer) {\n  if (!IsInLayerBounds(tileX, tileY, layer)) {\n    return null;\n  }\n\n  if (recalculateFaces === undefined) {\n    recalculateFaces = true;\n  }\n\n  var oldTile = layer.data[tileY][tileX];\n  var oldTileCollides = oldTile && oldTile.collides;\n\n  if (tile instanceof Tile) {\n    if (layer.data[tileY][tileX] === null) {\n      layer.data[tileY][tileX] = new Tile(layer, tile.index, tileX, tileY, tile.width, tile.height);\n    }\n\n    layer.data[tileY][tileX].copy(tile);\n  } else {\n    var index = tile;\n\n    if (layer.data[tileY][tileX] === null) {\n      layer.data[tileY][tileX] = new Tile(layer, index, tileX, tileY, layer.tileWidth, layer.tileHeight);\n    } else {\n      layer.data[tileY][tileX].index = index;\n    }\n  } // Updating colliding flag on the new tile\n\n\n  var newTile = layer.data[tileY][tileX];\n  var collides = layer.collideIndexes.indexOf(newTile.index) !== -1;\n  SetTileCollision(newTile, collides); // Recalculate faces only if the colliding flag at (tileX, tileY) has changed\n\n  if (recalculateFaces && oldTileCollides !== newTile.collides) {\n    CalculateFacesAt(tileX, tileY, layer);\n  }\n\n  return newTile;\n};\n\nmodule.exports = PutTileAt;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/tilemaps/components/PutTileAt.js"],"names":["Tile","require","IsInLayerBounds","CalculateFacesAt","SetTileCollision","PutTileAt","tile","tileX","tileY","recalculateFaces","layer","undefined","oldTile","data","oldTileCollides","collides","index","width","height","copy","tileWidth","tileHeight","newTile","collideIndexes","indexOf","module","exports"],"mappings":"AAAA;;;;;AAMA,IAAIA,IAAI,GAAGC,OAAO,CAAC,SAAD,CAAlB;;AACA,IAAIC,eAAe,GAAGD,OAAO,CAAC,mBAAD,CAA7B;;AACA,IAAIE,gBAAgB,GAAGF,OAAO,CAAC,oBAAD,CAA9B;;AACA,IAAIG,gBAAgB,GAAGH,OAAO,CAAC,oBAAD,CAA9B;AAEA;;;;;;;;;;;;;;;;;;;;AAkBA,IAAII,SAAS,GAAG,UAAUC,IAAV,EAAgBC,KAAhB,EAAuBC,KAAvB,EAA8BC,gBAA9B,EAAgDC,KAAhD,EAChB;AACI,MAAI,CAACR,eAAe,CAACK,KAAD,EAAQC,KAAR,EAAeE,KAAf,CAApB,EAA2C;AAAE,WAAO,IAAP;AAAc;;AAC3D,MAAID,gBAAgB,KAAKE,SAAzB,EAAoC;AAAEF,IAAAA,gBAAgB,GAAG,IAAnB;AAA0B;;AAEhE,MAAIG,OAAO,GAAGF,KAAK,CAACG,IAAN,CAAWL,KAAX,EAAkBD,KAAlB,CAAd;AACA,MAAIO,eAAe,GAAGF,OAAO,IAAIA,OAAO,CAACG,QAAzC;;AAEA,MAAIT,IAAI,YAAYN,IAApB,EACA;AACI,QAAIU,KAAK,CAACG,IAAN,CAAWL,KAAX,EAAkBD,KAAlB,MAA6B,IAAjC,EACA;AACIG,MAAAA,KAAK,CAACG,IAAN,CAAWL,KAAX,EAAkBD,KAAlB,IAA2B,IAAIP,IAAJ,CAASU,KAAT,EAAgBJ,IAAI,CAACU,KAArB,EAA4BT,KAA5B,EAAmCC,KAAnC,EAA0CF,IAAI,CAACW,KAA/C,EAAsDX,IAAI,CAACY,MAA3D,CAA3B;AACH;;AACDR,IAAAA,KAAK,CAACG,IAAN,CAAWL,KAAX,EAAkBD,KAAlB,EAAyBY,IAAzB,CAA8Bb,IAA9B;AACH,GAPD,MASA;AACI,QAAIU,KAAK,GAAGV,IAAZ;;AACA,QAAII,KAAK,CAACG,IAAN,CAAWL,KAAX,EAAkBD,KAAlB,MAA6B,IAAjC,EACA;AACIG,MAAAA,KAAK,CAACG,IAAN,CAAWL,KAAX,EAAkBD,KAAlB,IAA2B,IAAIP,IAAJ,CAASU,KAAT,EAAgBM,KAAhB,EAAuBT,KAAvB,EAA8BC,KAA9B,EAAqCE,KAAK,CAACU,SAA3C,EAAsDV,KAAK,CAACW,UAA5D,CAA3B;AACH,KAHD,MAKA;AACIX,MAAAA,KAAK,CAACG,IAAN,CAAWL,KAAX,EAAkBD,KAAlB,EAAyBS,KAAzB,GAAiCA,KAAjC;AACH;AACJ,GA1BL,CA4BI;;;AACA,MAAIM,OAAO,GAAGZ,KAAK,CAACG,IAAN,CAAWL,KAAX,EAAkBD,KAAlB,CAAd;AACA,MAAIQ,QAAQ,GAAGL,KAAK,CAACa,cAAN,CAAqBC,OAArB,CAA6BF,OAAO,CAACN,KAArC,MAAgD,CAAC,CAAhE;AACAZ,EAAAA,gBAAgB,CAACkB,OAAD,EAAUP,QAAV,CAAhB,CA/BJ,CAiCI;;AACA,MAAIN,gBAAgB,IAAKK,eAAe,KAAKQ,OAAO,CAACP,QAArD,EACA;AACIZ,IAAAA,gBAAgB,CAACI,KAAD,EAAQC,KAAR,EAAeE,KAAf,CAAhB;AACH;;AAED,SAAOY,OAAP;AACH,CAzCD;;AA2CAG,MAAM,CAACC,OAAP,GAAiBrB,SAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Tile = require('../Tile');\r\nvar IsInLayerBounds = require('./IsInLayerBounds');\r\nvar CalculateFacesAt = require('./CalculateFacesAt');\r\nvar SetTileCollision = require('./SetTileCollision');\r\n\r\n/**\r\n * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n * location. If you pass in an index, only the index at the specified location will be changed.\r\n * Collision information will be recalculated at the specified location.\r\n *\r\n * @function Phaser.Tilemaps.Components.PutTileAt\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {(integer|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n * @param {integer} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {integer} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was created or added to this map.\r\n */\r\nvar PutTileAt = function (tile, tileX, tileY, recalculateFaces, layer)\r\n{\r\n    if (!IsInLayerBounds(tileX, tileY, layer)) { return null; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    var oldTile = layer.data[tileY][tileX];\r\n    var oldTileCollides = oldTile && oldTile.collides;\r\n\r\n    if (tile instanceof Tile)\r\n    {\r\n        if (layer.data[tileY][tileX] === null)\r\n        {\r\n            layer.data[tileY][tileX] = new Tile(layer, tile.index, tileX, tileY, tile.width, tile.height);\r\n        }\r\n        layer.data[tileY][tileX].copy(tile);\r\n    }\r\n    else\r\n    {\r\n        var index = tile;\r\n        if (layer.data[tileY][tileX] === null)\r\n        {\r\n            layer.data[tileY][tileX] = new Tile(layer, index, tileX, tileY, layer.tileWidth, layer.tileHeight);\r\n        }\r\n        else\r\n        {\r\n            layer.data[tileY][tileX].index = index;\r\n        }\r\n    }\r\n\r\n    // Updating colliding flag on the new tile\r\n    var newTile = layer.data[tileY][tileX];\r\n    var collides = layer.collideIndexes.indexOf(newTile.index) !== -1;\r\n    SetTileCollision(newTile, collides);\r\n\r\n    // Recalculate faces only if the colliding flag at (tileX, tileY) has changed\r\n    if (recalculateFaces && (oldTileCollides !== newTile.collides))\r\n    {\r\n        CalculateFacesAt(tileX, tileY, layer);\r\n    }\r\n\r\n    return newTile;\r\n};\r\n\r\nmodule.exports = PutTileAt;\r\n\r\n"]},"metadata":{},"sourceType":"script"}