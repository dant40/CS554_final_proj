{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Clone = require('../../utils/object/Clone');\n/**\r\n * Parses a Texture Atlas JSON Array and adds the Frames to the Texture.\r\n * JSON format expected to match that defined by Texture Packer, with the frames property containing an array of Frames.\r\n *\r\n * @function Phaser.Textures.Parsers.JSONArray\r\n * @memberof Phaser.Textures.Parsers\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {integer} sourceIndex - The index of the TextureSource.\r\n * @param {object} json - The JSON data.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */\n\n\nvar JSONArray = function (texture, sourceIndex, json) {\n  //  Malformed?\n  if (!json['frames'] && !json['textures']) {\n    console.warn('Invalid Texture Atlas JSON Array');\n    return;\n  } //  Add in a __BASE entry (for the entire atlas)\n\n\n  var source = texture.source[sourceIndex];\n  texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height); //  By this stage frames is a fully parsed array\n\n  var frames = Array.isArray(json.textures) ? json.textures[sourceIndex].frames : json.frames;\n  var newFrame;\n\n  for (var i = 0; i < frames.length; i++) {\n    var src = frames[i]; //  The frame values are the exact coordinates to cut the frame out of the atlas from\n\n    newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h); //  These are the original (non-trimmed) sprite values\n\n    if (src.trimmed) {\n      newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h);\n    }\n\n    if (src.rotated) {\n      newFrame.rotated = true;\n      newFrame.updateUVsInverted();\n    }\n\n    if (src.anchor) {\n      newFrame.customPivot = true;\n      newFrame.pivotX = src.anchor.x;\n      newFrame.pivotY = src.anchor.y;\n    } //  Copy over any extra data\n\n\n    newFrame.customData = Clone(src);\n  } //  Copy over any additional data that was in the JSON to Texture.customData\n\n\n  for (var dataKey in json) {\n    if (dataKey === 'frames') {\n      continue;\n    }\n\n    if (Array.isArray(json[dataKey])) {\n      texture.customData[dataKey] = json[dataKey].slice(0);\n    } else {\n      texture.customData[dataKey] = json[dataKey];\n    }\n  }\n\n  return texture;\n};\n\nmodule.exports = JSONArray;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/textures/parsers/JSONArray.js"],"names":["Clone","require","JSONArray","texture","sourceIndex","json","console","warn","source","add","width","height","frames","Array","isArray","textures","newFrame","i","length","src","filename","frame","x","y","w","h","trimmed","setTrim","sourceSize","spriteSourceSize","rotated","updateUVsInverted","anchor","customPivot","pivotX","pivotY","customData","dataKey","slice","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clone = require('../../utils/object/Clone');\r\n\r\n/**\r\n * Parses a Texture Atlas JSON Array and adds the Frames to the Texture.\r\n * JSON format expected to match that defined by Texture Packer, with the frames property containing an array of Frames.\r\n *\r\n * @function Phaser.Textures.Parsers.JSONArray\r\n * @memberof Phaser.Textures.Parsers\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {integer} sourceIndex - The index of the TextureSource.\r\n * @param {object} json - The JSON data.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */\r\nvar JSONArray = function (texture, sourceIndex, json)\r\n{\r\n    //  Malformed?\r\n    if (!json['frames'] && !json['textures'])\r\n    {\r\n        console.warn('Invalid Texture Atlas JSON Array');\r\n        return;\r\n    }\r\n\r\n    //  Add in a __BASE entry (for the entire atlas)\r\n    var source = texture.source[sourceIndex];\r\n\r\n    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);\r\n\r\n    //  By this stage frames is a fully parsed array\r\n    var frames = (Array.isArray(json.textures)) ? json.textures[sourceIndex].frames : json.frames;\r\n\r\n    var newFrame;\r\n\r\n    for (var i = 0; i < frames.length; i++)\r\n    {\r\n        var src = frames[i];\r\n\r\n        //  The frame values are the exact coordinates to cut the frame out of the atlas from\r\n        newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);\r\n\r\n        //  These are the original (non-trimmed) sprite values\r\n        if (src.trimmed)\r\n        {\r\n            newFrame.setTrim(\r\n                src.sourceSize.w,\r\n                src.sourceSize.h,\r\n                src.spriteSourceSize.x,\r\n                src.spriteSourceSize.y,\r\n                src.spriteSourceSize.w,\r\n                src.spriteSourceSize.h\r\n            );\r\n        }\r\n\r\n        if (src.rotated)\r\n        {\r\n            newFrame.rotated = true;\r\n            newFrame.updateUVsInverted();\r\n        }\r\n\r\n        if (src.anchor)\r\n        {\r\n            newFrame.customPivot = true;\r\n            newFrame.pivotX = src.anchor.x;\r\n            newFrame.pivotY = src.anchor.y;\r\n        }\r\n\r\n        //  Copy over any extra data\r\n        newFrame.customData = Clone(src);\r\n    }\r\n\r\n    //  Copy over any additional data that was in the JSON to Texture.customData\r\n    for (var dataKey in json)\r\n    {\r\n        if (dataKey === 'frames')\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (Array.isArray(json[dataKey]))\r\n        {\r\n            texture.customData[dataKey] = json[dataKey].slice(0);\r\n        }\r\n        else\r\n        {\r\n            texture.customData[dataKey] = json[dataKey];\r\n        }\r\n    }\r\n\r\n    return texture;\r\n};\r\n\r\nmodule.exports = JSONArray;\r\n"]},"metadata":{},"sourceType":"script"}