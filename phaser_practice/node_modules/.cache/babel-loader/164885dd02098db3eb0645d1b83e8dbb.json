{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Utils = require('../../renderer/webgl/Utils');\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Particles.EmitterManager#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitterManager} emitterManager - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\n\n\nvar ParticleManagerWebGLRenderer = function (renderer, emitterManager, interpolationPercentage, camera, parentMatrix) {\n  var emitters = emitterManager.emitters.list;\n  var emittersLength = emitters.length;\n\n  if (emittersLength === 0) {\n    return;\n  }\n\n  var pipeline = this.pipeline;\n\n  var camMatrix = pipeline._tempMatrix1.copyFrom(camera.matrix);\n\n  var calcMatrix = pipeline._tempMatrix2;\n  var particleMatrix = pipeline._tempMatrix3;\n\n  var managerMatrix = pipeline._tempMatrix4.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);\n\n  camMatrix.multiply(managerMatrix);\n  renderer.setPipeline(pipeline);\n  var roundPixels = camera.roundPixels;\n  var texture = emitterManager.defaultFrame.glTexture;\n  var getTint = Utils.getTintAppendFloatAlphaAndSwap;\n  pipeline.setTexture2D(texture, 0);\n\n  for (var e = 0; e < emittersLength; e++) {\n    var emitter = emitters[e];\n    var particles = emitter.alive;\n    var particleCount = particles.length;\n\n    if (!emitter.visible || particleCount === 0) {\n      continue;\n    }\n\n    var scrollX = camera.scrollX * emitter.scrollFactorX;\n    var scrollY = camera.scrollY * emitter.scrollFactorY;\n\n    if (parentMatrix) {\n      //  Multiply the camera by the parent matrix\n      camMatrix.multiplyWithOffset(parentMatrix, -scrollX, -scrollY);\n      scrollX = 0;\n      scrollY = 0;\n    }\n\n    if (renderer.setBlendMode(emitter.blendMode)) {\n      //  Rebind the texture if we've flushed\n      pipeline.setTexture2D(texture, 0);\n    }\n\n    if (emitter.mask) {\n      emitter.mask.preRenderWebGL(renderer, emitter, camera);\n      pipeline.setTexture2D(texture, 0);\n    }\n\n    var tintEffect = 0;\n\n    for (var i = 0; i < particleCount; i++) {\n      var particle = particles[i];\n      var alpha = particle.alpha * camera.alpha;\n\n      if (alpha <= 0) {\n        continue;\n      }\n\n      var frame = particle.frame;\n      var x = -frame.halfWidth;\n      var y = -frame.halfHeight;\n      var xw = x + frame.width;\n      var yh = y + frame.height;\n      particleMatrix.applyITRS(0, 0, particle.rotation, particle.scaleX, particle.scaleY);\n      particleMatrix.e = particle.x - scrollX;\n      particleMatrix.f = particle.y - scrollY;\n      camMatrix.multiply(particleMatrix, calcMatrix);\n      var tx0 = calcMatrix.getX(x, y);\n      var ty0 = calcMatrix.getY(x, y);\n      var tx1 = calcMatrix.getX(x, yh);\n      var ty1 = calcMatrix.getY(x, yh);\n      var tx2 = calcMatrix.getX(xw, yh);\n      var ty2 = calcMatrix.getY(xw, yh);\n      var tx3 = calcMatrix.getX(xw, y);\n      var ty3 = calcMatrix.getY(xw, y);\n\n      if (roundPixels) {\n        tx0 = Math.round(tx0);\n        ty0 = Math.round(ty0);\n        tx1 = Math.round(tx1);\n        ty1 = Math.round(ty1);\n        tx2 = Math.round(tx2);\n        ty2 = Math.round(ty2);\n        tx3 = Math.round(tx3);\n        ty3 = Math.round(ty3);\n      }\n\n      var tint = getTint(particle.tint, alpha);\n      pipeline.batchQuad(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, texture, 0);\n    }\n\n    if (emitter.mask) {\n      emitter.mask.postRenderWebGL(renderer, camera);\n      pipeline.setTexture2D(texture, 0);\n    }\n  }\n};\n\nmodule.exports = ParticleManagerWebGLRenderer;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/particles/ParticleManagerWebGLRenderer.js"],"names":["Utils","require","ParticleManagerWebGLRenderer","renderer","emitterManager","interpolationPercentage","camera","parentMatrix","emitters","list","emittersLength","length","pipeline","camMatrix","_tempMatrix1","copyFrom","matrix","calcMatrix","_tempMatrix2","particleMatrix","_tempMatrix3","managerMatrix","_tempMatrix4","applyITRS","x","y","rotation","scaleX","scaleY","multiply","setPipeline","roundPixels","texture","defaultFrame","glTexture","getTint","getTintAppendFloatAlphaAndSwap","setTexture2D","e","emitter","particles","alive","particleCount","visible","scrollX","scrollFactorX","scrollY","scrollFactorY","multiplyWithOffset","setBlendMode","blendMode","mask","preRenderWebGL","tintEffect","i","particle","alpha","frame","halfWidth","halfHeight","xw","width","yh","height","f","tx0","getX","ty0","getY","tx1","ty1","tx2","ty2","tx3","ty3","Math","round","tint","batchQuad","u0","v0","u1","v1","postRenderWebGL","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Particles.EmitterManager#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitterManager} emitterManager - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ParticleManagerWebGLRenderer = function (renderer, emitterManager, interpolationPercentage, camera, parentMatrix)\r\n{\r\n    var emitters = emitterManager.emitters.list;\r\n    var emittersLength = emitters.length;\r\n\r\n    if (emittersLength === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var pipeline = this.pipeline;\r\n\r\n    var camMatrix = pipeline._tempMatrix1.copyFrom(camera.matrix);\r\n    var calcMatrix = pipeline._tempMatrix2;\r\n    var particleMatrix = pipeline._tempMatrix3;\r\n    var managerMatrix = pipeline._tempMatrix4.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);\r\n\r\n    camMatrix.multiply(managerMatrix);\r\n\r\n    renderer.setPipeline(pipeline);\r\n\r\n    var roundPixels = camera.roundPixels;\r\n    var texture = emitterManager.defaultFrame.glTexture;\r\n    var getTint = Utils.getTintAppendFloatAlphaAndSwap;\r\n\r\n    pipeline.setTexture2D(texture, 0);\r\n\r\n    for (var e = 0; e < emittersLength; e++)\r\n    {\r\n        var emitter = emitters[e];\r\n        var particles = emitter.alive;\r\n        var particleCount = particles.length;\r\n\r\n        if (!emitter.visible || particleCount === 0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var scrollX = camera.scrollX * emitter.scrollFactorX;\r\n        var scrollY = camera.scrollY * emitter.scrollFactorY;\r\n\r\n        if (parentMatrix)\r\n        {\r\n            //  Multiply the camera by the parent matrix\r\n            camMatrix.multiplyWithOffset(parentMatrix, -scrollX, -scrollY);\r\n\r\n            scrollX = 0;\r\n            scrollY = 0;\r\n        }\r\n\r\n        if (renderer.setBlendMode(emitter.blendMode))\r\n        {\r\n            //  Rebind the texture if we've flushed\r\n            pipeline.setTexture2D(texture, 0);\r\n        }\r\n\r\n        if (emitter.mask)\r\n        {\r\n            emitter.mask.preRenderWebGL(renderer, emitter, camera);\r\n            pipeline.setTexture2D(texture, 0);\r\n        }\r\n    \r\n        var tintEffect = 0;\r\n\r\n        for (var i = 0; i < particleCount; i++)\r\n        {\r\n            var particle = particles[i];\r\n\r\n            var alpha = particle.alpha * camera.alpha;\r\n\r\n            if (alpha <= 0)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var frame = particle.frame;\r\n\r\n            var x = -(frame.halfWidth);\r\n            var y = -(frame.halfHeight);\r\n            var xw = x + frame.width;\r\n            var yh = y + frame.height;\r\n\r\n            particleMatrix.applyITRS(0, 0, particle.rotation, particle.scaleX, particle.scaleY);\r\n\r\n            particleMatrix.e = particle.x - scrollX;\r\n            particleMatrix.f = particle.y - scrollY;\r\n\r\n            camMatrix.multiply(particleMatrix, calcMatrix);\r\n\r\n            var tx0 = calcMatrix.getX(x, y);\r\n            var ty0 = calcMatrix.getY(x, y);\r\n    \r\n            var tx1 = calcMatrix.getX(x, yh);\r\n            var ty1 = calcMatrix.getY(x, yh);\r\n    \r\n            var tx2 = calcMatrix.getX(xw, yh);\r\n            var ty2 = calcMatrix.getY(xw, yh);\r\n    \r\n            var tx3 = calcMatrix.getX(xw, y);\r\n            var ty3 = calcMatrix.getY(xw, y);\r\n\r\n            if (roundPixels)\r\n            {\r\n                tx0 = Math.round(tx0);\r\n                ty0 = Math.round(ty0);\r\n    \r\n                tx1 = Math.round(tx1);\r\n                ty1 = Math.round(ty1);\r\n    \r\n                tx2 = Math.round(tx2);\r\n                ty2 = Math.round(ty2);\r\n    \r\n                tx3 = Math.round(tx3);\r\n                ty3 = Math.round(ty3);\r\n            }\r\n\r\n            var tint = getTint(particle.tint, alpha);\r\n\r\n            pipeline.batchQuad(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, texture, 0);\r\n        }\r\n\r\n        if (emitter.mask)\r\n        {\r\n            emitter.mask.postRenderWebGL(renderer, camera);\r\n            pipeline.setTexture2D(texture, 0);\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = ParticleManagerWebGLRenderer;\r\n"]},"metadata":{},"sourceType":"script"}