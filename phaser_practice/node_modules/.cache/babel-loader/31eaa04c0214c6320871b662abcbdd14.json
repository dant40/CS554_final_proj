{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\n\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Particles.EmitterManager#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitterManager} emitterManager - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\nvar ParticleManagerCanvasRenderer = function (renderer, emitterManager, interpolationPercentage, camera, parentMatrix) {\n  var emitters = emitterManager.emitters.list;\n  var emittersLength = emitters.length;\n\n  if (emittersLength === 0) {\n    return;\n  }\n\n  var camMatrix = renderer._tempMatrix1.copyFrom(camera.matrix);\n\n  var calcMatrix = renderer._tempMatrix2;\n  var particleMatrix = renderer._tempMatrix3;\n\n  var managerMatrix = renderer._tempMatrix4.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);\n\n  camMatrix.multiply(managerMatrix);\n  var roundPixels = camera.roundPixels;\n  var ctx = renderer.currentContext;\n  ctx.save();\n\n  for (var e = 0; e < emittersLength; e++) {\n    var emitter = emitters[e];\n    var particles = emitter.alive;\n    var particleCount = particles.length;\n\n    if (!emitter.visible || particleCount === 0) {\n      continue;\n    }\n\n    var scrollX = camera.scrollX * emitter.scrollFactorX;\n    var scrollY = camera.scrollY * emitter.scrollFactorY;\n\n    if (parentMatrix) {\n      //  Multiply the camera by the parent matrix\n      camMatrix.multiplyWithOffset(parentMatrix, -scrollX, -scrollY);\n      scrollX = 0;\n      scrollY = 0;\n    }\n\n    ctx.globalCompositeOperation = renderer.blendModes[emitter.blendMode];\n\n    for (var i = 0; i < particleCount; i++) {\n      var particle = particles[i];\n      var alpha = particle.alpha * camera.alpha;\n\n      if (alpha <= 0) {\n        continue;\n      }\n\n      var frame = particle.frame;\n      var cd = frame.canvasData;\n      var x = -frame.halfWidth;\n      var y = -frame.halfHeight;\n      particleMatrix.applyITRS(0, 0, particle.rotation, particle.scaleX, particle.scaleY);\n      particleMatrix.e = particle.x - scrollX;\n      particleMatrix.f = particle.y - scrollY;\n      camMatrix.multiply(particleMatrix, calcMatrix);\n      ctx.globalAlpha = alpha;\n      ctx.save();\n      calcMatrix.copyToContext(ctx);\n\n      if (roundPixels) {\n        x = Math.round(x);\n        y = Math.round(y);\n      }\n\n      ctx.imageSmoothingEnabled = !(!renderer.antialias || frame.source.scaleMode);\n      ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);\n      ctx.restore();\n    }\n  }\n\n  ctx.restore();\n};\n\nmodule.exports = ParticleManagerCanvasRenderer;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/particles/ParticleManagerCanvasRenderer.js"],"names":["ParticleManagerCanvasRenderer","renderer","emitterManager","interpolationPercentage","camera","parentMatrix","emitters","list","emittersLength","length","camMatrix","_tempMatrix1","copyFrom","matrix","calcMatrix","_tempMatrix2","particleMatrix","_tempMatrix3","managerMatrix","_tempMatrix4","applyITRS","x","y","rotation","scaleX","scaleY","multiply","roundPixels","ctx","currentContext","save","e","emitter","particles","alive","particleCount","visible","scrollX","scrollFactorX","scrollY","scrollFactorY","multiplyWithOffset","globalCompositeOperation","blendModes","blendMode","i","particle","alpha","frame","cd","canvasData","halfWidth","halfHeight","f","globalAlpha","copyToContext","Math","round","imageSmoothingEnabled","antialias","source","scaleMode","drawImage","image","width","height","restore","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Particles.EmitterManager#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitterManager} emitterManager - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ParticleManagerCanvasRenderer = function (renderer, emitterManager, interpolationPercentage, camera, parentMatrix)\r\n{\r\n    var emitters = emitterManager.emitters.list;\r\n    var emittersLength = emitters.length;\r\n\r\n    if (emittersLength === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var camMatrix = renderer._tempMatrix1.copyFrom(camera.matrix);\r\n    var calcMatrix = renderer._tempMatrix2;\r\n    var particleMatrix = renderer._tempMatrix3;\r\n    var managerMatrix = renderer._tempMatrix4.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);\r\n\r\n    camMatrix.multiply(managerMatrix);\r\n\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    ctx.save();\r\n\r\n    for (var e = 0; e < emittersLength; e++)\r\n    {\r\n        var emitter = emitters[e];\r\n        var particles = emitter.alive;\r\n        var particleCount = particles.length;\r\n\r\n        if (!emitter.visible || particleCount === 0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var scrollX = camera.scrollX * emitter.scrollFactorX;\r\n        var scrollY = camera.scrollY * emitter.scrollFactorY;\r\n\r\n        if (parentMatrix)\r\n        {\r\n            //  Multiply the camera by the parent matrix\r\n            camMatrix.multiplyWithOffset(parentMatrix, -scrollX, -scrollY);\r\n\r\n            scrollX = 0;\r\n            scrollY = 0;\r\n        }\r\n\r\n        ctx.globalCompositeOperation = renderer.blendModes[emitter.blendMode];\r\n\r\n        for (var i = 0; i < particleCount; i++)\r\n        {\r\n            var particle = particles[i];\r\n\r\n            var alpha = particle.alpha * camera.alpha;\r\n\r\n            if (alpha <= 0)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var frame = particle.frame;\r\n            var cd = frame.canvasData;\r\n\r\n            var x = -(frame.halfWidth);\r\n            var y = -(frame.halfHeight);\r\n\r\n            particleMatrix.applyITRS(0, 0, particle.rotation, particle.scaleX, particle.scaleY);\r\n\r\n            particleMatrix.e = particle.x - scrollX;\r\n            particleMatrix.f = particle.y - scrollY;\r\n\r\n            camMatrix.multiply(particleMatrix, calcMatrix);\r\n\r\n            ctx.globalAlpha = alpha;\r\n        \r\n            ctx.save();\r\n\r\n            calcMatrix.copyToContext(ctx);\r\n\r\n            if (roundPixels)\r\n            {\r\n                x = Math.round(x);\r\n                y = Math.round(y);\r\n            }\r\n\r\n            ctx.imageSmoothingEnabled = !(!renderer.antialias || frame.source.scaleMode);\r\n\r\n            ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);\r\n\r\n            ctx.restore();\r\n        }\r\n    }\r\n\r\n    ctx.restore();\r\n};\r\n\r\nmodule.exports = ParticleManagerCanvasRenderer;\r\n"]},"metadata":{},"sourceType":"script"}