{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\n//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse\nfunction hasGetterOrSetter(def) {\n  return !!def.get && typeof def.get === 'function' || !!def.set && typeof def.set === 'function';\n}\n\nfunction getProperty(definition, k, isClassDescriptor) {\n  //  This may be a lightweight object, OR it might be a property that was defined previously.\n  //  For simple class descriptors we can just assume its NOT previously defined.\n  var def = isClassDescriptor ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);\n\n  if (!isClassDescriptor && def.value && typeof def.value === 'object') {\n    def = def.value;\n  } //  This might be a regular property, or it may be a getter/setter the user defined in a class.\n\n\n  if (def && hasGetterOrSetter(def)) {\n    if (typeof def.enumerable === 'undefined') {\n      def.enumerable = true;\n    }\n\n    if (typeof def.configurable === 'undefined') {\n      def.configurable = true;\n    }\n\n    return def;\n  } else {\n    return false;\n  }\n}\n\nfunction hasNonConfigurable(obj, k) {\n  var prop = Object.getOwnPropertyDescriptor(obj, k);\n\n  if (!prop) {\n    return false;\n  }\n\n  if (prop.value && typeof prop.value === 'object') {\n    prop = prop.value;\n  }\n\n  if (prop.configurable === false) {\n    return true;\n  }\n\n  return false;\n}\n/**\r\n * Extends the given `myClass` object's prototype with the properties of `definition`.\r\n *\r\n * @function extend\r\n * @param {Object} ctor The constructor object to mix into.\r\n * @param {Object} definition A dictionary of functions for the class.\r\n * @param {boolean} isClassDescriptor Is the definition a class descriptor?\r\n * @param {Object} [extend] The parent constructor object.\r\n */\n\n\nfunction extend(ctor, definition, isClassDescriptor, extend) {\n  for (var k in definition) {\n    if (!definition.hasOwnProperty(k)) {\n      continue;\n    }\n\n    var def = getProperty(definition, k, isClassDescriptor);\n\n    if (def !== false) {\n      //  If Extends is used, we will check its prototype to see if the final variable exists.\n      var parent = extend || ctor;\n\n      if (hasNonConfigurable(parent.prototype, k)) {\n        //  Just skip the final property\n        if (Class.ignoreFinals) {\n          continue;\n        } //  We cannot re-define a property that is configurable=false.\n        //  So we will consider them final and throw an error. This is by\n        //  default so it is clear to the developer what is happening.\n        //  You can set ignoreFinals to true if you need to extend a class\n        //  which has configurable=false; it will simply not re-define final properties.\n\n\n        throw new Error('cannot override final property \\'' + k + '\\', set Class.ignoreFinals = true to skip');\n      }\n\n      Object.defineProperty(ctor.prototype, k, def);\n    } else {\n      ctor.prototype[k] = definition[k];\n    }\n  }\n}\n/**\r\n * Applies the given `mixins` to the prototype of `myClass`.\r\n *\r\n * @function mixin\r\n * @param {Object} myClass The constructor object to mix into.\r\n * @param {Object|Array<Object>} mixins The mixins to apply to the constructor.\r\n */\n\n\nfunction mixin(myClass, mixins) {\n  if (!mixins) {\n    return;\n  }\n\n  if (!Array.isArray(mixins)) {\n    mixins = [mixins];\n  }\n\n  for (var i = 0; i < mixins.length; i++) {\n    extend(myClass, mixins[i].prototype || mixins[i]);\n  }\n}\n/**\r\n * Creates a new class with the given descriptor.\r\n * The constructor, defined by the name `initialize`,\r\n * is an optional function. If unspecified, an anonymous\r\n * function will be used which calls the parent class (if\r\n * one exists).\r\n *\r\n * You can also use `Extends` and `Mixins` to provide subclassing\r\n * and inheritance.\r\n *\r\n * @class Phaser.Class\r\n * @constructor\r\n * @param {Object} definition a dictionary of functions for the class\r\n * @example\r\n *\r\n *      var MyClass = new Phaser.Class({\r\n *\r\n *          initialize: function() {\r\n *              this.foo = 2.0;\r\n *          },\r\n *\r\n *          bar: function() {\r\n *              return this.foo + 5;\r\n *          }\r\n *      });\r\n */\n\n\nfunction Class(definition) {\n  if (!definition) {\n    definition = {};\n  } //  The variable name here dictates what we see in Chrome debugger\n\n\n  var initialize;\n  var Extends;\n\n  if (definition.initialize) {\n    if (typeof definition.initialize !== 'function') {\n      throw new Error('initialize must be a function');\n    }\n\n    initialize = definition.initialize; //  Usually we should avoid 'delete' in V8 at all costs.\n    //  However, its unlikely to make any performance difference\n    //  here since we only call this on class creation (i.e. not object creation).\n\n    delete definition.initialize;\n  } else if (definition.Extends) {\n    var base = definition.Extends;\n\n    initialize = function () {\n      base.apply(this, arguments);\n    };\n  } else {\n    initialize = function () {};\n  }\n\n  if (definition.Extends) {\n    initialize.prototype = Object.create(definition.Extends.prototype);\n    initialize.prototype.constructor = initialize; //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)\n\n    Extends = definition.Extends;\n    delete definition.Extends;\n  } else {\n    initialize.prototype.constructor = initialize;\n  } //  Grab the mixins, if they are specified...\n\n\n  var mixins = null;\n\n  if (definition.Mixins) {\n    mixins = definition.Mixins;\n    delete definition.Mixins;\n  } //  First, mixin if we can.\n\n\n  mixin(initialize, mixins); //  Now we grab the actual definition which defines the overrides.\n\n  extend(initialize, definition, true, Extends);\n  return initialize;\n}\n\nClass.extend = extend;\nClass.mixin = mixin;\nClass.ignoreFinals = false;\nmodule.exports = Class;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/utils/Class.js"],"names":["hasGetterOrSetter","def","get","set","getProperty","definition","k","isClassDescriptor","Object","getOwnPropertyDescriptor","value","enumerable","configurable","hasNonConfigurable","obj","prop","extend","ctor","hasOwnProperty","parent","prototype","Class","ignoreFinals","Error","defineProperty","mixin","myClass","mixins","Array","isArray","i","length","initialize","Extends","base","apply","arguments","create","constructor","Mixins","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse\r\n\r\nfunction hasGetterOrSetter (def)\r\n{\r\n    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');\r\n}\r\n\r\nfunction getProperty (definition, k, isClassDescriptor)\r\n{\r\n    //  This may be a lightweight object, OR it might be a property that was defined previously.\r\n\r\n    //  For simple class descriptors we can just assume its NOT previously defined.\r\n    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);\r\n\r\n    if (!isClassDescriptor && def.value && typeof def.value === 'object')\r\n    {\r\n        def = def.value;\r\n    }\r\n\r\n    //  This might be a regular property, or it may be a getter/setter the user defined in a class.\r\n    if (def && hasGetterOrSetter(def))\r\n    {\r\n        if (typeof def.enumerable === 'undefined')\r\n        {\r\n            def.enumerable = true;\r\n        }\r\n\r\n        if (typeof def.configurable === 'undefined')\r\n        {\r\n            def.configurable = true;\r\n        }\r\n\r\n        return def;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction hasNonConfigurable (obj, k)\r\n{\r\n    var prop = Object.getOwnPropertyDescriptor(obj, k);\r\n\r\n    if (!prop)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (prop.value && typeof prop.value === 'object')\r\n    {\r\n        prop = prop.value;\r\n    }\r\n\r\n    if (prop.configurable === false)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Extends the given `myClass` object's prototype with the properties of `definition`.\r\n *\r\n * @function extend\r\n * @param {Object} ctor The constructor object to mix into.\r\n * @param {Object} definition A dictionary of functions for the class.\r\n * @param {boolean} isClassDescriptor Is the definition a class descriptor?\r\n * @param {Object} [extend] The parent constructor object.\r\n */\r\nfunction extend (ctor, definition, isClassDescriptor, extend)\r\n{\r\n    for (var k in definition)\r\n    {\r\n        if (!definition.hasOwnProperty(k))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var def = getProperty(definition, k, isClassDescriptor);\r\n\r\n        if (def !== false)\r\n        {\r\n            //  If Extends is used, we will check its prototype to see if the final variable exists.\r\n\r\n            var parent = extend || ctor;\r\n\r\n            if (hasNonConfigurable(parent.prototype, k))\r\n            {\r\n                //  Just skip the final property\r\n                if (Class.ignoreFinals)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  We cannot re-define a property that is configurable=false.\r\n                //  So we will consider them final and throw an error. This is by\r\n                //  default so it is clear to the developer what is happening.\r\n                //  You can set ignoreFinals to true if you need to extend a class\r\n                //  which has configurable=false; it will simply not re-define final properties.\r\n                throw new Error('cannot override final property \\'' + k + '\\', set Class.ignoreFinals = true to skip');\r\n            }\r\n\r\n            Object.defineProperty(ctor.prototype, k, def);\r\n        }\r\n        else\r\n        {\r\n            ctor.prototype[k] = definition[k];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Applies the given `mixins` to the prototype of `myClass`.\r\n *\r\n * @function mixin\r\n * @param {Object} myClass The constructor object to mix into.\r\n * @param {Object|Array<Object>} mixins The mixins to apply to the constructor.\r\n */\r\nfunction mixin (myClass, mixins)\r\n{\r\n    if (!mixins)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!Array.isArray(mixins))\r\n    {\r\n        mixins = [ mixins ];\r\n    }\r\n\r\n    for (var i = 0; i < mixins.length; i++)\r\n    {\r\n        extend(myClass, mixins[i].prototype || mixins[i]);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a new class with the given descriptor.\r\n * The constructor, defined by the name `initialize`,\r\n * is an optional function. If unspecified, an anonymous\r\n * function will be used which calls the parent class (if\r\n * one exists).\r\n *\r\n * You can also use `Extends` and `Mixins` to provide subclassing\r\n * and inheritance.\r\n *\r\n * @class Phaser.Class\r\n * @constructor\r\n * @param {Object} definition a dictionary of functions for the class\r\n * @example\r\n *\r\n *      var MyClass = new Phaser.Class({\r\n *\r\n *          initialize: function() {\r\n *              this.foo = 2.0;\r\n *          },\r\n *\r\n *          bar: function() {\r\n *              return this.foo + 5;\r\n *          }\r\n *      });\r\n */\r\nfunction Class (definition)\r\n{\r\n    if (!definition)\r\n    {\r\n        definition = {};\r\n    }\r\n\r\n    //  The variable name here dictates what we see in Chrome debugger\r\n    var initialize;\r\n    var Extends;\r\n\r\n    if (definition.initialize)\r\n    {\r\n        if (typeof definition.initialize !== 'function')\r\n        {\r\n            throw new Error('initialize must be a function');\r\n        }\r\n\r\n        initialize = definition.initialize;\r\n\r\n        //  Usually we should avoid 'delete' in V8 at all costs.\r\n        //  However, its unlikely to make any performance difference\r\n        //  here since we only call this on class creation (i.e. not object creation).\r\n        delete definition.initialize;\r\n    }\r\n    else if (definition.Extends)\r\n    {\r\n        var base = definition.Extends;\r\n\r\n        initialize = function ()\r\n        {\r\n            base.apply(this, arguments);\r\n        };\r\n    }\r\n    else\r\n    {\r\n        initialize = function () {};\r\n    }\r\n\r\n    if (definition.Extends)\r\n    {\r\n        initialize.prototype = Object.create(definition.Extends.prototype);\r\n        initialize.prototype.constructor = initialize;\r\n\r\n        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)\r\n\r\n        Extends = definition.Extends;\r\n\r\n        delete definition.Extends;\r\n    }\r\n    else\r\n    {\r\n        initialize.prototype.constructor = initialize;\r\n    }\r\n\r\n    //  Grab the mixins, if they are specified...\r\n    var mixins = null;\r\n\r\n    if (definition.Mixins)\r\n    {\r\n        mixins = definition.Mixins;\r\n        delete definition.Mixins;\r\n    }\r\n\r\n    //  First, mixin if we can.\r\n    mixin(initialize, mixins);\r\n\r\n    //  Now we grab the actual definition which defines the overrides.\r\n    extend(initialize, definition, true, Extends);\r\n\r\n    return initialize;\r\n}\r\n\r\nClass.extend = extend;\r\nClass.mixin = mixin;\r\nClass.ignoreFinals = false;\r\n\r\nmodule.exports = Class;\r\n"]},"metadata":{},"sourceType":"script"}