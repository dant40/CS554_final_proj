{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar Components = require('../../gameobjects/components');\n\nvar DegToRad = require('../../math/DegToRad');\n\nvar EventEmitter = require('eventemitter3');\n\nvar Events = require('./events');\n\nvar Rectangle = require('../../geom/rectangle/Rectangle');\n\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\n\nvar ValueToColor = require('../../display/color/ValueToColor');\n\nvar Vector2 = require('../../math/Vector2');\n/**\r\n * @classdesc\r\n * A Base Camera class.\r\n *\r\n * The Camera is the way in which all games are rendered in Phaser. They provide a view into your game world,\r\n * and can be positioned, rotated, zoomed and scrolled accordingly.\r\n *\r\n * A Camera consists of two elements: The viewport and the scroll values.\r\n *\r\n * The viewport is the physical position and size of the Camera within your game. Cameras, by default, are\r\n * created the same size as your game, but their position and size can be set to anything. This means if you\r\n * wanted to create a camera that was 320x200 in size, positioned in the bottom-right corner of your game,\r\n * you'd adjust the viewport to do that (using methods like `setViewport` and `setSize`).\r\n *\r\n * If you wish to change where the Camera is looking in your game, then you scroll it. You can do this\r\n * via the properties `scrollX` and `scrollY` or the method `setScroll`. Scrolling has no impact on the\r\n * viewport, and changing the viewport has no impact on the scrolling.\r\n *\r\n * By default a Camera will render all Game Objects it can see. You can change this using the `ignore` method,\r\n * allowing you to filter Game Objects out on a per-Camera basis.\r\n * \r\n * The Base Camera is extended by the Camera class, which adds in special effects including Fade,\r\n * Flash and Camera Shake, as well as the ability to follow Game Objects.\r\n * \r\n * The Base Camera was introduced in Phaser 3.12. It was split off from the Camera class, to allow\r\n * you to isolate special effects as needed. Therefore the 'since' values for properties of this class relate\r\n * to when they were added to the Camera class.\r\n *\r\n * @class BaseCamera\r\n * @memberof Phaser.Cameras.Scene2D\r\n * @constructor\r\n * @since 3.12.0\r\n * \r\n * @extends Phaser.Events.EventEmitter\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {number} x - The x position of the Camera, relative to the top-left of the game canvas.\r\n * @param {number} y - The y position of the Camera, relative to the top-left of the game canvas.\r\n * @param {number} width - The width of the Camera, in pixels.\r\n * @param {number} height - The height of the Camera, in pixels.\r\n */\n\n\nvar BaseCamera = new Class({\n  Extends: EventEmitter,\n  Mixins: [Components.Alpha, Components.Visible],\n  initialize: function BaseCamera(x, y, width, height) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = 0;\n    }\n\n    if (height === undefined) {\n      height = 0;\n    }\n\n    EventEmitter.call(this);\n    /**\r\n     * A reference to the Scene this camera belongs to.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n\n    this.scene;\n    /**\r\n     * A reference to the Game Scene Manager.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#sceneManager\r\n     * @type {Phaser.Scenes.SceneManager}\r\n     * @since 3.12.0\r\n     */\n\n    this.sceneManager;\n    /**\r\n     * A reference to the Game Scale Manager.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#scaleManager\r\n     * @type {Phaser.Scale.ScaleManager}\r\n     * @since 3.16.0\r\n     */\n\n    this.scaleManager;\n    /**\r\n     * A reference to the Scene's Camera Manager to which this Camera belongs.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#cameraManager\r\n     * @type {Phaser.Cameras.Scene2D.CameraManager}\r\n     * @since 3.17.0\r\n     */\n\n    this.cameraManager;\n    /**\r\n     * The Camera ID. Assigned by the Camera Manager and used to handle camera exclusion.\r\n     * This value is a bitmask.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#id\r\n     * @type {integer}\r\n     * @readonly\r\n     * @since 3.11.0\r\n     */\n\n    this.id = 0;\n    /**\r\n     * The name of the Camera. This is left empty for your own use.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#name\r\n     * @type {string}\r\n     * @default ''\r\n     * @since 3.0.0\r\n     */\n\n    this.name = '';\n    /**\r\n     * This property is un-used in v3.16.\r\n     * \r\n     * The resolution of the Game, used in most Camera calculations.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#resolution\r\n     * @type {number}\r\n     * @readonly\r\n     * @deprecated\r\n     * @since 3.12.0\r\n     */\n\n    this.resolution = 1;\n    /**\r\n     * Should this camera round its pixel values to integers?\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#roundPixels\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.roundPixels = false;\n    /**\r\n     * Is this Camera visible or not?\r\n     *\r\n     * A visible camera will render and perform input tests.\r\n     * An invisible camera will not render anything and will skip input tests.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#visible\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.10.0\r\n     */\n\n    /**\r\n     * Is this Camera using a bounds to restrict scrolling movement?\r\n     *\r\n     * Set this property along with the bounds via `Camera.setBounds`.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#useBounds\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.useBounds = false;\n    /**\r\n     * The World View is a Rectangle that defines the area of the 'world' the Camera is currently looking at.\r\n     * This factors in the Camera viewport size, zoom and scroll position and is updated in the Camera preRender step.\r\n     * If you have enabled Camera bounds the worldview will be clamped to those bounds accordingly.\r\n     * You can use it for culling or intersection checks.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#worldView\r\n     * @type {Phaser.Geom.Rectangle}\r\n     * @readonly\r\n     * @since 3.11.0\r\n     */\n\n    this.worldView = new Rectangle();\n    /**\r\n     * Is this Camera dirty?\r\n     * \r\n     * A dirty Camera has had either its viewport size, bounds, scroll, rotation or zoom levels changed since the last frame.\r\n     * \r\n     * This flag is cleared during the `postRenderCamera` method of the renderer.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#dirty\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.11.0\r\n     */\n\n    this.dirty = true;\n    /**\r\n     * The x position of the Camera viewport, relative to the top-left of the game canvas.\r\n     * The viewport is the area into which the camera renders.\r\n     * To adjust the position the camera is looking at in the game world, see the `scrollX` value.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#x\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._x = x;\n    /**\r\n     * The y position of the Camera, relative to the top-left of the game canvas.\r\n     * The viewport is the area into which the camera renders.\r\n     * To adjust the position the camera is looking at in the game world, see the `scrollY` value.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#y\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._y = y;\n    /**\r\n     * Internal Camera X value multiplied by the resolution.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_cx\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._cx = 0;\n    /**\r\n     * Internal Camera Y value multiplied by the resolution.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_cy\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._cy = 0;\n    /**\r\n     * Internal Camera Width value multiplied by the resolution.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_cw\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._cw = 0;\n    /**\r\n     * Internal Camera Height value multiplied by the resolution.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_ch\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.12.0\r\n     */\n\n    this._ch = 0;\n    /**\r\n     * The width of the Camera viewport, in pixels.\r\n     *\r\n     * The viewport is the area into which the Camera renders. Setting the viewport does\r\n     * not restrict where the Camera can scroll to.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_width\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.11.0\r\n     */\n\n    this._width = width;\n    /**\r\n     * The height of the Camera viewport, in pixels.\r\n     *\r\n     * The viewport is the area into which the Camera renders. Setting the viewport does\r\n     * not restrict where the Camera can scroll to.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_height\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.11.0\r\n     */\n\n    this._height = height;\n    /**\r\n     * The bounds the camera is restrained to during scrolling.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_bounds\r\n     * @type {Phaser.Geom.Rectangle}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this._bounds = new Rectangle();\n    /**\r\n     * The horizontal scroll position of this Camera.\r\n     *\r\n     * Change this value to cause the Camera to scroll around your Scene.\r\n     *\r\n     * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,\r\n     * will automatically adjust the Camera scroll values accordingly.\r\n     *\r\n     * You can set the bounds within which the Camera can scroll via the `setBounds` method.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_scrollX\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.11.0\r\n     */\n\n    this._scrollX = 0;\n    /**\r\n     * The vertical scroll position of this Camera.\r\n     *\r\n     * Change this value to cause the Camera to scroll around your Scene.\r\n     *\r\n     * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,\r\n     * will automatically adjust the Camera scroll values accordingly.\r\n     *\r\n     * You can set the bounds within which the Camera can scroll via the `setBounds` method.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_scrollY\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.11.0\r\n     */\n\n    this._scrollY = 0;\n    /**\r\n     * The Camera zoom value. Change this value to zoom in, or out of, a Scene.\r\n     *\r\n     * A value of 0.5 would zoom the Camera out, so you can now see twice as much\r\n     * of the Scene as before. A value of 2 would zoom the Camera in, so every pixel\r\n     * now takes up 2 pixels when rendered.\r\n     *\r\n     * Set to 1 to return to the default zoom level.\r\n     *\r\n     * Be careful to never set this value to zero.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_zoom\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.11.0\r\n     */\n\n    this._zoom = 1;\n    /**\r\n     * The rotation of the Camera in radians.\r\n     *\r\n     * Camera rotation always takes place based on the Camera viewport. By default, rotation happens\r\n     * in the center of the viewport. You can adjust this with the `originX` and `originY` properties.\r\n     *\r\n     * Rotation influences the rendering of _all_ Game Objects visible by this Camera. However, it does not\r\n     * rotate the Camera viewport itself, which always remains an axis-aligned rectangle.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_rotation\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.11.0\r\n     */\n\n    this._rotation = 0;\n    /**\r\n     * A local transform matrix used for internal calculations.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#matrix\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this.matrix = new TransformMatrix();\n    /**\r\n     * Does this Camera have a transparent background?\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#transparent\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.transparent = true;\n    /**\r\n     * The background color of this Camera. Only used if `transparent` is `false`.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#backgroundColor\r\n     * @type {Phaser.Display.Color}\r\n     * @since 3.0.0\r\n     */\n\n    this.backgroundColor = ValueToColor('rgba(0,0,0,0)');\n    /**\r\n     * The Camera alpha value. Setting this property impacts every single object that this Camera\r\n     * renders. You can either set the property directly, i.e. via a Tween, to fade a Camera in or out,\r\n     * or via the chainable `setAlpha` method instead.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#alpha\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.11.0\r\n     */\n\n    /**\r\n     * Should the camera cull Game Objects before checking them for input hit tests?\r\n     * In some special cases it may be beneficial to disable this.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#disableCull\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\n\n    this.disableCull = false;\n    /**\r\n     * A temporary array of culled objects.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#culledObjects\r\n     * @type {Phaser.GameObjects.GameObject[]}\r\n     * @default []\r\n     * @private\r\n     * @since 3.0.0\r\n     */\n\n    this.culledObjects = [];\n    /**\r\n     * The mid-point of the Camera in 'world' coordinates.\r\n     *\r\n     * Use it to obtain exactly where in the world the center of the camera is currently looking.\r\n     *\r\n     * This value is updated in the preRender method, after the scroll values and follower\r\n     * have been processed.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#midPoint\r\n     * @type {Phaser.Math.Vector2}\r\n     * @readonly\r\n     * @since 3.11.0\r\n     */\n\n    this.midPoint = new Vector2(width / 2, height / 2);\n    /**\r\n     * The horizontal origin of rotation for this Camera.\r\n     *\r\n     * By default the camera rotates around the center of the viewport.\r\n     *\r\n     * Changing the origin allows you to adjust the point in the viewport from which rotation happens.\r\n     * A value of 0 would rotate from the top-left of the viewport. A value of 1 from the bottom right.\r\n     *\r\n     * See `setOrigin` to set both origins in a single, chainable call.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#originX\r\n     * @type {number}\r\n     * @default 0.5\r\n     * @since 3.11.0\r\n     */\n\n    this.originX = 0.5;\n    /**\r\n     * The vertical origin of rotation for this Camera.\r\n     *\r\n     * By default the camera rotates around the center of the viewport.\r\n     *\r\n     * Changing the origin allows you to adjust the point in the viewport from which rotation happens.\r\n     * A value of 0 would rotate from the top-left of the viewport. A value of 1 from the bottom right.\r\n     *\r\n     * See `setOrigin` to set both origins in a single, chainable call.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#originY\r\n     * @type {number}\r\n     * @default 0.5\r\n     * @since 3.11.0\r\n     */\n\n    this.originY = 0.5;\n    /**\r\n     * Does this Camera have a custom viewport?\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_customViewport\r\n     * @type {boolean}\r\n     * @private\r\n     * @default false\r\n     * @since 3.12.0\r\n     */\n\n    this._customViewport = false;\n    /**\r\n     * The Mask this Camera is using during render.\r\n     * Set the mask using the `setMask` method. Remove the mask using the `clearMask` method.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#mask\r\n     * @type {?(Phaser.Display.Masks.BitmapMask|Phaser.Display.Masks.GeometryMask)}\r\n     * @since 3.17.0\r\n     */\n\n    this.mask = null;\n    /**\r\n     * The Camera that this Camera uses for translation during masking.\r\n     * \r\n     * If the mask is fixed in position this will be a reference to\r\n     * the CameraManager.default instance. Otherwise, it'll be a reference\r\n     * to itself.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#_maskCamera\r\n     * @type {?Phaser.Cameras.Scene2D.BaseCamera}\r\n     * @private\r\n     * @since 3.17.0\r\n     */\n\n    this._maskCamera = null;\n  },\n\n  /**\r\n   * Set the Alpha level of this Camera. The alpha controls the opacity of the Camera as it renders.\r\n   * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setAlpha\r\n   * @since 3.11.0\r\n   *\r\n   * @param {number} [value=1] - The Camera alpha value.\r\n   *\r\n   * @return {this} This Camera instance.\r\n   */\n\n  /**\r\n   * Sets the rotation origin of this Camera.\r\n   *\r\n   * The values are given in the range 0 to 1 and are only used when calculating Camera rotation.\r\n   *\r\n   * By default the camera rotates around the center of the viewport.\r\n   *\r\n   * Changing the origin allows you to adjust the point in the viewport from which rotation happens.\r\n   * A value of 0 would rotate from the top-left of the viewport. A value of 1 from the bottom right.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setOrigin\r\n   * @since 3.11.0\r\n   *\r\n   * @param {number} [x=0.5] - The horizontal origin value.\r\n   * @param {number} [y=x] - The vertical origin value. If not defined it will be set to the value of `x`.\r\n   *\r\n   * @return {this} This Camera instance.\r\n   */\n  setOrigin: function (x, y) {\n    if (x === undefined) {\n      x = 0.5;\n    }\n\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.originX = x;\n    this.originY = y;\n    return this;\n  },\n\n  /**\r\n   * Calculates what the Camera.scrollX and scrollY values would need to be in order to move\r\n   * the Camera so it is centered on the given x and y coordinates, without actually moving\r\n   * the Camera there. The results are clamped based on the Camera bounds, if set.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#getScroll\r\n   * @since 3.11.0\r\n   *\r\n   * @param {number} x - The horizontal coordinate to center on.\r\n   * @param {number} y - The vertical coordinate to center on.\r\n   * @param {Phaser.Math.Vector2} [out] - A Vector2 to store the values in. If not given a new Vector2 is created.\r\n   *\r\n   * @return {Phaser.Math.Vector2} The scroll coordinates stored in the `x` and `y` properties.\r\n   */\n  getScroll: function (x, y, out) {\n    if (out === undefined) {\n      out = new Vector2();\n    }\n\n    var originX = this.width * 0.5;\n    var originY = this.height * 0.5;\n    out.x = x - originX;\n    out.y = y - originY;\n\n    if (this.useBounds) {\n      out.x = this.clampX(out.x);\n      out.y = this.clampY(out.y);\n    }\n\n    return out;\n  },\n\n  /**\r\n   * Moves the Camera horizontally so that it is centered on the given x coordinate, bounds allowing.\r\n   * Calling this does not change the scrollY value.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#centerOnX\r\n   * @since 3.16.0\r\n   *\r\n   * @param {number} x - The horizontal coordinate to center on.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  centerOnX: function (x) {\n    var originX = this.width * 0.5;\n    this.midPoint.x = x;\n    this.scrollX = x - originX;\n\n    if (this.useBounds) {\n      this.scrollX = this.clampX(this.scrollX);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Moves the Camera vertically so that it is centered on the given y coordinate, bounds allowing.\r\n   * Calling this does not change the scrollX value.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#centerOnY\r\n   * @since 3.16.0\r\n   *\r\n   * @param {number} y - The vertical coordinate to center on.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  centerOnY: function (y) {\n    var originY = this.height * 0.5;\n    this.midPoint.y = y;\n    this.scrollY = y - originY;\n\n    if (this.useBounds) {\n      this.scrollY = this.clampY(this.scrollY);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Moves the Camera so that it is centered on the given coordinates, bounds allowing.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#centerOn\r\n   * @since 3.11.0\r\n   *\r\n   * @param {number} x - The horizontal coordinate to center on.\r\n   * @param {number} y - The vertical coordinate to center on.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  centerOn: function (x, y) {\n    this.centerOnX(x);\n    this.centerOnY(y);\n    return this;\n  },\n\n  /**\r\n   * Moves the Camera so that it is looking at the center of the Camera Bounds, if enabled.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#centerToBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  centerToBounds: function () {\n    if (this.useBounds) {\n      var bounds = this._bounds;\n      var originX = this.width * 0.5;\n      var originY = this.height * 0.5;\n      this.midPoint.set(bounds.centerX, bounds.centerY);\n      this.scrollX = bounds.centerX - originX;\n      this.scrollY = bounds.centerY - originY;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Moves the Camera so that it is re-centered based on its viewport size.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#centerToSize\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  centerToSize: function () {\n    this.scrollX = this.width * 0.5;\n    this.scrollY = this.height * 0.5;\n    return this;\n  },\n\n  /**\r\n   * Takes an array of Game Objects and returns a new array featuring only those objects\r\n   * visible by this camera.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#cull\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.GameObjects.GameObject[]} G - [renderableObjects,$return]\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject[]} renderableObjects - An array of Game Objects to cull.\r\n   *\r\n   * @return {Phaser.GameObjects.GameObject[]} An array of Game Objects visible to this Camera.\r\n   */\n  cull: function (renderableObjects) {\n    if (this.disableCull) {\n      return renderableObjects;\n    }\n\n    var cameraMatrix = this.matrix.matrix;\n    var mva = cameraMatrix[0];\n    var mvb = cameraMatrix[1];\n    var mvc = cameraMatrix[2];\n    var mvd = cameraMatrix[3];\n    /* First Invert Matrix */\n\n    var determinant = mva * mvd - mvb * mvc;\n\n    if (!determinant) {\n      return renderableObjects;\n    }\n\n    var mve = cameraMatrix[4];\n    var mvf = cameraMatrix[5];\n    var scrollX = this.scrollX;\n    var scrollY = this.scrollY;\n    var cameraW = this.width;\n    var cameraH = this.height;\n    var culledObjects = this.culledObjects;\n    var length = renderableObjects.length;\n    determinant = 1 / determinant;\n    culledObjects.length = 0;\n\n    for (var index = 0; index < length; ++index) {\n      var object = renderableObjects[index];\n\n      if (!object.hasOwnProperty('width') || object.parentContainer) {\n        culledObjects.push(object);\n        continue;\n      }\n\n      var objectW = object.width;\n      var objectH = object.height;\n      var objectX = object.x - scrollX * object.scrollFactorX - objectW * object.originX;\n      var objectY = object.y - scrollY * object.scrollFactorY - objectH * object.originY;\n      var tx = objectX * mva + objectY * mvc + mve;\n      var ty = objectX * mvb + objectY * mvd + mvf;\n      var tw = (objectX + objectW) * mva + (objectY + objectH) * mvc + mve;\n      var th = (objectX + objectW) * mvb + (objectY + objectH) * mvd + mvf;\n      var cullTop = this.y;\n      var cullBottom = cullTop + cameraH;\n      var cullLeft = this.x;\n      var cullRight = cullLeft + cameraW;\n\n      if (tw > cullLeft && tx < cullRight && th > cullTop && ty < cullBottom) {\n        culledObjects.push(object);\n      }\n    }\n\n    return culledObjects;\n  },\n\n  /**\r\n   * Converts the given `x` and `y` coordinates into World space, based on this Cameras transform.\r\n   * You can optionally provide a Vector2, or similar object, to store the results in.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#getWorldPoint\r\n   * @since 3.0.0\r\n   *\r\n   * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n   *\r\n   * @param {number} x - The x position to convert to world space.\r\n   * @param {number} y - The y position to convert to world space.\r\n   * @param {(object|Phaser.Math.Vector2)} [output] - An optional object to store the results in. If not provided a new Vector2 will be created.\r\n   *\r\n   * @return {Phaser.Math.Vector2} An object holding the converted values in its `x` and `y` properties.\r\n   */\n  getWorldPoint: function (x, y, output) {\n    if (output === undefined) {\n      output = new Vector2();\n    }\n\n    var cameraMatrix = this.matrix.matrix;\n    var mva = cameraMatrix[0];\n    var mvb = cameraMatrix[1];\n    var mvc = cameraMatrix[2];\n    var mvd = cameraMatrix[3];\n    var mve = cameraMatrix[4];\n    var mvf = cameraMatrix[5]; //  Invert Matrix\n\n    var determinant = mva * mvd - mvb * mvc;\n\n    if (!determinant) {\n      output.x = x;\n      output.y = y;\n      return output;\n    }\n\n    determinant = 1 / determinant;\n    var ima = mvd * determinant;\n    var imb = -mvb * determinant;\n    var imc = -mvc * determinant;\n    var imd = mva * determinant;\n    var ime = (mvc * mvf - mvd * mve) * determinant;\n    var imf = (mvb * mve - mva * mvf) * determinant;\n    var c = Math.cos(this.rotation);\n    var s = Math.sin(this.rotation);\n    var zoom = this.zoom;\n    var res = this.resolution;\n    var scrollX = this.scrollX;\n    var scrollY = this.scrollY; //  Works for zoom of 1 with any resolution, but resolution > 1 and zoom !== 1 breaks\n\n    var sx = x + (scrollX * c - scrollY * s) * zoom;\n    var sy = y + (scrollX * s + scrollY * c) * zoom; //  Apply transform to point\n\n    output.x = (sx * ima + sy * imc) * res + ime;\n    output.y = (sx * imb + sy * imd) * res + imf;\n    return output;\n  },\n\n  /**\r\n   * Given a Game Object, or an array of Game Objects, it will update all of their camera filter settings\r\n   * so that they are ignored by this Camera. This means they will not be rendered by this Camera.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#ignore\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group)} entries - The Game Object, or array of Game Objects, to be ignored by this Camera.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  ignore: function (entries) {\n    var id = this.id;\n\n    if (!Array.isArray(entries)) {\n      entries = [entries];\n    }\n\n    for (var i = 0; i < entries.length; i++) {\n      var entry = entries[i];\n\n      if (Array.isArray(entry)) {\n        this.ignore(entry);\n      } else if (entry.isParent) {\n        this.ignore(entry.getChildren());\n      } else {\n        entry.cameraFilter |= id;\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Internal preRender step.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#preRender\r\n   * @protected\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} resolution - The game resolution, as set in the Scale Manager.\r\n   */\n  preRender: function (resolution) {\n    var width = this.width;\n    var height = this.height;\n    var halfWidth = width * 0.5;\n    var halfHeight = height * 0.5;\n    var zoom = this.zoom * resolution;\n    var matrix = this.matrix;\n    var originX = width * this.originX;\n    var originY = height * this.originY;\n    var sx = this.scrollX;\n    var sy = this.scrollY;\n\n    if (this.useBounds) {\n      sx = this.clampX(sx);\n      sy = this.clampY(sy);\n    }\n\n    if (this.roundPixels) {\n      originX = Math.round(originX);\n      originY = Math.round(originY);\n    } //  Values are in pixels and not impacted by zooming the Camera\n\n\n    this.scrollX = sx;\n    this.scrollY = sy;\n    var midX = sx + halfWidth;\n    var midY = sy + halfHeight; //  The center of the camera, in world space, so taking zoom into account\n    //  Basically the pixel value of what it's looking at in the middle of the cam\n\n    this.midPoint.set(midX, midY);\n    var displayWidth = width / zoom;\n    var displayHeight = height / zoom;\n    this.worldView.setTo(midX - displayWidth / 2, midY - displayHeight / 2, displayWidth, displayHeight);\n    matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoom, zoom);\n    matrix.translate(-originX, -originY);\n  },\n\n  /**\r\n   * Takes an x value and checks it's within the range of the Camera bounds, adjusting if required.\r\n   * Do not call this method if you are not using camera bounds.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#clampX\r\n   * @since 3.11.0\r\n   *\r\n   * @param {number} x - The value to horizontally scroll clamp.\r\n   *\r\n   * @return {number} The adjusted value to use as scrollX.\r\n   */\n  clampX: function (x) {\n    var bounds = this._bounds;\n    var dw = this.displayWidth;\n    var bx = bounds.x + (dw - this.width) / 2;\n    var bw = Math.max(bx, bx + bounds.width - dw);\n\n    if (x < bx) {\n      x = bx;\n    } else if (x > bw) {\n      x = bw;\n    }\n\n    return x;\n  },\n\n  /**\r\n   * Takes a y value and checks it's within the range of the Camera bounds, adjusting if required.\r\n   * Do not call this method if you are not using camera bounds.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#clampY\r\n   * @since 3.11.0\r\n   *\r\n   * @param {number} y - The value to vertically scroll clamp.\r\n   *\r\n   * @return {number} The adjusted value to use as scrollY.\r\n   */\n  clampY: function (y) {\n    var bounds = this._bounds;\n    var dh = this.displayHeight;\n    var by = bounds.y + (dh - this.height) / 2;\n    var bh = Math.max(by, by + bounds.height - dh);\n\n    if (y < by) {\n      y = by;\n    } else if (y > bh) {\n      y = bh;\n    }\n\n    return y;\n  },\n\n  /*\r\n      var gap = this._zoomInversed;\r\n      return gap * Math.round((src.x - this.scrollX * src.scrollFactorX) / gap);\r\n  */\n\n  /**\r\n   * If this Camera has previously had movement bounds set on it, this will remove them.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#removeBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  removeBounds: function () {\n    this.useBounds = false;\n    this.dirty = true;\n\n    this._bounds.setEmpty();\n\n    return this;\n  },\n\n  /**\r\n   * Set the rotation of this Camera. This causes everything it renders to appear rotated.\r\n   *\r\n   * Rotating a camera does not rotate the viewport itself, it is applied during rendering.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setAngle\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [value=0] - The cameras angle of rotation, given in degrees.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setAngle: function (value) {\n    if (value === undefined) {\n      value = 0;\n    }\n\n    this.rotation = DegToRad(value);\n    return this;\n  },\n\n  /**\r\n   * Sets the background color for this Camera.\r\n   *\r\n   * By default a Camera has a transparent background but it can be given a solid color, with any level\r\n   * of transparency, via this method.\r\n   *\r\n   * The color value can be specified using CSS color notation, hex or numbers.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setBackgroundColor\r\n   * @since 3.0.0\r\n   *\r\n   * @param {(string|number|Phaser.Types.Display.InputColorObject)} [color='rgba(0,0,0,0)'] - The color value. In CSS, hex or numeric color notation.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setBackgroundColor: function (color) {\n    if (color === undefined) {\n      color = 'rgba(0,0,0,0)';\n    }\n\n    this.backgroundColor = ValueToColor(color);\n    this.transparent = this.backgroundColor.alpha === 0;\n    return this;\n  },\n\n  /**\r\n   * Set the bounds of the Camera. The bounds are an axis-aligned rectangle.\r\n   * \r\n   * The Camera bounds controls where the Camera can scroll to, stopping it from scrolling off the\r\n   * edges and into blank space. It does not limit the placement of Game Objects, or where\r\n   * the Camera viewport can be positioned.\r\n   * \r\n   * Temporarily disable the bounds by changing the boolean `Camera.useBounds`.\r\n   * \r\n   * Clear the bounds entirely by calling `Camera.removeBounds`.\r\n   * \r\n   * If you set bounds that are smaller than the viewport it will stop the Camera from being\r\n   * able to scroll. The bounds can be positioned where-ever you wish. By default they are from\r\n   * 0x0 to the canvas width x height. This means that the coordinate 0x0 is the top left of\r\n   * the Camera bounds. However, you can position them anywhere. So if you wanted a game world\r\n   * that was 2048x2048 in size, with 0x0 being the center of it, you can set the bounds x/y\r\n   * to be -1024, -1024, with a width and height of 2048. Depending on your game you may find\r\n   * it easier for 0x0 to be the top-left of the bounds, or you may wish 0x0 to be the middle.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setBounds\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} x - The top-left x coordinate of the bounds.\r\n   * @param {integer} y - The top-left y coordinate of the bounds.\r\n   * @param {integer} width - The width of the bounds, in pixels.\r\n   * @param {integer} height - The height of the bounds, in pixels.\r\n   * @param {boolean} [centerOn=false] - If `true` the Camera will automatically be centered on the new bounds.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setBounds: function (x, y, width, height, centerOn) {\n    if (centerOn === undefined) {\n      centerOn = false;\n    }\n\n    this._bounds.setTo(x, y, width, height);\n\n    this.dirty = true;\n    this.useBounds = true;\n\n    if (centerOn) {\n      this.centerToBounds();\n    } else {\n      this.scrollX = this.clampX(this.scrollX);\n      this.scrollY = this.clampY(this.scrollY);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Returns a rectangle containing the bounds of the Camera.\r\n   * \r\n   * If the Camera does not have any bounds the rectangle will be empty.\r\n   * \r\n   * The rectangle is a copy of the bounds, so is safe to modify.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#getBounds\r\n   * @since 3.16.0\r\n   *\r\n   * @param {Phaser.Geom.Rectangle} [out] - An optional Rectangle to store the bounds in. If not given, a new Rectangle will be created.\r\n   *\r\n   * @return {Phaser.Geom.Rectangle} A rectangle containing the bounds of this Camera.\r\n   */\n  getBounds: function (out) {\n    if (out === undefined) {\n      out = new Rectangle();\n    }\n\n    var source = this._bounds;\n    out.setTo(source.x, source.y, source.width, source.height);\n    return out;\n  },\n\n  /**\r\n   * Sets the name of this Camera.\r\n   * This value is for your own use and isn't used internally.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setName\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [value=''] - The name of the Camera.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setName: function (value) {\n    if (value === undefined) {\n      value = '';\n    }\n\n    this.name = value;\n    return this;\n  },\n\n  /**\r\n   * Set the position of the Camera viewport within the game.\r\n   *\r\n   * This does not change where the camera is 'looking'. See `setScroll` to control that.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setPosition\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The top-left x coordinate of the Camera viewport.\r\n   * @param {number} [y=x] - The top-left y coordinate of the Camera viewport.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setPosition: function (x, y) {\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n\n  /**\r\n   * Set the rotation of this Camera. This causes everything it renders to appear rotated.\r\n   *\r\n   * Rotating a camera does not rotate the viewport itself, it is applied during rendering.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setRotation\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [value=0] - The rotation of the Camera, in radians.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setRotation: function (value) {\n    if (value === undefined) {\n      value = 0;\n    }\n\n    this.rotation = value;\n    return this;\n  },\n\n  /**\r\n   * Should the Camera round pixel values to whole integers when rendering Game Objects?\r\n   * \r\n   * In some types of game, especially with pixel art, this is required to prevent sub-pixel aliasing.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setRoundPixels\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - `true` to round Camera pixels, `false` to not.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setRoundPixels: function (value) {\n    this.roundPixels = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the Scene the Camera is bound to.\r\n   * \r\n   * Also populates the `resolution` property and updates the internal size values.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setScene\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Scene} scene - The Scene the camera is bound to.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setScene: function (scene) {\n    if (this.scene && this._customViewport) {\n      this.sceneManager.customViewports--;\n    }\n\n    this.scene = scene;\n    var sys = scene.sys;\n    this.sceneManager = sys.game.scene;\n    this.scaleManager = sys.scale;\n    this.cameraManager = sys.cameras;\n    var res = this.scaleManager.resolution;\n    this.resolution = res;\n    this._cx = this._x * res;\n    this._cy = this._y * res;\n    this._cw = this._width * res;\n    this._ch = this._height * res;\n    this.updateSystem();\n    return this;\n  },\n\n  /**\r\n   * Set the position of where the Camera is looking within the game.\r\n   * You can also modify the properties `Camera.scrollX` and `Camera.scrollY` directly.\r\n   * Use this method, or the scroll properties, to move your camera around the game world.\r\n   *\r\n   * This does not change where the camera viewport is placed. See `setPosition` to control that.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setScroll\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The x coordinate of the Camera in the game world.\r\n   * @param {number} [y=x] - The y coordinate of the Camera in the game world.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setScroll: function (x, y) {\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.scrollX = x;\n    this.scrollY = y;\n    return this;\n  },\n\n  /**\r\n   * Set the size of the Camera viewport.\r\n   *\r\n   * By default a Camera is the same size as the game, but can be made smaller via this method,\r\n   * allowing you to create mini-cam style effects by creating and positioning a smaller Camera\r\n   * viewport within your game.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setSize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} width - The width of the Camera viewport.\r\n   * @param {integer} [height=width] - The height of the Camera viewport.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setSize: function (width, height) {\n    if (height === undefined) {\n      height = width;\n    }\n\n    this.width = width;\n    this.height = height;\n    return this;\n  },\n\n  /**\r\n   * This method sets the position and size of the Camera viewport in a single call.\r\n   *\r\n   * If you're trying to change where the Camera is looking at in your game, then see\r\n   * the method `Camera.setScroll` instead. This method is for changing the viewport\r\n   * itself, not what the camera can see.\r\n   *\r\n   * By default a Camera is the same size as the game, but can be made smaller via this method,\r\n   * allowing you to create mini-cam style effects by creating and positioning a smaller Camera\r\n   * viewport within your game.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setViewport\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} x - The top-left x coordinate of the Camera viewport.\r\n   * @param {number} y - The top-left y coordinate of the Camera viewport.\r\n   * @param {integer} width - The width of the Camera viewport.\r\n   * @param {integer} [height=width] - The height of the Camera viewport.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setViewport: function (x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    return this;\n  },\n\n  /**\r\n   * Set the zoom value of the Camera.\r\n   *\r\n   * Changing to a smaller value, such as 0.5, will cause the camera to 'zoom out'.\r\n   * Changing to a larger value, such as 2, will cause the camera to 'zoom in'.\r\n   *\r\n   * A value of 1 means 'no zoom' and is the default.\r\n   *\r\n   * Changing the zoom does not impact the Camera viewport in any way, it is only applied during rendering.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setZoom\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} [value=1] - The zoom value of the Camera. The minimum it can be is 0.001.\r\n   *\r\n   * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n   */\n  setZoom: function (value) {\n    if (value === undefined) {\n      value = 1;\n    }\n\n    if (value === 0) {\n      value = 0.001;\n    }\n\n    this.zoom = value;\n    return this;\n  },\n\n  /**\r\n   * Sets the mask to be applied to this Camera during rendering.\r\n   *\r\n   * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.\r\n   * \r\n   * Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.\r\n   *\r\n   * If a mask is already set on this Camera it will be immediately replaced.\r\n   * \r\n   * Masks have no impact on physics or input detection. They are purely a rendering component\r\n   * that allows you to limit what is visible during the render pass.\r\n   * \r\n   * Note: You cannot mask a Camera that has `renderToTexture` set.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setMask\r\n   * @since 3.17.0\r\n   *\r\n   * @param {(Phaser.Display.Masks.BitmapMask|Phaser.Display.Masks.GeometryMask)} mask - The mask this Camera will use when rendering.\r\n   * @param {boolean} [fixedPosition=true] - Should the mask translate along with the Camera, or be fixed in place and not impacted by the Cameras transform?\r\n   *\r\n   * @return {this} This Camera instance.\r\n   */\n  setMask: function (mask, fixedPosition) {\n    if (fixedPosition === undefined) {\n      fixedPosition = true;\n    }\n\n    this.mask = mask;\n    this._maskCamera = fixedPosition ? this.cameraManager.default : this;\n    return this;\n  },\n\n  /**\r\n   * Clears the mask that this Camera was using.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#clearMask\r\n   * @since 3.17.0\r\n   *\r\n   * @param {boolean} [destroyMask=false] - Destroy the mask before clearing it?\r\n   *\r\n   * @return {this} This Camera instance.\r\n   */\n  clearMask: function (destroyMask) {\n    if (destroyMask === undefined) {\n      destroyMask = false;\n    }\n\n    if (destroyMask && this.mask) {\n      this.mask.destroy();\n    }\n\n    this.mask = null;\n    return this;\n  },\n\n  /**\r\n   * Sets the visibility of this Camera.\r\n   *\r\n   * An invisible Camera will skip rendering and input tests of everything it can see.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#setVisible\r\n   * @since 3.10.0\r\n   *\r\n   * @param {boolean} value - The visible state of the Camera.\r\n   *\r\n   * @return {this} This Camera instance.\r\n   */\n\n  /**\r\n   * Returns an Object suitable for JSON storage containing all of the Camera viewport and rendering properties.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#toJSON\r\n   * @since 3.0.0\r\n   *\r\n   * @return {Phaser.Types.Cameras.Scene2D.JSONCamera} A well-formed object suitable for conversion to JSON.\r\n   */\n  toJSON: function () {\n    var output = {\n      name: this.name,\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height,\n      zoom: this.zoom,\n      rotation: this.rotation,\n      roundPixels: this.roundPixels,\n      scrollX: this.scrollX,\n      scrollY: this.scrollY,\n      backgroundColor: this.backgroundColor.rgba\n    };\n\n    if (this.useBounds) {\n      output['bounds'] = {\n        x: this._bounds.x,\n        y: this._bounds.y,\n        width: this._bounds.width,\n        height: this._bounds.height\n      };\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Internal method called automatically by the Camera Manager.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#update\r\n   * @protected\r\n   * @since 3.0.0\r\n   *\r\n   * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n   * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n   */\n  update: function () {//  NOOP\n  },\n\n  /**\r\n   * Internal method called automatically when the viewport changes.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#updateSystem\r\n   * @private\r\n   * @since 3.12.0\r\n   */\n  updateSystem: function () {\n    if (!this.scaleManager) {\n      return;\n    }\n\n    var custom = this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height;\n    var sceneManager = this.sceneManager;\n\n    if (custom && !this._customViewport) {\n      //  We need a custom viewport for this Camera\n      sceneManager.customViewports++;\n    } else if (!custom && this._customViewport) {\n      //  We're turning off a custom viewport for this Camera\n      sceneManager.customViewports--;\n    }\n\n    this.dirty = true;\n    this._customViewport = custom;\n  },\n\n  /**\r\n   * Destroys this Camera instance and its internal properties and references.\r\n   * Once destroyed you cannot use this Camera again, even if re-added to a Camera Manager.\r\n   * \r\n   * This method is called automatically by `CameraManager.remove` if that methods `runDestroy` argument is `true`, which is the default.\r\n   * \r\n   * Unless you have a specific reason otherwise, always use `CameraManager.remove` and allow it to handle the camera destruction,\r\n   * rather than calling this method directly.\r\n   *\r\n   * @method Phaser.Cameras.Scene2D.BaseCamera#destroy\r\n   * @fires Phaser.Cameras.Scene2D.Events#DESTROY\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.emit(Events.DESTROY, this);\n    this.removeAllListeners();\n    this.matrix.destroy();\n    this.culledObjects = [];\n\n    if (this._customViewport) {\n      //  We're turning off a custom viewport for this Camera\n      this.sceneManager.customViewports--;\n    }\n\n    this._bounds = null;\n    this.scene = null;\n    this.scaleManager = null;\n    this.sceneManager = null;\n    this.cameraManager = null;\n  },\n\n  /**\r\n   * The x position of the Camera viewport, relative to the top-left of the game canvas.\r\n   * The viewport is the area into which the camera renders.\r\n   * To adjust the position the camera is looking at in the game world, see the `scrollX` value.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#x\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  x: {\n    get: function () {\n      return this._x;\n    },\n    set: function (value) {\n      this._x = value;\n      this._cx = value * this.resolution;\n      this.updateSystem();\n    }\n  },\n\n  /**\r\n   * The y position of the Camera viewport, relative to the top-left of the game canvas.\r\n   * The viewport is the area into which the camera renders.\r\n   * To adjust the position the camera is looking at in the game world, see the `scrollY` value.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#y\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  y: {\n    get: function () {\n      return this._y;\n    },\n    set: function (value) {\n      this._y = value;\n      this._cy = value * this.resolution;\n      this.updateSystem();\n    }\n  },\n\n  /**\r\n   * The width of the Camera viewport, in pixels.\r\n   *\r\n   * The viewport is the area into which the Camera renders. Setting the viewport does\r\n   * not restrict where the Camera can scroll to.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#width\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  width: {\n    get: function () {\n      return this._width;\n    },\n    set: function (value) {\n      this._width = value;\n      this._cw = value * this.resolution;\n      this.updateSystem();\n    }\n  },\n\n  /**\r\n   * The height of the Camera viewport, in pixels.\r\n   *\r\n   * The viewport is the area into which the Camera renders. Setting the viewport does\r\n   * not restrict where the Camera can scroll to.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#height\r\n   * @type {number}\r\n   * @since 3.0.0\r\n   */\n  height: {\n    get: function () {\n      return this._height;\n    },\n    set: function (value) {\n      this._height = value;\n      this._ch = value * this.resolution;\n      this.updateSystem();\n    }\n  },\n\n  /**\r\n   * The horizontal scroll position of this Camera.\r\n   *\r\n   * Change this value to cause the Camera to scroll around your Scene.\r\n   *\r\n   * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,\r\n   * will automatically adjust the Camera scroll values accordingly.\r\n   *\r\n   * You can set the bounds within which the Camera can scroll via the `setBounds` method.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#scrollX\r\n   * @type {number}\r\n   * @default 0\r\n   * @since 3.0.0\r\n   */\n  scrollX: {\n    get: function () {\n      return this._scrollX;\n    },\n    set: function (value) {\n      this._scrollX = value;\n      this.dirty = true;\n    }\n  },\n\n  /**\r\n   * The vertical scroll position of this Camera.\r\n   *\r\n   * Change this value to cause the Camera to scroll around your Scene.\r\n   *\r\n   * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,\r\n   * will automatically adjust the Camera scroll values accordingly.\r\n   *\r\n   * You can set the bounds within which the Camera can scroll via the `setBounds` method.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#scrollY\r\n   * @type {number}\r\n   * @default 0\r\n   * @since 3.0.0\r\n   */\n  scrollY: {\n    get: function () {\n      return this._scrollY;\n    },\n    set: function (value) {\n      this._scrollY = value;\n      this.dirty = true;\n    }\n  },\n\n  /**\r\n   * The Camera zoom value. Change this value to zoom in, or out of, a Scene.\r\n   *\r\n   * A value of 0.5 would zoom the Camera out, so you can now see twice as much\r\n   * of the Scene as before. A value of 2 would zoom the Camera in, so every pixel\r\n   * now takes up 2 pixels when rendered.\r\n   *\r\n   * Set to 1 to return to the default zoom level.\r\n   *\r\n   * Be careful to never set this value to zero.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#zoom\r\n   * @type {number}\r\n   * @default 1\r\n   * @since 3.0.0\r\n   */\n  zoom: {\n    get: function () {\n      return this._zoom;\n    },\n    set: function (value) {\n      this._zoom = value;\n      this.dirty = true;\n    }\n  },\n\n  /**\r\n   * The rotation of the Camera in radians.\r\n   *\r\n   * Camera rotation always takes place based on the Camera viewport. By default, rotation happens\r\n   * in the center of the viewport. You can adjust this with the `originX` and `originY` properties.\r\n   *\r\n   * Rotation influences the rendering of _all_ Game Objects visible by this Camera. However, it does not\r\n   * rotate the Camera viewport itself, which always remains an axis-aligned rectangle.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#rotation\r\n   * @type {number}\r\n   * @private\r\n   * @default 0\r\n   * @since 3.11.0\r\n   */\n  rotation: {\n    get: function () {\n      return this._rotation;\n    },\n    set: function (value) {\n      this._rotation = value;\n      this.dirty = true;\n    }\n  },\n\n  /**\r\n   * The horizontal position of the center of the Camera's viewport, relative to the left of the game canvas.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#centerX\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  centerX: {\n    get: function () {\n      return this.x + 0.5 * this.width;\n    }\n  },\n\n  /**\r\n   * The vertical position of the center of the Camera's viewport, relative to the top of the game canvas.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#centerY\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.10.0\r\n   */\n  centerY: {\n    get: function () {\n      return this.y + 0.5 * this.height;\n    }\n  },\n\n  /**\r\n   * The displayed width of the camera viewport, factoring in the camera zoom level.\r\n   *\r\n   * If a camera has a viewport width of 800 and a zoom of 0.5 then its display width\r\n   * would be 1600, as it's displaying twice as many pixels as zoom level 1.\r\n   *\r\n   * Equally, a camera with a width of 800 and zoom of 2 would have a display width\r\n   * of 400 pixels.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#displayWidth\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.11.0\r\n   */\n  displayWidth: {\n    get: function () {\n      return this.width / this.zoom;\n    }\n  },\n\n  /**\r\n   * The displayed height of the camera viewport, factoring in the camera zoom level.\r\n   *\r\n   * If a camera has a viewport height of 600 and a zoom of 0.5 then its display height\r\n   * would be 1200, as it's displaying twice as many pixels as zoom level 1.\r\n   *\r\n   * Equally, a camera with a height of 600 and zoom of 2 would have a display height\r\n   * of 300 pixels.\r\n   *\r\n   * @name Phaser.Cameras.Scene2D.BaseCamera#displayHeight\r\n   * @type {number}\r\n   * @readonly\r\n   * @since 3.11.0\r\n   */\n  displayHeight: {\n    get: function () {\n      return this.height / this.zoom;\n    }\n  }\n});\nmodule.exports = BaseCamera;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/cameras/2d/BaseCamera.js"],"names":["Class","require","Components","DegToRad","EventEmitter","Events","Rectangle","TransformMatrix","ValueToColor","Vector2","BaseCamera","Extends","Mixins","Alpha","Visible","initialize","x","y","width","height","undefined","call","scene","sceneManager","scaleManager","cameraManager","id","name","resolution","roundPixels","useBounds","worldView","dirty","_x","_y","_cx","_cy","_cw","_ch","_width","_height","_bounds","_scrollX","_scrollY","_zoom","_rotation","matrix","transparent","backgroundColor","disableCull","culledObjects","midPoint","originX","originY","_customViewport","mask","_maskCamera","setOrigin","getScroll","out","clampX","clampY","centerOnX","scrollX","centerOnY","scrollY","centerOn","centerToBounds","bounds","set","centerX","centerY","centerToSize","cull","renderableObjects","cameraMatrix","mva","mvb","mvc","mvd","determinant","mve","mvf","cameraW","cameraH","length","index","object","hasOwnProperty","parentContainer","push","objectW","objectH","objectX","scrollFactorX","objectY","scrollFactorY","tx","ty","tw","th","cullTop","cullBottom","cullLeft","cullRight","getWorldPoint","output","ima","imb","imc","imd","ime","imf","c","Math","cos","rotation","s","sin","zoom","res","sx","sy","ignore","entries","Array","isArray","i","entry","isParent","getChildren","cameraFilter","preRender","halfWidth","halfHeight","round","midX","midY","displayWidth","displayHeight","setTo","applyITRS","translate","dw","bx","bw","max","dh","by","bh","removeBounds","setEmpty","setAngle","value","setBackgroundColor","color","alpha","setBounds","getBounds","source","setName","setPosition","setRotation","setRoundPixels","setScene","customViewports","sys","game","scale","cameras","updateSystem","setScroll","setSize","setViewport","setZoom","setMask","fixedPosition","default","clearMask","destroyMask","destroy","toJSON","rgba","update","custom","emit","DESTROY","removeAllListeners","get","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../../gameobjects/components');\r\nvar DegToRad = require('../../math/DegToRad');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\r\nvar ValueToColor = require('../../display/color/ValueToColor');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Base Camera class.\r\n *\r\n * The Camera is the way in which all games are rendered in Phaser. They provide a view into your game world,\r\n * and can be positioned, rotated, zoomed and scrolled accordingly.\r\n *\r\n * A Camera consists of two elements: The viewport and the scroll values.\r\n *\r\n * The viewport is the physical position and size of the Camera within your game. Cameras, by default, are\r\n * created the same size as your game, but their position and size can be set to anything. This means if you\r\n * wanted to create a camera that was 320x200 in size, positioned in the bottom-right corner of your game,\r\n * you'd adjust the viewport to do that (using methods like `setViewport` and `setSize`).\r\n *\r\n * If you wish to change where the Camera is looking in your game, then you scroll it. You can do this\r\n * via the properties `scrollX` and `scrollY` or the method `setScroll`. Scrolling has no impact on the\r\n * viewport, and changing the viewport has no impact on the scrolling.\r\n *\r\n * By default a Camera will render all Game Objects it can see. You can change this using the `ignore` method,\r\n * allowing you to filter Game Objects out on a per-Camera basis.\r\n * \r\n * The Base Camera is extended by the Camera class, which adds in special effects including Fade,\r\n * Flash and Camera Shake, as well as the ability to follow Game Objects.\r\n * \r\n * The Base Camera was introduced in Phaser 3.12. It was split off from the Camera class, to allow\r\n * you to isolate special effects as needed. Therefore the 'since' values for properties of this class relate\r\n * to when they were added to the Camera class.\r\n *\r\n * @class BaseCamera\r\n * @memberof Phaser.Cameras.Scene2D\r\n * @constructor\r\n * @since 3.12.0\r\n * \r\n * @extends Phaser.Events.EventEmitter\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {number} x - The x position of the Camera, relative to the top-left of the game canvas.\r\n * @param {number} y - The y position of the Camera, relative to the top-left of the game canvas.\r\n * @param {number} width - The width of the Camera, in pixels.\r\n * @param {number} height - The height of the Camera, in pixels.\r\n */\r\nvar BaseCamera = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.Visible\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function BaseCamera (x, y, width, height)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = 0; }\r\n        if (height === undefined) { height = 0; }\r\n\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Scene this camera belongs to.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene;\r\n\r\n        /**\r\n         * A reference to the Game Scene Manager.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#sceneManager\r\n         * @type {Phaser.Scenes.SceneManager}\r\n         * @since 3.12.0\r\n         */\r\n        this.sceneManager;\r\n\r\n        /**\r\n         * A reference to the Game Scale Manager.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#scaleManager\r\n         * @type {Phaser.Scale.ScaleManager}\r\n         * @since 3.16.0\r\n         */\r\n        this.scaleManager;\r\n\r\n        /**\r\n         * A reference to the Scene's Camera Manager to which this Camera belongs.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#cameraManager\r\n         * @type {Phaser.Cameras.Scene2D.CameraManager}\r\n         * @since 3.17.0\r\n         */\r\n        this.cameraManager;\r\n\r\n        /**\r\n         * The Camera ID. Assigned by the Camera Manager and used to handle camera exclusion.\r\n         * This value is a bitmask.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#id\r\n         * @type {integer}\r\n         * @readonly\r\n         * @since 3.11.0\r\n         */\r\n        this.id = 0;\r\n\r\n        /**\r\n         * The name of the Camera. This is left empty for your own use.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.name = '';\r\n\r\n        /**\r\n         * This property is un-used in v3.16.\r\n         * \r\n         * The resolution of the Game, used in most Camera calculations.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#resolution\r\n         * @type {number}\r\n         * @readonly\r\n         * @deprecated\r\n         * @since 3.12.0\r\n         */\r\n        this.resolution = 1;\r\n\r\n        /**\r\n         * Should this camera round its pixel values to integers?\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#roundPixels\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.roundPixels = false;\r\n\r\n        /**\r\n         * Is this Camera visible or not?\r\n         *\r\n         * A visible camera will render and perform input tests.\r\n         * An invisible camera will not render anything and will skip input tests.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#visible\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.10.0\r\n         */\r\n\r\n        /**\r\n         * Is this Camera using a bounds to restrict scrolling movement?\r\n         *\r\n         * Set this property along with the bounds via `Camera.setBounds`.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#useBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.useBounds = false;\r\n\r\n        /**\r\n         * The World View is a Rectangle that defines the area of the 'world' the Camera is currently looking at.\r\n         * This factors in the Camera viewport size, zoom and scroll position and is updated in the Camera preRender step.\r\n         * If you have enabled Camera bounds the worldview will be clamped to those bounds accordingly.\r\n         * You can use it for culling or intersection checks.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#worldView\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @readonly\r\n         * @since 3.11.0\r\n         */\r\n        this.worldView = new Rectangle();\r\n\r\n        /**\r\n         * Is this Camera dirty?\r\n         * \r\n         * A dirty Camera has had either its viewport size, bounds, scroll, rotation or zoom levels changed since the last frame.\r\n         * \r\n         * This flag is cleared during the `postRenderCamera` method of the renderer.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#dirty\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.11.0\r\n         */\r\n        this.dirty = true;\r\n\r\n        /**\r\n         * The x position of the Camera viewport, relative to the top-left of the game canvas.\r\n         * The viewport is the area into which the camera renders.\r\n         * To adjust the position the camera is looking at in the game world, see the `scrollX` value.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#x\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._x = x;\r\n\r\n        /**\r\n         * The y position of the Camera, relative to the top-left of the game canvas.\r\n         * The viewport is the area into which the camera renders.\r\n         * To adjust the position the camera is looking at in the game world, see the `scrollY` value.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#y\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._y = y;\r\n\r\n        /**\r\n         * Internal Camera X value multiplied by the resolution.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#_cx\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._cx = 0;\r\n\r\n        /**\r\n         * Internal Camera Y value multiplied by the resolution.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#_cy\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._cy = 0;\r\n\r\n        /**\r\n         * Internal Camera Width value multiplied by the resolution.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#_cw\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._cw = 0;\r\n\r\n        /**\r\n         * Internal Camera Height value multiplied by the resolution.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#_ch\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._ch = 0;\r\n\r\n        /**\r\n         * The width of the Camera viewport, in pixels.\r\n         *\r\n         * The viewport is the area into which the Camera renders. Setting the viewport does\r\n         * not restrict where the Camera can scroll to.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#_width\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.11.0\r\n         */\r\n        this._width = width;\r\n\r\n        /**\r\n         * The height of the Camera viewport, in pixels.\r\n         *\r\n         * The viewport is the area into which the Camera renders. Setting the viewport does\r\n         * not restrict where the Camera can scroll to.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#_height\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.11.0\r\n         */\r\n        this._height = height;\r\n\r\n        /**\r\n         * The bounds the camera is restrained to during scrolling.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#_bounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._bounds = new Rectangle();\r\n\r\n        /**\r\n         * The horizontal scroll position of this Camera.\r\n         *\r\n         * Change this value to cause the Camera to scroll around your Scene.\r\n         *\r\n         * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,\r\n         * will automatically adjust the Camera scroll values accordingly.\r\n         *\r\n         * You can set the bounds within which the Camera can scroll via the `setBounds` method.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#_scrollX\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.11.0\r\n         */\r\n        this._scrollX = 0;\r\n\r\n        /**\r\n         * The vertical scroll position of this Camera.\r\n         *\r\n         * Change this value to cause the Camera to scroll around your Scene.\r\n         *\r\n         * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,\r\n         * will automatically adjust the Camera scroll values accordingly.\r\n         *\r\n         * You can set the bounds within which the Camera can scroll via the `setBounds` method.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#_scrollY\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.11.0\r\n         */\r\n        this._scrollY = 0;\r\n\r\n        /**\r\n         * The Camera zoom value. Change this value to zoom in, or out of, a Scene.\r\n         *\r\n         * A value of 0.5 would zoom the Camera out, so you can now see twice as much\r\n         * of the Scene as before. A value of 2 would zoom the Camera in, so every pixel\r\n         * now takes up 2 pixels when rendered.\r\n         *\r\n         * Set to 1 to return to the default zoom level.\r\n         *\r\n         * Be careful to never set this value to zero.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#_zoom\r\n         * @type {number}\r\n         * @private\r\n         * @default 1\r\n         * @since 3.11.0\r\n         */\r\n        this._zoom = 1;\r\n\r\n        /**\r\n         * The rotation of the Camera in radians.\r\n         *\r\n         * Camera rotation always takes place based on the Camera viewport. By default, rotation happens\r\n         * in the center of the viewport. You can adjust this with the `originX` and `originY` properties.\r\n         *\r\n         * Rotation influences the rendering of _all_ Game Objects visible by this Camera. However, it does not\r\n         * rotate the Camera viewport itself, which always remains an axis-aligned rectangle.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#_rotation\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.11.0\r\n         */\r\n        this._rotation = 0;\r\n\r\n        /**\r\n         * A local transform matrix used for internal calculations.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#matrix\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.matrix = new TransformMatrix();\r\n\r\n        /**\r\n         * Does this Camera have a transparent background?\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#transparent\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.transparent = true;\r\n\r\n        /**\r\n         * The background color of this Camera. Only used if `transparent` is `false`.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#backgroundColor\r\n         * @type {Phaser.Display.Color}\r\n         * @since 3.0.0\r\n         */\r\n        this.backgroundColor = ValueToColor('rgba(0,0,0,0)');\r\n\r\n        /**\r\n         * The Camera alpha value. Setting this property impacts every single object that this Camera\r\n         * renders. You can either set the property directly, i.e. via a Tween, to fade a Camera in or out,\r\n         * or via the chainable `setAlpha` method instead.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#alpha\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.11.0\r\n         */\r\n\r\n        /**\r\n         * Should the camera cull Game Objects before checking them for input hit tests?\r\n         * In some special cases it may be beneficial to disable this.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#disableCull\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.disableCull = false;\r\n\r\n        /**\r\n         * A temporary array of culled objects.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#culledObjects\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @default []\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.culledObjects = [];\r\n\r\n        /**\r\n         * The mid-point of the Camera in 'world' coordinates.\r\n         *\r\n         * Use it to obtain exactly where in the world the center of the camera is currently looking.\r\n         *\r\n         * This value is updated in the preRender method, after the scroll values and follower\r\n         * have been processed.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#midPoint\r\n         * @type {Phaser.Math.Vector2}\r\n         * @readonly\r\n         * @since 3.11.0\r\n         */\r\n        this.midPoint = new Vector2(width / 2, height / 2);\r\n\r\n        /**\r\n         * The horizontal origin of rotation for this Camera.\r\n         *\r\n         * By default the camera rotates around the center of the viewport.\r\n         *\r\n         * Changing the origin allows you to adjust the point in the viewport from which rotation happens.\r\n         * A value of 0 would rotate from the top-left of the viewport. A value of 1 from the bottom right.\r\n         *\r\n         * See `setOrigin` to set both origins in a single, chainable call.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#originX\r\n         * @type {number}\r\n         * @default 0.5\r\n         * @since 3.11.0\r\n         */\r\n        this.originX = 0.5;\r\n\r\n        /**\r\n         * The vertical origin of rotation for this Camera.\r\n         *\r\n         * By default the camera rotates around the center of the viewport.\r\n         *\r\n         * Changing the origin allows you to adjust the point in the viewport from which rotation happens.\r\n         * A value of 0 would rotate from the top-left of the viewport. A value of 1 from the bottom right.\r\n         *\r\n         * See `setOrigin` to set both origins in a single, chainable call.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#originY\r\n         * @type {number}\r\n         * @default 0.5\r\n         * @since 3.11.0\r\n         */\r\n        this.originY = 0.5;\r\n\r\n        /**\r\n         * Does this Camera have a custom viewport?\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#_customViewport\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.12.0\r\n         */\r\n        this._customViewport = false;\r\n\r\n        /**\r\n         * The Mask this Camera is using during render.\r\n         * Set the mask using the `setMask` method. Remove the mask using the `clearMask` method.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#mask\r\n         * @type {?(Phaser.Display.Masks.BitmapMask|Phaser.Display.Masks.GeometryMask)}\r\n         * @since 3.17.0\r\n         */\r\n        this.mask = null;\r\n\r\n        /**\r\n         * The Camera that this Camera uses for translation during masking.\r\n         * \r\n         * If the mask is fixed in position this will be a reference to\r\n         * the CameraManager.default instance. Otherwise, it'll be a reference\r\n         * to itself.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.BaseCamera#_maskCamera\r\n         * @type {?Phaser.Cameras.Scene2D.BaseCamera}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this._maskCamera = null;\r\n    },\r\n\r\n    /**\r\n     * Set the Alpha level of this Camera. The alpha controls the opacity of the Camera as it renders.\r\n     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#setAlpha\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} [value=1] - The Camera alpha value.\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n\r\n    /**\r\n     * Sets the rotation origin of this Camera.\r\n     *\r\n     * The values are given in the range 0 to 1 and are only used when calculating Camera rotation.\r\n     *\r\n     * By default the camera rotates around the center of the viewport.\r\n     *\r\n     * Changing the origin allows you to adjust the point in the viewport from which rotation happens.\r\n     * A value of 0 would rotate from the top-left of the viewport. A value of 1 from the bottom right.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#setOrigin\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} [x=0.5] - The horizontal origin value.\r\n     * @param {number} [y=x] - The vertical origin value. If not defined it will be set to the value of `x`.\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    setOrigin: function (x, y)\r\n    {\r\n        if (x === undefined) { x = 0.5; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.originX = x;\r\n        this.originY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculates what the Camera.scrollX and scrollY values would need to be in order to move\r\n     * the Camera so it is centered on the given x and y coordinates, without actually moving\r\n     * the Camera there. The results are clamped based on the Camera bounds, if set.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#getScroll\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} x - The horizontal coordinate to center on.\r\n     * @param {number} y - The vertical coordinate to center on.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 to store the values in. If not given a new Vector2 is created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The scroll coordinates stored in the `x` and `y` properties.\r\n     */\r\n    getScroll: function (x, y, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        var originX = this.width * 0.5;\r\n        var originY = this.height * 0.5;\r\n\r\n        out.x = x - originX;\r\n        out.y = y - originY;\r\n\r\n        if (this.useBounds)\r\n        {\r\n            out.x = this.clampX(out.x);\r\n            out.y = this.clampY(out.y);\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Moves the Camera horizontally so that it is centered on the given x coordinate, bounds allowing.\r\n     * Calling this does not change the scrollY value.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#centerOnX\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} x - The horizontal coordinate to center on.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    centerOnX: function (x)\r\n    {\r\n        var originX = this.width * 0.5;\r\n\r\n        this.midPoint.x = x;\r\n\r\n        this.scrollX = x - originX;\r\n\r\n        if (this.useBounds)\r\n        {\r\n            this.scrollX = this.clampX(this.scrollX);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves the Camera vertically so that it is centered on the given y coordinate, bounds allowing.\r\n     * Calling this does not change the scrollX value.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#centerOnY\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} y - The vertical coordinate to center on.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    centerOnY: function (y)\r\n    {\r\n        var originY = this.height * 0.5;\r\n\r\n        this.midPoint.y = y;\r\n\r\n        this.scrollY = y - originY;\r\n\r\n        if (this.useBounds)\r\n        {\r\n            this.scrollY = this.clampY(this.scrollY);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves the Camera so that it is centered on the given coordinates, bounds allowing.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#centerOn\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} x - The horizontal coordinate to center on.\r\n     * @param {number} y - The vertical coordinate to center on.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    centerOn: function (x, y)\r\n    {\r\n        this.centerOnX(x);\r\n        this.centerOnY(y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves the Camera so that it is looking at the center of the Camera Bounds, if enabled.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#centerToBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    centerToBounds: function ()\r\n    {\r\n        if (this.useBounds)\r\n        {\r\n            var bounds = this._bounds;\r\n            var originX = this.width * 0.5;\r\n            var originY = this.height * 0.5;\r\n\r\n            this.midPoint.set(bounds.centerX, bounds.centerY);\r\n\r\n            this.scrollX = bounds.centerX - originX;\r\n            this.scrollY = bounds.centerY - originY;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves the Camera so that it is re-centered based on its viewport size.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#centerToSize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    centerToSize: function ()\r\n    {\r\n        this.scrollX = this.width * 0.5;\r\n        this.scrollY = this.height * 0.5;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes an array of Game Objects and returns a new array featuring only those objects\r\n     * visible by this camera.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#cull\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.GameObject[]} G - [renderableObjects,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} renderableObjects - An array of Game Objects to cull.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} An array of Game Objects visible to this Camera.\r\n     */\r\n    cull: function (renderableObjects)\r\n    {\r\n        if (this.disableCull)\r\n        {\r\n            return renderableObjects;\r\n        }\r\n\r\n        var cameraMatrix = this.matrix.matrix;\r\n\r\n        var mva = cameraMatrix[0];\r\n        var mvb = cameraMatrix[1];\r\n        var mvc = cameraMatrix[2];\r\n        var mvd = cameraMatrix[3];\r\n\r\n        /* First Invert Matrix */\r\n        var determinant = (mva * mvd) - (mvb * mvc);\r\n\r\n        if (!determinant)\r\n        {\r\n            return renderableObjects;\r\n        }\r\n\r\n        var mve = cameraMatrix[4];\r\n        var mvf = cameraMatrix[5];\r\n\r\n        var scrollX = this.scrollX;\r\n        var scrollY = this.scrollY;\r\n        var cameraW = this.width;\r\n        var cameraH = this.height;\r\n        var culledObjects = this.culledObjects;\r\n        var length = renderableObjects.length;\r\n\r\n        determinant = 1 / determinant;\r\n\r\n        culledObjects.length = 0;\r\n\r\n        for (var index = 0; index < length; ++index)\r\n        {\r\n            var object = renderableObjects[index];\r\n\r\n            if (!object.hasOwnProperty('width') || object.parentContainer)\r\n            {\r\n                culledObjects.push(object);\r\n                continue;\r\n            }\r\n\r\n            var objectW = object.width;\r\n            var objectH = object.height;\r\n            var objectX = (object.x - (scrollX * object.scrollFactorX)) - (objectW * object.originX);\r\n            var objectY = (object.y - (scrollY * object.scrollFactorY)) - (objectH * object.originY);\r\n            var tx = (objectX * mva + objectY * mvc + mve);\r\n            var ty = (objectX * mvb + objectY * mvd + mvf);\r\n            var tw = ((objectX + objectW) * mva + (objectY + objectH) * mvc + mve);\r\n            var th = ((objectX + objectW) * mvb + (objectY + objectH) * mvd + mvf);\r\n            var cullTop = this.y;\r\n            var cullBottom = cullTop + cameraH;\r\n            var cullLeft = this.x;\r\n            var cullRight = cullLeft + cameraW;\r\n\r\n            if ((tw > cullLeft && tx < cullRight) && (th > cullTop && ty < cullBottom))\r\n            {\r\n                culledObjects.push(object);\r\n            }\r\n        }\r\n\r\n        return culledObjects;\r\n    },\r\n\r\n    /**\r\n     * Converts the given `x` and `y` coordinates into World space, based on this Cameras transform.\r\n     * You can optionally provide a Vector2, or similar object, to store the results in.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#getWorldPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {number} x - The x position to convert to world space.\r\n     * @param {number} y - The y position to convert to world space.\r\n     * @param {(object|Phaser.Math.Vector2)} [output] - An optional object to store the results in. If not provided a new Vector2 will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} An object holding the converted values in its `x` and `y` properties.\r\n     */\r\n    getWorldPoint: function (x, y, output)\r\n    {\r\n        if (output === undefined) { output = new Vector2(); }\r\n\r\n        var cameraMatrix = this.matrix.matrix;\r\n\r\n        var mva = cameraMatrix[0];\r\n        var mvb = cameraMatrix[1];\r\n        var mvc = cameraMatrix[2];\r\n        var mvd = cameraMatrix[3];\r\n        var mve = cameraMatrix[4];\r\n        var mvf = cameraMatrix[5];\r\n\r\n        //  Invert Matrix\r\n        var determinant = (mva * mvd) - (mvb * mvc);\r\n\r\n        if (!determinant)\r\n        {\r\n            output.x = x;\r\n            output.y = y;\r\n\r\n            return output;\r\n        }\r\n\r\n        determinant = 1 / determinant;\r\n\r\n        var ima = mvd * determinant;\r\n        var imb = -mvb * determinant;\r\n        var imc = -mvc * determinant;\r\n        var imd = mva * determinant;\r\n        var ime = (mvc * mvf - mvd * mve) * determinant;\r\n        var imf = (mvb * mve - mva * mvf) * determinant;\r\n\r\n        var c = Math.cos(this.rotation);\r\n        var s = Math.sin(this.rotation);\r\n\r\n        var zoom = this.zoom;\r\n        var res = this.resolution;\r\n\r\n        var scrollX = this.scrollX;\r\n        var scrollY = this.scrollY;\r\n\r\n        //  Works for zoom of 1 with any resolution, but resolution > 1 and zoom !== 1 breaks\r\n        var sx = x + ((scrollX * c - scrollY * s) * zoom);\r\n        var sy = y + ((scrollX * s + scrollY * c) * zoom);\r\n\r\n        //  Apply transform to point\r\n        output.x = (sx * ima + sy * imc) * res + ime;\r\n        output.y = (sx * imb + sy * imd) * res + imf;\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Given a Game Object, or an array of Game Objects, it will update all of their camera filter settings\r\n     * so that they are ignored by this Camera. This means they will not be rendered by this Camera.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#ignore\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group)} entries - The Game Object, or array of Game Objects, to be ignored by this Camera.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    ignore: function (entries)\r\n    {\r\n        var id = this.id;\r\n\r\n        if (!Array.isArray(entries))\r\n        {\r\n            entries = [ entries ];\r\n        }\r\n\r\n        for (var i = 0; i < entries.length; i++)\r\n        {\r\n            var entry = entries[i];\r\n\r\n            if (Array.isArray(entry))\r\n            {\r\n                this.ignore(entry);\r\n            }\r\n            else if (entry.isParent)\r\n            {\r\n                this.ignore(entry.getChildren());\r\n            }\r\n            else\r\n            {\r\n                entry.cameraFilter |= id;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal preRender step.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#preRender\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} resolution - The game resolution, as set in the Scale Manager.\r\n     */\r\n    preRender: function (resolution)\r\n    {\r\n        var width = this.width;\r\n        var height = this.height;\r\n\r\n        var halfWidth = width * 0.5;\r\n        var halfHeight = height * 0.5;\r\n\r\n        var zoom = this.zoom * resolution;\r\n        var matrix = this.matrix;\r\n\r\n        var originX = width * this.originX;\r\n        var originY = height * this.originY;\r\n\r\n        var sx = this.scrollX;\r\n        var sy = this.scrollY;\r\n\r\n        if (this.useBounds)\r\n        {\r\n            sx = this.clampX(sx);\r\n            sy = this.clampY(sy);\r\n        }\r\n\r\n        if (this.roundPixels)\r\n        {\r\n            originX = Math.round(originX);\r\n            originY = Math.round(originY);\r\n        }\r\n\r\n        //  Values are in pixels and not impacted by zooming the Camera\r\n        this.scrollX = sx;\r\n        this.scrollY = sy;\r\n\r\n        var midX = sx + halfWidth;\r\n        var midY = sy + halfHeight;\r\n\r\n        //  The center of the camera, in world space, so taking zoom into account\r\n        //  Basically the pixel value of what it's looking at in the middle of the cam\r\n        this.midPoint.set(midX, midY);\r\n\r\n        var displayWidth = width / zoom;\r\n        var displayHeight = height / zoom;\r\n\r\n        this.worldView.setTo(\r\n            midX - (displayWidth / 2),\r\n            midY - (displayHeight / 2),\r\n            displayWidth,\r\n            displayHeight\r\n        );\r\n\r\n        matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoom, zoom);\r\n        matrix.translate(-originX, -originY);\r\n    },\r\n\r\n    /**\r\n     * Takes an x value and checks it's within the range of the Camera bounds, adjusting if required.\r\n     * Do not call this method if you are not using camera bounds.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#clampX\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} x - The value to horizontally scroll clamp.\r\n     *\r\n     * @return {number} The adjusted value to use as scrollX.\r\n     */\r\n    clampX: function (x)\r\n    {\r\n        var bounds = this._bounds;\r\n\r\n        var dw = this.displayWidth;\r\n\r\n        var bx = bounds.x + ((dw - this.width) / 2);\r\n        var bw = Math.max(bx, bx + bounds.width - dw);\r\n\r\n        if (x < bx)\r\n        {\r\n            x = bx;\r\n        }\r\n        else if (x > bw)\r\n        {\r\n            x = bw;\r\n        }\r\n\r\n        return x;\r\n    },\r\n\r\n    /**\r\n     * Takes a y value and checks it's within the range of the Camera bounds, adjusting if required.\r\n     * Do not call this method if you are not using camera bounds.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#clampY\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} y - The value to vertically scroll clamp.\r\n     *\r\n     * @return {number} The adjusted value to use as scrollY.\r\n     */\r\n    clampY: function (y)\r\n    {\r\n        var bounds = this._bounds;\r\n\r\n        var dh = this.displayHeight;\r\n\r\n        var by = bounds.y + ((dh - this.height) / 2);\r\n        var bh = Math.max(by, by + bounds.height - dh);\r\n\r\n        if (y < by)\r\n        {\r\n            y = by;\r\n        }\r\n        else if (y > bh)\r\n        {\r\n            y = bh;\r\n        }\r\n\r\n        return y;\r\n    },\r\n\r\n    /*\r\n        var gap = this._zoomInversed;\r\n        return gap * Math.round((src.x - this.scrollX * src.scrollFactorX) / gap);\r\n    */\r\n\r\n    /**\r\n     * If this Camera has previously had movement bounds set on it, this will remove them.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#removeBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    removeBounds: function ()\r\n    {\r\n        this.useBounds = false;\r\n\r\n        this.dirty = true;\r\n\r\n        this._bounds.setEmpty();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the rotation of this Camera. This causes everything it renders to appear rotated.\r\n     *\r\n     * Rotating a camera does not rotate the viewport itself, it is applied during rendering.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#setAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The cameras angle of rotation, given in degrees.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    setAngle: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.rotation = DegToRad(value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the background color for this Camera.\r\n     *\r\n     * By default a Camera has a transparent background but it can be given a solid color, with any level\r\n     * of transparency, via this method.\r\n     *\r\n     * The color value can be specified using CSS color notation, hex or numbers.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#setBackgroundColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number|Phaser.Types.Display.InputColorObject)} [color='rgba(0,0,0,0)'] - The color value. In CSS, hex or numeric color notation.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    setBackgroundColor: function (color)\r\n    {\r\n        if (color === undefined) { color = 'rgba(0,0,0,0)'; }\r\n\r\n        this.backgroundColor = ValueToColor(color);\r\n\r\n        this.transparent = (this.backgroundColor.alpha === 0);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the bounds of the Camera. The bounds are an axis-aligned rectangle.\r\n     * \r\n     * The Camera bounds controls where the Camera can scroll to, stopping it from scrolling off the\r\n     * edges and into blank space. It does not limit the placement of Game Objects, or where\r\n     * the Camera viewport can be positioned.\r\n     * \r\n     * Temporarily disable the bounds by changing the boolean `Camera.useBounds`.\r\n     * \r\n     * Clear the bounds entirely by calling `Camera.removeBounds`.\r\n     * \r\n     * If you set bounds that are smaller than the viewport it will stop the Camera from being\r\n     * able to scroll. The bounds can be positioned where-ever you wish. By default they are from\r\n     * 0x0 to the canvas width x height. This means that the coordinate 0x0 is the top left of\r\n     * the Camera bounds. However, you can position them anywhere. So if you wanted a game world\r\n     * that was 2048x2048 in size, with 0x0 being the center of it, you can set the bounds x/y\r\n     * to be -1024, -1024, with a width and height of 2048. Depending on your game you may find\r\n     * it easier for 0x0 to be the top-left of the bounds, or you may wish 0x0 to be the middle.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#setBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} x - The top-left x coordinate of the bounds.\r\n     * @param {integer} y - The top-left y coordinate of the bounds.\r\n     * @param {integer} width - The width of the bounds, in pixels.\r\n     * @param {integer} height - The height of the bounds, in pixels.\r\n     * @param {boolean} [centerOn=false] - If `true` the Camera will automatically be centered on the new bounds.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    setBounds: function (x, y, width, height, centerOn)\r\n    {\r\n        if (centerOn === undefined) { centerOn = false; }\r\n\r\n        this._bounds.setTo(x, y, width, height);\r\n\r\n        this.dirty = true;\r\n        this.useBounds = true;\r\n\r\n        if (centerOn)\r\n        {\r\n            this.centerToBounds();\r\n        }\r\n        else\r\n        {\r\n            this.scrollX = this.clampX(this.scrollX);\r\n            this.scrollY = this.clampY(this.scrollY);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a rectangle containing the bounds of the Camera.\r\n     * \r\n     * If the Camera does not have any bounds the rectangle will be empty.\r\n     * \r\n     * The rectangle is a copy of the bounds, so is safe to modify.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#getBounds\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} [out] - An optional Rectangle to store the bounds in. If not given, a new Rectangle will be created.\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} A rectangle containing the bounds of this Camera.\r\n     */\r\n    getBounds: function (out)\r\n    {\r\n        if (out === undefined) { out = new Rectangle(); }\r\n\r\n        var source = this._bounds;\r\n\r\n        out.setTo(source.x, source.y, source.width, source.height);\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Sets the name of this Camera.\r\n     * This value is for your own use and isn't used internally.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#setName\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [value=''] - The name of the Camera.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    setName: function (value)\r\n    {\r\n        if (value === undefined) { value = ''; }\r\n\r\n        this.name = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the position of the Camera viewport within the game.\r\n     *\r\n     * This does not change where the camera is 'looking'. See `setScroll` to control that.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The top-left x coordinate of the Camera viewport.\r\n     * @param {number} [y=x] - The top-left y coordinate of the Camera viewport.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    setPosition: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the rotation of this Camera. This causes everything it renders to appear rotated.\r\n     *\r\n     * Rotating a camera does not rotate the viewport itself, it is applied during rendering.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#setRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The rotation of the Camera, in radians.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    setRotation: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.rotation = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Should the Camera round pixel values to whole integers when rendering Game Objects?\r\n     * \r\n     * In some types of game, especially with pixel art, this is required to prevent sub-pixel aliasing.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#setRoundPixels\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - `true` to round Camera pixels, `false` to not.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    setRoundPixels: function (value)\r\n    {\r\n        this.roundPixels = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Scene the Camera is bound to.\r\n     * \r\n     * Also populates the `resolution` property and updates the internal size values.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#setScene\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene the camera is bound to.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    setScene: function (scene)\r\n    {\r\n        if (this.scene && this._customViewport)\r\n        {\r\n            this.sceneManager.customViewports--;\r\n        }\r\n\r\n        this.scene = scene;\r\n\r\n        var sys = scene.sys;\r\n\r\n        this.sceneManager = sys.game.scene;\r\n        this.scaleManager = sys.scale;\r\n        this.cameraManager = sys.cameras;\r\n\r\n        var res = this.scaleManager.resolution;\r\n\r\n        this.resolution = res;\r\n\r\n        this._cx = this._x * res;\r\n        this._cy = this._y * res;\r\n        this._cw = this._width * res;\r\n        this._ch = this._height * res;\r\n\r\n        this.updateSystem();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the position of where the Camera is looking within the game.\r\n     * You can also modify the properties `Camera.scrollX` and `Camera.scrollY` directly.\r\n     * Use this method, or the scroll properties, to move your camera around the game world.\r\n     *\r\n     * This does not change where the camera viewport is placed. See `setPosition` to control that.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#setScroll\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the Camera in the game world.\r\n     * @param {number} [y=x] - The y coordinate of the Camera in the game world.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    setScroll: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.scrollX = x;\r\n        this.scrollY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the size of the Camera viewport.\r\n     *\r\n     * By default a Camera is the same size as the game, but can be made smaller via this method,\r\n     * allowing you to create mini-cam style effects by creating and positioning a smaller Camera\r\n     * viewport within your game.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} width - The width of the Camera viewport.\r\n     * @param {integer} [height=width] - The height of the Camera viewport.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        if (height === undefined) { height = width; }\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This method sets the position and size of the Camera viewport in a single call.\r\n     *\r\n     * If you're trying to change where the Camera is looking at in your game, then see\r\n     * the method `Camera.setScroll` instead. This method is for changing the viewport\r\n     * itself, not what the camera can see.\r\n     *\r\n     * By default a Camera is the same size as the game, but can be made smaller via this method,\r\n     * allowing you to create mini-cam style effects by creating and positioning a smaller Camera\r\n     * viewport within your game.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#setViewport\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The top-left x coordinate of the Camera viewport.\r\n     * @param {number} y - The top-left y coordinate of the Camera viewport.\r\n     * @param {integer} width - The width of the Camera viewport.\r\n     * @param {integer} [height=width] - The height of the Camera viewport.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    setViewport: function (x, y, width, height)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the zoom value of the Camera.\r\n     *\r\n     * Changing to a smaller value, such as 0.5, will cause the camera to 'zoom out'.\r\n     * Changing to a larger value, such as 2, will cause the camera to 'zoom in'.\r\n     *\r\n     * A value of 1 means 'no zoom' and is the default.\r\n     *\r\n     * Changing the zoom does not impact the Camera viewport in any way, it is only applied during rendering.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#setZoom\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=1] - The zoom value of the Camera. The minimum it can be is 0.001.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.BaseCamera} This Camera instance.\r\n     */\r\n    setZoom: function (value)\r\n    {\r\n        if (value === undefined) { value = 1; }\r\n\r\n        if (value === 0)\r\n        {\r\n            value = 0.001;\r\n        }\r\n\r\n        this.zoom = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the mask to be applied to this Camera during rendering.\r\n     *\r\n     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.\r\n     * \r\n     * Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.\r\n     *\r\n     * If a mask is already set on this Camera it will be immediately replaced.\r\n     * \r\n     * Masks have no impact on physics or input detection. They are purely a rendering component\r\n     * that allows you to limit what is visible during the render pass.\r\n     * \r\n     * Note: You cannot mask a Camera that has `renderToTexture` set.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#setMask\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(Phaser.Display.Masks.BitmapMask|Phaser.Display.Masks.GeometryMask)} mask - The mask this Camera will use when rendering.\r\n     * @param {boolean} [fixedPosition=true] - Should the mask translate along with the Camera, or be fixed in place and not impacted by the Cameras transform?\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    setMask: function (mask, fixedPosition)\r\n    {\r\n        if (fixedPosition === undefined) { fixedPosition = true; }\r\n\r\n        this.mask = mask;\r\n\r\n        this._maskCamera = (fixedPosition) ? this.cameraManager.default : this;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clears the mask that this Camera was using.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#clearMask\r\n     * @since 3.17.0\r\n     *\r\n     * @param {boolean} [destroyMask=false] - Destroy the mask before clearing it?\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    clearMask: function (destroyMask)\r\n    {\r\n        if (destroyMask === undefined) { destroyMask = false; }\r\n\r\n        if (destroyMask && this.mask)\r\n        {\r\n            this.mask.destroy();\r\n        }\r\n\r\n        this.mask = null;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the visibility of this Camera.\r\n     *\r\n     * An invisible Camera will skip rendering and input tests of everything it can see.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#setVisible\r\n     * @since 3.10.0\r\n     *\r\n     * @param {boolean} value - The visible state of the Camera.\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n\r\n    /**\r\n     * Returns an Object suitable for JSON storage containing all of the Camera viewport and rendering properties.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.Cameras.Scene2D.JSONCamera} A well-formed object suitable for conversion to JSON.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        var output = {\r\n            name: this.name,\r\n            x: this.x,\r\n            y: this.y,\r\n            width: this.width,\r\n            height: this.height,\r\n            zoom: this.zoom,\r\n            rotation: this.rotation,\r\n            roundPixels: this.roundPixels,\r\n            scrollX: this.scrollX,\r\n            scrollY: this.scrollY,\r\n            backgroundColor: this.backgroundColor.rgba\r\n        };\r\n\r\n        if (this.useBounds)\r\n        {\r\n            output['bounds'] = {\r\n                x: this._bounds.x,\r\n                y: this._bounds.y,\r\n                width: this._bounds.width,\r\n                height: this._bounds.height\r\n            };\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Internal method called automatically by the Camera Manager.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#update\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    update: function ()\r\n    {\r\n        //  NOOP\r\n    },\r\n\r\n    /**\r\n     * Internal method called automatically when the viewport changes.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#updateSystem\r\n     * @private\r\n     * @since 3.12.0\r\n     */\r\n    updateSystem: function ()\r\n    {\r\n        if (!this.scaleManager)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var custom = (this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height);\r\n\r\n        var sceneManager = this.sceneManager;\r\n\r\n        if (custom && !this._customViewport)\r\n        {\r\n            //  We need a custom viewport for this Camera\r\n            sceneManager.customViewports++;\r\n        }\r\n        else if (!custom && this._customViewport)\r\n        {\r\n            //  We're turning off a custom viewport for this Camera\r\n            sceneManager.customViewports--;\r\n        }\r\n\r\n        this.dirty = true;\r\n        this._customViewport = custom;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Camera instance and its internal properties and references.\r\n     * Once destroyed you cannot use this Camera again, even if re-added to a Camera Manager.\r\n     * \r\n     * This method is called automatically by `CameraManager.remove` if that methods `runDestroy` argument is `true`, which is the default.\r\n     * \r\n     * Unless you have a specific reason otherwise, always use `CameraManager.remove` and allow it to handle the camera destruction,\r\n     * rather than calling this method directly.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.BaseCamera#destroy\r\n     * @fires Phaser.Cameras.Scene2D.Events#DESTROY\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.emit(Events.DESTROY, this);\r\n\r\n        this.removeAllListeners();\r\n\r\n        this.matrix.destroy();\r\n\r\n        this.culledObjects = [];\r\n\r\n        if (this._customViewport)\r\n        {\r\n            //  We're turning off a custom viewport for this Camera\r\n            this.sceneManager.customViewports--;\r\n        }\r\n\r\n        this._bounds = null;\r\n\r\n        this.scene = null;\r\n        this.scaleManager = null;\r\n        this.sceneManager = null;\r\n        this.cameraManager = null;\r\n    },\r\n\r\n    /**\r\n     * The x position of the Camera viewport, relative to the top-left of the game canvas.\r\n     * The viewport is the area into which the camera renders.\r\n     * To adjust the position the camera is looking at in the game world, see the `scrollX` value.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._x = value;\r\n            this._cx = value * this.resolution;\r\n            this.updateSystem();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The y position of the Camera viewport, relative to the top-left of the game canvas.\r\n     * The viewport is the area into which the camera renders.\r\n     * To adjust the position the camera is looking at in the game world, see the `scrollY` value.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._y = value;\r\n            this._cy = value * this.resolution;\r\n            this.updateSystem();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The width of the Camera viewport, in pixels.\r\n     *\r\n     * The viewport is the area into which the Camera renders. Setting the viewport does\r\n     * not restrict where the Camera can scroll to.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#width\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    width: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._width;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._width = value;\r\n            this._cw = value * this.resolution;\r\n            this.updateSystem();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The height of the Camera viewport, in pixels.\r\n     *\r\n     * The viewport is the area into which the Camera renders. Setting the viewport does\r\n     * not restrict where the Camera can scroll to.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#height\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    height: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._height;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._height = value;\r\n            this._ch = value * this.resolution;\r\n            this.updateSystem();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The horizontal scroll position of this Camera.\r\n     *\r\n     * Change this value to cause the Camera to scroll around your Scene.\r\n     *\r\n     * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,\r\n     * will automatically adjust the Camera scroll values accordingly.\r\n     *\r\n     * You can set the bounds within which the Camera can scroll via the `setBounds` method.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#scrollX\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    scrollX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scrollX;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scrollX = value;\r\n            this.dirty = true;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scroll position of this Camera.\r\n     *\r\n     * Change this value to cause the Camera to scroll around your Scene.\r\n     *\r\n     * Alternatively, setting the Camera to follow a Game Object, via the `startFollow` method,\r\n     * will automatically adjust the Camera scroll values accordingly.\r\n     *\r\n     * You can set the bounds within which the Camera can scroll via the `setBounds` method.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#scrollY\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    scrollY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scrollY;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scrollY = value;\r\n            this.dirty = true;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Camera zoom value. Change this value to zoom in, or out of, a Scene.\r\n     *\r\n     * A value of 0.5 would zoom the Camera out, so you can now see twice as much\r\n     * of the Scene as before. A value of 2 would zoom the Camera in, so every pixel\r\n     * now takes up 2 pixels when rendered.\r\n     *\r\n     * Set to 1 to return to the default zoom level.\r\n     *\r\n     * Be careful to never set this value to zero.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#zoom\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    zoom: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._zoom;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._zoom = value;\r\n            this.dirty = true;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The rotation of the Camera in radians.\r\n     *\r\n     * Camera rotation always takes place based on the Camera viewport. By default, rotation happens\r\n     * in the center of the viewport. You can adjust this with the `originX` and `originY` properties.\r\n     *\r\n     * Rotation influences the rendering of _all_ Game Objects visible by this Camera. However, it does not\r\n     * rotate the Camera viewport itself, which always remains an axis-aligned rectangle.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#rotation\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.11.0\r\n     */\r\n    rotation: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._rotation;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._rotation = value;\r\n            this.dirty = true;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The horizontal position of the center of the Camera's viewport, relative to the left of the game canvas.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#centerX\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    centerX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.x + (0.5 * this.width);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical position of the center of the Camera's viewport, relative to the top of the game canvas.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#centerY\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    centerY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.y + (0.5 * this.height);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The displayed width of the camera viewport, factoring in the camera zoom level.\r\n     *\r\n     * If a camera has a viewport width of 800 and a zoom of 0.5 then its display width\r\n     * would be 1600, as it's displaying twice as many pixels as zoom level 1.\r\n     *\r\n     * Equally, a camera with a width of 800 and zoom of 2 would have a display width\r\n     * of 400 pixels.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#displayWidth\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.11.0\r\n     */\r\n    displayWidth: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.width / this.zoom;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The displayed height of the camera viewport, factoring in the camera zoom level.\r\n     *\r\n     * If a camera has a viewport height of 600 and a zoom of 0.5 then its display height\r\n     * would be 1200, as it's displaying twice as many pixels as zoom level 1.\r\n     *\r\n     * Equally, a camera with a height of 600 and zoom of 2 would have a display height\r\n     * of 300 pixels.\r\n     *\r\n     * @name Phaser.Cameras.Scene2D.BaseCamera#displayHeight\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.11.0\r\n     */\r\n    displayHeight: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.height / this.zoom;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = BaseCamera;\r\n"]},"metadata":{},"sourceType":"script"}