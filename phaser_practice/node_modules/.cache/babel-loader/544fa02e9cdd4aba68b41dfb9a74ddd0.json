{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar SnapFloor = require('../../math/snap/SnapFloor');\n\nvar SnapCeil = require('../../math/snap/SnapCeil');\n/**\r\n * Returns the tiles in the given layer that are within the camera's viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.CullTiles\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to run the cull check against.\r\n * @param {array} [outputArray] - An optional array to store the Tile objects within.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\n\n\nvar CullTiles = function (layer, camera, outputArray, renderOrder) {\n  if (outputArray === undefined) {\n    outputArray = [];\n  }\n\n  if (renderOrder === undefined) {\n    renderOrder = 0;\n  }\n\n  outputArray.length = 0;\n  var tilemap = layer.tilemapLayer.tilemap;\n  var tilemapLayer = layer.tilemapLayer;\n  var mapData = layer.data;\n  var mapWidth = layer.width;\n  var mapHeight = layer.height; //  We need to use the tile sizes defined for the map as a whole, not the layer,\n  //  in order to calculate the bounds correctly. As different sized tiles may be\n  //  placed on the grid and we cannot trust layer.baseTileWidth to give us the true size.\n\n  var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);\n  var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);\n  var drawLeft = 0;\n  var drawRight = mapWidth;\n  var drawTop = 0;\n  var drawBottom = mapHeight;\n\n  if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1) {\n    //  Camera world view bounds, snapped for scaled tile size\n    //  Cull Padding values are given in tiles, not pixels\n    var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;\n    var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;\n    var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH, 0, true) - tilemapLayer.cullPaddingY;\n    var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH, 0, true) + tilemapLayer.cullPaddingY;\n    drawLeft = Math.max(0, boundsLeft);\n    drawRight = Math.min(mapWidth, boundsRight);\n    drawTop = Math.max(0, boundsTop);\n    drawBottom = Math.min(mapHeight, boundsBottom);\n  }\n\n  var x;\n  var y;\n  var tile;\n\n  if (renderOrder === 0) {\n    //  right-down\n    for (y = drawTop; y < drawBottom; y++) {\n      for (x = drawLeft; mapData[y] && x < drawRight; x++) {\n        tile = mapData[y][x];\n\n        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {\n          continue;\n        }\n\n        outputArray.push(tile);\n      }\n    }\n  } else if (renderOrder === 1) {\n    //  left-down\n    for (y = drawTop; y < drawBottom; y++) {\n      for (x = drawRight; mapData[y] && x >= drawLeft; x--) {\n        tile = mapData[y][x];\n\n        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {\n          continue;\n        }\n\n        outputArray.push(tile);\n      }\n    }\n  } else if (renderOrder === 2) {\n    //  right-up\n    for (y = drawBottom; y >= drawTop; y--) {\n      for (x = drawLeft; mapData[y] && x < drawRight; x++) {\n        tile = mapData[y][x];\n\n        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {\n          continue;\n        }\n\n        outputArray.push(tile);\n      }\n    }\n  } else if (renderOrder === 3) {\n    //  left-up\n    for (y = drawBottom; y >= drawTop; y--) {\n      for (x = drawRight; mapData[y] && x >= drawLeft; x--) {\n        tile = mapData[y][x];\n\n        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0) {\n          continue;\n        }\n\n        outputArray.push(tile);\n      }\n    }\n  }\n\n  tilemapLayer.tilesDrawn = outputArray.length;\n  tilemapLayer.tilesTotal = mapWidth * mapHeight;\n  return outputArray;\n};\n\nmodule.exports = CullTiles;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/tilemaps/components/CullTiles.js"],"names":["SnapFloor","require","SnapCeil","CullTiles","layer","camera","outputArray","renderOrder","undefined","length","tilemap","tilemapLayer","mapData","data","mapWidth","width","mapHeight","height","tileW","Math","floor","tileWidth","scaleX","tileH","tileHeight","scaleY","drawLeft","drawRight","drawTop","drawBottom","skipCull","scrollFactorX","scrollFactorY","boundsLeft","worldView","x","cullPaddingX","boundsRight","right","boundsTop","y","cullPaddingY","boundsBottom","bottom","max","min","tile","index","visible","alpha","push","tilesDrawn","tilesTotal","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SnapFloor = require('../../math/snap/SnapFloor');\r\nvar SnapCeil = require('../../math/snap/SnapCeil');\r\n\r\n/**\r\n * Returns the tiles in the given layer that are within the camera's viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.CullTiles\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to run the cull check against.\r\n * @param {array} [outputArray] - An optional array to store the Tile objects within.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\r\nvar CullTiles = function (layer, camera, outputArray, renderOrder)\r\n{\r\n    if (outputArray === undefined) { outputArray = []; }\r\n    if (renderOrder === undefined) { renderOrder = 0; }\r\n\r\n    outputArray.length = 0;\r\n\r\n    var tilemap = layer.tilemapLayer.tilemap;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var mapData = layer.data;\r\n    var mapWidth = layer.width;\r\n    var mapHeight = layer.height;\r\n\r\n    //  We need to use the tile sizes defined for the map as a whole, not the layer,\r\n    //  in order to calculate the bounds correctly. As different sized tiles may be\r\n    //  placed on the grid and we cannot trust layer.baseTileWidth to give us the true size.\r\n    var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);\r\n    var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);\r\n\r\n    var drawLeft = 0;\r\n    var drawRight = mapWidth;\r\n    var drawTop = 0;\r\n    var drawBottom = mapHeight;\r\n\r\n    if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1)\r\n    {\r\n        //  Camera world view bounds, snapped for scaled tile size\r\n        //  Cull Padding values are given in tiles, not pixels\r\n\r\n        var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;\r\n        var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;\r\n        var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH, 0, true) - tilemapLayer.cullPaddingY;\r\n        var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH, 0, true) + tilemapLayer.cullPaddingY;\r\n\r\n        drawLeft = Math.max(0, boundsLeft);\r\n        drawRight = Math.min(mapWidth, boundsRight);\r\n        drawTop = Math.max(0, boundsTop);\r\n        drawBottom = Math.min(mapHeight, boundsBottom);\r\n    }\r\n\r\n    var x;\r\n    var y;\r\n    var tile;\r\n\r\n    if (renderOrder === 0)\r\n    {\r\n        //  right-down\r\n\r\n        for (y = drawTop; y < drawBottom; y++)\r\n        {\r\n            for (x = drawLeft; mapData[y] && x < drawRight; x++)\r\n            {\r\n                tile = mapData[y][x];\r\n\r\n                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                outputArray.push(tile);\r\n            }\r\n        }\r\n    }\r\n    else if (renderOrder === 1)\r\n    {\r\n        //  left-down\r\n\r\n        for (y = drawTop; y < drawBottom; y++)\r\n        {\r\n            for (x = drawRight; mapData[y] && x >= drawLeft; x--)\r\n            {\r\n                tile = mapData[y][x];\r\n\r\n                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                outputArray.push(tile);\r\n            }\r\n        }\r\n    }\r\n    else if (renderOrder === 2)\r\n    {\r\n        //  right-up\r\n\r\n        for (y = drawBottom; y >= drawTop; y--)\r\n        {\r\n            for (x = drawLeft; mapData[y] && x < drawRight; x++)\r\n            {\r\n                tile = mapData[y][x];\r\n\r\n                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                outputArray.push(tile);\r\n            }\r\n        }\r\n    }\r\n    else if (renderOrder === 3)\r\n    {\r\n        //  left-up\r\n\r\n        for (y = drawBottom; y >= drawTop; y--)\r\n        {\r\n            for (x = drawRight; mapData[y] && x >= drawLeft; x--)\r\n            {\r\n                tile = mapData[y][x];\r\n\r\n                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                outputArray.push(tile);\r\n            }\r\n        }\r\n    }\r\n\r\n    tilemapLayer.tilesDrawn = outputArray.length;\r\n    tilemapLayer.tilesTotal = mapWidth * mapHeight;\r\n\r\n    return outputArray;\r\n};\r\n\r\nmodule.exports = CullTiles;\r\n"]},"metadata":{},"sourceType":"script"}