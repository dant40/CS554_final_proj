{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Clamp = require('../math/Clamp');\n\nvar Class = require('../utils/Class');\n\nvar Events = require('./events');\n\nvar GetFastValue = require('../utils/object/GetFastValue');\n\nvar PluginCache = require('../plugins/PluginCache');\n/**\r\n * @classdesc\r\n * A proxy class to the Global Scene Manager.\r\n *\r\n * @class ScenePlugin\r\n * @memberof Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that this ScenePlugin belongs to.\r\n */\n\n\nvar ScenePlugin = new Class({\n  initialize: function ScenePlugin(scene) {\n    /**\r\n     * The Scene that this ScenePlugin belongs to.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#scene\r\n     * @type {Phaser.Scene}\r\n     * @since 3.0.0\r\n     */\n    this.scene = scene;\n    /**\r\n     * The Scene Systems instance of the Scene that this ScenePlugin belongs to.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#systems\r\n     * @type {Phaser.Scenes.Systems}\r\n     * @since 3.0.0\r\n     */\n\n    this.systems = scene.sys;\n    /**\r\n     * The settings of the Scene this ScenePlugin belongs to.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#settings\r\n     * @type {Phaser.Types.Scenes.SettingsObject}\r\n     * @since 3.0.0\r\n     */\n\n    this.settings = scene.sys.settings;\n    /**\r\n     * The key of the Scene this ScenePlugin belongs to.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#key\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\n\n    this.key = scene.sys.settings.key;\n    /**\r\n     * The Game's SceneManager.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#manager\r\n     * @type {Phaser.Scenes.SceneManager}\r\n     * @since 3.0.0\r\n     */\n\n    this.manager = scene.sys.game.scene;\n    /**\r\n     * If this Scene is currently transitioning to another, this holds\r\n     * the current percentage of the transition progress, between 0 and 1.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#transitionProgress\r\n     * @type {number}\r\n     * @since 3.5.0\r\n     */\n\n    this.transitionProgress = 0;\n    /**\r\n     * Transition elapsed timer.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#_elapsed\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.5.0\r\n     */\n\n    this._elapsed = 0;\n    /**\r\n     * Transition elapsed timer.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#_target\r\n     * @type {?Phaser.Scenes.Scene}\r\n     * @private\r\n     * @since 3.5.0\r\n     */\n\n    this._target = null;\n    /**\r\n     * Transition duration.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#_duration\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.5.0\r\n     */\n\n    this._duration = 0;\n    /**\r\n     * Transition callback.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#_onUpdate\r\n     * @type {function}\r\n     * @private\r\n     * @since 3.5.0\r\n     */\n\n    this._onUpdate;\n    /**\r\n     * Transition callback scope.\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#_onUpdateScope\r\n     * @type {object}\r\n     * @private\r\n     * @since 3.5.0\r\n     */\n\n    this._onUpdateScope;\n    /**\r\n     * Will this Scene sleep (true) after the transition, or stop (false)\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#_willSleep\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.5.0\r\n     */\n\n    this._willSleep = false;\n    /**\r\n     * Will this Scene be removed from the Scene Manager after the transition completes?\r\n     *\r\n     * @name Phaser.Scenes.ScenePlugin#_willRemove\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.5.0\r\n     */\n\n    this._willRemove = false;\n    scene.sys.events.once(Events.BOOT, this.boot, this);\n    scene.sys.events.on(Events.START, this.pluginStart, this);\n  },\n\n  /**\r\n   * This method is called automatically, only once, when the Scene is first created.\r\n   * Do not invoke it directly.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#boot\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  boot: function () {\n    this.systems.events.once(Events.DESTROY, this.destroy, this);\n  },\n\n  /**\r\n   * This method is called automatically by the Scene when it is starting up.\r\n   * It is responsible for creating local systems, properties and listening for Scene events.\r\n   * Do not invoke it directly.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#pluginStart\r\n   * @private\r\n   * @since 3.5.0\r\n   */\n  pluginStart: function () {\n    this._target = null;\n    this.systems.events.once(Events.SHUTDOWN, this.shutdown, this);\n  },\n\n  /**\r\n   * Shutdown this Scene and run the given one.\r\n   *\r\n   * This will happen at the next Scene Manager update, not immediately.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#start\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to start.\r\n   * @param {object} [data] - The Scene data.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  start: function (key, data) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.queueOp('stop', this.key);\n    this.manager.queueOp('start', key, data);\n    return this;\n  },\n\n  /**\r\n   * Restarts this Scene.\r\n   *\r\n   * This will happen at the next Scene Manager update, not immediately.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#restart\r\n   * @since 3.4.0\r\n   *\r\n   * @param {object} [data] - The Scene data.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  restart: function (data) {\n    var key = this.key;\n    this.manager.queueOp('stop', key);\n    this.manager.queueOp('start', key, data);\n    return this;\n  },\n\n  /**\r\n   * This will start a transition from the current Scene to the target Scene given.\r\n   *\r\n   * The transition will last for the duration specified in milliseconds.\r\n   *\r\n   * You can have the target Scene moved above or below this one in the display list.\r\n   *\r\n   * You can specify an update callback. This callback will be invoked _every frame_ for the duration\r\n   * of the transition.\r\n   *\r\n   * This Scene can either be sent to sleep at the end of the transition, or stopped. The default is to stop.\r\n   *\r\n   * There are also 5 transition related events: This scene will emit the event `transitionout` when\r\n   * the transition begins, which is typically the frame after calling this method.\r\n   *\r\n   * The target Scene will emit the event `transitioninit` when that Scene's `init` method is called.\r\n   * It will then emit the event `transitionstart` when its `create` method is called.\r\n   * If the Scene was sleeping and has been woken up, it will emit the event `transitionwake` instead of these two,\r\n   * as the Scenes `init` and `create` methods are not invoked when a Scene wakes up.\r\n   *\r\n   * When the duration of the transition has elapsed it will emit the event `transitioncomplete`.\r\n   * These events are cleared of all listeners when the Scene shuts down, but not if it is sent to sleep.\r\n   *\r\n   * It's important to understand that the duration of the transition begins the moment you call this method.\r\n   * If the Scene you are transitioning to includes delayed processes, such as waiting for files to load, the\r\n   * time still counts down even while that is happening. If the game itself pauses, or something else causes\r\n   * this Scenes update loop to stop, then the transition will also pause for that duration. There are\r\n   * checks in place to prevent you accidentally stopping a transitioning Scene but if you've got code to\r\n   * override this understand that until the target Scene completes it might never be unlocked for input events.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#transition\r\n   * @fires Phaser.Scenes.Events#TRANSITION_OUT\r\n   * @since 3.5.0\r\n   *\r\n   * @param {Phaser.Types.Scenes.SceneTransitionConfig} config - The transition configuration object.\r\n   *\r\n   * @return {boolean} `true` is the transition was started, otherwise `false`.\r\n   */\n  transition: function (config) {\n    if (config === undefined) {\n      config = {};\n    }\n\n    var key = GetFastValue(config, 'target', false);\n    var target = this.manager.getScene(key);\n\n    if (!key || !this.checkValidTransition(target)) {\n      return false;\n    }\n\n    var duration = GetFastValue(config, 'duration', 1000);\n    this._elapsed = 0;\n    this._target = target;\n    this._duration = duration;\n    this._willSleep = GetFastValue(config, 'sleep', false);\n    this._willRemove = GetFastValue(config, 'remove', false);\n    var callback = GetFastValue(config, 'onUpdate', null);\n\n    if (callback) {\n      this._onUpdate = callback;\n      this._onUpdateScope = GetFastValue(config, 'onUpdateScope', this.scene);\n    }\n\n    var allowInput = GetFastValue(config, 'allowInput', false);\n    this.settings.transitionAllowInput = allowInput;\n    var targetSettings = target.sys.settings;\n    targetSettings.isTransition = true;\n    targetSettings.transitionFrom = this.scene;\n    targetSettings.transitionDuration = duration;\n    targetSettings.transitionAllowInput = allowInput;\n\n    if (GetFastValue(config, 'moveAbove', false)) {\n      this.manager.moveAbove(this.key, key);\n    } else if (GetFastValue(config, 'moveBelow', false)) {\n      this.manager.moveBelow(this.key, key);\n    }\n\n    if (target.sys.isSleeping()) {\n      target.sys.wake();\n    } else {\n      this.manager.start(key, GetFastValue(config, 'data'));\n    }\n\n    this.systems.events.emit(Events.TRANSITION_OUT, target, duration);\n    this.systems.events.on(Events.UPDATE, this.step, this);\n    return true;\n  },\n\n  /**\r\n   * Checks to see if this Scene can transition to the target Scene or not.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#checkValidTransition\r\n   * @private\r\n   * @since 3.5.0\r\n   *\r\n   * @param {Phaser.Scene} target - The Scene to test against.\r\n   *\r\n   * @return {boolean} `true` if this Scene can transition, otherwise `false`.\r\n   */\n  checkValidTransition: function (target) {\n    //  Not a valid target if it doesn't exist, isn't active or is already transitioning in or out\n    if (!target || target.sys.isActive() || target.sys.isTransitioning() || target === this.scene || this.systems.isTransitioning()) {\n      return false;\n    }\n\n    return true;\n  },\n\n  /**\r\n   * A single game step. This is only called if the parent Scene is transitioning\r\n   * out to another Scene.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#step\r\n   * @private\r\n   * @since 3.5.0\r\n   *\r\n   * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n   * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n   */\n  step: function (time, delta) {\n    this._elapsed += delta;\n    this.transitionProgress = Clamp(this._elapsed / this._duration, 0, 1);\n\n    if (this._onUpdate) {\n      this._onUpdate.call(this._onUpdateScope, this.transitionProgress);\n    }\n\n    if (this._elapsed >= this._duration) {\n      this.transitionComplete();\n    }\n  },\n\n  /**\r\n   * Called by `step` when the transition out of this scene to another is over.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#transitionComplete\r\n   * @private\r\n   * @fires Phaser.Scenes.Events#TRANSITION_COMPLETE\r\n   * @since 3.5.0\r\n   */\n  transitionComplete: function () {\n    var targetSys = this._target.sys;\n    var targetSettings = this._target.sys.settings; //  Stop the step\n\n    this.systems.events.off(Events.UPDATE, this.step, this); //  Notify target scene\n\n    targetSys.events.emit(Events.TRANSITION_COMPLETE, this.scene); //  Clear target scene settings\n\n    targetSettings.isTransition = false;\n    targetSettings.transitionFrom = null; //  Clear local settings\n\n    this._duration = 0;\n    this._target = null;\n    this._onUpdate = null;\n    this._onUpdateScope = null; //  Now everything is clear we can handle what happens to this Scene\n\n    if (this._willRemove) {\n      this.manager.remove(this.key);\n    } else if (this._willSleep) {\n      this.systems.sleep();\n    } else {\n      this.manager.stop(this.key);\n    }\n  },\n\n  /**\r\n   * Add the Scene into the Scene Manager and start it if 'autoStart' is true or the Scene config 'active' property is set.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#add\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene key.\r\n   * @param {(Phaser.Scene|Phaser.Types.Scenes.SettingsConfig|Phaser.Types.Scenes.CreateSceneFromObjectConfig|function)} sceneConfig - The config for the Scene.\r\n   * @param {boolean} autoStart - Whether to start the Scene after it's added.\r\n   * @param {object} [data] - Optional data object. This will be set as Scene.settings.data and passed to `Scene.init`.\r\n   *\r\n   * @return {Phaser.Scene} An instance of the Scene that was added to the Scene Manager.\r\n   */\n  add: function (key, sceneConfig, autoStart, data) {\n    return this.manager.add(key, sceneConfig, autoStart, data);\n  },\n\n  /**\r\n   * Launch the given Scene and run it in parallel with this one.\r\n   *\r\n   * This will happen at the next Scene Manager update, not immediately.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#launch\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to launch.\r\n   * @param {object} [data] - The Scene data.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  launch: function (key, data) {\n    if (key && key !== this.key) {\n      this.manager.queueOp('start', key, data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Runs the given Scene, but does not change the state of this Scene.\r\n   *\r\n   * This will happen at the next Scene Manager update, not immediately.\r\n   *\r\n   * If the given Scene is paused, it will resume it. If sleeping, it will wake it.\r\n   * If not running at all, it will be started.\r\n   *\r\n   * Use this if you wish to open a modal Scene by calling `pause` on the current\r\n   * Scene, then `run` on the modal Scene.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#run\r\n   * @since 3.10.0\r\n   *\r\n   * @param {string} key - The Scene to run.\r\n   * @param {object} [data] - A data object that will be passed to the Scene and emitted in its ready, wake, or resume events.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  run: function (key, data) {\n    if (key && key !== this.key) {\n      this.manager.queueOp('run', key, data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Pause the Scene - this stops the update step from happening but it still renders.\r\n   *\r\n   * This will happen at the next Scene Manager update, not immediately.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#pause\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to pause.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its pause event.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  pause: function (key, data) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.queueOp('pause', key, data);\n    return this;\n  },\n\n  /**\r\n   * Resume the Scene - starts the update loop again.\r\n   *\r\n   * This will happen at the next Scene Manager update, not immediately.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#resume\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to resume.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its resume event.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  resume: function (key, data) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.queueOp('resume', key, data);\n    return this;\n  },\n\n  /**\r\n   * Makes the Scene sleep (no update, no render) but doesn't shutdown.\r\n   *\r\n   * This will happen at the next Scene Manager update, not immediately.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#sleep\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to put to sleep.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its sleep event.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  sleep: function (key, data) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.queueOp('sleep', key, data);\n    return this;\n  },\n\n  /**\r\n   * Makes the Scene wake-up (starts update and render)\r\n   *\r\n   * This will happen at the next Scene Manager update, not immediately.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#wake\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to wake up.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its wake event.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  wake: function (key, data) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.queueOp('wake', key, data);\n    return this;\n  },\n\n  /**\r\n   * Makes this Scene sleep then starts the Scene given.\r\n   *\r\n   * This will happen at the next Scene Manager update, not immediately.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#switch\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to start.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  switch: function (key) {\n    if (key !== this.key) {\n      this.manager.queueOp('switch', this.key, key);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Shutdown the Scene, clearing display list, timers, etc.\r\n   *\r\n   * This happens at the next Scene Manager update, not immediately.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#stop\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to stop.\r\n   * @param {any} [data] - Optional data object to pass to Scene.Systems.shutdown.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  stop: function (key, data) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.queueOp('stop', key, data);\n    return this;\n  },\n\n  /**\r\n   * Sets the active state of the given Scene.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#setActive\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - If `true` the Scene will be resumed. If `false` it will be paused.\r\n   * @param {string} [key] - The Scene to set the active state of.\r\n   * @param {object} [data] - An optional data object that will be passed to the Scene and emitted with its events.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  setActive: function (value, key, data) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    var scene = this.manager.getScene(key);\n\n    if (scene) {\n      scene.sys.setActive(value, data);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the visible state of the given Scene.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#setVisible\r\n   * @since 3.0.0\r\n   *\r\n   * @param {boolean} value - The visible value.\r\n   * @param {string} [key] - The Scene to set the visible state for.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  setVisible: function (value, key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    var scene = this.manager.getScene(key);\n\n    if (scene) {\n      scene.sys.setVisible(value);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Checks if the given Scene is sleeping or not?\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#isSleeping\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to check.\r\n   *\r\n   * @return {boolean} Whether the Scene is sleeping.\r\n   */\n  isSleeping: function (key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    return this.manager.isSleeping(key);\n  },\n\n  /**\r\n   * Checks if the given Scene is running or not?\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#isActive\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to check.\r\n   *\r\n   * @return {boolean} Whether the Scene is running.\r\n   */\n  isActive: function (key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    return this.manager.isActive(key);\n  },\n\n  /**\r\n   * Checks if the given Scene is paused or not?\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#isPaused\r\n   * @since 3.17.0\r\n   *\r\n   * @param {string} [key] - The Scene to check.\r\n   *\r\n   * @return {boolean} Whether the Scene is paused.\r\n   */\n  isPaused: function (key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    return this.manager.isPaused(key);\n  },\n\n  /**\r\n   * Checks if the given Scene is visible or not?\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#isVisible\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to check.\r\n   *\r\n   * @return {boolean} Whether the Scene is visible.\r\n   */\n  isVisible: function (key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    return this.manager.isVisible(key);\n  },\n\n  /**\r\n   * Swaps the position of two scenes in the Scenes list.\r\n   *\r\n   * This controls the order in which they are rendered and updated.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#swapPosition\r\n   * @since 3.2.0\r\n   *\r\n   * @param {string} keyA - The first Scene to swap.\r\n   * @param {string} [keyB] - The second Scene to swap. If none is given it defaults to this Scene.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  swapPosition: function (keyA, keyB) {\n    if (keyB === undefined) {\n      keyB = this.key;\n    }\n\n    if (keyA !== keyB) {\n      this.manager.swapPosition(keyA, keyB);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Swaps the position of two scenes in the Scenes list, so that Scene B is directly above Scene A.\r\n   *\r\n   * This controls the order in which they are rendered and updated.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#moveAbove\r\n   * @since 3.2.0\r\n   *\r\n   * @param {string} keyA - The Scene that Scene B will be moved to be above.\r\n   * @param {string} [keyB] - The Scene to be moved. If none is given it defaults to this Scene.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  moveAbove: function (keyA, keyB) {\n    if (keyB === undefined) {\n      keyB = this.key;\n    }\n\n    if (keyA !== keyB) {\n      this.manager.moveAbove(keyA, keyB);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Swaps the position of two scenes in the Scenes list, so that Scene B is directly below Scene A.\r\n   *\r\n   * This controls the order in which they are rendered and updated.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#moveBelow\r\n   * @since 3.2.0\r\n   *\r\n   * @param {string} keyA - The Scene that Scene B will be moved to be below.\r\n   * @param {string} [keyB] - The Scene to be moved. If none is given it defaults to this Scene.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  moveBelow: function (keyA, keyB) {\n    if (keyB === undefined) {\n      keyB = this.key;\n    }\n\n    if (keyA !== keyB) {\n      this.manager.moveBelow(keyA, keyB);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes a Scene from the SceneManager.\r\n   *\r\n   * The Scene is removed from the local scenes array, it's key is cleared from the keys\r\n   * cache and Scene.Systems.destroy is then called on it.\r\n   *\r\n   * If the SceneManager is processing the Scenes when this method is called it will\r\n   * queue the operation for the next update sequence.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#remove\r\n   * @since 3.2.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} [key] - The Scene to be removed.\r\n   *\r\n   * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n   */\n  remove: function (key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.remove(key);\n    return this;\n  },\n\n  /**\r\n   * Moves a Scene up one position in the Scenes list.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#moveUp\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to move.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  moveUp: function (key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.moveUp(key);\n    return this;\n  },\n\n  /**\r\n   * Moves a Scene down one position in the Scenes list.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#moveDown\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to move.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  moveDown: function (key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.moveDown(key);\n    return this;\n  },\n\n  /**\r\n   * Brings a Scene to the top of the Scenes list.\r\n   *\r\n   * This means it will render above all other Scenes.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#bringToTop\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to move.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  bringToTop: function (key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.bringToTop(key);\n    return this;\n  },\n\n  /**\r\n   * Sends a Scene to the back of the Scenes list.\r\n   *\r\n   * This means it will render below all other Scenes.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#sendToBack\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} [key] - The Scene to move.\r\n   *\r\n   * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n   */\n  sendToBack: function (key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    this.manager.sendToBack(key);\n    return this;\n  },\n\n  /**\r\n   * Retrieve a Scene.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#get\r\n   * @since 3.0.0\r\n   *\r\n   * @param {string} key - The Scene to retrieve.\r\n   *\r\n   * @return {Phaser.Scene} The Scene.\r\n   */\n  get: function (key) {\n    return this.manager.getScene(key);\n  },\n\n  /**\r\n   * Retrieves the numeric index of a Scene in the Scenes list.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#getIndex\r\n   * @since 3.7.0\r\n   *\r\n   * @param {(string|Phaser.Scene)} [key] - The Scene to get the index of.\r\n   *\r\n   * @return {integer} The index of the Scene.\r\n   */\n  getIndex: function (key) {\n    if (key === undefined) {\n      key = this.key;\n    }\n\n    return this.manager.getIndex(key);\n  },\n\n  /**\r\n   * The Scene that owns this plugin is shutting down.\r\n   * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#shutdown\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  shutdown: function () {\n    var eventEmitter = this.systems.events;\n    eventEmitter.off(Events.SHUTDOWN, this.shutdown, this);\n    eventEmitter.off(Events.POST_UPDATE, this.step, this);\n    eventEmitter.off(Events.TRANSITION_OUT);\n  },\n\n  /**\r\n   * The Scene that owns this plugin is being destroyed.\r\n   * We need to shutdown and then kill off all external references.\r\n   *\r\n   * @method Phaser.Scenes.ScenePlugin#destroy\r\n   * @private\r\n   * @since 3.0.0\r\n   */\n  destroy: function () {\n    this.shutdown();\n    this.scene.sys.events.off(Events.START, this.start, this);\n    this.scene = null;\n    this.systems = null;\n    this.settings = null;\n    this.manager = null;\n  }\n});\nPluginCache.register('ScenePlugin', ScenePlugin, 'scenePlugin');\nmodule.exports = ScenePlugin;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/scene/ScenePlugin.js"],"names":["Clamp","require","Class","Events","GetFastValue","PluginCache","ScenePlugin","initialize","scene","systems","sys","settings","key","manager","game","transitionProgress","_elapsed","_target","_duration","_onUpdate","_onUpdateScope","_willSleep","_willRemove","events","once","BOOT","boot","on","START","pluginStart","DESTROY","destroy","SHUTDOWN","shutdown","start","data","undefined","queueOp","restart","transition","config","target","getScene","checkValidTransition","duration","callback","allowInput","transitionAllowInput","targetSettings","isTransition","transitionFrom","transitionDuration","moveAbove","moveBelow","isSleeping","wake","emit","TRANSITION_OUT","UPDATE","step","isActive","isTransitioning","time","delta","call","transitionComplete","targetSys","off","TRANSITION_COMPLETE","remove","sleep","stop","add","sceneConfig","autoStart","launch","run","pause","resume","switch","setActive","value","setVisible","isPaused","isVisible","swapPosition","keyA","keyB","moveUp","moveDown","bringToTop","sendToBack","get","getIndex","eventEmitter","POST_UPDATE","register","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clamp = require('../math/Clamp');\r\nvar Class = require('../utils/Class');\r\nvar Events = require('./events');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar PluginCache = require('../plugins/PluginCache');\r\n\r\n/**\r\n * @classdesc\r\n * A proxy class to the Global Scene Manager.\r\n *\r\n * @class ScenePlugin\r\n * @memberof Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that this ScenePlugin belongs to.\r\n */\r\nvar ScenePlugin = new Class({\r\n\r\n    initialize:\r\n\r\n    function ScenePlugin (scene)\r\n    {\r\n        /**\r\n         * The Scene that this ScenePlugin belongs to.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The Scene Systems instance of the Scene that this ScenePlugin belongs to.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * The settings of the Scene this ScenePlugin belongs to.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#settings\r\n         * @type {Phaser.Types.Scenes.SettingsObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.settings = scene.sys.settings;\r\n\r\n        /**\r\n         * The key of the Scene this ScenePlugin belongs to.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#key\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.key = scene.sys.settings.key;\r\n\r\n        /**\r\n         * The Game's SceneManager.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#manager\r\n         * @type {Phaser.Scenes.SceneManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = scene.sys.game.scene;\r\n\r\n        /**\r\n         * If this Scene is currently transitioning to another, this holds\r\n         * the current percentage of the transition progress, between 0 and 1.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#transitionProgress\r\n         * @type {number}\r\n         * @since 3.5.0\r\n         */\r\n        this.transitionProgress = 0;\r\n\r\n        /**\r\n         * Transition elapsed timer.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_elapsed\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._elapsed = 0;\r\n\r\n        /**\r\n         * Transition elapsed timer.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_target\r\n         * @type {?Phaser.Scenes.Scene}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._target = null;\r\n\r\n        /**\r\n         * Transition duration.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_duration\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._duration = 0;\r\n\r\n        /**\r\n         * Transition callback.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_onUpdate\r\n         * @type {function}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._onUpdate;\r\n\r\n        /**\r\n         * Transition callback scope.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_onUpdateScope\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._onUpdateScope;\r\n\r\n        /**\r\n         * Will this Scene sleep (true) after the transition, or stop (false)\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_willSleep\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._willSleep = false;\r\n\r\n        /**\r\n         * Will this Scene be removed from the Scene Manager after the transition completes?\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_willRemove\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._willRemove = false;\r\n\r\n        scene.sys.events.once(Events.BOOT, this.boot, this);\r\n        scene.sys.events.on(Events.START, this.pluginStart, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#boot\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.systems.events.once(Events.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#pluginStart\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    pluginStart: function ()\r\n    {\r\n        this._target = null;\r\n\r\n        this.systems.events.once(Events.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * Shutdown this Scene and run the given one.\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#start\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to start.\r\n     * @param {object} [data] - The Scene data.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    start: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('stop', this.key);\r\n        this.manager.queueOp('start', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Restarts this Scene.\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#restart\r\n     * @since 3.4.0\r\n     *\r\n     * @param {object} [data] - The Scene data.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    restart: function (data)\r\n    {\r\n        var key = this.key;\r\n\r\n        this.manager.queueOp('stop', key);\r\n        this.manager.queueOp('start', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This will start a transition from the current Scene to the target Scene given.\r\n     *\r\n     * The transition will last for the duration specified in milliseconds.\r\n     *\r\n     * You can have the target Scene moved above or below this one in the display list.\r\n     *\r\n     * You can specify an update callback. This callback will be invoked _every frame_ for the duration\r\n     * of the transition.\r\n     *\r\n     * This Scene can either be sent to sleep at the end of the transition, or stopped. The default is to stop.\r\n     *\r\n     * There are also 5 transition related events: This scene will emit the event `transitionout` when\r\n     * the transition begins, which is typically the frame after calling this method.\r\n     *\r\n     * The target Scene will emit the event `transitioninit` when that Scene's `init` method is called.\r\n     * It will then emit the event `transitionstart` when its `create` method is called.\r\n     * If the Scene was sleeping and has been woken up, it will emit the event `transitionwake` instead of these two,\r\n     * as the Scenes `init` and `create` methods are not invoked when a Scene wakes up.\r\n     *\r\n     * When the duration of the transition has elapsed it will emit the event `transitioncomplete`.\r\n     * These events are cleared of all listeners when the Scene shuts down, but not if it is sent to sleep.\r\n     *\r\n     * It's important to understand that the duration of the transition begins the moment you call this method.\r\n     * If the Scene you are transitioning to includes delayed processes, such as waiting for files to load, the\r\n     * time still counts down even while that is happening. If the game itself pauses, or something else causes\r\n     * this Scenes update loop to stop, then the transition will also pause for that duration. There are\r\n     * checks in place to prevent you accidentally stopping a transitioning Scene but if you've got code to\r\n     * override this understand that until the target Scene completes it might never be unlocked for input events.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#transition\r\n     * @fires Phaser.Scenes.Events#TRANSITION_OUT\r\n     * @since 3.5.0\r\n     *\r\n     * @param {Phaser.Types.Scenes.SceneTransitionConfig} config - The transition configuration object.\r\n     *\r\n     * @return {boolean} `true` is the transition was started, otherwise `false`.\r\n     */\r\n    transition: function (config)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        var key = GetFastValue(config, 'target', false);\r\n\r\n        var target = this.manager.getScene(key);\r\n\r\n        if (!key || !this.checkValidTransition(target))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var duration = GetFastValue(config, 'duration', 1000);\r\n\r\n        this._elapsed = 0;\r\n        this._target = target;\r\n        this._duration = duration;\r\n        this._willSleep = GetFastValue(config, 'sleep', false);\r\n        this._willRemove = GetFastValue(config, 'remove', false);\r\n\r\n        var callback = GetFastValue(config, 'onUpdate', null);\r\n\r\n        if (callback)\r\n        {\r\n            this._onUpdate = callback;\r\n            this._onUpdateScope = GetFastValue(config, 'onUpdateScope', this.scene);\r\n        }\r\n\r\n        var allowInput = GetFastValue(config, 'allowInput', false);\r\n\r\n        this.settings.transitionAllowInput = allowInput;\r\n\r\n        var targetSettings = target.sys.settings;\r\n\r\n        targetSettings.isTransition = true;\r\n        targetSettings.transitionFrom = this.scene;\r\n        targetSettings.transitionDuration = duration;\r\n        targetSettings.transitionAllowInput = allowInput;\r\n\r\n        if (GetFastValue(config, 'moveAbove', false))\r\n        {\r\n            this.manager.moveAbove(this.key, key);\r\n        }\r\n        else if (GetFastValue(config, 'moveBelow', false))\r\n        {\r\n            this.manager.moveBelow(this.key, key);\r\n        }\r\n\r\n        if (target.sys.isSleeping())\r\n        {\r\n            target.sys.wake();\r\n        }\r\n        else\r\n        {\r\n            this.manager.start(key, GetFastValue(config, 'data'));\r\n        }\r\n\r\n        this.systems.events.emit(Events.TRANSITION_OUT, target, duration);\r\n\r\n        this.systems.events.on(Events.UPDATE, this.step, this);\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if this Scene can transition to the target Scene or not.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#checkValidTransition\r\n     * @private\r\n     * @since 3.5.0\r\n     *\r\n     * @param {Phaser.Scene} target - The Scene to test against.\r\n     *\r\n     * @return {boolean} `true` if this Scene can transition, otherwise `false`.\r\n     */\r\n    checkValidTransition: function (target)\r\n    {\r\n        //  Not a valid target if it doesn't exist, isn't active or is already transitioning in or out\r\n        if (!target || target.sys.isActive() || target.sys.isTransitioning() || target === this.scene || this.systems.isTransitioning())\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * A single game step. This is only called if the parent Scene is transitioning\r\n     * out to another Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#step\r\n     * @private\r\n     * @since 3.5.0\r\n     *\r\n     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     */\r\n    step: function (time, delta)\r\n    {\r\n        this._elapsed += delta;\r\n\r\n        this.transitionProgress = Clamp(this._elapsed / this._duration, 0, 1);\r\n\r\n        if (this._onUpdate)\r\n        {\r\n            this._onUpdate.call(this._onUpdateScope, this.transitionProgress);\r\n        }\r\n\r\n        if (this._elapsed >= this._duration)\r\n        {\r\n            this.transitionComplete();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by `step` when the transition out of this scene to another is over.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#transitionComplete\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#TRANSITION_COMPLETE\r\n     * @since 3.5.0\r\n     */\r\n    transitionComplete: function ()\r\n    {\r\n        var targetSys = this._target.sys;\r\n        var targetSettings = this._target.sys.settings;\r\n\r\n        //  Stop the step\r\n        this.systems.events.off(Events.UPDATE, this.step, this);\r\n\r\n        //  Notify target scene\r\n        targetSys.events.emit(Events.TRANSITION_COMPLETE, this.scene);\r\n\r\n        //  Clear target scene settings\r\n        targetSettings.isTransition = false;\r\n        targetSettings.transitionFrom = null;\r\n\r\n        //  Clear local settings\r\n        this._duration = 0;\r\n        this._target = null;\r\n        this._onUpdate = null;\r\n        this._onUpdateScope = null;\r\n\r\n        //  Now everything is clear we can handle what happens to this Scene\r\n        if (this._willRemove)\r\n        {\r\n            this.manager.remove(this.key);\r\n        }\r\n        else if (this._willSleep)\r\n        {\r\n            this.systems.sleep();\r\n        }\r\n        else\r\n        {\r\n            this.manager.stop(this.key);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Add the Scene into the Scene Manager and start it if 'autoStart' is true or the Scene config 'active' property is set.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene key.\r\n     * @param {(Phaser.Scene|Phaser.Types.Scenes.SettingsConfig|Phaser.Types.Scenes.CreateSceneFromObjectConfig|function)} sceneConfig - The config for the Scene.\r\n     * @param {boolean} autoStart - Whether to start the Scene after it's added.\r\n     * @param {object} [data] - Optional data object. This will be set as Scene.settings.data and passed to `Scene.init`.\r\n     *\r\n     * @return {Phaser.Scene} An instance of the Scene that was added to the Scene Manager.\r\n     */\r\n    add: function (key, sceneConfig, autoStart, data)\r\n    {\r\n        return this.manager.add(key, sceneConfig, autoStart, data);\r\n    },\r\n\r\n    /**\r\n     * Launch the given Scene and run it in parallel with this one.\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#launch\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to launch.\r\n     * @param {object} [data] - The Scene data.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    launch: function (key, data)\r\n    {\r\n        if (key && key !== this.key)\r\n        {\r\n            this.manager.queueOp('start', key, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Runs the given Scene, but does not change the state of this Scene.\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * If the given Scene is paused, it will resume it. If sleeping, it will wake it.\r\n     * If not running at all, it will be started.\r\n     *\r\n     * Use this if you wish to open a modal Scene by calling `pause` on the current\r\n     * Scene, then `run` on the modal Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#run\r\n     * @since 3.10.0\r\n     *\r\n     * @param {string} key - The Scene to run.\r\n     * @param {object} [data] - A data object that will be passed to the Scene and emitted in its ready, wake, or resume events.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    run: function (key, data)\r\n    {\r\n        if (key && key !== this.key)\r\n        {\r\n            this.manager.queueOp('run', key, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Pause the Scene - this stops the update step from happening but it still renders.\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to pause.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its pause event.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    pause: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('pause', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resume the Scene - starts the update loop again.\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to resume.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its resume event.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    resume: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('resume', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Makes the Scene sleep (no update, no render) but doesn't shutdown.\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#sleep\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to put to sleep.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its sleep event.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    sleep: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('sleep', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Makes the Scene wake-up (starts update and render)\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#wake\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to wake up.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its wake event.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    wake: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('wake', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Makes this Scene sleep then starts the Scene given.\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#switch\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to start.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    switch: function (key)\r\n    {\r\n        if (key !== this.key)\r\n        {\r\n            this.manager.queueOp('switch', this.key, key);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shutdown the Scene, clearing display list, timers, etc.\r\n     *\r\n     * This happens at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to stop.\r\n     * @param {any} [data] - Optional data object to pass to Scene.Systems.shutdown.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    stop: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('stop', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the active state of the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - If `true` the Scene will be resumed. If `false` it will be paused.\r\n     * @param {string} [key] - The Scene to set the active state of.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted with its events.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    setActive: function (value, key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        var scene = this.manager.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.setActive(value, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the visible state of the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#setVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The visible value.\r\n     * @param {string} [key] - The Scene to set the visible state for.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    setVisible: function (value, key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        var scene = this.manager.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.setVisible(value);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Scene is sleeping or not?\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#isSleeping\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is sleeping.\r\n     */\r\n    isSleeping: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        return this.manager.isSleeping(key);\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Scene is running or not?\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#isActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is running.\r\n     */\r\n    isActive: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        return this.manager.isActive(key);\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Scene is paused or not?\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#isPaused\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} [key] - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is paused.\r\n     */\r\n    isPaused: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        return this.manager.isPaused(key);\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Scene is visible or not?\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#isVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is visible.\r\n     */\r\n    isVisible: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        return this.manager.isVisible(key);\r\n    },\r\n\r\n    /**\r\n     * Swaps the position of two scenes in the Scenes list.\r\n     *\r\n     * This controls the order in which they are rendered and updated.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#swapPosition\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} keyA - The first Scene to swap.\r\n     * @param {string} [keyB] - The second Scene to swap. If none is given it defaults to this Scene.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    swapPosition: function (keyA, keyB)\r\n    {\r\n        if (keyB === undefined) { keyB = this.key; }\r\n\r\n        if (keyA !== keyB)\r\n        {\r\n            this.manager.swapPosition(keyA, keyB);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Swaps the position of two scenes in the Scenes list, so that Scene B is directly above Scene A.\r\n     *\r\n     * This controls the order in which they are rendered and updated.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#moveAbove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} keyA - The Scene that Scene B will be moved to be above.\r\n     * @param {string} [keyB] - The Scene to be moved. If none is given it defaults to this Scene.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    moveAbove: function (keyA, keyB)\r\n    {\r\n        if (keyB === undefined) { keyB = this.key; }\r\n\r\n        if (keyA !== keyB)\r\n        {\r\n            this.manager.moveAbove(keyA, keyB);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Swaps the position of two scenes in the Scenes list, so that Scene B is directly below Scene A.\r\n     *\r\n     * This controls the order in which they are rendered and updated.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#moveBelow\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} keyA - The Scene that Scene B will be moved to be below.\r\n     * @param {string} [keyB] - The Scene to be moved. If none is given it defaults to this Scene.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    moveBelow: function (keyA, keyB)\r\n    {\r\n        if (keyB === undefined) { keyB = this.key; }\r\n\r\n        if (keyA !== keyB)\r\n        {\r\n            this.manager.moveBelow(keyA, keyB);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a Scene from the SceneManager.\r\n     *\r\n     * The Scene is removed from the local scenes array, it's key is cleared from the keys\r\n     * cache and Scene.Systems.destroy is then called on it.\r\n     *\r\n     * If the SceneManager is processing the Scenes when this method is called it will\r\n     * queue the operation for the next update sequence.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#remove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to be removed.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    remove: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.remove(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene up one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#moveUp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    moveUp: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.moveUp(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene down one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#moveDown\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    moveDown: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.moveDown(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Brings a Scene to the top of the Scenes list.\r\n     *\r\n     * This means it will render above all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#bringToTop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    bringToTop: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.bringToTop(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sends a Scene to the back of the Scenes list.\r\n     *\r\n     * This means it will render below all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#sendToBack\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.ScenePlugin} This ScenePlugin object.\r\n     */\r\n    sendToBack: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.sendToBack(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieve a Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to retrieve.\r\n     *\r\n     * @return {Phaser.Scene} The Scene.\r\n     */\r\n    get: function (key)\r\n    {\r\n        return this.manager.getScene(key);\r\n    },\r\n\r\n    /**\r\n     * Retrieves the numeric index of a Scene in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#getIndex\r\n     * @since 3.7.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to get the index of.\r\n     *\r\n     * @return {integer} The index of the Scene.\r\n     */\r\n    getIndex: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        return this.manager.getIndex(key);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off(Events.SHUTDOWN, this.shutdown, this);\r\n        eventEmitter.off(Events.POST_UPDATE, this.step, this);\r\n        eventEmitter.off(Events.TRANSITION_OUT);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene.sys.events.off(Events.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n        this.settings = null;\r\n        this.manager = null;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('ScenePlugin', ScenePlugin, 'scenePlugin');\r\n\r\nmodule.exports = ScenePlugin;\r\n"]},"metadata":{},"sourceType":"script"}