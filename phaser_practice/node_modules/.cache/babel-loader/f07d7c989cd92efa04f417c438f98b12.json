{"ast":null,"code":"/**\r\n * @author       Stefan Hedman <schteppe@gmail.com> (http://steffe.se)\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\n//  v0.3.0\nmodule.exports = {\n  decomp: polygonDecomp,\n  quickDecomp: polygonQuickDecomp,\n  isSimple: polygonIsSimple,\n  removeCollinearPoints: polygonRemoveCollinearPoints,\n  removeDuplicatePoints: polygonRemoveDuplicatePoints,\n  makeCCW: polygonMakeCCW\n};\n/**\r\n * Compute the intersection between two lines.\r\n * @static\r\n * @method lineInt\r\n * @param  {Array}  l1          Line vector 1\r\n * @param  {Array}  l2          Line vector 2\r\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\r\n * @return {Array}              The intersection point.\r\n */\n\nfunction lineInt(l1, l2, precision) {\n  precision = precision || 0;\n  var i = [0, 0]; // point\n\n  var a1, b1, c1, a2, b2, c2, det; // scalars\n\n  a1 = l1[1][1] - l1[0][1];\n  b1 = l1[0][0] - l1[1][0];\n  c1 = a1 * l1[0][0] + b1 * l1[0][1];\n  a2 = l2[1][1] - l2[0][1];\n  b2 = l2[0][0] - l2[1][0];\n  c2 = a2 * l2[0][0] + b2 * l2[0][1];\n  det = a1 * b2 - a2 * b1;\n\n  if (!scalar_eq(det, 0, precision)) {\n    // lines are not parallel\n    i[0] = (b2 * c1 - b1 * c2) / det;\n    i[1] = (a1 * c2 - a2 * c1) / det;\n  }\n\n  return i;\n}\n/**\r\n * Checks if two line segments intersects.\r\n * @method segmentsIntersect\r\n * @param {Array} p1 The start vertex of the first line segment.\r\n * @param {Array} p2 The end vertex of the first line segment.\r\n * @param {Array} q1 The start vertex of the second line segment.\r\n * @param {Array} q2 The end vertex of the second line segment.\r\n * @return {Boolean} True if the two line segments intersect\r\n */\n\n\nfunction lineSegmentsIntersect(p1, p2, q1, q2) {\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var da = q2[0] - q1[0];\n  var db = q2[1] - q1[1]; // segments are parallel\n\n  if (da * dy - db * dx === 0) {\n    return false;\n  }\n\n  var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n  var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n  return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n}\n/**\r\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\r\n * @static\r\n * @method area\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Array} c\r\n * @return {Number}\r\n */\n\n\nfunction triangleArea(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);\n}\n\nfunction isLeft(a, b, c) {\n  return triangleArea(a, b, c) > 0;\n}\n\nfunction isLeftOn(a, b, c) {\n  return triangleArea(a, b, c) >= 0;\n}\n\nfunction isRight(a, b, c) {\n  return triangleArea(a, b, c) < 0;\n}\n\nfunction isRightOn(a, b, c) {\n  return triangleArea(a, b, c) <= 0;\n}\n\nvar tmpPoint1 = [],\n    tmpPoint2 = [];\n/**\r\n * Check if three points are collinear\r\n * @method collinear\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Array} c\r\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\r\n * @return {Boolean}\r\n */\n\nfunction collinear(a, b, c, thresholdAngle) {\n  if (!thresholdAngle) {\n    return triangleArea(a, b, c) === 0;\n  } else {\n    var ab = tmpPoint1,\n        bc = tmpPoint2;\n    ab[0] = b[0] - a[0];\n    ab[1] = b[1] - a[1];\n    bc[0] = c[0] - b[0];\n    bc[1] = c[1] - b[1];\n    var dot = ab[0] * bc[0] + ab[1] * bc[1],\n        magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]),\n        magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]),\n        angle = Math.acos(dot / (magA * magB));\n    return angle < thresholdAngle;\n  }\n}\n\nfunction sqdist(a, b) {\n  var dx = b[0] - a[0];\n  var dy = b[1] - a[1];\n  return dx * dx + dy * dy;\n}\n/**\r\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\r\n * @method at\r\n * @param  {Number} i\r\n * @return {Array}\r\n */\n\n\nfunction polygonAt(polygon, i) {\n  var s = polygon.length;\n  return polygon[i < 0 ? i % s + s : i % s];\n}\n/**\r\n * Clear the polygon data\r\n * @method clear\r\n * @return {Array}\r\n */\n\n\nfunction polygonClear(polygon) {\n  polygon.length = 0;\n}\n/**\r\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\r\n * @method append\r\n * @param {Polygon} poly The polygon to get points from.\r\n * @param {Number}  from The vertex index in \"poly\".\r\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\r\n * @return {Array}\r\n */\n\n\nfunction polygonAppend(polygon, poly, from, to) {\n  for (var i = from; i < to; i++) {\n    polygon.push(poly[i]);\n  }\n}\n/**\r\n * Make sure that the polygon vertices are ordered counter-clockwise.\r\n * @method makeCCW\r\n */\n\n\nfunction polygonMakeCCW(polygon) {\n  var br = 0,\n      v = polygon; // find bottom right point\n\n  for (var i = 1; i < polygon.length; ++i) {\n    if (v[i][1] < v[br][1] || v[i][1] === v[br][1] && v[i][0] > v[br][0]) {\n      br = i;\n    }\n  } // reverse poly if clockwise\n\n\n  if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n    polygonReverse(polygon);\n    return true;\n  } else {\n    return false;\n  }\n}\n/**\r\n * Reverse the vertices in the polygon\r\n * @method reverse\r\n */\n\n\nfunction polygonReverse(polygon) {\n  var tmp = [];\n  var N = polygon.length;\n\n  for (var i = 0; i !== N; i++) {\n    tmp.push(polygon.pop());\n  }\n\n  for (var i = 0; i !== N; i++) {\n    polygon[i] = tmp[i];\n  }\n}\n/**\r\n * Check if a point in the polygon is a reflex point\r\n * @method isReflex\r\n * @param  {Number}  i\r\n * @return {Boolean}\r\n */\n\n\nfunction polygonIsReflex(polygon, i) {\n  return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n}\n\nvar tmpLine1 = [],\n    tmpLine2 = [];\n/**\r\n * Check if two vertices in the polygon can see each other\r\n * @method canSee\r\n * @param  {Number} a Vertex index 1\r\n * @param  {Number} b Vertex index 2\r\n * @return {Boolean}\r\n */\n\nfunction polygonCanSee(polygon, a, b) {\n  var p,\n      dist,\n      l1 = tmpLine1,\n      l2 = tmpLine2;\n\n  if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\n    return false;\n  }\n\n  dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n\n  for (var i = 0; i !== polygon.length; ++i) {\n    // for each edge\n    if ((i + 1) % polygon.length === a || i === a) {\n      // ignore incident edges\n      continue;\n    }\n\n    if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) {\n      // if diag intersects an edge\n      l1[0] = polygonAt(polygon, a);\n      l1[1] = polygonAt(polygon, b);\n      l2[0] = polygonAt(polygon, i);\n      l2[1] = polygonAt(polygon, i + 1);\n      p = lineInt(l1, l2);\n\n      if (sqdist(polygonAt(polygon, a), p) < dist) {\n        // if edge is blocking visibility to b\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\r\n * Check if two vertices in the polygon can see each other\r\n * @method canSee2\r\n * @param  {Number} a Vertex index 1\r\n * @param  {Number} b Vertex index 2\r\n * @return {Boolean}\r\n */\n\n\nfunction polygonCanSee2(polygon, a, b) {\n  // for each edge\n  for (var i = 0; i !== polygon.length; ++i) {\n    // ignore incident edges\n    if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b) {\n      continue;\n    }\n\n    if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\r\n * Copy the polygon from vertex i to vertex j.\r\n * @method copy\r\n * @param  {Number} i\r\n * @param  {Number} j\r\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\r\n * @return {Polygon}                The resulting copy.\r\n */\n\n\nfunction polygonCopy(polygon, i, j, targetPoly) {\n  var p = targetPoly || [];\n  polygonClear(p);\n\n  if (i < j) {\n    // Insert all vertices from i to j\n    for (var k = i; k <= j; k++) {\n      p.push(polygon[k]);\n    }\n  } else {\n    // Insert vertices 0 to j\n    for (var k = 0; k <= j; k++) {\n      p.push(polygon[k]);\n    } // Insert vertices i to end\n\n\n    for (var k = i; k < polygon.length; k++) {\n      p.push(polygon[k]);\n    }\n  }\n\n  return p;\n}\n/**\r\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\r\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\r\n * @method getCutEdges\r\n * @return {Array}\r\n */\n\n\nfunction polygonGetCutEdges(polygon) {\n  var min = [],\n      tmp1 = [],\n      tmp2 = [],\n      tmpPoly = [];\n  var nDiags = Number.MAX_VALUE;\n\n  for (var i = 0; i < polygon.length; ++i) {\n    if (polygonIsReflex(polygon, i)) {\n      for (var j = 0; j < polygon.length; ++j) {\n        if (polygonCanSee(polygon, i, j)) {\n          tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n          tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n\n          for (var k = 0; k < tmp2.length; k++) {\n            tmp1.push(tmp2[k]);\n          }\n\n          if (tmp1.length < nDiags) {\n            min = tmp1;\n            nDiags = tmp1.length;\n            min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\n          }\n        }\n      }\n    }\n  }\n\n  return min;\n}\n/**\r\n * Decomposes the polygon into one or more convex sub-Polygons.\r\n * @method decomp\r\n * @return {Array} An array or Polygon objects.\r\n */\n\n\nfunction polygonDecomp(polygon) {\n  var edges = polygonGetCutEdges(polygon);\n\n  if (edges.length > 0) {\n    return polygonSlice(polygon, edges);\n  } else {\n    return [polygon];\n  }\n}\n/**\r\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\r\n * @method slice\r\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\r\n * @return {Array}\r\n */\n\n\nfunction polygonSlice(polygon, cutEdges) {\n  if (cutEdges.length === 0) {\n    return [polygon];\n  }\n\n  if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {\n    var polys = [polygon];\n\n    for (var i = 0; i < cutEdges.length; i++) {\n      var cutEdge = cutEdges[i]; // Cut all polys\n\n      for (var j = 0; j < polys.length; j++) {\n        var poly = polys[j];\n        var result = polygonSlice(poly, cutEdge);\n\n        if (result) {\n          // Found poly! Cut and quit\n          polys.splice(j, 1);\n          polys.push(result[0], result[1]);\n          break;\n        }\n      }\n    }\n\n    return polys;\n  } else {\n    // Was given one edge\n    var cutEdge = cutEdges;\n    var i = polygon.indexOf(cutEdge[0]);\n    var j = polygon.indexOf(cutEdge[1]);\n\n    if (i !== -1 && j !== -1) {\n      return [polygonCopy(polygon, i, j), polygonCopy(polygon, j, i)];\n    } else {\n      return false;\n    }\n  }\n}\n/**\r\n * Checks that the line segments of this polygon do not intersect each other.\r\n * @method isSimple\r\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\r\n * @return {Boolean}\r\n * @todo Should it check all segments with all others?\r\n */\n\n\nfunction polygonIsSimple(polygon) {\n  var path = polygon,\n      i; // Check\n\n  for (i = 0; i < path.length - 1; i++) {\n    for (var j = 0; j < i - 1; j++) {\n      if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {\n        return false;\n      }\n    }\n  } // Check the segment between the last and the first point to all others\n\n\n  for (i = 1; i < path.length - 2; i++) {\n    if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getIntersectionPoint(p1, p2, q1, q2, delta) {\n  delta = delta || 0;\n  var a1 = p2[1] - p1[1];\n  var b1 = p1[0] - p2[0];\n  var c1 = a1 * p1[0] + b1 * p1[1];\n  var a2 = q2[1] - q1[1];\n  var b2 = q1[0] - q2[0];\n  var c2 = a2 * q1[0] + b2 * q1[1];\n  var det = a1 * b2 - a2 * b1;\n\n  if (!scalar_eq(det, 0, delta)) {\n    return [(b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det];\n  } else {\n    return [0, 0];\n  }\n}\n/**\r\n * Quickly decompose the Polygon into convex sub-polygons.\r\n * @method quickDecomp\r\n * @param  {Array} result\r\n * @param  {Array} [reflexVertices]\r\n * @param  {Array} [steinerPoints]\r\n * @param  {Number} [delta]\r\n * @param  {Number} [maxlevel]\r\n * @param  {Number} [level]\r\n * @return {Array}\r\n */\n\n\nfunction polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {\n  maxlevel = maxlevel || 100;\n  level = level || 0;\n  delta = delta || 25;\n  result = typeof result !== \"undefined\" ? result : [];\n  reflexVertices = reflexVertices || [];\n  steinerPoints = steinerPoints || [];\n  var upperInt = [0, 0],\n      lowerInt = [0, 0],\n      p = [0, 0]; // Points\n\n  var upperDist = 0,\n      lowerDist = 0,\n      d = 0,\n      closestDist = 0; // scalars\n\n  var upperIndex = 0,\n      lowerIndex = 0,\n      closestIndex = 0; // Integers\n\n  var lowerPoly = [],\n      upperPoly = []; // polygons\n\n  var poly = polygon,\n      v = polygon;\n\n  if (v.length < 3) {\n    return result;\n  }\n\n  level++;\n\n  if (level > maxlevel) {\n    console.warn(\"quickDecomp: max level (\" + maxlevel + \") reached.\");\n    return result;\n  }\n\n  for (var i = 0; i < polygon.length; ++i) {\n    if (polygonIsReflex(poly, i)) {\n      reflexVertices.push(poly[i]);\n      upperDist = lowerDist = Number.MAX_VALUE;\n\n      for (var j = 0; j < polygon.length; ++j) {\n        if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) {\n          // if line intersects with an edge\n          p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n\n          if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) {\n            // make sure it's inside the poly\n            d = sqdist(poly[i], p);\n\n            if (d < lowerDist) {\n              // keep only the closest intersection\n              lowerDist = d;\n              lowerInt = p;\n              lowerIndex = j;\n            }\n          }\n        }\n\n        if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n          p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n\n          if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n            d = sqdist(poly[i], p);\n\n            if (d < upperDist) {\n              upperDist = d;\n              upperInt = p;\n              upperIndex = j;\n            }\n          }\n        }\n      } // if there are no vertices to connect to, choose a point in the middle\n\n\n      if (lowerIndex === (upperIndex + 1) % polygon.length) {\n        //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\n        p[0] = (lowerInt[0] + upperInt[0]) / 2;\n        p[1] = (lowerInt[1] + upperInt[1]) / 2;\n        steinerPoints.push(p);\n\n        if (i < upperIndex) {\n          //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n          polygonAppend(lowerPoly, poly, i, upperIndex + 1);\n          lowerPoly.push(p);\n          upperPoly.push(p);\n\n          if (lowerIndex !== 0) {\n            //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n            polygonAppend(upperPoly, poly, lowerIndex, poly.length);\n          } //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n\n\n          polygonAppend(upperPoly, poly, 0, i + 1);\n        } else {\n          if (i !== 0) {\n            //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n            polygonAppend(lowerPoly, poly, i, poly.length);\n          } //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n\n\n          polygonAppend(lowerPoly, poly, 0, upperIndex + 1);\n          lowerPoly.push(p);\n          upperPoly.push(p); //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n\n          polygonAppend(upperPoly, poly, lowerIndex, i + 1);\n        }\n      } else {\n        // connect to the closest point within the triangle\n        //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\n        if (lowerIndex > upperIndex) {\n          upperIndex += polygon.length;\n        }\n\n        closestDist = Number.MAX_VALUE;\n\n        if (upperIndex < lowerIndex) {\n          return result;\n        }\n\n        for (var j = lowerIndex; j <= upperIndex; ++j) {\n          if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n            d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n\n            if (d < closestDist && polygonCanSee2(poly, i, j)) {\n              closestDist = d;\n              closestIndex = j % polygon.length;\n            }\n          }\n        }\n\n        if (i < closestIndex) {\n          polygonAppend(lowerPoly, poly, i, closestIndex + 1);\n\n          if (closestIndex !== 0) {\n            polygonAppend(upperPoly, poly, closestIndex, v.length);\n          }\n\n          polygonAppend(upperPoly, poly, 0, i + 1);\n        } else {\n          if (i !== 0) {\n            polygonAppend(lowerPoly, poly, i, v.length);\n          }\n\n          polygonAppend(lowerPoly, poly, 0, closestIndex + 1);\n          polygonAppend(upperPoly, poly, closestIndex, i + 1);\n        }\n      } // solve smallest poly first\n\n\n      if (lowerPoly.length < upperPoly.length) {\n        polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n        polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n      } else {\n        polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n        polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n      }\n\n      return result;\n    }\n  }\n\n  result.push(polygon);\n  return result;\n}\n/**\r\n * Remove collinear points in the polygon.\r\n * @method removeCollinearPoints\r\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\r\n * @return {Number}           The number of points removed\r\n */\n\n\nfunction polygonRemoveCollinearPoints(polygon, precision) {\n  var num = 0;\n\n  for (var i = polygon.length - 1; polygon.length > 3 && i >= 0; --i) {\n    if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision)) {\n      // Remove the middle point\n      polygon.splice(i % polygon.length, 1);\n      num++;\n    }\n  }\n\n  return num;\n}\n/**\r\n * Remove duplicate points in the polygon.\r\n * @method removeDuplicatePoints\r\n * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.\r\n */\n\n\nfunction polygonRemoveDuplicatePoints(polygon, precision) {\n  for (var i = polygon.length - 1; i >= 1; --i) {\n    var pi = polygon[i];\n\n    for (var j = i - 1; j >= 0; --j) {\n      if (points_eq(pi, polygon[j], precision)) {\n        polygon.splice(i, 1);\n        continue;\n      }\n    }\n  }\n}\n/**\r\n * Check if two scalars are equal\r\n * @static\r\n * @method eq\r\n * @param  {Number} a\r\n * @param  {Number} b\r\n * @param  {Number} [precision]\r\n * @return {Boolean}\r\n */\n\n\nfunction scalar_eq(a, b, precision) {\n  precision = precision || 0;\n  return Math.abs(a - b) <= precision;\n}\n/**\r\n * Check if two points are equal\r\n * @static\r\n * @method points_eq\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Number} [precision]\r\n * @return {Boolean}\r\n */\n\n\nfunction points_eq(a, b, precision) {\n  return scalar_eq(a[0], b[0], precision) && scalar_eq(a[1], b[1], precision);\n}","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/poly-decomp/index.js"],"names":["module","exports","decomp","polygonDecomp","quickDecomp","polygonQuickDecomp","isSimple","polygonIsSimple","removeCollinearPoints","polygonRemoveCollinearPoints","removeDuplicatePoints","polygonRemoveDuplicatePoints","makeCCW","polygonMakeCCW","lineInt","l1","l2","precision","i","a1","b1","c1","a2","b2","c2","det","scalar_eq","lineSegmentsIntersect","p1","p2","q1","q2","dx","dy","da","db","s","t","triangleArea","a","b","c","isLeft","isLeftOn","isRight","isRightOn","tmpPoint1","tmpPoint2","collinear","thresholdAngle","ab","bc","dot","magA","Math","sqrt","magB","angle","acos","sqdist","polygonAt","polygon","length","polygonClear","polygonAppend","poly","from","to","push","br","v","polygonReverse","tmp","N","pop","polygonIsReflex","tmpLine1","tmpLine2","polygonCanSee","p","dist","polygonCanSee2","polygonCopy","j","targetPoly","k","polygonGetCutEdges","min","tmp1","tmp2","tmpPoly","nDiags","Number","MAX_VALUE","edges","polygonSlice","cutEdges","Array","polys","cutEdge","result","splice","indexOf","path","getIntersectionPoint","delta","reflexVertices","steinerPoints","maxlevel","level","upperInt","lowerInt","upperDist","lowerDist","d","closestDist","upperIndex","lowerIndex","closestIndex","lowerPoly","upperPoly","console","warn","num","pi","points_eq","abs"],"mappings":"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","sourcesContent":["/**\r\n * @author       Stefan Hedman <schteppe@gmail.com> (http://steffe.se)\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  v0.3.0\r\n\r\nmodule.exports = {\r\n    decomp: polygonDecomp,\r\n    quickDecomp: polygonQuickDecomp,\r\n    isSimple: polygonIsSimple,\r\n    removeCollinearPoints: polygonRemoveCollinearPoints,\r\n    removeDuplicatePoints: polygonRemoveDuplicatePoints,\r\n    makeCCW: polygonMakeCCW\r\n};\r\n\r\n/**\r\n * Compute the intersection between two lines.\r\n * @static\r\n * @method lineInt\r\n * @param  {Array}  l1          Line vector 1\r\n * @param  {Array}  l2          Line vector 2\r\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\r\n * @return {Array}              The intersection point.\r\n */\r\nfunction lineInt(l1,l2,precision){\r\n    precision = precision || 0;\r\n    var i = [0,0]; // point\r\n    var a1, b1, c1, a2, b2, c2, det; // scalars\r\n    a1 = l1[1][1] - l1[0][1];\r\n    b1 = l1[0][0] - l1[1][0];\r\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\r\n    a2 = l2[1][1] - l2[0][1];\r\n    b2 = l2[0][0] - l2[1][0];\r\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\r\n    det = a1 * b2 - a2*b1;\r\n    if (!scalar_eq(det, 0, precision)) { // lines are not parallel\r\n        i[0] = (b2 * c1 - b1 * c2) / det;\r\n        i[1] = (a1 * c2 - a2 * c1) / det;\r\n    }\r\n    return i;\r\n}\r\n\r\n/**\r\n * Checks if two line segments intersects.\r\n * @method segmentsIntersect\r\n * @param {Array} p1 The start vertex of the first line segment.\r\n * @param {Array} p2 The end vertex of the first line segment.\r\n * @param {Array} q1 The start vertex of the second line segment.\r\n * @param {Array} q2 The end vertex of the second line segment.\r\n * @return {Boolean} True if the two line segments intersect\r\n */\r\nfunction lineSegmentsIntersect(p1, p2, q1, q2){\r\n\tvar dx = p2[0] - p1[0];\r\n\tvar dy = p2[1] - p1[1];\r\n\tvar da = q2[0] - q1[0];\r\n\tvar db = q2[1] - q1[1];\r\n\r\n\t// segments are parallel\r\n\tif((da*dy - db*dx) === 0){\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\r\n\tvar t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\r\n\r\n\treturn (s>=0 && s<=1 && t>=0 && t<=1);\r\n}\r\n\r\n/**\r\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\r\n * @static\r\n * @method area\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Array} c\r\n * @return {Number}\r\n */\r\nfunction triangleArea(a,b,c){\r\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\r\n}\r\n\r\nfunction isLeft(a,b,c){\r\n    return triangleArea(a,b,c) > 0;\r\n}\r\n\r\nfunction isLeftOn(a,b,c) {\r\n    return triangleArea(a, b, c) >= 0;\r\n}\r\n\r\nfunction isRight(a,b,c) {\r\n    return triangleArea(a, b, c) < 0;\r\n}\r\n\r\nfunction isRightOn(a,b,c) {\r\n    return triangleArea(a, b, c) <= 0;\r\n}\r\n\r\nvar tmpPoint1 = [],\r\n    tmpPoint2 = [];\r\n\r\n/**\r\n * Check if three points are collinear\r\n * @method collinear\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Array} c\r\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\r\n * @return {Boolean}\r\n */\r\nfunction collinear(a,b,c,thresholdAngle) {\r\n    if(!thresholdAngle){\r\n        return triangleArea(a, b, c) === 0;\r\n    } else {\r\n        var ab = tmpPoint1,\r\n            bc = tmpPoint2;\r\n\r\n        ab[0] = b[0]-a[0];\r\n        ab[1] = b[1]-a[1];\r\n        bc[0] = c[0]-b[0];\r\n        bc[1] = c[1]-b[1];\r\n\r\n        var dot = ab[0]*bc[0] + ab[1]*bc[1],\r\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\r\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\r\n            angle = Math.acos(dot/(magA*magB));\r\n        return angle < thresholdAngle;\r\n    }\r\n}\r\n\r\nfunction sqdist(a,b){\r\n    var dx = b[0] - a[0];\r\n    var dy = b[1] - a[1];\r\n    return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\r\n * @method at\r\n * @param  {Number} i\r\n * @return {Array}\r\n */\r\nfunction polygonAt(polygon, i){\r\n    var s = polygon.length;\r\n    return polygon[i < 0 ? i % s + s : i % s];\r\n}\r\n\r\n/**\r\n * Clear the polygon data\r\n * @method clear\r\n * @return {Array}\r\n */\r\nfunction polygonClear(polygon){\r\n    polygon.length = 0;\r\n}\r\n\r\n/**\r\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\r\n * @method append\r\n * @param {Polygon} poly The polygon to get points from.\r\n * @param {Number}  from The vertex index in \"poly\".\r\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\r\n * @return {Array}\r\n */\r\nfunction polygonAppend(polygon, poly, from, to){\r\n    for(var i=from; i<to; i++){\r\n        polygon.push(poly[i]);\r\n    }\r\n}\r\n\r\n/**\r\n * Make sure that the polygon vertices are ordered counter-clockwise.\r\n * @method makeCCW\r\n */\r\nfunction polygonMakeCCW(polygon){\r\n    var br = 0,\r\n        v = polygon;\r\n\r\n    // find bottom right point\r\n    for (var i = 1; i < polygon.length; ++i) {\r\n        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {\r\n            br = i;\r\n        }\r\n    }\r\n\r\n    // reverse poly if clockwise\r\n    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\r\n        polygonReverse(polygon);\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Reverse the vertices in the polygon\r\n * @method reverse\r\n */\r\nfunction polygonReverse(polygon){\r\n    var tmp = [];\r\n    var N = polygon.length;\r\n    for(var i=0; i!==N; i++){\r\n        tmp.push(polygon.pop());\r\n    }\r\n    for(var i=0; i!==N; i++){\r\n\t\tpolygon[i] = tmp[i];\r\n    }\r\n}\r\n\r\n/**\r\n * Check if a point in the polygon is a reflex point\r\n * @method isReflex\r\n * @param  {Number}  i\r\n * @return {Boolean}\r\n */\r\nfunction polygonIsReflex(polygon, i){\r\n    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\r\n}\r\n\r\nvar tmpLine1=[],\r\n    tmpLine2=[];\r\n\r\n/**\r\n * Check if two vertices in the polygon can see each other\r\n * @method canSee\r\n * @param  {Number} a Vertex index 1\r\n * @param  {Number} b Vertex index 2\r\n * @return {Boolean}\r\n */\r\nfunction polygonCanSee(polygon, a,b) {\r\n    var p, dist, l1=tmpLine1, l2=tmpLine2;\r\n\r\n    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\r\n        return false;\r\n    }\r\n    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\r\n    for (var i = 0; i !== polygon.length; ++i) { // for each edge\r\n        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges\r\n            continue;\r\n        }\r\n        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge\r\n            l1[0] = polygonAt(polygon, a);\r\n            l1[1] = polygonAt(polygon, b);\r\n            l2[0] = polygonAt(polygon, i);\r\n            l2[1] = polygonAt(polygon, i + 1);\r\n            p = lineInt(l1,l2);\r\n            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Check if two vertices in the polygon can see each other\r\n * @method canSee2\r\n * @param  {Number} a Vertex index 1\r\n * @param  {Number} b Vertex index 2\r\n * @return {Boolean}\r\n */\r\nfunction polygonCanSee2(polygon, a,b) {\r\n    // for each edge\r\n    for (var i = 0; i !== polygon.length; ++i) {\r\n        // ignore incident edges\r\n        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b){\r\n            continue;\r\n        }\r\n        if( lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i+1)) ){\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n/**\r\n * Copy the polygon from vertex i to vertex j.\r\n * @method copy\r\n * @param  {Number} i\r\n * @param  {Number} j\r\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\r\n * @return {Polygon}                The resulting copy.\r\n */\r\nfunction polygonCopy(polygon, i,j,targetPoly){\r\n    var p = targetPoly || [];\r\n    polygonClear(p);\r\n    if (i < j) {\r\n        // Insert all vertices from i to j\r\n        for(var k=i; k<=j; k++){\r\n            p.push(polygon[k]);\r\n        }\r\n\r\n    } else {\r\n\r\n        // Insert vertices 0 to j\r\n        for(var k=0; k<=j; k++){\r\n            p.push(polygon[k]);\r\n        }\r\n\r\n        // Insert vertices i to end\r\n        for(var k=i; k<polygon.length; k++){\r\n            p.push(polygon[k]);\r\n        }\r\n    }\r\n\r\n    return p;\r\n}\r\n\r\n/**\r\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\r\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\r\n * @method getCutEdges\r\n * @return {Array}\r\n */\r\nfunction polygonGetCutEdges(polygon) {\r\n    var min=[], tmp1=[], tmp2=[], tmpPoly = [];\r\n    var nDiags = Number.MAX_VALUE;\r\n\r\n    for (var i = 0; i < polygon.length; ++i) {\r\n        if (polygonIsReflex(polygon, i)) {\r\n            for (var j = 0; j < polygon.length; ++j) {\r\n                if (polygonCanSee(polygon, i, j)) {\r\n                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\r\n                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\r\n\r\n                    for(var k=0; k<tmp2.length; k++){\r\n                        tmp1.push(tmp2[k]);\r\n                    }\r\n\r\n                    if (tmp1.length < nDiags) {\r\n                        min = tmp1;\r\n                        nDiags = tmp1.length;\r\n                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return min;\r\n}\r\n\r\n/**\r\n * Decomposes the polygon into one or more convex sub-Polygons.\r\n * @method decomp\r\n * @return {Array} An array or Polygon objects.\r\n */\r\nfunction polygonDecomp(polygon){\r\n    var edges = polygonGetCutEdges(polygon);\r\n    if(edges.length > 0){\r\n        return polygonSlice(polygon, edges);\r\n    } else {\r\n        return [polygon];\r\n    }\r\n}\r\n\r\n/**\r\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\r\n * @method slice\r\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\r\n * @return {Array}\r\n */\r\nfunction polygonSlice(polygon, cutEdges){\r\n    if(cutEdges.length === 0){\r\n\t\treturn [polygon];\r\n    }\r\n    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){\r\n\r\n        var polys = [polygon];\r\n\r\n        for(var i=0; i<cutEdges.length; i++){\r\n            var cutEdge = cutEdges[i];\r\n            // Cut all polys\r\n            for(var j=0; j<polys.length; j++){\r\n                var poly = polys[j];\r\n                var result = polygonSlice(poly, cutEdge);\r\n                if(result){\r\n                    // Found poly! Cut and quit\r\n                    polys.splice(j,1);\r\n                    polys.push(result[0],result[1]);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return polys;\r\n    } else {\r\n\r\n        // Was given one edge\r\n        var cutEdge = cutEdges;\r\n        var i = polygon.indexOf(cutEdge[0]);\r\n        var j = polygon.indexOf(cutEdge[1]);\r\n\r\n        if(i !== -1 && j !== -1){\r\n            return [polygonCopy(polygon, i,j),\r\n                    polygonCopy(polygon, j,i)];\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Checks that the line segments of this polygon do not intersect each other.\r\n * @method isSimple\r\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\r\n * @return {Boolean}\r\n * @todo Should it check all segments with all others?\r\n */\r\nfunction polygonIsSimple(polygon){\r\n    var path = polygon, i;\r\n    // Check\r\n    for(i=0; i<path.length-1; i++){\r\n        for(var j=0; j<i-1; j++){\r\n            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check the segment between the last and the first point to all others\r\n    for(i=1; i<path.length-2; i++){\r\n        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction getIntersectionPoint(p1, p2, q1, q2, delta){\r\n\tdelta = delta || 0;\r\n\tvar a1 = p2[1] - p1[1];\r\n\tvar b1 = p1[0] - p2[0];\r\n\tvar c1 = (a1 * p1[0]) + (b1 * p1[1]);\r\n\tvar a2 = q2[1] - q1[1];\r\n\tvar b2 = q1[0] - q2[0];\r\n\tvar c2 = (a2 * q1[0]) + (b2 * q1[1]);\r\n\tvar det = (a1 * b2) - (a2 * b1);\r\n\r\n\tif(!scalar_eq(det,0,delta)){\r\n\t\treturn [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];\r\n\t} else {\r\n\t\treturn [0,0];\r\n    }\r\n}\r\n\r\n/**\r\n * Quickly decompose the Polygon into convex sub-polygons.\r\n * @method quickDecomp\r\n * @param  {Array} result\r\n * @param  {Array} [reflexVertices]\r\n * @param  {Array} [steinerPoints]\r\n * @param  {Number} [delta]\r\n * @param  {Number} [maxlevel]\r\n * @param  {Number} [level]\r\n * @return {Array}\r\n */\r\nfunction polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){\r\n    maxlevel = maxlevel || 100;\r\n    level = level || 0;\r\n    delta = delta || 25;\r\n    result = typeof(result)!==\"undefined\" ? result : [];\r\n    reflexVertices = reflexVertices || [];\r\n    steinerPoints = steinerPoints || [];\r\n\r\n    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points\r\n    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars\r\n    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers\r\n    var lowerPoly=[], upperPoly=[]; // polygons\r\n    var poly = polygon,\r\n        v = polygon;\r\n\r\n    if(v.length < 3){\r\n\t\treturn result;\r\n    }\r\n\r\n    level++;\r\n    if(level > maxlevel){\r\n        console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\r\n        return result;\r\n    }\r\n\r\n    for (var i = 0; i < polygon.length; ++i) {\r\n        if (polygonIsReflex(poly, i)) {\r\n            reflexVertices.push(poly[i]);\r\n            upperDist = lowerDist = Number.MAX_VALUE;\r\n\r\n\r\n            for (var j = 0; j < polygon.length; ++j) {\r\n                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge\r\n                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\r\n                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly\r\n                        d = sqdist(poly[i], p);\r\n                        if (d < lowerDist) { // keep only the closest intersection\r\n                            lowerDist = d;\r\n                            lowerInt = p;\r\n                            lowerIndex = j;\r\n                        }\r\n                    }\r\n                }\r\n                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\r\n                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\r\n                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\r\n                        d = sqdist(poly[i], p);\r\n                        if (d < upperDist) {\r\n                            upperDist = d;\r\n                            upperInt = p;\r\n                            upperIndex = j;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // if there are no vertices to connect to, choose a point in the middle\r\n            if (lowerIndex === (upperIndex + 1) % polygon.length) {\r\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\r\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\r\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\r\n                steinerPoints.push(p);\r\n\r\n                if (i < upperIndex) {\r\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\r\n                    polygonAppend(lowerPoly, poly, i, upperIndex+1);\r\n                    lowerPoly.push(p);\r\n                    upperPoly.push(p);\r\n                    if (lowerIndex !== 0){\r\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\r\n                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);\r\n                    }\r\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\r\n                    polygonAppend(upperPoly, poly,0,i+1);\r\n                } else {\r\n                    if (i !== 0){\r\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\r\n                        polygonAppend(lowerPoly, poly,i,poly.length);\r\n                    }\r\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\r\n                    polygonAppend(lowerPoly, poly,0,upperIndex+1);\r\n                    lowerPoly.push(p);\r\n                    upperPoly.push(p);\r\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\r\n                    polygonAppend(upperPoly, poly,lowerIndex,i+1);\r\n                }\r\n            } else {\r\n                // connect to the closest point within the triangle\r\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\r\n\r\n                if (lowerIndex > upperIndex) {\r\n                    upperIndex += polygon.length;\r\n                }\r\n                closestDist = Number.MAX_VALUE;\r\n\r\n                if(upperIndex < lowerIndex){\r\n                    return result;\r\n                }\r\n\r\n                for (var j = lowerIndex; j <= upperIndex; ++j) {\r\n                    if (\r\n                        isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) &&\r\n                        isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))\r\n                    ) {\r\n                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\r\n                        if (d < closestDist && polygonCanSee2(poly, i, j)) {\r\n                            closestDist = d;\r\n                            closestIndex = j % polygon.length;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (i < closestIndex) {\r\n                    polygonAppend(lowerPoly, poly,i,closestIndex+1);\r\n                    if (closestIndex !== 0){\r\n                        polygonAppend(upperPoly, poly,closestIndex,v.length);\r\n                    }\r\n                    polygonAppend(upperPoly, poly,0,i+1);\r\n                } else {\r\n                    if (i !== 0){\r\n                        polygonAppend(lowerPoly, poly,i,v.length);\r\n                    }\r\n                    polygonAppend(lowerPoly, poly,0,closestIndex+1);\r\n                    polygonAppend(upperPoly, poly,closestIndex,i+1);\r\n                }\r\n            }\r\n\r\n            // solve smallest poly first\r\n            if (lowerPoly.length < upperPoly.length) {\r\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\r\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\r\n            } else {\r\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\r\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n    result.push(polygon);\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Remove collinear points in the polygon.\r\n * @method removeCollinearPoints\r\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\r\n * @return {Number}           The number of points removed\r\n */\r\nfunction polygonRemoveCollinearPoints(polygon, precision){\r\n    var num = 0;\r\n    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){\r\n        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){\r\n            // Remove the middle point\r\n            polygon.splice(i%polygon.length,1);\r\n            num++;\r\n        }\r\n    }\r\n    return num;\r\n}\r\n\r\n/**\r\n * Remove duplicate points in the polygon.\r\n * @method removeDuplicatePoints\r\n * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.\r\n */\r\nfunction polygonRemoveDuplicatePoints(polygon, precision){\r\n    for(var i=polygon.length-1; i>=1; --i){\r\n        var pi = polygon[i];\r\n        for(var j=i-1; j>=0; --j){\r\n            if(points_eq(pi, polygon[j], precision)){\r\n                polygon.splice(i,1);\r\n                continue;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Check if two scalars are equal\r\n * @static\r\n * @method eq\r\n * @param  {Number} a\r\n * @param  {Number} b\r\n * @param  {Number} [precision]\r\n * @return {Boolean}\r\n */\r\nfunction scalar_eq(a,b,precision){\r\n    precision = precision || 0;\r\n    return Math.abs(a-b) <= precision;\r\n}\r\n\r\n/**\r\n * Check if two points are equal\r\n * @static\r\n * @method points_eq\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Number} [precision]\r\n * @return {Boolean}\r\n */\r\nfunction points_eq(a,b,precision){\r\n    return scalar_eq(a[0],b[0],precision) && scalar_eq(a[1],b[1],precision);\r\n}\r\n"]},"metadata":{},"sourceType":"script"}