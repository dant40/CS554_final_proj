{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\n\n/**\r\n * Using Bresenham's line algorithm this will return an array of all coordinates on this line.\r\n *\r\n * The `start` and `end` points are rounded before this runs as the algorithm works on integers.\r\n *\r\n * @function Phaser.Geom.Line.BresenhamPoints\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The line.\r\n * @param {integer} [stepRate=1] - The optional step rate for the points on the line.\r\n * @param {Phaser.Types.Math.Vector2Like[]} [results] - An optional array to push the resulting coordinates into.\r\n *\r\n * @return {Phaser.Types.Math.Vector2Like[]} The array of coordinates on the line.\r\n */\nvar BresenhamPoints = function (line, stepRate, results) {\n  if (stepRate === undefined) {\n    stepRate = 1;\n  }\n\n  if (results === undefined) {\n    results = [];\n  }\n\n  var x1 = Math.round(line.x1);\n  var y1 = Math.round(line.y1);\n  var x2 = Math.round(line.x2);\n  var y2 = Math.round(line.y2);\n  var dx = Math.abs(x2 - x1);\n  var dy = Math.abs(y2 - y1);\n  var sx = x1 < x2 ? 1 : -1;\n  var sy = y1 < y2 ? 1 : -1;\n  var err = dx - dy;\n  results.push({\n    x: x1,\n    y: y1\n  });\n  var i = 1;\n\n  while (!(x1 === x2 && y1 === y2)) {\n    var e2 = err << 1;\n\n    if (e2 > -dy) {\n      err -= dy;\n      x1 += sx;\n    }\n\n    if (e2 < dx) {\n      err += dx;\n      y1 += sy;\n    }\n\n    if (i % stepRate === 0) {\n      results.push({\n        x: x1,\n        y: y1\n      });\n    }\n\n    i++;\n  }\n\n  return results;\n};\n\nmodule.exports = BresenhamPoints;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/geom/line/BresenhamPoints.js"],"names":["BresenhamPoints","line","stepRate","results","undefined","x1","Math","round","y1","x2","y2","dx","abs","dy","sx","sy","err","push","x","y","i","e2","module","exports"],"mappings":"AAAA;;;;;;AAMA;;;;;;;;;;;;;;AAcA,IAAIA,eAAe,GAAG,UAAUC,IAAV,EAAgBC,QAAhB,EAA0BC,OAA1B,EACtB;AACI,MAAID,QAAQ,KAAKE,SAAjB,EAA4B;AAAEF,IAAAA,QAAQ,GAAG,CAAX;AAAe;;AAC7C,MAAIC,OAAO,KAAKC,SAAhB,EAA2B;AAAED,IAAAA,OAAO,GAAG,EAAV;AAAe;;AAE5C,MAAIE,EAAE,GAAGC,IAAI,CAACC,KAAL,CAAWN,IAAI,CAACI,EAAhB,CAAT;AACA,MAAIG,EAAE,GAAGF,IAAI,CAACC,KAAL,CAAWN,IAAI,CAACO,EAAhB,CAAT;AACA,MAAIC,EAAE,GAAGH,IAAI,CAACC,KAAL,CAAWN,IAAI,CAACQ,EAAhB,CAAT;AACA,MAAIC,EAAE,GAAGJ,IAAI,CAACC,KAAL,CAAWN,IAAI,CAACS,EAAhB,CAAT;AAEA,MAAIC,EAAE,GAAGL,IAAI,CAACM,GAAL,CAASH,EAAE,GAAGJ,EAAd,CAAT;AACA,MAAIQ,EAAE,GAAGP,IAAI,CAACM,GAAL,CAASF,EAAE,GAAGF,EAAd,CAAT;AACA,MAAIM,EAAE,GAAIT,EAAE,GAAGI,EAAN,GAAY,CAAZ,GAAgB,CAAC,CAA1B;AACA,MAAIM,EAAE,GAAIP,EAAE,GAAGE,EAAN,GAAY,CAAZ,GAAgB,CAAC,CAA1B;AACA,MAAIM,GAAG,GAAGL,EAAE,GAAGE,EAAf;AAEAV,EAAAA,OAAO,CAACc,IAAR,CAAa;AAAEC,IAAAA,CAAC,EAAEb,EAAL;AAASc,IAAAA,CAAC,EAAEX;AAAZ,GAAb;AAEA,MAAIY,CAAC,GAAG,CAAR;;AAEA,SAAO,EAAGf,EAAE,KAAKI,EAAR,IAAgBD,EAAE,KAAKE,EAAzB,CAAP,EACA;AACI,QAAIW,EAAE,GAAGL,GAAG,IAAI,CAAhB;;AAEA,QAAIK,EAAE,GAAG,CAACR,EAAV,EACA;AACIG,MAAAA,GAAG,IAAIH,EAAP;AACAR,MAAAA,EAAE,IAAIS,EAAN;AACH;;AAED,QAAIO,EAAE,GAAGV,EAAT,EACA;AACIK,MAAAA,GAAG,IAAIL,EAAP;AACAH,MAAAA,EAAE,IAAIO,EAAN;AACH;;AAED,QAAIK,CAAC,GAAGlB,QAAJ,KAAiB,CAArB,EACA;AACIC,MAAAA,OAAO,CAACc,IAAR,CAAa;AAAEC,QAAAA,CAAC,EAAEb,EAAL;AAASc,QAAAA,CAAC,EAAEX;AAAZ,OAAb;AACH;;AAEDY,IAAAA,CAAC;AACJ;;AAED,SAAOjB,OAAP;AACH,CA7CD;;AA+CAmB,MAAM,CAACC,OAAP,GAAiBvB,eAAjB","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Using Bresenham's line algorithm this will return an array of all coordinates on this line.\r\n *\r\n * The `start` and `end` points are rounded before this runs as the algorithm works on integers.\r\n *\r\n * @function Phaser.Geom.Line.BresenhamPoints\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The line.\r\n * @param {integer} [stepRate=1] - The optional step rate for the points on the line.\r\n * @param {Phaser.Types.Math.Vector2Like[]} [results] - An optional array to push the resulting coordinates into.\r\n *\r\n * @return {Phaser.Types.Math.Vector2Like[]} The array of coordinates on the line.\r\n */\r\nvar BresenhamPoints = function (line, stepRate, results)\r\n{\r\n    if (stepRate === undefined) { stepRate = 1; }\r\n    if (results === undefined) { results = []; }\r\n\r\n    var x1 = Math.round(line.x1);\r\n    var y1 = Math.round(line.y1);\r\n    var x2 = Math.round(line.x2);\r\n    var y2 = Math.round(line.y2);\r\n\r\n    var dx = Math.abs(x2 - x1);\r\n    var dy = Math.abs(y2 - y1);\r\n    var sx = (x1 < x2) ? 1 : -1;\r\n    var sy = (y1 < y2) ? 1 : -1;\r\n    var err = dx - dy;\r\n\r\n    results.push({ x: x1, y: y1 });\r\n\r\n    var i = 1;\r\n\r\n    while (!((x1 === x2) && (y1 === y2)))\r\n    {\r\n        var e2 = err << 1;\r\n\r\n        if (e2 > -dy)\r\n        {\r\n            err -= dy;\r\n            x1 += sx;\r\n        }\r\n\r\n        if (e2 < dx)\r\n        {\r\n            err += dx;\r\n            y1 += sy;\r\n        }\r\n\r\n        if (i % stepRate === 0)\r\n        {\r\n            results.push({ x: x1, y: y1 });\r\n        }\r\n\r\n        i++;\r\n    }\r\n\r\n    return results;\r\n};\r\n\r\nmodule.exports = BresenhamPoints;\r\n"]},"metadata":{},"sourceType":"script"}