{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Commands = require('./Commands');\n\nvar Utils = require('../../renderer/webgl/Utils'); //  TODO: Remove the use of this\n\n\nvar Point = function (x, y, width) {\n  this.x = x;\n  this.y = y;\n  this.width = width;\n}; //  TODO: Remove the use of this\n\n\nvar Path = function (x, y, width) {\n  this.points = [];\n  this.pointsLength = 1;\n  this.points[0] = new Point(x, y, width);\n};\n\nvar matrixStack = [];\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Graphics#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Graphics} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\n\nvar GraphicsWebGLRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix) {\n  if (src.commandBuffer.length === 0) {\n    return;\n  }\n\n  var pipeline = this.pipeline;\n  renderer.setPipeline(pipeline, src);\n  var camMatrix = src._tempMatrix1;\n  var graphicsMatrix = src._tempMatrix2;\n  var currentMatrix = src._tempMatrix3;\n  currentMatrix.loadIdentity();\n  graphicsMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\n  camMatrix.copyFrom(camera.matrix);\n\n  if (parentMatrix) {\n    //  Multiply the camera by the parent matrix\n    camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY); //  Undo the camera scroll\n\n    graphicsMatrix.e = src.x;\n    graphicsMatrix.f = src.y; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n    camMatrix.multiply(graphicsMatrix);\n  } else {\n    graphicsMatrix.e -= camera.scrollX * src.scrollFactorX;\n    graphicsMatrix.f -= camera.scrollY * src.scrollFactorY; //  Multiply by the Sprite matrix, store result in calcMatrix\n\n    camMatrix.multiply(graphicsMatrix);\n  }\n\n  var commands = src.commandBuffer;\n  var alpha = camera.alpha * src.alpha;\n  var lineWidth = 1;\n  var fillTint = pipeline.fillTint;\n  var strokeTint = pipeline.strokeTint;\n  var tx = 0;\n  var ty = 0;\n  var ta = 0;\n  var iterStep = 0.01;\n  var PI2 = Math.PI * 2;\n  var cmd;\n  var path = [];\n  var pathIndex = 0;\n  var pathOpen = false;\n  var lastPath = null;\n  var getTint = Utils.getTintAppendFloatAlphaAndSwap;\n  var currentTexture = renderer.blankTexture.glTexture;\n\n  for (var cmdIndex = 0; cmdIndex < commands.length; cmdIndex++) {\n    cmd = commands[cmdIndex];\n\n    switch (cmd) {\n      case Commands.BEGIN_PATH:\n        path.length = 0;\n        lastPath = null;\n        pathOpen = true;\n        break;\n\n      case Commands.CLOSE_PATH:\n        pathOpen = false;\n\n        if (lastPath && lastPath.points.length) {\n          lastPath.points.push(lastPath.points[0]);\n        }\n\n        break;\n\n      case Commands.FILL_PATH:\n        for (pathIndex = 0; pathIndex < path.length; pathIndex++) {\n          pipeline.setTexture2D(currentTexture);\n          pipeline.batchFillPath(path[pathIndex].points, currentMatrix, camMatrix);\n        }\n\n        break;\n\n      case Commands.STROKE_PATH:\n        for (pathIndex = 0; pathIndex < path.length; pathIndex++) {\n          pipeline.setTexture2D(currentTexture);\n          pipeline.batchStrokePath(path[pathIndex].points, lineWidth, pathOpen, currentMatrix, camMatrix);\n        }\n\n        break;\n\n      case Commands.LINE_STYLE:\n        lineWidth = commands[++cmdIndex];\n        var strokeColor = commands[++cmdIndex];\n        var strokeAlpha = commands[++cmdIndex] * alpha;\n        var strokeTintColor = getTint(strokeColor, strokeAlpha);\n        strokeTint.TL = strokeTintColor;\n        strokeTint.TR = strokeTintColor;\n        strokeTint.BL = strokeTintColor;\n        strokeTint.BR = strokeTintColor;\n        break;\n\n      case Commands.FILL_STYLE:\n        var fillColor = commands[++cmdIndex];\n        var fillAlpha = commands[++cmdIndex] * alpha;\n        var fillTintColor = getTint(fillColor, fillAlpha);\n        fillTint.TL = fillTintColor;\n        fillTint.TR = fillTintColor;\n        fillTint.BL = fillTintColor;\n        fillTint.BR = fillTintColor;\n        break;\n\n      case Commands.GRADIENT_FILL_STYLE:\n        var gradientFillAlpha = commands[++cmdIndex] * alpha;\n        fillTint.TL = getTint(commands[++cmdIndex], gradientFillAlpha);\n        fillTint.TR = getTint(commands[++cmdIndex], gradientFillAlpha);\n        fillTint.BL = getTint(commands[++cmdIndex], gradientFillAlpha);\n        fillTint.BR = getTint(commands[++cmdIndex], gradientFillAlpha);\n        break;\n\n      case Commands.GRADIENT_LINE_STYLE:\n        lineWidth = commands[++cmdIndex];\n        var gradientLineAlpha = commands[++cmdIndex] * alpha;\n        strokeTint.TL = getTint(commands[++cmdIndex], gradientLineAlpha);\n        strokeTint.TR = getTint(commands[++cmdIndex], gradientLineAlpha);\n        strokeTint.BL = getTint(commands[++cmdIndex], gradientLineAlpha);\n        strokeTint.BR = getTint(commands[++cmdIndex], gradientLineAlpha);\n        break;\n\n      case Commands.ARC:\n        var iteration = 0;\n        var x = commands[++cmdIndex];\n        var y = commands[++cmdIndex];\n        var radius = commands[++cmdIndex];\n        var startAngle = commands[++cmdIndex];\n        var endAngle = commands[++cmdIndex];\n        var anticlockwise = commands[++cmdIndex];\n        var overshoot = commands[++cmdIndex];\n        endAngle -= startAngle;\n\n        if (anticlockwise) {\n          if (endAngle < -PI2) {\n            endAngle = -PI2;\n          } else if (endAngle > 0) {\n            endAngle = -PI2 + endAngle % PI2;\n          }\n        } else if (endAngle > PI2) {\n          endAngle = PI2;\n        } else if (endAngle < 0) {\n          endAngle = PI2 + endAngle % PI2;\n        }\n\n        if (lastPath === null) {\n          lastPath = new Path(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius, lineWidth);\n          path.push(lastPath);\n          iteration += iterStep;\n        }\n\n        while (iteration < 1 + overshoot) {\n          ta = endAngle * iteration + startAngle;\n          tx = x + Math.cos(ta) * radius;\n          ty = y + Math.sin(ta) * radius;\n          lastPath.points.push(new Point(tx, ty, lineWidth));\n          iteration += iterStep;\n        }\n\n        ta = endAngle + startAngle;\n        tx = x + Math.cos(ta) * radius;\n        ty = y + Math.sin(ta) * radius;\n        lastPath.points.push(new Point(tx, ty, lineWidth));\n        break;\n\n      case Commands.FILL_RECT:\n        pipeline.setTexture2D(currentTexture);\n        pipeline.batchFillRect(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, camMatrix);\n        break;\n\n      case Commands.FILL_TRIANGLE:\n        pipeline.setTexture2D(currentTexture);\n        pipeline.batchFillTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], currentMatrix, camMatrix);\n        break;\n\n      case Commands.STROKE_TRIANGLE:\n        pipeline.setTexture2D(currentTexture);\n        pipeline.batchStrokeTriangle(commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], commands[++cmdIndex], lineWidth, currentMatrix, camMatrix);\n        break;\n\n      case Commands.LINE_TO:\n        if (lastPath !== null) {\n          lastPath.points.push(new Point(commands[++cmdIndex], commands[++cmdIndex], lineWidth));\n        } else {\n          lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);\n          path.push(lastPath);\n        }\n\n        break;\n\n      case Commands.MOVE_TO:\n        lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);\n        path.push(lastPath);\n        break;\n\n      case Commands.SAVE:\n        matrixStack.push(currentMatrix.copyToArray());\n        break;\n\n      case Commands.RESTORE:\n        currentMatrix.copyFromArray(matrixStack.pop());\n        break;\n\n      case Commands.TRANSLATE:\n        x = commands[++cmdIndex];\n        y = commands[++cmdIndex];\n        currentMatrix.translate(x, y);\n        break;\n\n      case Commands.SCALE:\n        x = commands[++cmdIndex];\n        y = commands[++cmdIndex];\n        currentMatrix.scale(x, y);\n        break;\n\n      case Commands.ROTATE:\n        currentMatrix.rotate(commands[++cmdIndex]);\n        break;\n\n      case Commands.SET_TEXTURE:\n        var frame = commands[++cmdIndex];\n        var mode = commands[++cmdIndex];\n        pipeline.currentFrame = frame;\n        pipeline.setTexture2D(frame.glTexture, 0);\n        pipeline.tintEffect = mode;\n        currentTexture = frame.glTexture;\n        break;\n\n      case Commands.CLEAR_TEXTURE:\n        pipeline.currentFrame = renderer.blankTexture;\n        pipeline.tintEffect = 2;\n        currentTexture = renderer.blankTexture.glTexture;\n        break;\n    }\n  }\n};\n\nmodule.exports = GraphicsWebGLRenderer;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/graphics/GraphicsWebGLRenderer.js"],"names":["Commands","require","Utils","Point","x","y","width","Path","points","pointsLength","matrixStack","GraphicsWebGLRenderer","renderer","src","interpolationPercentage","camera","parentMatrix","commandBuffer","length","pipeline","setPipeline","camMatrix","_tempMatrix1","graphicsMatrix","_tempMatrix2","currentMatrix","_tempMatrix3","loadIdentity","applyITRS","rotation","scaleX","scaleY","copyFrom","matrix","multiplyWithOffset","scrollX","scrollFactorX","scrollY","scrollFactorY","e","f","multiply","commands","alpha","lineWidth","fillTint","strokeTint","tx","ty","ta","iterStep","PI2","Math","PI","cmd","path","pathIndex","pathOpen","lastPath","getTint","getTintAppendFloatAlphaAndSwap","currentTexture","blankTexture","glTexture","cmdIndex","BEGIN_PATH","CLOSE_PATH","push","FILL_PATH","setTexture2D","batchFillPath","STROKE_PATH","batchStrokePath","LINE_STYLE","strokeColor","strokeAlpha","strokeTintColor","TL","TR","BL","BR","FILL_STYLE","fillColor","fillAlpha","fillTintColor","GRADIENT_FILL_STYLE","gradientFillAlpha","GRADIENT_LINE_STYLE","gradientLineAlpha","ARC","iteration","radius","startAngle","endAngle","anticlockwise","overshoot","cos","sin","FILL_RECT","batchFillRect","FILL_TRIANGLE","batchFillTriangle","STROKE_TRIANGLE","batchStrokeTriangle","LINE_TO","MOVE_TO","SAVE","copyToArray","RESTORE","copyFromArray","pop","TRANSLATE","translate","SCALE","scale","ROTATE","rotate","SET_TEXTURE","frame","mode","currentFrame","tintEffect","CLEAR_TEXTURE","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Commands = require('./Commands');\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\n//  TODO: Remove the use of this\r\nvar Point = function (x, y, width)\r\n{\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n};\r\n\r\n//  TODO: Remove the use of this\r\nvar Path = function (x, y, width)\r\n{\r\n    this.points = [];\r\n    this.pointsLength = 1;\r\n    this.points[0] = new Point(x, y, width);\r\n};\r\n\r\nvar matrixStack = [];\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Graphics#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Graphics} src - The Game Object being rendered in this call.\r\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar GraphicsWebGLRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix)\r\n{\r\n    if (src.commandBuffer.length === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var pipeline = this.pipeline;\r\n\r\n    renderer.setPipeline(pipeline, src);\r\n\r\n    var camMatrix = src._tempMatrix1;\r\n    var graphicsMatrix = src._tempMatrix2;\r\n    var currentMatrix = src._tempMatrix3;\r\n\r\n    currentMatrix.loadIdentity();\r\n\r\n    graphicsMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\r\n\r\n    camMatrix.copyFrom(camera.matrix);\r\n\r\n    if (parentMatrix)\r\n    {\r\n        //  Multiply the camera by the parent matrix\r\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n\r\n        //  Undo the camera scroll\r\n        graphicsMatrix.e = src.x;\r\n        graphicsMatrix.f = src.y;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(graphicsMatrix);\r\n    }\r\n    else\r\n    {\r\n        graphicsMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n        graphicsMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(graphicsMatrix);\r\n    }\r\n\r\n    var commands = src.commandBuffer;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    var lineWidth = 1;\r\n    var fillTint = pipeline.fillTint;\r\n    var strokeTint = pipeline.strokeTint;\r\n\r\n    var tx = 0;\r\n    var ty = 0;\r\n    var ta = 0;\r\n    var iterStep = 0.01;\r\n    var PI2 = Math.PI * 2;\r\n\r\n    var cmd;\r\n\r\n    var path = [];\r\n    var pathIndex = 0;\r\n    var pathOpen = false;\r\n    var lastPath = null;\r\n\r\n    var getTint = Utils.getTintAppendFloatAlphaAndSwap;\r\n\r\n    var currentTexture = renderer.blankTexture.glTexture;\r\n\r\n    for (var cmdIndex = 0; cmdIndex < commands.length; cmdIndex++)\r\n    {\r\n        cmd = commands[cmdIndex];\r\n\r\n        switch (cmd)\r\n        {\r\n            case Commands.BEGIN_PATH:\r\n\r\n                path.length = 0;\r\n                lastPath = null;\r\n                pathOpen = true;\r\n                break;\r\n\r\n            case Commands.CLOSE_PATH:\r\n\r\n                pathOpen = false;\r\n\r\n                if (lastPath && lastPath.points.length)\r\n                {\r\n                    lastPath.points.push(lastPath.points[0]);\r\n                }\r\n                break;\r\n\r\n            case Commands.FILL_PATH:\r\n                for (pathIndex = 0; pathIndex < path.length; pathIndex++)\r\n                {\r\n                    pipeline.setTexture2D(currentTexture);\r\n\r\n                    pipeline.batchFillPath(\r\n                        path[pathIndex].points,\r\n                        currentMatrix,\r\n                        camMatrix\r\n                    );\r\n                }\r\n                break;\r\n\r\n            case Commands.STROKE_PATH:\r\n                for (pathIndex = 0; pathIndex < path.length; pathIndex++)\r\n                {\r\n                    pipeline.setTexture2D(currentTexture);\r\n\r\n                    pipeline.batchStrokePath(\r\n                        path[pathIndex].points,\r\n                        lineWidth,\r\n                        pathOpen,\r\n                        currentMatrix,\r\n                        camMatrix\r\n                    );\r\n                }\r\n                break;\r\n\r\n            case Commands.LINE_STYLE:\r\n                lineWidth = commands[++cmdIndex];\r\n                var strokeColor = commands[++cmdIndex];\r\n                var strokeAlpha = commands[++cmdIndex] * alpha;\r\n                var strokeTintColor = getTint(strokeColor, strokeAlpha);\r\n                strokeTint.TL = strokeTintColor;\r\n                strokeTint.TR = strokeTintColor;\r\n                strokeTint.BL = strokeTintColor;\r\n                strokeTint.BR = strokeTintColor;\r\n                break;\r\n\r\n            case Commands.FILL_STYLE:\r\n                var fillColor = commands[++cmdIndex];\r\n                var fillAlpha = commands[++cmdIndex] * alpha;\r\n                var fillTintColor = getTint(fillColor, fillAlpha);\r\n                fillTint.TL = fillTintColor;\r\n                fillTint.TR = fillTintColor;\r\n                fillTint.BL = fillTintColor;\r\n                fillTint.BR = fillTintColor;\r\n                break;\r\n\r\n            case Commands.GRADIENT_FILL_STYLE:\r\n                var gradientFillAlpha = commands[++cmdIndex] * alpha;\r\n                fillTint.TL = getTint(commands[++cmdIndex], gradientFillAlpha);\r\n                fillTint.TR = getTint(commands[++cmdIndex], gradientFillAlpha);\r\n                fillTint.BL = getTint(commands[++cmdIndex], gradientFillAlpha);\r\n                fillTint.BR = getTint(commands[++cmdIndex], gradientFillAlpha);\r\n                break;\r\n\r\n            case Commands.GRADIENT_LINE_STYLE:\r\n                lineWidth = commands[++cmdIndex];\r\n                var gradientLineAlpha = commands[++cmdIndex] * alpha;\r\n                strokeTint.TL = getTint(commands[++cmdIndex], gradientLineAlpha);\r\n                strokeTint.TR = getTint(commands[++cmdIndex], gradientLineAlpha);\r\n                strokeTint.BL = getTint(commands[++cmdIndex], gradientLineAlpha);\r\n                strokeTint.BR = getTint(commands[++cmdIndex], gradientLineAlpha);\r\n                break;\r\n\r\n            case Commands.ARC:\r\n                var iteration = 0;\r\n                var x = commands[++cmdIndex];\r\n                var y = commands[++cmdIndex];\r\n                var radius = commands[++cmdIndex];\r\n                var startAngle = commands[++cmdIndex];\r\n                var endAngle = commands[++cmdIndex];\r\n                var anticlockwise = commands[++cmdIndex];\r\n                var overshoot = commands[++cmdIndex];\r\n\r\n                endAngle -= startAngle;\r\n\r\n                if (anticlockwise)\r\n                {\r\n                    if (endAngle < -PI2)\r\n                    {\r\n                        endAngle = -PI2;\r\n                    }\r\n                    else if (endAngle > 0)\r\n                    {\r\n                        endAngle = -PI2 + endAngle % PI2;\r\n                    }\r\n                }\r\n                else if (endAngle > PI2)\r\n                {\r\n                    endAngle = PI2;\r\n                }\r\n                else if (endAngle < 0)\r\n                {\r\n                    endAngle = PI2 + endAngle % PI2;\r\n                }\r\n\r\n                if (lastPath === null)\r\n                {\r\n                    lastPath = new Path(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius, lineWidth);\r\n                    path.push(lastPath);\r\n                    iteration += iterStep;\r\n                }\r\n\r\n                while (iteration < 1 + overshoot)\r\n                {\r\n                    ta = endAngle * iteration + startAngle;\r\n                    tx = x + Math.cos(ta) * radius;\r\n                    ty = y + Math.sin(ta) * radius;\r\n\r\n                    lastPath.points.push(new Point(tx, ty, lineWidth));\r\n\r\n                    iteration += iterStep;\r\n                }\r\n\r\n                ta = endAngle + startAngle;\r\n                tx = x + Math.cos(ta) * radius;\r\n                ty = y + Math.sin(ta) * radius;\r\n\r\n                lastPath.points.push(new Point(tx, ty, lineWidth));\r\n\r\n                break;\r\n\r\n            case Commands.FILL_RECT:\r\n                pipeline.setTexture2D(currentTexture);\r\n                pipeline.batchFillRect(\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    currentMatrix,\r\n                    camMatrix\r\n                );\r\n                break;\r\n\r\n            case Commands.FILL_TRIANGLE:\r\n                pipeline.setTexture2D(currentTexture);\r\n                pipeline.batchFillTriangle(\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    currentMatrix,\r\n                    camMatrix\r\n                );\r\n                break;\r\n\r\n            case Commands.STROKE_TRIANGLE:\r\n                pipeline.setTexture2D(currentTexture);\r\n                pipeline.batchStrokeTriangle(\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    lineWidth,\r\n                    currentMatrix,\r\n                    camMatrix\r\n                );\r\n                break;\r\n\r\n            case Commands.LINE_TO:\r\n                if (lastPath !== null)\r\n                {\r\n                    lastPath.points.push(new Point(commands[++cmdIndex], commands[++cmdIndex], lineWidth));\r\n                }\r\n                else\r\n                {\r\n                    lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);\r\n                    path.push(lastPath);\r\n                }\r\n                break;\r\n\r\n            case Commands.MOVE_TO:\r\n                lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);\r\n                path.push(lastPath);\r\n                break;\r\n\r\n            case Commands.SAVE:\r\n                matrixStack.push(currentMatrix.copyToArray());\r\n                break;\r\n\r\n            case Commands.RESTORE:\r\n                currentMatrix.copyFromArray(matrixStack.pop());\r\n                break;\r\n\r\n            case Commands.TRANSLATE:\r\n                x = commands[++cmdIndex];\r\n                y = commands[++cmdIndex];\r\n                currentMatrix.translate(x, y);\r\n                break;\r\n\r\n            case Commands.SCALE:\r\n                x = commands[++cmdIndex];\r\n                y = commands[++cmdIndex];\r\n                currentMatrix.scale(x, y);\r\n                break;\r\n\r\n            case Commands.ROTATE:\r\n                currentMatrix.rotate(commands[++cmdIndex]);\r\n                break;\r\n\r\n            case Commands.SET_TEXTURE:\r\n                var frame = commands[++cmdIndex];\r\n                var mode = commands[++cmdIndex];\r\n\r\n                pipeline.currentFrame = frame;\r\n                pipeline.setTexture2D(frame.glTexture, 0);\r\n                pipeline.tintEffect = mode;\r\n\r\n                currentTexture = frame.glTexture;\r\n\r\n                break;\r\n\r\n            case Commands.CLEAR_TEXTURE:\r\n                pipeline.currentFrame = renderer.blankTexture;\r\n                pipeline.tintEffect = 2;\r\n                currentTexture = renderer.blankTexture.glTexture;\r\n                break;\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = GraphicsWebGLRenderer;\r\n"]},"metadata":{},"sourceType":"script"}