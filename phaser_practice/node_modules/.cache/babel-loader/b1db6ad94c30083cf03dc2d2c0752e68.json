{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\n\n/**\r\n * Calculate the position, width and height of a BitmapText Game Object.\r\n *\r\n * Returns a BitmapTextSize object that contains global and local variants of the Game Objects x and y coordinates and\r\n * its width and height.\r\n *\r\n * The global position and size take into account the Game Object's position and scale.\r\n *\r\n * The local position and size just takes into account the font data.\r\n *\r\n * @function GetBitmapTextSize\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {(Phaser.GameObjects.DynamicBitmapText|Phaser.GameObjects.BitmapText)} src - The BitmapText to calculate the position, width and height of.\r\n * @param {boolean} [round] - Whether to round the results to the nearest integer.\r\n * @param {object} [out] - Optional object to store the results in, to save constant object creation.\r\n *\r\n * @return {Phaser.Types.GameObjects.BitmapText.BitmapTextSize} The calculated position, width and height of the BitmapText.\r\n */\nvar GetBitmapTextSize = function (src, round, out) {\n  if (out === undefined) {\n    out = {\n      local: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      },\n      global: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      },\n      lines: {\n        shortest: 0,\n        longest: 0,\n        lengths: null,\n        height: 0\n      },\n      wrappedText: '',\n      words: [],\n      scaleX: 0,\n      scaleY: 0\n    };\n    return out;\n  }\n\n  var text = src.text;\n  var textLength = text.length;\n  var maxWidth = src.maxWidth;\n  var wordWrapCharCode = src.wordWrapCharCode;\n  var bx = Number.MAX_VALUE;\n  var by = Number.MAX_VALUE;\n  var bw = 0;\n  var bh = 0;\n  var chars = src.fontData.chars;\n  var lineHeight = src.fontData.lineHeight;\n  var letterSpacing = src.letterSpacing;\n  var xAdvance = 0;\n  var yAdvance = 0;\n  var charCode = 0;\n  var glyph = null;\n  var x = 0;\n  var y = 0;\n  var scale = src.fontSize / src.fontData.size;\n  var sx = scale * src.scaleX;\n  var sy = scale * src.scaleY;\n  var lastGlyph = null;\n  var lastCharCode = 0;\n  var lineWidths = [];\n  var shortestLine = Number.MAX_VALUE;\n  var longestLine = 0;\n  var currentLine = 0;\n  var currentLineWidth = 0;\n  var i;\n  var words = [];\n  var current = null; //  Scan for breach of maxWidth and insert carriage-returns\n\n  if (maxWidth > 0) {\n    for (i = 0; i < textLength; i++) {\n      charCode = text.charCodeAt(i);\n\n      if (charCode === 10) {\n        if (current !== null) {\n          words.push({\n            word: current.word,\n            i: current.i,\n            x: current.x * sx,\n            y: current.y * sy,\n            w: current.w * sx,\n            h: current.h * sy,\n            cr: true\n          });\n          current = null;\n        }\n\n        xAdvance = 0;\n        yAdvance += lineHeight;\n        lastGlyph = null;\n        continue;\n      }\n\n      glyph = chars[charCode];\n\n      if (!glyph) {\n        continue;\n      }\n\n      if (lastGlyph !== null) {\n        var glyphKerningOffset = glyph.kerning[lastCharCode];\n      }\n\n      if (charCode === wordWrapCharCode) {\n        if (current !== null) {\n          words.push({\n            word: current.word,\n            i: current.i,\n            x: current.x * sx,\n            y: current.y * sy,\n            w: current.w * sx,\n            h: current.h * sy,\n            cr: false\n          });\n          current = null;\n        }\n      } else {\n        if (current === null) {\n          //  We're starting a new word, recording the starting index, etc\n          current = {\n            word: '',\n            i: i,\n            x: xAdvance,\n            y: yAdvance,\n            w: 0,\n            h: lineHeight,\n            cr: false\n          };\n        }\n\n        current.word = current.word.concat(text[i]);\n        current.w += glyph.xOffset + glyph.xAdvance + (glyphKerningOffset !== undefined ? glyphKerningOffset : 0);\n      }\n\n      xAdvance += glyph.xAdvance + letterSpacing;\n      lastGlyph = glyph;\n      lastCharCode = charCode;\n    } //  Last word\n\n\n    if (current !== null) {\n      words.push({\n        word: current.word,\n        i: current.i,\n        x: current.x * sx,\n        y: current.y * sy,\n        w: current.w * sx,\n        h: current.h * sy,\n        cr: false\n      });\n    } //  Reset for the next loop\n\n\n    xAdvance = 0;\n    yAdvance = 0;\n    lastGlyph = null;\n    lastCharCode = 0; //  Loop through the words array and see if we've got any > maxWidth\n\n    var prev;\n    var offset = 0;\n    var crs = [];\n\n    for (i = 0; i < words.length; i++) {\n      var entry = words[i];\n      var left = entry.x;\n      var right = entry.x + entry.w;\n\n      if (prev) {\n        var diff = left - (prev.x + prev.w);\n        offset = left - (diff + prev.w);\n        prev = null;\n      }\n\n      var checkLeft = left - offset;\n      var checkRight = right - offset;\n\n      if (checkLeft > maxWidth || checkRight > maxWidth) {\n        crs.push(entry.i - 1);\n\n        if (entry.cr) {\n          crs.push(entry.i + entry.word.length);\n          offset = 0;\n          prev = null;\n        } else {\n          prev = entry;\n        }\n      } else if (entry.cr) {\n        crs.push(entry.i + entry.word.length);\n        offset = 0;\n        prev = null;\n      }\n    }\n\n    var stringInsert = function (str, index, value) {\n      return str.substr(0, index) + value + str.substr(index + 1);\n    };\n\n    for (i = crs.length - 1; i >= 0; i--) {\n      // eslint-disable-next-line quotes\n      text = stringInsert(text, crs[i], \"\\n\");\n    }\n\n    out.wrappedText = text;\n    textLength = text.length; //  Recalculated in the next loop\n\n    words = [];\n    current = null;\n  }\n\n  for (i = 0; i < textLength; i++) {\n    charCode = text.charCodeAt(i);\n\n    if (charCode === 10) {\n      if (current !== null) {\n        words.push({\n          word: current.word,\n          i: current.i,\n          x: current.x * sx,\n          y: current.y * sy,\n          w: current.w * sx,\n          h: current.h * sy\n        });\n        current = null;\n      }\n\n      xAdvance = 0;\n      yAdvance += lineHeight;\n      lastGlyph = null;\n      lineWidths[currentLine] = currentLineWidth;\n\n      if (currentLineWidth > longestLine) {\n        longestLine = currentLineWidth;\n      }\n\n      if (currentLineWidth < shortestLine) {\n        shortestLine = currentLineWidth;\n      }\n\n      currentLine++;\n      currentLineWidth = 0;\n      continue;\n    }\n\n    glyph = chars[charCode];\n\n    if (!glyph) {\n      continue;\n    }\n\n    x = xAdvance;\n    y = yAdvance;\n\n    if (lastGlyph !== null) {\n      var kerningOffset = glyph.kerning[lastCharCode];\n      x += kerningOffset !== undefined ? kerningOffset : 0;\n    }\n\n    if (bx > x) {\n      bx = x;\n    }\n\n    if (by > y) {\n      by = y;\n    }\n\n    var gw = x + glyph.xAdvance;\n    var gh = y + lineHeight;\n\n    if (bw < gw) {\n      bw = gw;\n    }\n\n    if (bh < gh) {\n      bh = gh;\n    }\n\n    if (charCode === wordWrapCharCode) {\n      if (current !== null) {\n        words.push({\n          word: current.word,\n          i: current.i,\n          x: current.x * sx,\n          y: current.y * sy,\n          w: current.w * sx,\n          h: current.h * sy\n        });\n        current = null;\n      }\n    } else {\n      if (current === null) {\n        //  We're starting a new word, recording the starting index, etc\n        current = {\n          word: '',\n          i: i,\n          x: xAdvance,\n          y: yAdvance,\n          w: 0,\n          h: lineHeight\n        };\n      }\n\n      current.word = current.word.concat(text[i]);\n      current.w += glyph.xOffset + glyph.xAdvance + (kerningOffset !== undefined ? kerningOffset : 0);\n    }\n\n    xAdvance += glyph.xAdvance + letterSpacing;\n    lastGlyph = glyph;\n    lastCharCode = charCode;\n    currentLineWidth = gw * scale;\n  } //  Last word\n\n\n  if (current !== null) {\n    words.push({\n      word: current.word,\n      i: current.i,\n      x: current.x * sx,\n      y: current.y * sy,\n      w: current.w * sx,\n      h: current.h * sy\n    });\n  }\n\n  lineWidths[currentLine] = currentLineWidth;\n\n  if (currentLineWidth > longestLine) {\n    longestLine = currentLineWidth;\n  }\n\n  if (currentLineWidth < shortestLine) {\n    shortestLine = currentLineWidth;\n  }\n\n  var local = out.local;\n  var global = out.global;\n  var lines = out.lines;\n  local.x = bx * scale;\n  local.y = by * scale;\n  local.width = bw * scale;\n  local.height = bh * scale;\n  global.x = src.x - src.displayOriginX + bx * sx;\n  global.y = src.y - src.displayOriginY + by * sy;\n  global.width = bw * sx;\n  global.height = bh * sy;\n  lines.shortest = shortestLine;\n  lines.longest = longestLine;\n  lines.lengths = lineWidths;\n\n  if (round) {\n    local.x = Math.round(local.x);\n    local.y = Math.round(local.y);\n    local.width = Math.round(local.width);\n    local.height = Math.round(local.height);\n    global.x = Math.round(global.x);\n    global.y = Math.round(global.y);\n    global.width = Math.round(global.width);\n    global.height = Math.round(global.height);\n    lines.shortest = Math.round(shortestLine);\n    lines.longest = Math.round(longestLine);\n  }\n\n  out.words = words;\n  out.lines.height = lineHeight;\n  out.scaleX = src.scaleX;\n  out.scaleY = src.scaleY;\n  return out;\n};\n\nmodule.exports = GetBitmapTextSize;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/gameobjects/bitmaptext/GetBitmapTextSize.js"],"names":["GetBitmapTextSize","src","round","out","undefined","local","x","y","width","height","global","lines","shortest","longest","lengths","wrappedText","words","scaleX","scaleY","text","textLength","length","maxWidth","wordWrapCharCode","bx","Number","MAX_VALUE","by","bw","bh","chars","fontData","lineHeight","letterSpacing","xAdvance","yAdvance","charCode","glyph","scale","fontSize","size","sx","sy","lastGlyph","lastCharCode","lineWidths","shortestLine","longestLine","currentLine","currentLineWidth","i","current","charCodeAt","push","word","w","h","cr","glyphKerningOffset","kerning","concat","xOffset","prev","offset","crs","entry","left","right","diff","checkLeft","checkRight","stringInsert","str","index","value","substr","kerningOffset","gw","gh","displayOriginX","displayOriginY","Math","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the position, width and height of a BitmapText Game Object.\r\n *\r\n * Returns a BitmapTextSize object that contains global and local variants of the Game Objects x and y coordinates and\r\n * its width and height.\r\n *\r\n * The global position and size take into account the Game Object's position and scale.\r\n *\r\n * The local position and size just takes into account the font data.\r\n *\r\n * @function GetBitmapTextSize\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {(Phaser.GameObjects.DynamicBitmapText|Phaser.GameObjects.BitmapText)} src - The BitmapText to calculate the position, width and height of.\r\n * @param {boolean} [round] - Whether to round the results to the nearest integer.\r\n * @param {object} [out] - Optional object to store the results in, to save constant object creation.\r\n *\r\n * @return {Phaser.Types.GameObjects.BitmapText.BitmapTextSize} The calculated position, width and height of the BitmapText.\r\n */\r\nvar GetBitmapTextSize = function (src, round, out)\r\n{\r\n    if (out === undefined)\r\n    {\r\n        out = {\r\n            local: {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            },\r\n            global: {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            },\r\n            lines: {\r\n                shortest: 0,\r\n                longest: 0,\r\n                lengths: null,\r\n                height: 0\r\n            },\r\n            wrappedText: '',\r\n            words: [],\r\n            scaleX: 0,\r\n            scaleY: 0\r\n        };\r\n\r\n        return out;\r\n    }\r\n\r\n    var text = src.text;\r\n    var textLength = text.length;\r\n    var maxWidth = src.maxWidth;\r\n    var wordWrapCharCode = src.wordWrapCharCode;\r\n\r\n    var bx = Number.MAX_VALUE;\r\n    var by = Number.MAX_VALUE;\r\n    var bw = 0;\r\n    var bh = 0;\r\n\r\n    var chars = src.fontData.chars;\r\n    var lineHeight = src.fontData.lineHeight;\r\n    var letterSpacing = src.letterSpacing;\r\n\r\n    var xAdvance = 0;\r\n    var yAdvance = 0;\r\n\r\n    var charCode = 0;\r\n\r\n    var glyph = null;\r\n\r\n    var x = 0;\r\n    var y = 0;\r\n\r\n    var scale = (src.fontSize / src.fontData.size);\r\n    var sx = scale * src.scaleX;\r\n    var sy = scale * src.scaleY;\r\n\r\n    var lastGlyph = null;\r\n    var lastCharCode = 0;\r\n    var lineWidths = [];\r\n    var shortestLine = Number.MAX_VALUE;\r\n    var longestLine = 0;\r\n    var currentLine = 0;\r\n    var currentLineWidth = 0;\r\n\r\n    var i;\r\n    var words = [];\r\n    var current = null;\r\n\r\n    //  Scan for breach of maxWidth and insert carriage-returns\r\n    if (maxWidth > 0)\r\n    {\r\n        for (i = 0; i < textLength; i++)\r\n        {\r\n            charCode = text.charCodeAt(i);\r\n\r\n            if (charCode === 10)\r\n            {\r\n                if (current !== null)\r\n                {\r\n                    words.push({\r\n                        word: current.word,\r\n                        i: current.i,\r\n                        x: current.x * sx,\r\n                        y: current.y * sy,\r\n                        w: current.w * sx,\r\n                        h: current.h * sy,\r\n                        cr: true\r\n                    });\r\n\r\n                    current = null;\r\n                }\r\n\r\n                xAdvance = 0;\r\n                yAdvance += lineHeight;\r\n                lastGlyph = null;\r\n\r\n                continue;\r\n            }\r\n\r\n            glyph = chars[charCode];\r\n\r\n            if (!glyph)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (lastGlyph !== null)\r\n            {\r\n                var glyphKerningOffset = glyph.kerning[lastCharCode];\r\n            }\r\n\r\n            if (charCode === wordWrapCharCode)\r\n            {\r\n                if (current !== null)\r\n                {\r\n                    words.push({\r\n                        word: current.word,\r\n                        i: current.i,\r\n                        x: current.x * sx,\r\n                        y: current.y * sy,\r\n                        w: current.w * sx,\r\n                        h: current.h * sy,\r\n                        cr: false\r\n                    });\r\n    \r\n                    current = null;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if (current === null)\r\n                {\r\n                    //  We're starting a new word, recording the starting index, etc\r\n                    current = { word: '', i: i, x: xAdvance, y: yAdvance, w: 0, h: lineHeight, cr: false };\r\n                }\r\n\r\n                current.word = current.word.concat(text[i]);\r\n                current.w += glyph.xOffset + glyph.xAdvance + ((glyphKerningOffset !== undefined) ? glyphKerningOffset : 0);\r\n            }\r\n\r\n            xAdvance += glyph.xAdvance + letterSpacing;\r\n            lastGlyph = glyph;\r\n            lastCharCode = charCode;\r\n        }\r\n\r\n        //  Last word\r\n        if (current !== null)\r\n        {\r\n            words.push({\r\n                word: current.word,\r\n                i: current.i,\r\n                x: current.x * sx,\r\n                y: current.y * sy,\r\n                w: current.w * sx,\r\n                h: current.h * sy,\r\n                cr: false\r\n            });\r\n        }\r\n\r\n        //  Reset for the next loop\r\n        xAdvance = 0;\r\n        yAdvance = 0;\r\n        lastGlyph = null;\r\n        lastCharCode = 0;\r\n\r\n        //  Loop through the words array and see if we've got any > maxWidth\r\n        var prev;\r\n        var offset = 0;\r\n        var crs = [];\r\n\r\n        for (i = 0; i < words.length; i++)\r\n        {\r\n            var entry = words[i];\r\n            var left = entry.x;\r\n            var right = entry.x + entry.w;\r\n\r\n            if (prev)\r\n            {\r\n                var diff = left - (prev.x + prev.w);\r\n\r\n                offset = left - (diff + prev.w);\r\n\r\n                prev = null;\r\n            }\r\n\r\n            var checkLeft = left - offset;\r\n            var checkRight = right - offset;\r\n\r\n            if (checkLeft > maxWidth || checkRight > maxWidth)\r\n            {\r\n                crs.push(entry.i - 1);\r\n\r\n                if (entry.cr)\r\n                {\r\n                    crs.push(entry.i + entry.word.length);\r\n\r\n                    offset = 0;\r\n                    prev = null;\r\n                }\r\n                else\r\n                {\r\n                    prev = entry;\r\n                }\r\n            }\r\n            else if (entry.cr)\r\n            {\r\n                crs.push(entry.i + entry.word.length);\r\n\r\n                offset = 0;\r\n                prev = null;\r\n            }\r\n        }\r\n\r\n        var stringInsert = function (str, index, value)\r\n        {\r\n            return str.substr(0, index) + value + str.substr(index + 1);\r\n        };\r\n\r\n        for (i = crs.length - 1; i >= 0; i--)\r\n        {\r\n            // eslint-disable-next-line quotes\r\n            text = stringInsert(text, crs[i], \"\\n\");\r\n        }\r\n\r\n        out.wrappedText = text;\r\n\r\n        textLength = text.length;\r\n\r\n        //  Recalculated in the next loop\r\n        words = [];\r\n        current = null;\r\n    }\r\n\r\n    for (i = 0; i < textLength; i++)\r\n    {\r\n        charCode = text.charCodeAt(i);\r\n\r\n        if (charCode === 10)\r\n        {\r\n            if (current !== null)\r\n            {\r\n                words.push({\r\n                    word: current.word,\r\n                    i: current.i,\r\n                    x: current.x * sx,\r\n                    y: current.y * sy,\r\n                    w: current.w * sx,\r\n                    h: current.h * sy\r\n                });\r\n\r\n                current = null;\r\n            }\r\n\r\n            xAdvance = 0;\r\n            yAdvance += lineHeight;\r\n            lastGlyph = null;\r\n\r\n            lineWidths[currentLine] = currentLineWidth;\r\n\r\n            if (currentLineWidth > longestLine)\r\n            {\r\n                longestLine = currentLineWidth;\r\n            }\r\n\r\n            if (currentLineWidth < shortestLine)\r\n            {\r\n                shortestLine = currentLineWidth;\r\n            }\r\n\r\n            currentLine++;\r\n            currentLineWidth = 0;\r\n\r\n            continue;\r\n        }\r\n\r\n        glyph = chars[charCode];\r\n\r\n        if (!glyph)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        x = xAdvance;\r\n        y = yAdvance;\r\n\r\n        if (lastGlyph !== null)\r\n        {\r\n            var kerningOffset = glyph.kerning[lastCharCode];\r\n\r\n            x += (kerningOffset !== undefined) ? kerningOffset : 0;\r\n        }\r\n\r\n        if (bx > x)\r\n        {\r\n            bx = x;\r\n        }\r\n\r\n        if (by > y)\r\n        {\r\n            by = y;\r\n        }\r\n\r\n        var gw = x + glyph.xAdvance;\r\n        var gh = y + lineHeight;\r\n\r\n        if (bw < gw)\r\n        {\r\n            bw = gw;\r\n        }\r\n\r\n        if (bh < gh)\r\n        {\r\n            bh = gh;\r\n        }\r\n\r\n        if (charCode === wordWrapCharCode)\r\n        {\r\n            if (current !== null)\r\n            {\r\n                words.push({\r\n                    word: current.word,\r\n                    i: current.i,\r\n                    x: current.x * sx,\r\n                    y: current.y * sy,\r\n                    w: current.w * sx,\r\n                    h: current.h * sy\r\n                });\r\n    \r\n                current = null;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if (current === null)\r\n            {\r\n                //  We're starting a new word, recording the starting index, etc\r\n                current = { word: '', i: i, x: xAdvance, y: yAdvance, w: 0, h: lineHeight };\r\n            }\r\n\r\n            current.word = current.word.concat(text[i]);\r\n            current.w += glyph.xOffset + glyph.xAdvance + ((kerningOffset !== undefined) ? kerningOffset : 0);\r\n        }\r\n\r\n        xAdvance += glyph.xAdvance + letterSpacing;\r\n        lastGlyph = glyph;\r\n        lastCharCode = charCode;\r\n        currentLineWidth = gw * scale;\r\n    }\r\n\r\n    //  Last word\r\n    if (current !== null)\r\n    {\r\n        words.push({\r\n            word: current.word,\r\n            i: current.i,\r\n            x: current.x * sx,\r\n            y: current.y * sy,\r\n            w: current.w * sx,\r\n            h: current.h * sy\r\n        });\r\n    }\r\n\r\n    lineWidths[currentLine] = currentLineWidth;\r\n\r\n    if (currentLineWidth > longestLine)\r\n    {\r\n        longestLine = currentLineWidth;\r\n    }\r\n\r\n    if (currentLineWidth < shortestLine)\r\n    {\r\n        shortestLine = currentLineWidth;\r\n    }\r\n\r\n    var local = out.local;\r\n    var global = out.global;\r\n    var lines = out.lines;\r\n\r\n    local.x = bx * scale;\r\n    local.y = by * scale;\r\n    local.width = bw * scale;\r\n    local.height = bh * scale;\r\n\r\n    global.x = (src.x - src.displayOriginX) + (bx * sx);\r\n    global.y = (src.y - src.displayOriginY) + (by * sy);\r\n    global.width = bw * sx;\r\n    global.height = bh * sy;\r\n\r\n    lines.shortest = shortestLine;\r\n    lines.longest = longestLine;\r\n    lines.lengths = lineWidths;\r\n\r\n    if (round)\r\n    {\r\n        local.x = Math.round(local.x);\r\n        local.y = Math.round(local.y);\r\n        local.width = Math.round(local.width);\r\n        local.height = Math.round(local.height);\r\n\r\n        global.x = Math.round(global.x);\r\n        global.y = Math.round(global.y);\r\n        global.width = Math.round(global.width);\r\n        global.height = Math.round(global.height);\r\n\r\n        lines.shortest = Math.round(shortestLine);\r\n        lines.longest = Math.round(longestLine);\r\n    }\r\n\r\n    out.words = words;\r\n    out.lines.height = lineHeight;\r\n    out.scaleX = src.scaleX;\r\n    out.scaleY = src.scaleY;\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetBitmapTextSize;\r\n"]},"metadata":{},"sourceType":"script"}