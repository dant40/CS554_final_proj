{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../../utils/Class');\n\nvar ShaderSourceFS = require('../shaders/BitmapMask-frag.js');\n\nvar ShaderSourceVS = require('../shaders/BitmapMask-vert.js');\n\nvar WebGLPipeline = require('../WebGLPipeline');\n/**\r\n * @classdesc\r\n * BitmapMaskPipeline handles all bitmap masking rendering in WebGL. It works by using \r\n * sampling two texture on the fragment shader and using the fragment's alpha to clip the region.\r\n * The config properties are:\r\n * - game: Current game instance.\r\n * - renderer: Current WebGL renderer.\r\n * - topology: This indicates how the primitives are rendered. The default value is GL_TRIANGLES.\r\n *              Here is the full list of rendering primitives (https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants).\r\n * - vertShader: Source for vertex shader as a string.\r\n * - fragShader: Source for fragment shader as a string.\r\n * - vertexCapacity: The amount of vertices that shall be allocated\r\n * - vertexSize: The size of a single vertex in bytes.\r\n *\r\n * @class BitmapMaskPipeline\r\n * @extends Phaser.Renderer.WebGL.WebGLPipeline\r\n * @memberof Phaser.Renderer.WebGL.Pipelines\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - Used for overriding shader an pipeline properties if extending this pipeline.\r\n */\n\n\nvar BitmapMaskPipeline = new Class({\n  Extends: WebGLPipeline,\n  initialize: function BitmapMaskPipeline(config) {\n    WebGLPipeline.call(this, {\n      game: config.game,\n      renderer: config.renderer,\n      gl: config.renderer.gl,\n      topology: config.topology ? config.topology : config.renderer.gl.TRIANGLES,\n      vertShader: config.vertShader ? config.vertShader : ShaderSourceVS,\n      fragShader: config.fragShader ? config.fragShader : ShaderSourceFS,\n      vertexCapacity: config.vertexCapacity ? config.vertexCapacity : 3,\n      vertexSize: config.vertexSize ? config.vertexSize : Float32Array.BYTES_PER_ELEMENT * 2,\n      vertices: new Float32Array([-1, +1, -1, -7, +7, +1]).buffer,\n      attributes: [{\n        name: 'inPosition',\n        size: 2,\n        type: config.renderer.gl.FLOAT,\n        normalized: false,\n        offset: 0\n      }]\n    });\n    /**\r\n     * Float32 view of the array buffer containing the pipeline's vertices.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#vertexViewF32\r\n     * @type {Float32Array}\r\n     * @since 3.0.0\r\n     */\n\n    this.vertexViewF32 = new Float32Array(this.vertexData);\n    /**\r\n     * Size of the batch.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#maxQuads\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\n\n    this.maxQuads = 1;\n    /**\r\n     * Dirty flag to check if resolution properties need to be updated on the \r\n     * masking shader.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#resolutionDirty\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\n\n    this.resolutionDirty = true;\n  },\n\n  /**\r\n   * Called every time the pipeline needs to be used.\r\n   * It binds all necessary resources.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#onBind\r\n   * @since 3.0.0\r\n   *\r\n   * @return {this} This WebGLPipeline instance.\r\n   */\n  onBind: function () {\n    WebGLPipeline.prototype.onBind.call(this);\n    var renderer = this.renderer;\n    var program = this.program;\n\n    if (this.resolutionDirty) {\n      renderer.setFloat2(program, 'uResolution', this.width, this.height);\n      renderer.setInt1(program, 'uMainSampler', 0);\n      renderer.setInt1(program, 'uMaskSampler', 1);\n      this.resolutionDirty = false;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * [description]\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#resize\r\n   * @since 3.0.0\r\n   *\r\n   * @param {number} width - [description]\r\n   * @param {number} height - [description]\r\n   * @param {number} resolution - [description]\r\n   *\r\n   * @return {this} This WebGLPipeline instance.\r\n   */\n  resize: function (width, height, resolution) {\n    WebGLPipeline.prototype.resize.call(this, width, height, resolution);\n    this.resolutionDirty = true;\n    return this;\n  },\n\n  /**\r\n   * Binds necessary resources and renders the mask to a separated framebuffer.\r\n   * The framebuffer for the masked object is also bound for further use.\r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#beginMask\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} mask - GameObject used as mask.\r\n   * @param {Phaser.GameObjects.GameObject} maskedObject - GameObject masked by the mask GameObject.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n   */\n  beginMask: function (mask, maskedObject, camera) {\n    var renderer = this.renderer;\n    var gl = this.gl; //  The renderable Game Object that is being used for the bitmap mask\n\n    var bitmapMask = mask.bitmapMask;\n\n    if (bitmapMask && gl) {\n      renderer.flush();\n      mask.prevFramebuffer = renderer.currentFramebuffer;\n      renderer.setFramebuffer(mask.mainFramebuffer);\n      gl.disable(gl.STENCIL_TEST);\n      gl.clearColor(0, 0, 0, 0);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n\n      if (renderer.currentCameraMask.mask !== mask) {\n        renderer.currentMask.mask = mask;\n        renderer.currentMask.camera = camera;\n      }\n    }\n  },\n\n  /**\r\n   * The masked game objects framebuffer is unbound and its texture \r\n   * is bound together with the mask texture and the mask shader and \r\n   * a draw call with a single quad is processed. Here is where the\r\n   * masking effect is applied.  \r\n   *\r\n   * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#endMask\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.GameObject} mask - GameObject used as a mask.\r\n   */\n  endMask: function (mask, camera) {\n    var gl = this.gl;\n    var renderer = this.renderer; //  The renderable Game Object that is being used for the bitmap mask\n\n    var bitmapMask = mask.bitmapMask;\n\n    if (bitmapMask && gl) {\n      renderer.flush(); //  First we draw the mask to the mask fb\n\n      renderer.setFramebuffer(mask.maskFramebuffer);\n      gl.clearColor(0, 0, 0, 0);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      renderer.setBlendMode(0, true);\n      bitmapMask.renderWebGL(renderer, bitmapMask, 0, camera);\n      renderer.flush();\n      renderer.setFramebuffer(mask.prevFramebuffer); //  Is there a stencil further up the stack?\n\n      var prev = renderer.getCurrentStencilMask();\n\n      if (prev) {\n        gl.enable(gl.STENCIL_TEST);\n        prev.mask.applyStencil(renderer, prev.camera, true);\n      } else {\n        renderer.currentMask.mask = null;\n      } //  Bind bitmap mask pipeline and draw\n\n\n      renderer.setPipeline(this);\n      gl.activeTexture(gl.TEXTURE1);\n      gl.bindTexture(gl.TEXTURE_2D, mask.maskTexture);\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, mask.mainTexture);\n      gl.uniform1i(gl.getUniformLocation(this.program, 'uInvertMaskAlpha'), mask.invertAlpha); //  Finally, draw a triangle filling the whole screen\n\n      gl.drawArrays(this.topology, 0, 3);\n    }\n  }\n});\nmodule.exports = BitmapMaskPipeline;","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/renderer/webgl/pipelines/BitmapMaskPipeline.js"],"names":["Class","require","ShaderSourceFS","ShaderSourceVS","WebGLPipeline","BitmapMaskPipeline","Extends","initialize","config","call","game","renderer","gl","topology","TRIANGLES","vertShader","fragShader","vertexCapacity","vertexSize","Float32Array","BYTES_PER_ELEMENT","vertices","buffer","attributes","name","size","type","FLOAT","normalized","offset","vertexViewF32","vertexData","maxQuads","resolutionDirty","onBind","prototype","program","setFloat2","width","height","setInt1","resize","resolution","beginMask","mask","maskedObject","camera","bitmapMask","flush","prevFramebuffer","currentFramebuffer","setFramebuffer","mainFramebuffer","disable","STENCIL_TEST","clearColor","clear","COLOR_BUFFER_BIT","currentCameraMask","currentMask","endMask","maskFramebuffer","setBlendMode","renderWebGL","prev","getCurrentStencilMask","enable","applyStencil","setPipeline","activeTexture","TEXTURE1","bindTexture","TEXTURE_2D","maskTexture","TEXTURE0","mainTexture","uniform1i","getUniformLocation","invertAlpha","drawArrays","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar ShaderSourceFS = require('../shaders/BitmapMask-frag.js');\r\nvar ShaderSourceVS = require('../shaders/BitmapMask-vert.js');\r\nvar WebGLPipeline = require('../WebGLPipeline');\r\n\r\n/**\r\n * @classdesc\r\n * BitmapMaskPipeline handles all bitmap masking rendering in WebGL. It works by using \r\n * sampling two texture on the fragment shader and using the fragment's alpha to clip the region.\r\n * The config properties are:\r\n * - game: Current game instance.\r\n * - renderer: Current WebGL renderer.\r\n * - topology: This indicates how the primitives are rendered. The default value is GL_TRIANGLES.\r\n *              Here is the full list of rendering primitives (https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants).\r\n * - vertShader: Source for vertex shader as a string.\r\n * - fragShader: Source for fragment shader as a string.\r\n * - vertexCapacity: The amount of vertices that shall be allocated\r\n * - vertexSize: The size of a single vertex in bytes.\r\n *\r\n * @class BitmapMaskPipeline\r\n * @extends Phaser.Renderer.WebGL.WebGLPipeline\r\n * @memberof Phaser.Renderer.WebGL.Pipelines\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - Used for overriding shader an pipeline properties if extending this pipeline.\r\n */\r\nvar BitmapMaskPipeline = new Class({\r\n\r\n    Extends: WebGLPipeline,\r\n    \r\n    initialize:\r\n\r\n    function BitmapMaskPipeline (config)\r\n    {\r\n        WebGLPipeline.call(this, {\r\n            game: config.game,\r\n            renderer: config.renderer,\r\n            gl: config.renderer.gl,\r\n            topology: (config.topology ? config.topology : config.renderer.gl.TRIANGLES),\r\n            vertShader: (config.vertShader ? config.vertShader : ShaderSourceVS),\r\n            fragShader: (config.fragShader ? config.fragShader : ShaderSourceFS),\r\n            vertexCapacity: (config.vertexCapacity ? config.vertexCapacity : 3),\r\n\r\n            vertexSize: (config.vertexSize ? config.vertexSize :\r\n                Float32Array.BYTES_PER_ELEMENT * 2),\r\n\r\n            vertices: new Float32Array([\r\n                -1, +1, -1, -7, +7, +1\r\n            ]).buffer,\r\n\r\n            attributes: [\r\n                {\r\n                    name: 'inPosition',\r\n                    size: 2,\r\n                    type: config.renderer.gl.FLOAT,\r\n                    normalized: false,\r\n                    offset: 0\r\n                }\r\n            ]\r\n        });\r\n\r\n        /**\r\n         * Float32 view of the array buffer containing the pipeline's vertices.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#vertexViewF32\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.vertexViewF32 = new Float32Array(this.vertexData);\r\n\r\n        /**\r\n         * Size of the batch.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#maxQuads\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.maxQuads = 1;\r\n\r\n        /**\r\n         * Dirty flag to check if resolution properties need to be updated on the \r\n         * masking shader.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#resolutionDirty\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.resolutionDirty = true;\r\n    },\r\n\r\n    /**\r\n     * Called every time the pipeline needs to be used.\r\n     * It binds all necessary resources.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#onBind\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    onBind: function ()\r\n    {\r\n        WebGLPipeline.prototype.onBind.call(this);\r\n\r\n        var renderer = this.renderer;\r\n        var program = this.program;\r\n        \r\n        if (this.resolutionDirty)\r\n        {\r\n            renderer.setFloat2(program, 'uResolution', this.width, this.height);\r\n            renderer.setInt1(program, 'uMainSampler', 0);\r\n            renderer.setInt1(program, 'uMaskSampler', 1);\r\n            this.resolutionDirty = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#resize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} resolution - [description]\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    resize: function (width, height, resolution)\r\n    {\r\n        WebGLPipeline.prototype.resize.call(this, width, height, resolution);\r\n        this.resolutionDirty = true;\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Binds necessary resources and renders the mask to a separated framebuffer.\r\n     * The framebuffer for the masked object is also bound for further use.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#beginMask\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} mask - GameObject used as mask.\r\n     * @param {Phaser.GameObjects.GameObject} maskedObject - GameObject masked by the mask GameObject.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - [description]\r\n     */\r\n    beginMask: function (mask, maskedObject, camera)\r\n    {\r\n        var renderer = this.renderer;\r\n        var gl = this.gl;\r\n\r\n        //  The renderable Game Object that is being used for the bitmap mask\r\n        var bitmapMask = mask.bitmapMask;\r\n\r\n        if (bitmapMask && gl)\r\n        {\r\n            renderer.flush();\r\n\r\n            mask.prevFramebuffer = renderer.currentFramebuffer;\r\n\r\n            renderer.setFramebuffer(mask.mainFramebuffer);\r\n\r\n            gl.disable(gl.STENCIL_TEST);\r\n\r\n            gl.clearColor(0, 0, 0, 0);\r\n\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n            if (renderer.currentCameraMask.mask !== mask)\r\n            {\r\n                renderer.currentMask.mask = mask;\r\n                renderer.currentMask.camera = camera;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The masked game objects framebuffer is unbound and its texture \r\n     * is bound together with the mask texture and the mask shader and \r\n     * a draw call with a single quad is processed. Here is where the\r\n     * masking effect is applied.  \r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#endMask\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} mask - GameObject used as a mask.\r\n     */\r\n    endMask: function (mask, camera)\r\n    {\r\n        var gl = this.gl;\r\n        var renderer = this.renderer;\r\n\r\n        //  The renderable Game Object that is being used for the bitmap mask\r\n        var bitmapMask = mask.bitmapMask;\r\n\r\n        if (bitmapMask && gl)\r\n        {\r\n            renderer.flush();\r\n\r\n            //  First we draw the mask to the mask fb\r\n            renderer.setFramebuffer(mask.maskFramebuffer);\r\n\r\n            gl.clearColor(0, 0, 0, 0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n            renderer.setBlendMode(0, true);\r\n\r\n            bitmapMask.renderWebGL(renderer, bitmapMask, 0, camera);\r\n\r\n            renderer.flush();\r\n\r\n            renderer.setFramebuffer(mask.prevFramebuffer);\r\n\r\n            //  Is there a stencil further up the stack?\r\n            var prev = renderer.getCurrentStencilMask();\r\n\r\n            if (prev)\r\n            {\r\n                gl.enable(gl.STENCIL_TEST);\r\n\r\n                prev.mask.applyStencil(renderer, prev.camera, true);\r\n            }\r\n            else\r\n            {\r\n                renderer.currentMask.mask = null;\r\n            }\r\n\r\n            //  Bind bitmap mask pipeline and draw\r\n            renderer.setPipeline(this);\r\n\r\n            gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(gl.TEXTURE_2D, mask.maskTexture);\r\n\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_2D, mask.mainTexture);\r\n\r\n            gl.uniform1i(gl.getUniformLocation(this.program, 'uInvertMaskAlpha'), mask.invertAlpha);\r\n\r\n            //  Finally, draw a triangle filling the whole screen\r\n            gl.drawArrays(this.topology, 0, 3);\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = BitmapMaskPipeline;\r\n"]},"metadata":{},"sourceType":"script"}