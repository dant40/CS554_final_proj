{"ast":null,"code":"/**\r\n* The `Matter.Bodies` module contains factory methods for creating rigid body models \r\n* with commonly used body configurations (such as rectangles, circles and other polygons).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Bodies\r\n*/\n// TODO: true circle bodies\nvar Bodies = {};\nmodule.exports = Bodies;\n\nvar Vertices = require('../geometry/Vertices');\n\nvar Common = require('../core/Common');\n\nvar Body = require('../body/Body');\n\nvar Bounds = require('../geometry/Bounds');\n\nvar Vector = require('../geometry/Vector');\n\nvar decomp = require('../../poly-decomp');\n\n(function () {\n  /**\r\n   * Creates a new rigid body model with a rectangle hull. \r\n   * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n   * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n   * @method rectangle\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} width\r\n   * @param {number} height\r\n   * @param {object} [options]\r\n   * @return {body} A new rectangle body\r\n   */\n  Bodies.rectangle = function (x, y, width, height, options) {\n    options = options || {};\n    var rectangle = {\n      label: 'Rectangle Body',\n      position: {\n        x: x,\n        y: y\n      },\n      vertices: Vertices.fromPath('L 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height)\n    };\n\n    if (options.chamfer) {\n      var chamfer = options.chamfer;\n      rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n      delete options.chamfer;\n    }\n\n    return Body.create(Common.extend({}, rectangle, options));\n  };\n  /**\r\n   * Creates a new rigid body model with a trapezoid hull. \r\n   * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n   * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n   * @method trapezoid\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} width\r\n   * @param {number} height\r\n   * @param {number} slope\r\n   * @param {object} [options]\r\n   * @return {body} A new trapezoid body\r\n   */\n\n\n  Bodies.trapezoid = function (x, y, width, height, slope, options) {\n    options = options || {};\n    slope *= 0.5;\n    var roof = (1 - slope * 2) * width;\n    var x1 = width * slope,\n        x2 = x1 + roof,\n        x3 = x2 + x1,\n        verticesPath;\n\n    if (slope < 0.5) {\n      verticesPath = 'L 0 0 L ' + x1 + ' ' + -height + ' L ' + x2 + ' ' + -height + ' L ' + x3 + ' 0';\n    } else {\n      verticesPath = 'L 0 0 L ' + x2 + ' ' + -height + ' L ' + x3 + ' 0';\n    }\n\n    var trapezoid = {\n      label: 'Trapezoid Body',\n      position: {\n        x: x,\n        y: y\n      },\n      vertices: Vertices.fromPath(verticesPath)\n    };\n\n    if (options.chamfer) {\n      var chamfer = options.chamfer;\n      trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n      delete options.chamfer;\n    }\n\n    return Body.create(Common.extend({}, trapezoid, options));\n  };\n  /**\r\n   * Creates a new rigid body model with a circle hull. \r\n   * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n   * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n   * @method circle\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} radius\r\n   * @param {object} [options]\r\n   * @param {number} [maxSides]\r\n   * @return {body} A new circle body\r\n   */\n\n\n  Bodies.circle = function (x, y, radius, options, maxSides) {\n    options = options || {};\n    var circle = {\n      label: 'Circle Body',\n      circleRadius: radius\n    }; // approximate circles with polygons until true circles implemented in SAT\n\n    maxSides = maxSides || 25;\n    var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius))); // optimisation: always use even number of sides (half the number of unique axes)\n\n    if (sides % 2 === 1) sides += 1;\n    return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));\n  };\n  /**\r\n   * Creates a new rigid body model with a regular polygon hull with the given number of sides. \r\n   * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n   * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n   * @method polygon\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} sides\r\n   * @param {number} radius\r\n   * @param {object} [options]\r\n   * @return {body} A new regular polygon body\r\n   */\n\n\n  Bodies.polygon = function (x, y, sides, radius, options) {\n    options = options || {};\n    if (sides < 3) return Bodies.circle(x, y, radius, options);\n    var theta = 2 * Math.PI / sides,\n        path = '',\n        offset = theta * 0.5;\n\n    for (var i = 0; i < sides; i += 1) {\n      var angle = offset + i * theta,\n          xx = Math.cos(angle) * radius,\n          yy = Math.sin(angle) * radius;\n      path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';\n    }\n\n    var polygon = {\n      label: 'Polygon Body',\n      position: {\n        x: x,\n        y: y\n      },\n      vertices: Vertices.fromPath(path)\n    };\n\n    if (options.chamfer) {\n      var chamfer = options.chamfer;\n      polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n      delete options.chamfer;\n    }\n\n    return Body.create(Common.extend({}, polygon, options));\n  };\n  /**\r\n   * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).\r\n   * If the vertices are convex, they will pass through as supplied.\r\n   * Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.\r\n   * Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).\r\n   * By default the decomposition will discard collinear edges (to improve performance).\r\n   * It can also optionally discard any parts that have an area less than `minimumArea`.\r\n   * If the vertices can not be decomposed, the result will fall back to using the convex hull.\r\n   * The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.\r\n   * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n   * @method fromVertices\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param [[vector]] vertexSets\r\n   * @param {object} [options]\r\n   * @param {bool} [flagInternal=false]\r\n   * @param {number} [removeCollinear=0.01]\r\n   * @param {number} [minimumArea=10]\r\n   * @return {body}\r\n   */\n\n\n  Bodies.fromVertices = function (x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {\n    var body, parts, isConvex, vertices, i, j, k, v, z;\n    options = options || {};\n    parts = [];\n    flagInternal = typeof flagInternal !== 'undefined' ? flagInternal : false;\n    removeCollinear = typeof removeCollinear !== 'undefined' ? removeCollinear : 0.01;\n    minimumArea = typeof minimumArea !== 'undefined' ? minimumArea : 10;\n\n    if (!decomp) {\n      Common.warn('Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.');\n    } // ensure vertexSets is an array of arrays\n\n\n    if (!Common.isArray(vertexSets[0])) {\n      vertexSets = [vertexSets];\n    }\n\n    for (v = 0; v < vertexSets.length; v += 1) {\n      vertices = vertexSets[v];\n      isConvex = Vertices.isConvex(vertices);\n\n      if (isConvex || !decomp) {\n        if (isConvex) {\n          vertices = Vertices.clockwiseSort(vertices);\n        } else {\n          // fallback to convex hull when decomposition is not possible\n          vertices = Vertices.hull(vertices);\n        }\n\n        parts.push({\n          position: {\n            x: x,\n            y: y\n          },\n          vertices: vertices\n        });\n      } else {\n        // initialise a decomposition\n        var concave = vertices.map(function (vertex) {\n          return [vertex.x, vertex.y];\n        }); // vertices are concave and simple, we can decompose into parts\n\n        decomp.makeCCW(concave);\n        if (removeCollinear !== false) decomp.removeCollinearPoints(concave, removeCollinear); // use the quick decomposition algorithm (Bayazit)\n\n        var decomposed = decomp.quickDecomp(concave); // for each decomposed chunk\n\n        for (i = 0; i < decomposed.length; i++) {\n          var chunk = decomposed[i]; // convert vertices into the correct structure\n\n          var chunkVertices = chunk.map(function (vertices) {\n            return {\n              x: vertices[0],\n              y: vertices[1]\n            };\n          }); // skip small chunks\n\n          if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea) continue; // create a compound part\n\n          parts.push({\n            position: Vertices.centre(chunkVertices),\n            vertices: chunkVertices\n          });\n        }\n      }\n    } // create body parts\n\n\n    for (i = 0; i < parts.length; i++) {\n      parts[i] = Body.create(Common.extend(parts[i], options));\n    }\n\n    if (flagInternal) {\n      Bodies.flagCoincidentParts(parts, 5);\n    }\n\n    if (parts.length > 1) {\n      // create the parent body to be returned, that contains generated compound parts\n      body = Body.create(Common.extend({\n        parts: parts.slice(0)\n      }, options));\n      Body.setPosition(body, {\n        x: x,\n        y: y\n      });\n      return body;\n    } else {\n      return parts[0];\n    }\n  };\n  /**\r\n   * Takes an array of Body objects and flags all internal edges (coincident parts) based on the maxDistance\r\n   * value. The array is changed in-place and returned, so you can pass this function a `Body.parts` property.\r\n   * \r\n   * @method flagCoincidentParts\r\n   * @param {body[]} parts - The Body parts, or array of bodies, to flag.\r\n   * @param {number} [maxDistance=5]\r\n   * @return {body[]} The modified `parts` parameter.\r\n   */\n\n\n  Bodies.flagCoincidentParts = function (parts, maxDistance) {\n    if (maxDistance === undefined) {\n      maxDistance = 5;\n    }\n\n    for (var i = 0; i < parts.length; i++) {\n      var partA = parts[i];\n\n      for (var j = i + 1; j < parts.length; j++) {\n        var partB = parts[j];\n\n        if (Bounds.overlaps(partA.bounds, partB.bounds)) {\n          var pav = partA.vertices;\n          var pbv = partB.vertices; // iterate vertices of both parts\n\n          for (var k = 0; k < partA.vertices.length; k++) {\n            for (var z = 0; z < partB.vertices.length; z++) {\n              // find distances between the vertices\n              var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z]));\n              var db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length])); // if both vertices are very close, consider the edge concident (internal)\n\n              if (da < maxDistance && db < maxDistance) {\n                pav[k].isInternal = true;\n                pbv[z].isInternal = true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return parts;\n  };\n})();","map":{"version":3,"sources":["/mnt/c/Users/kubec/Desktop/Projects/Projects/Phaser/phaser_practice/node_modules/phaser/src/physics/matter-js/lib/factory/Bodies.js"],"names":["Bodies","module","exports","Vertices","require","Common","Body","Bounds","Vector","decomp","rectangle","x","y","width","height","options","label","position","vertices","fromPath","chamfer","radius","quality","qualityMin","qualityMax","create","extend","trapezoid","slope","roof","x1","x2","x3","verticesPath","circle","maxSides","circleRadius","sides","Math","ceil","max","min","polygon","theta","PI","path","offset","i","angle","xx","cos","yy","sin","toFixed","fromVertices","vertexSets","flagInternal","removeCollinear","minimumArea","body","parts","isConvex","j","k","v","z","warn","isArray","length","clockwiseSort","hull","push","concave","map","vertex","makeCCW","removeCollinearPoints","decomposed","quickDecomp","chunk","chunkVertices","area","centre","flagCoincidentParts","slice","setPosition","maxDistance","undefined","partA","partB","overlaps","bounds","pav","pbv","da","magnitudeSquared","sub","db","isInternal"],"mappings":"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","sourcesContent":["/**\r\n* The `Matter.Bodies` module contains factory methods for creating rigid body models \r\n* with commonly used body configurations (such as rectangles, circles and other polygons).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Bodies\r\n*/\r\n\r\n// TODO: true circle bodies\r\n\r\nvar Bodies = {};\r\n\r\nmodule.exports = Bodies;\r\n\r\nvar Vertices = require('../geometry/Vertices');\r\nvar Common = require('../core/Common');\r\nvar Body = require('../body/Body');\r\nvar Bounds = require('../geometry/Bounds');\r\nvar Vector = require('../geometry/Vector');\r\nvar decomp = require('../../poly-decomp');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new rigid body model with a rectangle hull. \r\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method rectangle\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} width\r\n     * @param {number} height\r\n     * @param {object} [options]\r\n     * @return {body} A new rectangle body\r\n     */\r\n    Bodies.rectangle = function(x, y, width, height, options) {\r\n        options = options || {};\r\n\r\n        var rectangle = { \r\n            label: 'Rectangle Body',\r\n            position: { x: x, y: y },\r\n            vertices: Vertices.fromPath('L 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height)\r\n        };\r\n\r\n        if (options.chamfer) {\r\n            var chamfer = options.chamfer;\r\n            rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, \r\n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\r\n            delete options.chamfer;\r\n        }\r\n\r\n        return Body.create(Common.extend({}, rectangle, options));\r\n    };\r\n    \r\n    /**\r\n     * Creates a new rigid body model with a trapezoid hull. \r\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method trapezoid\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} width\r\n     * @param {number} height\r\n     * @param {number} slope\r\n     * @param {object} [options]\r\n     * @return {body} A new trapezoid body\r\n     */\r\n    Bodies.trapezoid = function(x, y, width, height, slope, options) {\r\n        options = options || {};\r\n\r\n        slope *= 0.5;\r\n        var roof = (1 - (slope * 2)) * width;\r\n        \r\n        var x1 = width * slope,\r\n            x2 = x1 + roof,\r\n            x3 = x2 + x1,\r\n            verticesPath;\r\n\r\n        if (slope < 0.5) {\r\n            verticesPath = 'L 0 0 L ' + x1 + ' ' + (-height) + ' L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';\r\n        } else {\r\n            verticesPath = 'L 0 0 L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';\r\n        }\r\n\r\n        var trapezoid = { \r\n            label: 'Trapezoid Body',\r\n            position: { x: x, y: y },\r\n            vertices: Vertices.fromPath(verticesPath)\r\n        };\r\n\r\n        if (options.chamfer) {\r\n            var chamfer = options.chamfer;\r\n            trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, \r\n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\r\n            delete options.chamfer;\r\n        }\r\n\r\n        return Body.create(Common.extend({}, trapezoid, options));\r\n    };\r\n\r\n    /**\r\n     * Creates a new rigid body model with a circle hull. \r\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method circle\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} radius\r\n     * @param {object} [options]\r\n     * @param {number} [maxSides]\r\n     * @return {body} A new circle body\r\n     */\r\n    Bodies.circle = function(x, y, radius, options, maxSides) {\r\n        options = options || {};\r\n\r\n        var circle = {\r\n            label: 'Circle Body',\r\n            circleRadius: radius\r\n        };\r\n        \r\n        // approximate circles with polygons until true circles implemented in SAT\r\n        maxSides = maxSides || 25;\r\n        var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));\r\n\r\n        // optimisation: always use even number of sides (half the number of unique axes)\r\n        if (sides % 2 === 1)\r\n            sides += 1;\r\n\r\n        return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));\r\n    };\r\n\r\n    /**\r\n     * Creates a new rigid body model with a regular polygon hull with the given number of sides. \r\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method polygon\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} sides\r\n     * @param {number} radius\r\n     * @param {object} [options]\r\n     * @return {body} A new regular polygon body\r\n     */\r\n    Bodies.polygon = function(x, y, sides, radius, options) {\r\n        options = options || {};\r\n\r\n        if (sides < 3)\r\n            return Bodies.circle(x, y, radius, options);\r\n\r\n        var theta = 2 * Math.PI / sides,\r\n            path = '',\r\n            offset = theta * 0.5;\r\n\r\n        for (var i = 0; i < sides; i += 1) {\r\n            var angle = offset + (i * theta),\r\n                xx = Math.cos(angle) * radius,\r\n                yy = Math.sin(angle) * radius;\r\n\r\n            path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';\r\n        }\r\n\r\n        var polygon = { \r\n            label: 'Polygon Body',\r\n            position: { x: x, y: y },\r\n            vertices: Vertices.fromPath(path)\r\n        };\r\n\r\n        if (options.chamfer) {\r\n            var chamfer = options.chamfer;\r\n            polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, \r\n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\r\n            delete options.chamfer;\r\n        }\r\n\r\n        return Body.create(Common.extend({}, polygon, options));\r\n    };\r\n\r\n    /**\r\n     * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).\r\n     * If the vertices are convex, they will pass through as supplied.\r\n     * Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.\r\n     * Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).\r\n     * By default the decomposition will discard collinear edges (to improve performance).\r\n     * It can also optionally discard any parts that have an area less than `minimumArea`.\r\n     * If the vertices can not be decomposed, the result will fall back to using the convex hull.\r\n     * The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method fromVertices\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param [[vector]] vertexSets\r\n     * @param {object} [options]\r\n     * @param {bool} [flagInternal=false]\r\n     * @param {number} [removeCollinear=0.01]\r\n     * @param {number} [minimumArea=10]\r\n     * @return {body}\r\n     */\r\n    Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {\r\n        var body,\r\n            parts,\r\n            isConvex,\r\n            vertices,\r\n            i,\r\n            j,\r\n            k,\r\n            v,\r\n            z;\r\n\r\n        options = options || {};\r\n        parts = [];\r\n\r\n        flagInternal = typeof flagInternal !== 'undefined' ? flagInternal : false;\r\n        removeCollinear = typeof removeCollinear !== 'undefined' ? removeCollinear : 0.01;\r\n        minimumArea = typeof minimumArea !== 'undefined' ? minimumArea : 10;\r\n\r\n        if (!decomp) {\r\n            Common.warn('Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.');\r\n        }\r\n\r\n        // ensure vertexSets is an array of arrays\r\n        if (!Common.isArray(vertexSets[0])) {\r\n            vertexSets = [vertexSets];\r\n        }\r\n\r\n        for (v = 0; v < vertexSets.length; v += 1) {\r\n            vertices = vertexSets[v];\r\n            isConvex = Vertices.isConvex(vertices);\r\n\r\n            if (isConvex || !decomp) {\r\n                if (isConvex) {\r\n                    vertices = Vertices.clockwiseSort(vertices);\r\n                } else {\r\n                    // fallback to convex hull when decomposition is not possible\r\n                    vertices = Vertices.hull(vertices);\r\n                }\r\n\r\n                parts.push({\r\n                    position: { x: x, y: y },\r\n                    vertices: vertices\r\n                });\r\n            } else {\r\n                // initialise a decomposition\r\n                var concave = vertices.map(function(vertex) {\r\n                    return [vertex.x, vertex.y];\r\n                });\r\n\r\n                // vertices are concave and simple, we can decompose into parts\r\n                decomp.makeCCW(concave);\r\n                if (removeCollinear !== false)\r\n                    decomp.removeCollinearPoints(concave, removeCollinear);\r\n\r\n                // use the quick decomposition algorithm (Bayazit)\r\n                var decomposed = decomp.quickDecomp(concave);\r\n\r\n                // for each decomposed chunk\r\n                for (i = 0; i < decomposed.length; i++) {\r\n                    var chunk = decomposed[i];\r\n\r\n                    // convert vertices into the correct structure\r\n                    var chunkVertices = chunk.map(function(vertices) {\r\n                        return {\r\n                            x: vertices[0],\r\n                            y: vertices[1]\r\n                        };\r\n                    });\r\n\r\n                    // skip small chunks\r\n                    if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea)\r\n                        continue;\r\n\r\n                    // create a compound part\r\n                    parts.push({\r\n                        position: Vertices.centre(chunkVertices),\r\n                        vertices: chunkVertices\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        // create body parts\r\n        for (i = 0; i < parts.length; i++) {\r\n            parts[i] = Body.create(Common.extend(parts[i], options));\r\n        }\r\n\r\n        if (flagInternal)\r\n        {\r\n            Bodies.flagCoincidentParts(parts, 5);\r\n        }\r\n\r\n        if (parts.length > 1) {\r\n            // create the parent body to be returned, that contains generated compound parts\r\n            body = Body.create(Common.extend({ parts: parts.slice(0) }, options));\r\n            Body.setPosition(body, { x: x, y: y });\r\n\r\n            return body;\r\n        } else {\r\n            return parts[0];\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Takes an array of Body objects and flags all internal edges (coincident parts) based on the maxDistance\r\n     * value. The array is changed in-place and returned, so you can pass this function a `Body.parts` property.\r\n     * \r\n     * @method flagCoincidentParts\r\n     * @param {body[]} parts - The Body parts, or array of bodies, to flag.\r\n     * @param {number} [maxDistance=5]\r\n     * @return {body[]} The modified `parts` parameter.\r\n     */\r\n    Bodies.flagCoincidentParts = function (parts, maxDistance)\r\n    {\r\n        if (maxDistance === undefined) { maxDistance = 5; }\r\n\r\n        for (var i = 0; i < parts.length; i++)\r\n        {\r\n            var partA = parts[i];\r\n\r\n            for (var j = i + 1; j < parts.length; j++)\r\n            {\r\n                var partB = parts[j];\r\n\r\n                if (Bounds.overlaps(partA.bounds, partB.bounds))\r\n                {\r\n                    var pav = partA.vertices;\r\n                    var pbv = partB.vertices;\r\n\r\n                    // iterate vertices of both parts\r\n                    for (var k = 0; k < partA.vertices.length; k++)\r\n                    {\r\n                        for (var z = 0; z < partB.vertices.length; z++)\r\n                        {\r\n                            // find distances between the vertices\r\n                            var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z]));\r\n                            var db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));\r\n\r\n                            // if both vertices are very close, consider the edge concident (internal)\r\n                            if (da < maxDistance && db < maxDistance)\r\n                            {\r\n                                pav[k].isInternal = true;\r\n                                pbv[z].isInternal = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return parts;\r\n    };\r\n\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}